#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\definecolor{fgcolor}{rgb}{0.345, 0.345, 0.345}\definecolor{messagecolor}{rgb}{0, 0, 0}\definecolor{warningcolor}{rgb}{1, 0, 1}\definecolor{errorcolor}{rgb}{1, 0, 0}\setlength{\headheight}{14.5pt}\usepackage{babel}


\definecolor{fgcolor}{rgb}{0.345, 0.345, 0.345}\definecolor{messagecolor}{rgb}{0, 0, 0}\definecolor{warningcolor}{rgb}{1, 0, 1}\definecolor{errorcolor}{rgb}{1, 0, 0}\usepackage{babel}
% macro for italic page numbers in the index
\newcommand{\IndexDef}[1]{\textit{#1}}
\newcommand{\IndexPrimary}[1]{\textbf{#1}}
% force a page break at the start of sections
\let\stdsection\section
\renewcommand{\section}{\newpage\stdsection}


% workaround for a makeindex bug,
% see sec. "Index Entry Order"
% only uncomment this when you are using makindex
%\let\OrgIndex\index 
%\renewcommand*{\index}[1]{\OrgIndex{#1}}
%\usepackage{splitidx}

% workaround for a makeindex bug,
% see sec. "Index Entry Order"
% only uncomment this when you are using makindex
\let\OrgIndex\index 
\renewcommand*{\index}[1]{\OrgIndex{#1}}
\usepackage{splitidx}
%\indexsetup{noclearpage}
\AtBeginDocument{
  \def\labelitemii{\(\circ\)}
  \def\labelitemiii{\(\triangleright\)}
}
\usepackage[font={normal,sl}]{caption}% set captions slanted

\IfFileExists{upquote.sty}{\usepackage{upquote}}{}

\newenvironment{lylist}[1]{\begin{list}{}
{\settowidth{\labelwidth}{#1}
\setlength{\leftmargin}{\labelwidth}
\addtolength{\leftmargin}{\labelsep}
\renewcommand{\makelabel}[1]{##1\hfil}}}{\end{list}}
\newcommand{\datetoday}{\number\day\space
     \ifcase\month\or January\or February\or March\or April\or May\or
     June\or July\or August\or September\or October\or November\or
     December\fi
     \space\number\year}
\newcommand{\EOLmemo}{\null \vskip-1.5truein
{\raggedright \textsf{\textsc{\large \textcolor{blue}{Earth Observing Laboratory}}}}\par
{\raggedright \textsf{\textsl{\textcolor{blue}{Memorandum:}}}} \par \vskip6pt
{\color{blue}{\hrule}}\par
\vskip0.3truein \leftline{\hskip \longindent \datetoday} \vskip0.2truein
\thispagestyle{empty}}
\newcommand{\attachm}[1]{\begin{lylist}{Attachments:00}
\item [Attachments:] {#1}
\end{lylist}}
\newcommand{\cc}[1]{\begin{lylist}{Attachments:00}
\item [cc:] {#1}
\end{lylist}}
\newcommand{\attach}[1]{\begin{lylist}{Attachments:00}
\item [Attachment:] {#1}
\end{lylist}}

\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\pagenumbering{gobble}
%\usepackage{xcolor}
%\providecolor{lyxadded}{rgb}{0,0,1}
%\providecolor{lyxdeleted}{rgb}{1,0,0}
%% Change tracking with ulem
%\DeclareRobustCommand{\lyxadded}[3]{{\color{lyxadded}{}#3}}
%\DeclareRobustCommand{\lyxdeleted}[3]{{\color{lyxdeleted}\sout{#3}}}
\end_preamble
\options 12pt,twoside,american
\use_default_options false
\begin_modules
knitr
hanging
\end_modules
\maintain_unincluded_children false
\language american
\language_package babel
\inputencoding default
\fontencoding global
\font_roman "times" "default"
\font_sans "helvet" "default"
\font_typewriter "lmtt" "default"
\font_math "auto" "auto"
\font_default_family rmdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format pdf2
\output_sync 0
\bibtex_command bibtex
\index_command makeindex
\paperfontsize 11
\spacing single
\use_hyperref true
\pdf_title "Measuring the Flux of Sensible Heat with Airborne Thermometers"
\pdf_author "William A. Cooper"
\pdf_subject "Correcting Measurements of Sensible-Heat Flux"
\pdf_keywords "sensible heat flux, temperature, time response of sensors, NCAR Research Aviation Facility, research aircraft, NCAR/EOL/RAF"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref section
\pdf_pdfusetitle false
\pdf_quoted_options " linkcolor=blue, citecolor={blue}"
\papersize letterpaper
\use_geometry true
\use_package amsmath 2
\use_package amssymb 0
\use_package cancel 0
\use_package esint 2
\use_package mathdots 0
\use_package mathtools 0
\use_package mhchem 0
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine natbib
\cite_engine_type authoryear
\biblio_style plainnat
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 0
\use_minted 0
\backgroundcolor #ffffff
\boxbgcolor #f7f7f7
\branch Extra
\selected 0
\filename_suffix 0
\color #faf0e6
\end_branch
\branch expanded
\selected 0
\filename_suffix 0
\color #faf0e6
\end_branch
\index Index
\shortcut idx
\color #008000
\end_index
\index Variable Names and Acronyms
\shortcut var
\color #00aaff
\end_index
\index List of Symbols
\shortcut lis
\color #ff0000
\end_index
\leftmargin 1.2in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 2
\paragraph_separation skip
\defskip medskip
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Measuring the Flux of Sensible Heat With Airborne Thermometers
\end_layout

\begin_layout Author
William A.
 Cooper and others...
\end_layout

\begin_layout Date

\color red
DRAFT
\color inherit
 May 2020
\end_layout

\begin_layout Standard
National Center for Atmospheric Research
\begin_inset Newline newline
\end_inset

Earth Observing Laboratory
\begin_inset Newline newline
\end_inset

Research Aviation Facility
\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\begin_inset Newpage cleardoublepage
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{roman}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
contentsname}{Table of Contents} 
\end_layout

\end_inset


\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset

 
\begin_inset VSpace vfill
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
eject
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%% LyX 2.2.2 created this file.
  For more info, see http://www.lyx.org/.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\backslash
phantomsection 
\backslash
addcontentsline{toc}{section}{List of Figures}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
clearpage %
\backslash
phantomsection 
\backslash
addcontentsline{toc}{section}{List of Tables}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList table

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
abstractname}{Preface and Abstract}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{plain}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{abstract}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Most measurements of temperature from research aircraft rely on sensors
 that have inadequate response for demanding applications, including especially
 measuring the flux of sensible heat.
 This paper uses a new method to characterize the time response of standard
 sensors in terms of the frequency-domain transfer function, and it uses
 the result to improve measurements of the flux of sensible heat.
 The transfer function is found by observing the response to turbulent dynamic
 heating in regions where that is the dominant cause of fluctuations in
 the measurement.
 Suggested differential equations for the response are consistent with the
 observed transfer function, and the observations constrain the parameters
 in those differential equations with low uncertainty.
 Examples and a simulation illustrate that, without correction, measurements
 of sensible-heat flux with an unheated Rosemount 102E4AL sensor can be
 more than 30% too low, but the proposed correction procedure removes this
 error and results in reliable measurements with negligible error attributable
 to the response time of the sensor.
 An additional result of the study is the identification of a source of
 error, prevalent in most archived data files produced by research aircraft,
 that results from incorrect adjustment for dynamic heating of the sensor.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{abstract}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Section*
Acknowledgements
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:acknowledgements"

\end_inset


\end_layout

\begin_layout Standard
This material is based upon work supported by the National Center for Atmospheri
c Research, which is a major facility sponsored by the National Science
 Foundation under Cooperative Agreement No.
 1852977.
 Any opinions, findings and conclusions or recom-mendations expressed in
 this publication are those of the author(s) and do not necessarily reflect
 the views of the National Science Foundation.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
The data used in the examples presented are from the VOCALS (VAMOS Ocean-Cloud-A
tmosphere-Land Study), SOCRATES (Southern Ocean Clouds, Radiation, Aerosol
 Transport Experimental Study) and the CSET (Cloud Systems Evolution in
 the Trades) experiments, 
\begin_inset Note Note
status open

\begin_layout Plain Layout
WE-CAN (Western wildfire Experiment for Cloud chemistry, Aerosol absorption
 and Nitrogen) projects,
\end_layout

\end_inset

each described at 
\begin_inset CommandInset href
LatexCommand href
name "this URL"
target "https://www.eol.ucar.edu/field_projects/"
literal "false"

\end_inset

.
 Citations for the data sets are included in the references.
\end_layout

\end_inset

Measurements used here (
\begin_inset CommandInset citation
LatexCommand citet
key "VOCALS2011"
literal "false"

\end_inset

, 
\begin_inset CommandInset citation
LatexCommand citet
key "SOCRATES2019"
literal "false"

\end_inset

, 
\begin_inset CommandInset citation
LatexCommand citet
key "WECAN2018"
literal "false"

\end_inset

) were collected in research projects (
\begin_inset CommandInset citation
LatexCommand citet
key "wood2011vamos"
literal "false"

\end_inset

, 
\begin_inset CommandInset citation
LatexCommand citet
key "albrecht2019CSET"
literal "false"

\end_inset

, 
\begin_inset CommandInset citation
LatexCommand citet
key "mcfarquhar2014southern"
literal "false"

\end_inset

) that used the NSF/NCAR research aircraft.
 Project descriptions and additional information can be found at 
\begin_inset CommandInset href
LatexCommand href
name "this URL"
target "https://www.eol.ucar.edu/field_projects/"
literal "false"

\end_inset

.
 The referenced project teams conducted the experiments, with flight operations,
 data acquisition and processing, and other project support by the Research
 Aviation Facility, Earth Observing Laboratory, National Center for Atmospheric
 Research (NCAR).
 The analyses reported here were mostly performed using R (
\begin_inset CommandInset citation
LatexCommand citet
key "Rlanguage"
literal "true"

\end_inset

), with 
\begin_inset Index idx
status open

\begin_layout Plain Layout
RStudio
\end_layout

\end_inset

RStudio (
\begin_inset CommandInset citation
LatexCommand citet
key "RStudio2012"
literal "true"

\end_inset

) and 
\begin_inset Index idx
status open

\begin_layout Plain Layout
knitr
\end_layout

\end_inset

knitr (
\begin_inset CommandInset citation
LatexCommand citet
key "Xie2014a,Xie2014b"
literal "true"

\end_inset

).
 Data files in netCDF format have been read and written using the R 
\begin_inset Index idx
status open

\begin_layout Plain Layout
R language!package!ncdf4
\end_layout

\end_inset

package 
\begin_inset Quotes eld
\end_inset

ncdf4
\begin_inset Quotes erd
\end_inset

; cf.
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citet
key "ncdf4"
literal "true"

\end_inset

.
 Substantial use also was made of the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
ggplot2
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
R language!package!ggplot2
\end_layout

\end_inset


\begin_inset Quotes eld
\end_inset

ggplot2
\begin_inset Quotes erd
\end_inset

 package (
\begin_inset CommandInset citation
LatexCommand citet
key "wickham2009"
literal "true"

\end_inset

) for R, and extensive use was made of the 
\begin_inset Quotes eld
\end_inset

stats
\begin_inset Quotes erd
\end_inset

 package, part of Core R\SpecialChar endofsentence
 Some of the numerical integrations used the Runge-Kutta
 function from the 
\begin_inset Quotes eld
\end_inset

rmutil
\begin_inset Quotes erd
\end_inset

 package (
\begin_inset CommandInset citation
LatexCommand citet
key "runge.kutta"
literal "false"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{plain}
\end_layout

\end_inset


\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{arabic}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Research aircraft routinely measure air temperature, but the standard sensors
 do not respond fast enough to meet many scientific needs.
 In particular, measurements of the flux of sensible heat need faster response
 than is typically available, as do measurements of near-discontinuous changes
 such as those at the top of boundary layers or at cloud boundaries.
 The measurement of sensible-heat flux requires, for the standard eddy-correlati
on measurement, that temperature be measured with sufficient response to
 resolve the spectrum of contributions to the flux.
 Various reviews of priorities for research in atmospheric science have
 called attention to the important roles that fluxes of various quantities
 play in climate science and have advocated increased focus on those fluxes;
 e.g., 
\begin_inset CommandInset citation
LatexCommand citet
key "NAP6021"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
The basis for the measurement of the flux of sensible heat (
\begin_inset Formula $F_{s})$
\end_inset

 by eddy correlation is this equation:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
F_{s}=\rho_{a}\thinspace C_{p}\left\langle w^{\prime}T^{\prime}\right\rangle \label{eq:heatFlux}
\end{equation}

\end_inset

where 
\begin_inset Formula $\rho_{a}$
\end_inset

 is the density of air, 
\begin_inset Formula $C_{p}$
\end_inset

 the specific heat of air at constant pressure, 
\begin_inset Formula $w$
\end_inset

 the vertical wind, and 
\begin_inset Formula $T$
\end_inset

 the temperature.
 Primes in this equation denote fluctuations from the mean and angle brackets
 denote an ensemble average.
 The measurement thus depends on having a temperature sensor that can respond
 to the range of fluctuations making significant contributions to the heat
 flux.
 
\begin_inset CommandInset citation
LatexCommand citet
key "FrieheKhelif1992"
literal "false"

\end_inset

 suggested
\begin_inset Note Note
status open

\begin_layout Plain Layout
, without demonstration,
\end_layout

\end_inset

 that 4–5
\begin_inset space ~
\end_inset

Hz is 
\begin_inset Quotes eld
\end_inset

just adequate
\begin_inset Quotes erd
\end_inset

 (for flight at around 125
\begin_inset space ~
\end_inset

m/s) and that 25
\begin_inset space ~
\end_inset

Hz would be desirable to resolve some interesting aspects of the temperature
 structure.
 If the response of the temperature sensor is reduced or shifted in phase
 at a particular frequency, an error will be introduced into the measurement
 of sensible-heat flux.
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset CommandInset citation
LatexCommand citet
key "LawsonRodi1992"
literal "false"

\end_inset

 argued that sensible-heat flux measured by some of the fastest sensors
 then in common use produced measurements of sensible heat flux about 21%
 too low compared to the measurements from their faster thermocouple-based
 sensor.
\end_layout

\end_inset

 To avoid significant errors in this measurement, it therefore is essential
 to characterize the time response of the temperature sensor used and, where
 necessary, to apply corrections to compensate for that response.
\end_layout

\begin_layout Section
Determining the Transfer Function
\begin_inset CommandInset label
LatexCommand label
name "sec:theTransferFn"

\end_inset


\end_layout

\begin_layout Standard
In this first section, the time response of some standard airborne temperature
 sensors is characterized in terms of a frequency-domain transfer function
 that relates the measurand (the recovery temperature) to the measurement
 (the sensor output) in ways that are invertible.
 Two coupled differential equations with three parameters are proposed as
 the basis for this characterization, but the transfer function is determined
 independent of those equations.
 Because the equations predict a transfer function matching the observations,
 they provide a useful generalization when the measurements are fitted to
 a three-parameter equation consistent with those equations.
 The measured transfer functions then are used in the sections that follow
 to access how common measurements are affected.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<initialization, echo=FALSE,include=FALSE>>=
\end_layout

\begin_layout Plain Layout

## This chunk loads some needed R packages and defines a function
\end_layout

\begin_layout Plain Layout

## used for the Laplace-transform solution of the governing
\end_layout

\begin_layout Plain Layout

## differential equations.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

setwd('~/RStudio/SensibleHeatFlux')
\end_layout

\begin_layout Plain Layout

source('chunks/initialize.R')
\end_layout

\begin_layout Plain Layout

opts_chunk$set(fig.height = 3.5, digits = 3)
\end_layout

\begin_layout Plain Layout

thisFileName <- "SensibleHeatFluxPaper"
\end_layout

\begin_layout Plain Layout

library(rmutil)      ## provides the runge-kutta integration function
\end_layout

\begin_layout Plain Layout

CACHE <- FALSE
\end_layout

\begin_layout Plain Layout

Directory <- DataDirectory ()
\end_layout

\begin_layout Plain Layout

## standard values:
\end_layout

\begin_layout Plain Layout

frq <- seq(0.01, 25, by = 0.01)
\end_layout

\begin_layout Plain Layout

Phi <- rep(0, length(frq))
\end_layout

\begin_layout Plain Layout

H <- rep(0, length(frq))
\end_layout

\begin_layout Plain Layout

a <- 0.733 # 0.713
\end_layout

\begin_layout Plain Layout

tau1 <- 0.0308  # 0.0335
\end_layout

\begin_layout Plain Layout

tau2 <- 0.447
\end_layout

\begin_layout Plain Layout

# The Laplace-transform solution, given the parameters in P:
\end_layout

\begin_layout Plain Layout

LTphase <- function(f, P) {
\end_layout

\begin_layout Plain Layout

  ## f=frequency; P=Param
\end_layout

\begin_layout Plain Layout

  tau1 <- P$tau1
\end_layout

\begin_layout Plain Layout

  tau2 <- P$tau2
\end_layout

\begin_layout Plain Layout

  a <- P$a
\end_layout

\begin_layout Plain Layout

  b <- sqrt(1 / (1 + (2 * pi * f * tau2) ^ 2))
\end_layout

\begin_layout Plain Layout

  zeta <- -atan(2 * pi * f * tau2)
\end_layout

\begin_layout Plain Layout

  C1 <- 1 / (1 + 4 * pi ^ 2 * f ^ 2 * tau1 ^ 2) *
\end_layout

\begin_layout Plain Layout

    (-(a + (1 - a) * b * cos(zeta)) * 2 * pi * f * tau1 +
\end_layout

\begin_layout Plain Layout

       (1 - a) * b * sin(zeta))
\end_layout

\begin_layout Plain Layout

  C2 <- 1 / (1 + 4 * pi ^ 2 * f ^ 2 * tau1 ^ 2) *
\end_layout

\begin_layout Plain Layout

    ((a + (1 - a) * b * cos(zeta)) +
\end_layout

\begin_layout Plain Layout

       (1 - a) * b * sin(zeta) * 2 * pi * f * tau1)
\end_layout

\begin_layout Plain Layout

  cTF <- sqrt(C1 ^ 2 + C2 ^ 2)
\end_layout

\begin_layout Plain Layout

  phiTF <- atan2(C1, C2) * 180 / pi
\end_layout

\begin_layout Plain Layout

  return(list('Amp' = cTF, 'Phase' = phiTF))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Theory
\begin_inset CommandInset label
LatexCommand label
name "subsec:Theory"

\end_inset


\end_layout

\begin_layout Standard
The errors considered here apply to the measurement from the sensor, the
 
\begin_inset Quotes eld
\end_inset

recovery temperature,
\begin_inset Quotes erd
\end_inset

 rather than the final temperature after correction for dynamic heating.
 Because the sensor cannot respond to rapid fluctuations, the standard correctio
n for dynamic heating introduces errors into the measured air temperature
 that are then amplified by a correction procedure.
 This will be addressed in the next section, but for this reason the present
 section will discuss only the recovery temperature.
\end_layout

\begin_layout Standard
\begin_inset CommandInset citation
LatexCommand citet
key "PayneEtAl1994"
literal "false"

\end_inset

 provided a particularly illuminating analysis of the expected response
 of a temperature sensor and developed their results in terms of a transfer
 function.
 They represent the response of the sensor in terms of two coupled differential
 equations, one representing the temperature of the sensing wire and a second
 representing the temperature of the structure that supports that wire.
 Their analysis in terms of fundamental representation of the heat transport
 leads to reasonable consistency with previous two-time-constant models
 like that of 
\begin_inset CommandInset citation
LatexCommand citet
key "mccarthy1973method"
literal "false"

\end_inset

 but poor agreement with the empirical evidence regarding the time-response
 parameters in those models.
 They note, however, that the empirical evidence is not as consistent or
 convincing as would be desirable.
 One goal of the present work is to develop a different and readily available
 method of determining those parameters.
 
\end_layout

\begin_layout Standard
Previous studies have demonstrated that a simple first-order exponential
 equation with one time constant does not represent the time response of
 airborne temperature sensors.
 The suggested explanation (
\begin_inset CommandInset citation
LatexCommand citet
key "NCAR_OpenSky_TECH-NOTE-000-000-000-064"
literal "false"

\end_inset

 is that heat is transferred to the sensing wire of standard sensors not
 only from the air but also from the supporting structure that is in contact
 with the wire.
 Friehe and Khelif (
\begin_inset CommandInset citation
LatexCommand citet
key "FrieheKhelif1992"
literal "false"

\end_inset

), following other prior work including that of 
\begin_inset CommandInset citation
LatexCommand citet
key "rodi1972analysis"
literal "false"

\end_inset

 and 
\begin_inset CommandInset citation
LatexCommand citet
key "mccarthy1973method"
literal "false"

\end_inset

, suggested representing the two-time-constant response via the following
 functional form:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\Theta(t)=A_{1}e^{-t/\tau_{1}}+A_{2}e^{-t/\tau_{2}}\label{eq:FrieheKehlif}
\end{equation}

\end_inset

where 
\begin_inset Formula $\Theta(t)$
\end_inset

 is the normalized history of the measured temperature decaying from an
 initial value of unity to a final value of zero.
 The sum of the coefficients 
\begin_inset Formula $A_{1}$
\end_inset

 and 
\begin_inset Formula $A_{2}$
\end_inset

 must then be 1.
 The values for {
\begin_inset Formula $A_{1},\,A_{2},\,\tau_{1},\,\tau_{2}$
\end_inset

} suggested by 
\begin_inset CommandInset citation
LatexCommand citet
key "FrieheKhelif1992"
literal "false"

\end_inset

 were {0.65, 0.35, 0.09
\begin_inset space ~
\end_inset

s, 0.5
\begin_inset space ~
\end_inset

s}.
\end_layout

\begin_layout Standard
Following the approach of 
\begin_inset CommandInset citation
LatexCommand citet
key "PayneEtAl1994"
literal "false"

\end_inset

, the time response of the sensor will be represented here by two coupled
 differential equations, one that describes the response of the support
 on which the sensing wire is wound to the air temperature and a second
 that describes the response of the sensing wire to two inputs, one from
 the support and one from the air.
 No attempt is made here to determine the parameters from first principles
 as in 
\begin_inset CommandInset citation
LatexCommand citet
key "PayneEtAl1994"
literal "false"

\end_inset

, however; instead, parameters entering the equations are determined empirically.
 The equations are:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\frac{dT_{s}(t)}{dt}=\frac{T_{r}(t)-T_{s}(t)}{\tau_{2}}\label{eq:Ts}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{align}
\frac{dT_{m}(t)}{dt} & =\frac{a(T_{r}(t)-T_{m}(t))+(1-a)(T_{s}(t)-T_{m}(t))}{\tau_{1}}\label{eq:Tm}\\
= & \frac{\left\{ aT_{r}(t)+(1-a)T_{s}(t)\right\} -T_{m}(t)}{\tau_{1}}\nonumber 
\end{align}

\end_inset

where 
\begin_inset Formula $T_{s}(t)$
\end_inset

 is the temperature of the 
\bar under
s
\bar default
upport, 
\begin_inset Formula $T_{m}(t)$
\end_inset

 the 
\bar under
m
\bar default
easured temperature of the sensing wire, and 
\begin_inset Formula $T_{r}(t)$
\end_inset

 the true 
\bar under
r
\bar default
ecovery temperature that is the measurand.
 For heat transfer to or from the wire, the parameter 
\begin_inset Formula $a$
\end_inset

 then represents the fraction of the heat transferred by the air, while
 
\begin_inset Formula $(1-a)$
\end_inset

 is transferred to or from the support.
 The wire responds to the combined transfers of heat with characteristic
 time constant 
\begin_inset Formula $\tau_{1}$
\end_inset

 while the support structure responds to the air temperature more slowly,
 with time constant 
\begin_inset Formula $\tau_{2}$
\end_inset

.
 It is straightforward to apply 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to changing but not necessarily discrete conditions, so a general response
 to a given air-temperature history can be predicted by numerical integration
 of these equations.
 Furthermore, the equations are linear and, for constant values of the parameter
s, they are also time-invariant (i.e., 
\begin_inset Quotes eld
\end_inset

LTI
\begin_inset Quotes erd
\end_inset

) descriptions of the response.
 As a result, a particular signal for 
\begin_inset Formula $T_{r}(t)$
\end_inset

 can be decomposed into its sinusoidal Fourier components and each will
 satisfy these equations independently.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The step-function response of 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is the sum of two exponentials as in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:FrieheKehlif"
plural "false"
caps "false"
noprefix "false"

\end_inset

, with the same time constants but with the adjustment that 
\begin_inset Formula $A_{1}=(a-\tau_{1}/\tau_{2})/(1-\tau_{1}/\tau_{2})$
\end_inset

 and 
\begin_inset Formula $A_{2}=(1-a)/\left(1-\tau_{1}/\tau_{2}\right)$
\end_inset

.
 Because 
\begin_inset Formula $\tau_{1}$
\end_inset

 is normally small compared to 
\begin_inset Formula $\tau_{2}$
\end_inset

 for the Rosemount 102E4AL sensor, 
\begin_inset Formula $A_{1}\approx a$
\end_inset

.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The solution to 
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\frac{dT_{m}(t)}{dt}=\frac{(1-a)e^{-t/\tau_{2}}-T_{m}(t)}{\tau_{1}}
\]

\end_inset


\begin_inset Formula 
\[
T_{m}(t)=be^{-t/\tau_{a}}+(1-b)e^{-t/\tau_{b}}
\]

\end_inset


\begin_inset Formula 
\[
-b\frac{e^{-t/\tau_{a}}}{\tau_{a}}-(1-b)\frac{e^{-t/\tau_{b}}}{\tau_{b}}=\frac{(1-a)e^{-t/\tau_{2}}-be^{-t/\tau_{a}}-(1-b)e^{-t/\tau_{b}}}{\tau_{1}}
\]

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
e^{-t/\tau_{a}}:\,\,\,\frac{b}{\tau_{a}}=\frac{b}{\tau_{1}}
\]

\end_inset


\begin_inset Formula 
\[
e^{-t/\tau_{b}}:\,\,\,-\frac{1-b}{\tau_{b}}=-\frac{(1-b)}{\tau_{1}}
\]

\end_inset


\begin_inset Formula 
\[
e^{-t/\tau_{2}}:\,\,\,0=\frac{(1-a)}{\tau_{1}}
\]

\end_inset

If 
\begin_inset Formula $\tau_{a}=\tau_{1}$
\end_inset

 and 
\begin_inset Formula $\tau_{b}=\tau_{2}$
\end_inset

, 
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
(1-b)e^{-t/\tau_{b}}\left(\frac{1}{\tau_{1}}-\frac{1}{\tau_{b}}\right)=(1-a)e^{-t/\tau_{2}}\frac{1}{\tau_{1}}
\]

\end_inset


\begin_inset Formula 
\[
1-b=\frac{1-a}{\left(1-\frac{\tau_{1}}{\tau_{2}}\right)}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

The first equation does not involve the measurement, so for a particular
 history of recovery temperature 
\begin_inset Formula $T_{r}(t)$
\end_inset

 the support temperature can be determined solely by integration of 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Then, with 
\begin_inset Formula $T_{s}(t)$
\end_inset

 determined, 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 can be integrated to find the expected measurement 
\begin_inset Formula $T_{m}(t)$
\end_inset

 for a specified measurand history 
\begin_inset Formula $T_{r}(t)$
\end_inset

.
 The inverse process, finding 
\begin_inset Formula $T_{r}(t)$
\end_inset

 from the measurements 
\begin_inset Formula $T_{m}(t)$
\end_inset

, is also straightforward and only slightly more complicated, as discussed
 in Appendix
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Correcting-the-Temperature"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
For a sinusoidal input these equations have analytic solutions after any
 transient response from initial conditions has decayed.
 If the actual recovery temperature is 
\begin_inset Formula $T_{r}(t)=\sin\omega t$
\end_inset

 where 
\begin_inset Formula $\omega$
\end_inset

 is the angular frequency, then the solutions for 
\begin_inset Formula $T_{s}(t)$
\end_inset

 and 
\begin_inset Formula $T_{m}(t)$
\end_inset

 are given by the following equations:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
T_{s}(t)=b\sin(\omega t+\zeta)\label{eq:TsSolved}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
T_{m}(t)=c\sin(\omega t+\phi)=C_{1}\cos\omega t+C_{2}\sin\omega t\label{eq:TmSolved}
\end{equation}

\end_inset


\begin_inset Newline newline
\end_inset

where
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
b=\frac{1}{\sqrt{1+\omega^{2}\tau_{2}^{2}}}
\]

\end_inset


\begin_inset Formula 
\[
\zeta=-\arctan(\omega\tau_{2})
\]

\end_inset


\begin_inset Formula 
\begin{align*}
C_{1}= & \frac{-\omega}{(1+\omega^{2}\tau_{1}^{2})}\left(\tau_{1}a+\frac{(1-a)(\tau_{1}+\tau_{2})}{(1+\omega^{2}\tau_{2}^{2})}\right)
\end{align*}

\end_inset


\begin_inset Formula 
\begin{align*}
C_{2}= & \left(\frac{1}{1+\omega^{2}\tau_{1}^{2}}\right)\left(a+\frac{(1-a)(1-\omega^{2}\tau_{1}\tau_{2})}{(1+\omega^{2}\tau_{2}^{2})}\right)
\end{align*}

\end_inset


\begin_inset Formula 
\begin{equation}
c=\sqrt{C_{1}^{2}+C_{2}^{2}}\label{eq:responseAmp}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
\phi=\arctan(C_{1}/C_{2})\label{eq:responsePhase}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset citation
LatexCommand citet
key "mccarthy1973method"
literal "false"

\end_inset

 used the derivative of the step-function response to find the impulse response
 function and, from its Fourier transform, the sensor response function.
 That leads to the following alternate expressions for 
\begin_inset Formula $C_{1}$
\end_inset

 and 
\begin_inset Formula $C_{2}$
\end_inset

:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
C_{1}=-\omega\left(\frac{A_{1}\tau_{1}}{1+\omega^{2}\tau_{1}^{2}}+\frac{A_{2}\tau_{2}}{1+\omega^{2}\tau_{2}^{2}}\right)
\]

\end_inset


\begin_inset Formula 
\[
C_{2}=\left(\frac{A_{1}}{1+\omega^{2}\tau_{1}^{2}}+\frac{A_{2}}{1+\omega^{2}\tau_{2}^{2}}\right)
\]

\end_inset

With 
\begin_inset Formula $A_{2}=(1-a)/(1-\tau_{1}/\tau_{2})$
\end_inset

 and 
\begin_inset Formula $A_{1}=1-A_{2},$
\end_inset

 these are equivalent to the expressions for the same coefficients given
 above 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:responseAmp"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 This demonstrates that the equations 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 are a representation of the response equivalent to 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:FrieheKehlif"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and to the equations used by 
\begin_inset CommandInset citation
LatexCommand citet
key "mccarthy1973method"
literal "false"

\end_inset

 and 
\begin_inset CommandInset citation
LatexCommand citet
key "InverarityJTech2000"
literal "false"

\end_inset

, among others.
\end_layout

\begin_layout Standard
The transfer function 
\begin_inset Formula $H(\omega)=c(\omega)e^{i\phi(\omega)}$
\end_inset

 then characterizes how the sensor will respond to a unit-amplitude sine
 wave with angular frequency 
\begin_inset Formula $\omega=2\pi\nu$
\end_inset

 where 
\begin_inset Formula $\nu$
\end_inset

 is the frequency.
 For a particular set of parameters (
\begin_inset Formula $a=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(a, 3)}
\end_layout

\end_inset

, 
\begin_inset Formula $\tau_{1}=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(tau1, 4)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

s, 
\begin_inset Formula $\tau_{2}=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(tau2, 3)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

s),
\begin_inset Foot
status open

\begin_layout Plain Layout
These parameters are approximately representative of an unheated Rosemount
 102E4AL sensor used on the NSF/NCAR C-130, as will be demonstrated in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand eqref
reference "subsec:The-unheated-Rosemount"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\end_inset

 the amplitude response and phase delay of the transfer function are shown
 in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:LTsolution}
\end_layout

\end_inset

.
 Similar plots of the amplitude (but not the phase) have been shown by 
\begin_inset CommandInset citation
LatexCommand citet
key "mccarthy1973method"
literal "false"

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
(Fig.
\begin_inset space ~
\end_inset

2)
\end_layout

\end_inset

 and 
\begin_inset CommandInset citation
LatexCommand citet
key "nicholls1978measurements"
literal "false"

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
(Fig.
 3)
\end_layout

\end_inset

.
 Modified transfer functions for two small changes to these parameters are
 also shown to illustrate the sensitivity of the solution to these parameters.
 This figure illustrates that serious errors will enter estimates of the
 sensible heat flux if temperature fluctuations at frequencies above 1
\begin_inset space ~
\end_inset

Hz make a significant contribution to the flux.
 The contribution to the cospectrum of temperature and vertical wind will
 be reduced by the product of the amplitude and the cosine of the phase
 
\begin_inset Branch expanded
inverted 0
status open

\begin_layout Standard
(Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:FE}
\end_layout

\end_inset

) 
\end_layout

\end_inset

so at 10-Hz the error is about 86%, but even at 1
\begin_inset space ~
\end_inset

Hz the error is about 28%.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Characterizing the time response of sensors and correcting for that response
 when calculating fluxes therefore is an essential part of measuring fluxes
 with this sensor.
 The unheated Rosemount 102E4AL sensor is the fastest sensor available on
 the NSF/NCAR aircraft; other sensors will lead to still larger errors.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<LTsolution, include = TRUE, fig.height=3.7, fig.scap = 'The amplitude and
 phase for the frequency domain transfer function of the Rosemount 102E4AL
 temperature sensor.', fig.cap = 'The amplitude and phase for the frequency
 domain transfer function of the Rosemount 102E4AL temperature sensor.
 The parameters representing that sensor, labeled 
\begin_inset Quotes eld
\end_inset

best
\begin_inset Quotes erd
\end_inset

, are $a$=0.733, $
\backslash

\backslash
tau_1=0.0308$ s and $
\backslash

\backslash
tau_2=0.447$ s.
 To illustrate sensitivity,  the curves labeled 
\begin_inset Quotes eld
\end_inset

t1=0.05
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

t2=0.6
\begin_inset Quotes erd
\end_inset

 use instead $
\backslash

\backslash
tau_1=0.05$ s and $
\backslash

\backslash
tau_2=0.6$ s, respectively.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

zeta <- -atan(2 * pi * frq * tau2)
\end_layout

\begin_layout Plain Layout

b <- cos(zeta)
\end_layout

\begin_layout Plain Layout

Param <- list(
\end_layout

\begin_layout Plain Layout

  a = a,
\end_layout

\begin_layout Plain Layout

  tau1 = tau1,
\end_layout

\begin_layout Plain Layout

  tau2 = tau2,
\end_layout

\begin_layout Plain Layout

  b = b,
\end_layout

\begin_layout Plain Layout

  zeta = zeta,
\end_layout

\begin_layout Plain Layout

  frq = frq
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

Param1 <- Param
\end_layout

\begin_layout Plain Layout

Param3 <- Param
\end_layout

\begin_layout Plain Layout

Param4 <- Param
\end_layout

\begin_layout Plain Layout

Param3$tau1 <- 0.05
\end_layout

\begin_layout Plain Layout

Param4$tau2 <- 0.6
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Use the Laplace-transform solution
\end_layout

\begin_layout Plain Layout

H1 <- LTphase(frq, Param1)
\end_layout

\begin_layout Plain Layout

cTF <- H1$Amp
\end_layout

\begin_layout Plain Layout

phiTF <- H1$Phase
\end_layout

\begin_layout Plain Layout

H3 <- LTphase(frq, Param3)
\end_layout

\begin_layout Plain Layout

cTF3 <- H3$Amp
\end_layout

\begin_layout Plain Layout

phiTF3 <- H3$Phase
\end_layout

\begin_layout Plain Layout

H4 <- LTphase(frq, Param4)
\end_layout

\begin_layout Plain Layout

cTF4 <- H4$Amp
\end_layout

\begin_layout Plain Layout

phiTF4 <- H4$Phase
\end_layout

\begin_layout Plain Layout

dfAP <- data.frame(
\end_layout

\begin_layout Plain Layout

  'Time' = frq,
\end_layout

\begin_layout Plain Layout

  'Amp' = cTF,
\end_layout

\begin_layout Plain Layout

  'Amp3' = cTF3,
\end_layout

\begin_layout Plain Layout

  'Amp4' = cTF4,
\end_layout

\begin_layout Plain Layout

  'Phase' = phiTF,
\end_layout

\begin_layout Plain Layout

  'Phase3' = phiTF3,
\end_layout

\begin_layout Plain Layout

  'Phase4' = phiTF4
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

Panel2Label <- bquote('   Phase [' * degree ~ ']')
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  ggplotWAC(
\end_layout

\begin_layout Plain Layout

    dfAP,
\end_layout

\begin_layout Plain Layout

    panels = 2,
\end_layout

\begin_layout Plain Layout

    labelP = c(bquote('    ' ~ 'Amplitude'), Panel2Label), 
\end_layout

\begin_layout Plain Layout

    labelL = c('best', 't1=0.05', 't2=0.6'),
\end_layout

\begin_layout Plain Layout

    lty = c(1, 1, 2)
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab(bquote('transfer function H(' * nu
 ~ ')'))
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  g + scale_x_log10(
\end_layout

\begin_layout Plain Layout

    breaks = trans_breaks("log10", function(x)
\end_layout

\begin_layout Plain Layout

      10 ^ x, n = 4),
\end_layout

\begin_layout Plain Layout

    labels = trans_format("log10", math_format(expr = 10 ^ .x))
\end_layout

\begin_layout Plain Layout

  ) + xlab('frequency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = 'tb')
\end_layout

\begin_layout Plain Layout

g + theme_WAC(1) + theme(legend.position = c(0.3, 0.65))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<SEQNS, include=TRUE, echo=FALSE, fig.cap='transfer function (amplitude
 and phase) for the Rosemount 102E4AL sensor, based on the parameters a=0.72,
 $
\backslash

\backslash
tau_1$=0.032 s, $
\backslash

\backslash
tau_2$=0.6 s.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

library(nleqslv)
\end_layout

\begin_layout Plain Layout

frq <- seq(0.01, 25, by=0.01)
\end_layout

\begin_layout Plain Layout

Phi <- rep(0, length(frq))
\end_layout

\begin_layout Plain Layout

H <- rep(0, length(frq))
\end_layout

\begin_layout Plain Layout

tau2 <- 0.6
\end_layout

\begin_layout Plain Layout

tau1 <- 0.032
\end_layout

\begin_layout Plain Layout

a <- 0.72
\end_layout

\begin_layout Plain Layout

zeta <- -atan(2*pi*frq*tau2)
\end_layout

\begin_layout Plain Layout

b <- cos(zeta)
\end_layout

\begin_layout Plain Layout

Param <- list(a=a, tau1=tau1, tau2=tau2, b=b, zeta=zeta, frq=frq)
\end_layout

\begin_layout Plain Layout

f2solve <- function (x) { # x[1]=phi, x[2]=cf
\end_layout

\begin_layout Plain Layout

  phi <- x[1]
\end_layout

\begin_layout Plain Layout

  cf <- x[2]
\end_layout

\begin_layout Plain Layout

  v <- x
\end_layout

\begin_layout Plain Layout

  v[1] <- a+(1-a)*bA*cos(zeta)+cf*tau1*2*pi*frqA*sin(phi)-cf*cos(phi)
\end_layout

\begin_layout Plain Layout

  v[2] <- cf*(tau1*2*pi*frqA*cos(phi)+sin(phi))-(1-a)*bA*sin(zeta)
\end_layout

\begin_layout Plain Layout

  return(v)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

for (i in 1:length(frq)) {
\end_layout

\begin_layout Plain Layout

  xg <- c(0.1, 0.5)
\end_layout

\begin_layout Plain Layout

  bA <- b[i]
\end_layout

\begin_layout Plain Layout

  zetaA <- zeta[i]
\end_layout

\begin_layout Plain Layout

  frqA <- frq[i]
\end_layout

\begin_layout Plain Layout

  r <- nleqslv(xg, f2solve)
\end_layout

\begin_layout Plain Layout

  Phi[i] <- r$x[1]
\end_layout

\begin_layout Plain Layout

  H[i] <- r$x[2]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

Phi <- Phi * 180 / pi
\end_layout

\begin_layout Plain Layout

dfAP <- data.frame('Amplitude'=H, 'Phase'=Phi)
\end_layout

\begin_layout Plain Layout

dfAP <- data.frame('Time'=frq, 'Amplitude'=H, 'Phase'=Phi)
\end_layout

\begin_layout Plain Layout

g <- ggplotWAC(dfAP, panels=2, labelP=c('       Amplitude', '    Phase [degrees]
'))
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab('transfer function')
\end_layout

\begin_layout Plain Layout

g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=4),
\end_layout

\begin_layout Plain Layout

     labels = trans_format("log10", math_format(expr = 10^.x))) + xlab('frequency
 [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides='tb')
\end_layout

\begin_layout Plain Layout

g + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Branch expanded
inverted 0
status open

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<FE, include=TRUE, echo=FALSE, fig.height=3, fig.cap='Fractional error in
 the cospectrum of sensible-heat flux caused by the delayed response of
 the Rosemount 102E4AL temperature sensor.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

dfFE <-
\end_layout

\begin_layout Plain Layout

  data.frame('Time' = frq,
\end_layout

\begin_layout Plain Layout

             'FractionalError' = 100 * (1 - dfAP$Amp * cos(dfAP$Phase *
 pi / 180)))
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  ggplotWAC(dfFE) + xlab('frequency [Hz]') + ylab('fractional error [%]')
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  g + scale_x_log10(
\end_layout

\begin_layout Plain Layout

    breaks = trans_breaks("log10", function(x)
\end_layout

\begin_layout Plain Layout

      10 ^ x, n = 4),
\end_layout

\begin_layout Plain Layout

    labels = trans_format("log10", math_format(expr = 10 ^ .x))
\end_layout

\begin_layout Plain Layout

  ) + xlab('frequency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = 'tb')
\end_layout

\begin_layout Plain Layout

g + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
These equations and their solution provide a basis for correcting either
 the measured temperature or the sensible-heat flux calculated from the
 cospectrum in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:heatFlux"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Corrected values can be obtained by several methods including integration
 of the equations for the derivatives or by dividing the Fourier transform
 of the time series by the transfer function and then using inverse Fourier
 transformation to recover the corrected time series.
\begin_inset Note Note
status collapsed

\begin_layout Enumerate
Solve 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for 
\begin_inset Formula $T_{r}(t)$
\end_inset

 and substitute that into 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to eliminate that unknown.
 The resulting equation can be solved for 
\begin_inset Formula $T_{s}(t)$
\end_inset

 by numerical integration from an arbitrary starting point.
 The result can then be substituted into 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to solve for 
\begin_inset Formula $T(t)$
\end_inset

, the corrected estimate of the true recovery temperature 
\begin_inset Formula $T_{r}(t)$
\end_inset

.
 Both steps require that the derivative of the measurement, 
\begin_inset Formula $dT_{m}(t)/dt$
\end_inset

, be estimated from finite differences or another higher-order formula.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Because by convention the variables in the data files represent the average
 value at the time corresponding to the midpoint of the time step, finite-differ
ence estimates need to be shifted forward by half the data period, or 0.02
\begin_inset space ~
\end_inset

s in this case of 25\SpecialChar softhyphen
Hz data.
\end_layout

\end_inset

 In practice, a fourth-order Runge-Kutta method is used here for the integration.
 Once 
\begin_inset Formula $T_{s}(t)$
\end_inset

 is known from that integration, 
\begin_inset Formula $T_{r}(t)$
\end_inset

 can be obtained by solution of the second equation without further integration.
\end_layout

\begin_layout Enumerate
Fourier transform the time series 
\begin_inset Formula $T_{m}(t)$
\end_inset

, divide the result by the transfer function, and use the inverse Fourier
 transform to recover the corrected time series.
 This is particularly suited to correction of the flux cospectrum because
 the corrected Fourier transform can be used directly
\end_layout

\end_inset

 Those correction schemes are discussed in Appendix A.
 To support such corrections, the next section determines the transfer function
 experimentally.
 
\end_layout

\begin_layout Subsection
The response to dynamic heating
\begin_inset CommandInset label
LatexCommand label
name "subsec:Dynamic-heating"

\end_inset


\end_layout

\begin_layout Standard
The evaluation of the time response that follows relies on the dynamic heating
 produced by airspeed fluctuations.
 In steady conditions a temperature sensor exposed to the air stream will
 measure the recovery temperature, defined as the ambient temperature increased
 by the effect of dynamic heating.
 Dynamic heating fluctuates as the airspeed fluctuates, so in a turbulent
 wind field fluctuations with a measurable frequency spectrum are imposed
 on the sensor.
 These fluctuations are often significantly larger than real fluctuations
 in the ambient temperature.
 Dynamic heating of temperature sensors is discussed for example by 
\begin_inset CommandInset citation
LatexCommand citet
key "BangeEtAl2013.ch2"
literal "false"

\end_inset

 (cf.
\begin_inset space ~
\end_inset

their Eq.
\begin_inset space ~
\end_inset

2.23), who express dynamic heating 
\begin_inset Formula $Q$
\end_inset

 as
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
Q=\alpha_{r}\frac{V^{2}}{2C_{p}}=T_{r}\left(\frac{\alpha_{r}M^{2}R_{a}/(2C_{v})}{1+\alpha_{r}M^{2}R_{a}/(2C_{v})}\right)\label{eq:DHterm}
\end{equation}

\end_inset

where 
\begin_inset Formula $\alpha_{r}$
\end_inset

 is the 
\begin_inset Quotes eld
\end_inset

recovery factor
\begin_inset Quotes erd
\end_inset

 characterizing the extent to which the air is brought to rest relative
 to the sensor, 
\begin_inset Formula $V$
\end_inset

 is the airspeed, 
\begin_inset Formula $C_{p}$
\end_inset

 and 
\begin_inset Formula $C_{v}$
\end_inset

 are respectively the specific heat of air at constant pressure and constant
 volume.
 
\begin_inset Formula $T_{r}$
\end_inset

 is the (true) recovery temperature expressed in absolute units, 
\begin_inset Formula $M$
\end_inset

 the Mach number, and 
\begin_inset Formula $R_{a}$
\end_inset

 the gas constant for air.
 The ambient air temperature 
\begin_inset Formula $T_{a}$
\end_inset

 is related to the recovery temperature and the dynamic heating via
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
T_{r}=T_{a}+Q\,\,\,.\label{eq:recoveryTemperature}
\end{equation}

\end_inset

Because dynamic heating can exceed 
\begin_inset Formula $20^{\circ}\mathrm{C}$
\end_inset

 at jet-aircraft flight speeds, it is often the dominant cause of fluctuations
 in the recovery temperature.
 If the fluctuations in dynamic heating are higher in frequency than those
 to which the sensor can respond, corresponding fluctuations will be attenuated
 in the measured spectrum and the phase of the measured response relative
 to the imposed signal will vary, from near 
\begin_inset Formula $0^{\circ}$
\end_inset

 for fluctuations slow compared to sensor response to near 
\begin_inset Formula $90^{\circ}$
\end_inset

 or even more
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
A sensor with a first-order time constant cannot produce a phase lag of
 more than 
\begin_inset Formula $90^{\circ}$
\end_inset

, but larger lags are possible for systems characterized by two time constants.
\end_layout

\end_inset


\end_layout

\end_inset

 for fluctuations fast compared to that response.
 The amplitude and phase of the recovery temperature relative to the dynamic-hea
ting forcing therefore can be used as sensitive indicators of the response
 characteristics of the sensor and can constrain parameters like 
\begin_inset Formula $a$
\end_inset

, 
\begin_inset Formula $\tau_{1}$
\end_inset

 and 
\begin_inset Formula $\tau_{2}$
\end_inset

 that fit the predictions to the observations.
 The evaluation in terms of the amplitude ratio and phase shift of the recovery
 temperature in response to dynamic heating will be used to characterize
 the transfer function and to determine if it is represented adequately
 by the parameterized form given by 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:responseAmp"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:responsePhase"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subsection
Data sources
\end_layout

\begin_layout Standard
The present investigation uses measurements from two NSF/NCAR (National
 Science Foundation / National Center for Atmospheric Research) research
 aircraft, a Gulfstream V (hereafter, GV) and a Hercules C-130.
 The temperature sensors producing the measurements are in widespread use
 so these results should have broad applicability.
 Some aspects of the uncertainty limits associated with these measurements
 of temperature are included in an NCAR Technical Note (
\begin_inset CommandInset citation
LatexCommand citet
key "Cooper2016ncartn"
literal "true"

\end_inset

), which focused on the measurements of wind from the GV\SpecialChar endofsentence
 That document included
 an estimate that the standard uncertainty in measurements of temperature
 from the GV is about 
\begin_inset Formula $0.3^{\circ}\mathrm{C}$
\end_inset

 and referenced 
\begin_inset CommandInset citation
LatexCommand citet
key "CooperEtAl2014"
literal "false"

\end_inset

 for supporting evidence.
 This limit applies when the temperature being measured is varying slowly
 but does not apply when the temperature changes rapidly.
 
\begin_inset CommandInset citation
LatexCommand citet
key "FrieheKhelif1992"
literal "false"

\end_inset

 and 
\begin_inset CommandInset citation
LatexCommand citet
key "LawsonRodi1992"
literal "false"

\end_inset

, among others, provide reviews of the evidence for delayed response of
 the standard sensors.
 In particular, the unheated Rosemount 102E4AL sensor has been used widely
 as a fast-responding sensor, so it will be a focus of this study.
\end_layout

\begin_layout Standard
This research uses data archives produced by three research projects, the
 VOCALS (VAMOS Ocean-Cloud-Atmosphere-Land Study), CSET (Cloud Systems Evolution
 in the Trades) and SOCRATES (Southern Ocean Clouds, Radiation, Aerosol
 Transport Experimental Study) experiments.
 The field projects are described by 
\begin_inset CommandInset citation
LatexCommand citet
key "wood2011vamos"
literal "false"

\end_inset

, 
\begin_inset CommandInset citation
LatexCommand citet
key "albrecht2019cloud"
literal "false"

\end_inset

 and 
\begin_inset CommandInset citation
LatexCommand citet
key "mcfarquhar2014southern"
literal "false"

\end_inset

, respectively.
 All included low-level flight segments over the Pacific Ocean that are
 used in this paper.
 The reference list includes appropriate DOI references to the measurements.
\end_layout

\begin_layout Subsection
Fits to the measurements
\end_layout

\begin_layout Standard
Because the airspeed 
\begin_inset Formula $V$
\end_inset

 is itself conventionally determined using the processed air temperature
 
\begin_inset Formula $T_{a}$
\end_inset

, via 
\begin_inset Formula $V=M\sqrt{\gamma R_{a}T_{a}}$
\end_inset

 where 
\begin_inset Formula $\gamma=C_{p}/C_{v}$
\end_inset

, the second expression in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:DHterm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 provides the advantage that it does not rely on prior calculation of the
 air temperature 
\begin_inset Formula $T_{a}$
\end_inset

 but can be calculated from only the recovery temperature 
\begin_inset Formula $T_{r}$
\end_inset

 and the Mach number.
 The Mach number in turn depends only on measurements of the dynamic and
 ambient pressures, with a small adjustment for the water vapor pressure.
 However, the available measurement is not the true recovery temperature
 
\begin_inset Formula $T_{r}$
\end_inset

 but instead the measured temperature 
\begin_inset Formula $T_{m}$
\end_inset

 which may not include high-frequency fluctuations in 
\begin_inset Formula $T_{r}$
\end_inset

.
 This in turn affects the estimated fluctuations determined from 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:DHterm"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 To minimize this problem, regions were sought where the fluctuations in
 dynamic heating were the dominant cause of fluctuations in recovery temperature.
 Temporarily consider these approximations: 
\begin_inset Formula $\alpha_{r}\approx1$
\end_inset

, 
\begin_inset Formula $R_{a}/(2C_{v})\approx1/5$
\end_inset

, and 
\begin_inset Formula $M$
\end_inset

 small enough that the denominator of the right side of 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:DHterm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 can be assumed equal to unity.
 Dynamic heating then is approximately 
\begin_inset Formula $Q\approx T_{r}M^{2}/5$
\end_inset

 and fluctuations in 
\begin_inset Formula $Q$
\end_inset

 are related to those in 
\begin_inset Formula $T_{r}$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 according to
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\frac{\delta Q}{Q}\approx\frac{\delta T_{r}}{T_{r}}+\frac{2}{5}\frac{\delta M}{M}\label{eq:QprimeOverQ}
\end{equation}

\end_inset

Because the measured recovery temperature 
\begin_inset Formula $T_{m}$
\end_inset

 may not include true high-frequency fluctuations in 
\begin_inset Formula $T_{r}$
\end_inset

, the measured phase and amplitude of the response to the dynamic-heating
 term may be distorted from the correct value at frequencies where 
\begin_inset Formula $\delta T_{m}/T_{m}$
\end_inset

 differs from 
\begin_inset Formula $\delta T_{r}/T_{r}$
\end_inset

.
 In regions where the last term in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:QprimeOverQ"
plural "false"
caps "false"
noprefix "false"

\end_inset

 dominates, underestimation of the fluctuations in the recovery temperature
 arising from sensor response will cause less significant errors in the
 measured fluctuations in dynamic heating 
\begin_inset Formula $Q$
\end_inset

, and those errors can be addressed by correction procedures.
\end_layout

\begin_layout Standard
\begin_inset Branch expanded
inverted 0
status open

\begin_layout Standard
Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:Qprime}
\end_layout

\end_inset

 shows the contributions to the dynamic-heating term from the two terms
 on the right side of 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:QprimeOverQ"
plural "false"
caps "false"
noprefix "false"

\end_inset

, except that 
\begin_inset Formula $T_{m}$
\end_inset

 is used instead of the unknown 
\begin_inset Formula $T_{r}$
\end_inset

.
 
\end_layout

\end_inset

For a representative low-level flight segment with moderate turbulence where
 the airspeed fluctuations were approximately consistent with an eddy dissipatio
n rate of 
\begin_inset Formula $3\times10^{-4}\,\mathrm{m}^{2}\mathrm{s}^{-3}$
\end_inset

, the variance of the second term in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:QprimeOverQ"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is more than 100 times that of the first, indicating that the fluctuations
 in the first term are less than 10% of those in the second term.
 Therefore the right side of 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:DHterm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 with 
\begin_inset Formula $T_{m}$
\end_inset

 in place of 
\begin_inset Formula $T_{r}$
\end_inset

 was used initially to represent dynamic heating.
 Once a set of parameters was determined, 
\begin_inset Formula $T_{r}(t)$
\end_inset

 was calculated using the first correction procedure discussed in Appendix
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Correcting-the-Temperature"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Using this revised estimate of 
\begin_inset Formula $T_{r}(t)$
\end_inset

 in place of 
\begin_inset Formula $T_{m}(t)$
\end_inset

 led to a small change in the fitted values of the parameters, but the estimate
 became stable after only one iteration.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<TASX, include = FALSE, fig.height = 3.4, fig.cap = 'Spectral variance $P(
\backslash

\backslash
nu)$ for airspeed ($V$) as a function of frequency $
\backslash

\backslash
nu$ from a segment from VOCALS C-130 flight 3, 11:39:00 -- 11:52:00 UTC.
 The dotted orange lines show the spectral variance for various values of
 the eddy dissipation rate, with the heavy-dotted line representing $10^{-4}$
 m$^2$ s$^{-3}$.
 The wavelength scale shows the correspondence between frequency and wavelength
 at the average airspeed.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

reviseDH <-
\end_layout

\begin_layout Plain Layout

  function (.data, P, alphaR) {
\end_layout

\begin_layout Plain Layout

    # P is Param1, e.g.; alphaR is recovery factor
\end_layout

\begin_layout Plain Layout

    .data$Q <- .data$TASX ^ 2 / 2010
\end_layout

\begin_layout Plain Layout

    aV <- P$a
\end_layout

\begin_layout Plain Layout

    tau1V <- P$tau1
\end_layout

\begin_layout Plain Layout

    tau2V <- P$tau2
\end_layout

\begin_layout Plain Layout

    Rate <- attr (.data, 'Rate')
\end_layout

\begin_layout Plain Layout

    fS <- function(y, i) {
\end_layout

\begin_layout Plain Layout

      (.data$Q[i] - y) / (tau2V * Rate)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    fM <- function (y, i) {
\end_layout

\begin_layout Plain Layout

      (aV * .data$Q[i] + (1 - aV) * TsQ[i] - y) / (Rate * tau1V)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    TsQ <- rk4.integrate (fS, .data$Q[1], 1:nrow(.data))
\end_layout

\begin_layout Plain Layout

    Qp <- rk4.integrate (fM, .data$Q[1], 1:nrow(.data))
\end_layout

\begin_layout Plain Layout

    return (.data$ATX + alphaR * (.data$Q - Qp))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

if (file.exists ('./DVOCALS.Rdata')) {
\end_layout

\begin_layout Plain Layout

  load (file = './DVOCALS.Rdata')
\end_layout

\begin_layout Plain Layout

  DVOCALS <- D
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  D <- getNetCDF(
\end_layout

\begin_layout Plain Layout

    file.path(DataDirectory(), 'VOCALS/VOCALSrf03h.nc'),
\end_layout

\begin_layout Plain Layout

    c(
\end_layout

\begin_layout Plain Layout

      'TASX',
\end_layout

\begin_layout Plain Layout

      'PALT',
\end_layout

\begin_layout Plain Layout

      'TTRR',
\end_layout

\begin_layout Plain Layout

      'ATRR',
\end_layout

\begin_layout Plain Layout

      'TTWH',
\end_layout

\begin_layout Plain Layout

      'WIC',
\end_layout

\begin_layout Plain Layout

      'ATX',
\end_layout

\begin_layout Plain Layout

      'PSXC',
\end_layout

\begin_layout Plain Layout

      'QCXC'
\end_layout

\begin_layout Plain Layout

    )
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

  D$DH <- D$TASX ^ 2 / 2010
\end_layout

\begin_layout Plain Layout

  ## For use later, "filter" the dynamic-heating term and revise the temperature
:
\end_layout

\begin_layout Plain Layout

  alphaR <- attr(D[, 'ATRR'], 'RecoveryFactor')
\end_layout

\begin_layout Plain Layout

  D$AT <- reviseDH(D, Param1, alphaR)
\end_layout

\begin_layout Plain Layout

  ## Find a corrected recovery temperature to use in the estimate of dynamic
 heating:
\end_layout

\begin_layout Plain Layout

  a <- Param1$a
\end_layout

\begin_layout Plain Layout

  tau1 <- Param1$tau1
\end_layout

\begin_layout Plain Layout

  tau2 <- Param1$tau2
\end_layout

\begin_layout Plain Layout

  ## RT is the working solution; Ts is the support temperature
\end_layout

\begin_layout Plain Layout

  D$Ts <- D$TTRR
\end_layout

\begin_layout Plain Layout

  Rate <- attr (D, 'Rate')
\end_layout

\begin_layout Plain Layout

  D$DTMDT <-
\end_layout

\begin_layout Plain Layout

    c(0, diff(D$TTRR, 2), 0) * Rate / 2  ## Average this and one-sample-advanced
\end_layout

\begin_layout Plain Layout

  # D$DTMDT <- (D$DTMDT + c(0, D$DTMDT[1:(nrow(D)-1)])) / 2
\end_layout

\begin_layout Plain Layout

  # DT$DTMDT <- as.vector (signal::filter(signal::sgolay(1, 3, m=1), DT$TTRR))
 * Rate
\end_layout

\begin_layout Plain Layout

  fS <- function(y, i) {
\end_layout

\begin_layout Plain Layout

    # Eq.
 Ts3
\end_layout

\begin_layout Plain Layout

    ((1 / a) * (tau1 * D$DTMDT[i] + D$TTRR[i] - (1 - a) * y) - y) / (Rate
 * tau2)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  D$Ts <- rk4.integrate (fS, D$Ts[1], 1:nrow(D))
\end_layout

\begin_layout Plain Layout

  D$RT <- (1 / a) * (tau1 * D$DTMDT + D$TTRR - (1 - a) * D$Ts)
\end_layout

\begin_layout Plain Layout

  # D %>% select(Time, TTRR, RT, Ts) %>% selectTime(114500, 114505) %>%
 plotWAC()
\end_layout

\begin_layout Plain Layout

  save(D, file = './DVOCALS.Rdata')
\end_layout

\begin_layout Plain Layout

  DVOCALS <- D
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

## Revise the calculation of dynamic heating to avoid dependence on AT:
\end_layout

\begin_layout Plain Layout

D$MACH <- MachNumber(D$PSXC, D$QCXC)
\end_layout

\begin_layout Plain Layout

XXA <- attr(D[, 'ATRR'], 'RecoveryFactor') * D$MACH ^ 2 / 5
\end_layout

\begin_layout Plain Layout

D$DH <- (D$TTRR + 273.15) * XXA / (1 + XXA)
\end_layout

\begin_layout Plain Layout

D$DH2 <- (D$RT + 273.15) * XXA / (1 + XXA)
\end_layout

\begin_layout Plain Layout

## temporary: shift D$AT later in time
\end_layout

\begin_layout Plain Layout

# D$AT <- ShiftInTime (D$AT, .rate=25, .shift=40)
\end_layout

\begin_layout Plain Layout

Tasm <- mean(D$TASX, na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

DT <- D %>% selectTime(113900, 115200)
\end_layout

\begin_layout Plain Layout

## Save it for use in the workflow document:
\end_layout

\begin_layout Plain Layout

save(DT, file='DT.Rdata')
\end_layout

\begin_layout Plain Layout

# select six boundary-layer segments of 10 min each:
\end_layout

\begin_layout Plain Layout

DT1 <- D %>% selectTime(65000, 70000)
\end_layout

\begin_layout Plain Layout

DT2 <- D %>% selectTime(73300, 74300)
\end_layout

\begin_layout Plain Layout

DT3 <- D %>% selectTime(104600, 105600)
\end_layout

\begin_layout Plain Layout

DT4 <- D %>% selectTime(114200, 115200)  ## 113900, 115200
\end_layout

\begin_layout Plain Layout

DT5 <- D %>% selectTime(124300, 125300)
\end_layout

\begin_layout Plain Layout

DT6 <- D %>% selectTime(133000, 134000)
\end_layout

\begin_layout Plain Layout

DZV <- rbind(DT1, DT2, DT3, DT4, DT5, DT6)
\end_layout

\begin_layout Plain Layout

rhozero <- 1013.25 * 100 / (287.05 * 288.15)
\end_layout

\begin_layout Plain Layout

# omitting 832-841, 920-951, 955-1005 -- look problematic
\end_layout

\begin_layout Plain Layout

# g <- VSpec(DT, 'TTRR', spans=99, xlim=c(0.01,15), ylim=c(1.e-5, 1.e-1))
\end_layout

\begin_layout Plain Layout

# g <- VSpec(DT, 'ATRR', spans=99, add=g)
\end_layout

\begin_layout Plain Layout

# VSpec(DT, 'DH', spans=99, add=g) + theme_WAC()
\end_layout

\begin_layout Plain Layout

DT$V <- DT$TASX
\end_layout

\begin_layout Plain Layout

VSpec(DT, 'V', VLabel='V=airspeed', spans = 99, ylim=c(1.e-3, 10)) + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch expanded
inverted 0
status open

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<Qprime, include=TRUE, fig.height=3.4, fig.pos='t', fig.cap='Frequency-weighted
 spectral variance for $
\backslash

\backslash
delta T_m/T_m$ and 0.4$
\backslash

\backslash
delta M/M$ as functions of frequency ($
\backslash

\backslash
nu$) for a low-level flight segment from VOCALS flight 3, 21 Oct 2008 11:39:00
 -- 11:52:00 UTC.
 The wavelength scale shows the correspondence between frequency and wavelength
 at the average airspeed.
 The two terms are labeled 
\begin_inset Quotes eld
\end_inset

Tm
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

Mach
\begin_inset Quotes erd
\end_inset

 in the legend.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DT$Mach <- (DT$MACH - mean(DT$MACH, na.rm = TRUE)) / 
\end_layout

\begin_layout Plain Layout

            mean(DT$MACH, na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

DT$Tm <- (DT$TTRR - mean(DT$TTRR, na.rm = TRUE)) / 
\end_layout

\begin_layout Plain Layout

          (273.15 + mean(DT$TTRR, na.rm = TRUE))
\end_layout

\begin_layout Plain Layout

DT$Mach <- DT$Mach * 0.4
\end_layout

\begin_layout Plain Layout

g <- VSpec(DT, 'Mach', ylim = c(1.e-10, 1.e-4))
\end_layout

\begin_layout Plain Layout

VSpec(DT, 'Tm', add = g) + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<extra2, include=FALSE, echo=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## This is a special version with features not in the standard Ranadu version
\end_layout

\begin_layout Plain Layout

CohP <-
\end_layout

\begin_layout Plain Layout

  function (.data,
\end_layout

\begin_layout Plain Layout

            .Var1,
\end_layout

\begin_layout Plain Layout

            .Var2,
\end_layout

\begin_layout Plain Layout

            col = 'blue',
\end_layout

\begin_layout Plain Layout

            spans = 25,
\end_layout

\begin_layout Plain Layout

            smoothBins = 50,
\end_layout

\begin_layout Plain Layout

            plotType = 'ggplot',
\end_layout

\begin_layout Plain Layout

            showErrors = 0,
\end_layout

\begin_layout Plain Layout

            returnCospectrum = FALSE) {
\end_layout

\begin_layout Plain Layout

    if (is.data.frame(.data)) {
\end_layout

\begin_layout Plain Layout

      if (.Var1 %in% names(.data)) {
\end_layout

\begin_layout Plain Layout

        Z <-
\end_layout

\begin_layout Plain Layout

          capture.output (Vr <-
\end_layout

\begin_layout Plain Layout

                            SmoothInterp(detrend (.data[, c('Time', .Var1)]),
 .Length = 0))
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        print(sprintf(
\end_layout

\begin_layout Plain Layout

          'CohPhase ERROR: Variable %s is not in the supplied data.frame',
\end_layout

\begin_layout Plain Layout

          .Var1
\end_layout

\begin_layout Plain Layout

        ))
\end_layout

\begin_layout Plain Layout

        return (NA)
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      if (.Var2 %in% names(.data)) {
\end_layout

\begin_layout Plain Layout

        Z <-
\end_layout

\begin_layout Plain Layout

          capture.output (VrC <-
\end_layout

\begin_layout Plain Layout

                            SmoothInterp(detrend (.data[, c('Time', .Var2)]),
 .Length = 0))
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        print(sprintf(
\end_layout

\begin_layout Plain Layout

          'CohPhase ERROR: Variable %s is not in the supplied data.frame',
\end_layout

\begin_layout Plain Layout

          .Var2
\end_layout

\begin_layout Plain Layout

        ))
\end_layout

\begin_layout Plain Layout

        return (NA)
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      print('CohPhase ERROR: first argument is not a data.frame.')
\end_layout

\begin_layout Plain Layout

      return (NA)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if (is.null(attr(.data, 'Rate'))) {
\end_layout

\begin_layout Plain Layout

      print ('CohPhase warning: Rate attribute missing from data.frame, so
 using Rate=1')
\end_layout

\begin_layout Plain Layout

      Rate <- 1
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      Rate <- attr(.data, 'Rate')
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    vcv <- cbind(ts(Vr, frequency = Rate), ts(VrC, frequency = Rate))
\end_layout

\begin_layout Plain Layout

    P <-
\end_layout

\begin_layout Plain Layout

      spec.pgram(
\end_layout

\begin_layout Plain Layout

        vcv,
\end_layout

\begin_layout Plain Layout

        detrend = FALSE,
\end_layout

\begin_layout Plain Layout

        fast = TRUE,
\end_layout

\begin_layout Plain Layout

        plot = FALSE,
\end_layout

\begin_layout Plain Layout

        spans = spans
\end_layout

\begin_layout Plain Layout

      )
\end_layout

\begin_layout Plain Layout

    df1 <- data.frame(P$coh, log(P$freq))
\end_layout

\begin_layout Plain Layout

    df2 <- data.frame (P$phase, log(P$freq))
\end_layout

\begin_layout Plain Layout

    df3 <- data.frame (P$spec[, 1], log(P$freq))
\end_layout

\begin_layout Plain Layout

    df4 <- data.frame (P$spec[, 2], log(P$freq))
\end_layout

\begin_layout Plain Layout

    pf1 <- binStats (df1, bins = smoothBins)
\end_layout

\begin_layout Plain Layout

    pf2 <- binStats (df2, bins = smoothBins)
\end_layout

\begin_layout Plain Layout

    pf3 <- binStats (df3, bins = smoothBins)
\end_layout

\begin_layout Plain Layout

    pf4 <- binStats (df4, bins = smoothBins)
\end_layout

\begin_layout Plain Layout

    pf1 <- pf1[!is.na (pf1$ybar),]
\end_layout

\begin_layout Plain Layout

    pf2 <- pf2[!is.na (pf2$ybar),]
\end_layout

\begin_layout Plain Layout

    pf3 <- pf3[!is.na (pf3$ybar),]
\end_layout

\begin_layout Plain Layout

    pf4 <- pf4[!is.na (pf4$ybar),]
\end_layout

\begin_layout Plain Layout

    # pf1$sigma[pf1$nb > 1] <- pf1$sigma[pf1$nb > 1] / sqrt(pf1$nb[pf1$nb
 > 2])
\end_layout

\begin_layout Plain Layout

    pf1$sigma[pf1$nb <= 1] <- NA # pf1$ybar[pf1$nb <= 1] * 0.5
\end_layout

\begin_layout Plain Layout

    # pf2$sigma[pf2$nb > 1] <- pf2$sigma[pf2$nb > 1] / sqrt(pf2$nb[pf2$nb
 > 2])
\end_layout

\begin_layout Plain Layout

    pf2$sigma[pf2$nb <= 1] <- NA # pf2$ybar[pf2$nb <= 1] * 0.5is
\end_layout

\begin_layout Plain Layout

    if (plotType != 'ggplot') {
\end_layout

\begin_layout Plain Layout

      pf1 <- binStats (df1, bins = smoothBins, addBin = TRUE)
\end_layout

\begin_layout Plain Layout

      pf2 <- binStats (df2, bins = smoothBins, addBin = TRUE)
\end_layout

\begin_layout Plain Layout

      pf3 <- binStats (df3, bins = smoothBins, addBin = TRUE)
\end_layout

\begin_layout Plain Layout

      pf4 <- binStats (df4, bins = smoothBins, addBin = TRUE)
\end_layout

\begin_layout Plain Layout

      return(cbind(pf1, pf2, pf3, pf4)[, c(2, 1, 3, 4, 6, 7, 10)])
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      d2 <-
\end_layout

\begin_layout Plain Layout

        data.frame(
\end_layout

\begin_layout Plain Layout

          Time = exp(pf1$xc),
\end_layout

\begin_layout Plain Layout

          coherence = pf1$ybar,
\end_layout

\begin_layout Plain Layout

          phase = pf2$ybar * 180 / pi,
\end_layout

\begin_layout Plain Layout

          clo = (pf1$ybar - showErrors * pf1$sigma),
\end_layout

\begin_layout Plain Layout

          chi = pf1$ybar + showErrors * pf1$sigma,
\end_layout

\begin_layout Plain Layout

          plo = (pf2$ybar - showErrors * pf2$sigma) * 180 / pi,
\end_layout

\begin_layout Plain Layout

          phi = (pf2$ybar + showErrors * pf2$sigma) * 180 / pi
\end_layout

\begin_layout Plain Layout

        )
\end_layout

\begin_layout Plain Layout

      d2$clo[!is.na(d2$clo) & (d2$clo < 0)] <- 0
\end_layout

\begin_layout Plain Layout

      labelP <- c('coherence', 'phase [degrees]')
\end_layout

\begin_layout Plain Layout

      g <- ggplotWAC(
\end_layout

\begin_layout Plain Layout

        d2[, c(1, 2, 3)],
\end_layout

\begin_layout Plain Layout

        panels = 2,
\end_layout

\begin_layout Plain Layout

        labelP = labelP,
\end_layout

\begin_layout Plain Layout

        col = col,
\end_layout

\begin_layout Plain Layout

        lwd = c(1.0),
\end_layout

\begin_layout Plain Layout

        lty = c(1),
\end_layout

\begin_layout Plain Layout

        xlab = 'freq'
\end_layout

\begin_layout Plain Layout

      )
\end_layout

\begin_layout Plain Layout

      g <-
\end_layout

\begin_layout Plain Layout

        g + xlab('frequency [Hz]') + ylab (sprintf ('%s x %s', .Var1, .Var2))
\end_layout

\begin_layout Plain Layout

      g <-
\end_layout

\begin_layout Plain Layout

        g + scale_x_log10(
\end_layout

\begin_layout Plain Layout

          breaks = trans_breaks("log10", function(x)
\end_layout

\begin_layout Plain Layout

            10 ^ x, n = 4),
\end_layout

\begin_layout Plain Layout

          labels = trans_format("log10", math_format(expr = 10 ^ .x))
\end_layout

\begin_layout Plain Layout

        ) + xlab('frequency [Hz]')
\end_layout

\begin_layout Plain Layout

      if (showErrors > 0 && smoothBins > 5) {
\end_layout

\begin_layout Plain Layout

        da <- data.frame(d2[, c(1, 4, 5)])
\end_layout

\begin_layout Plain Layout

        db <- data.frame(d2[, c(1, 6, 7)])
\end_layout

\begin_layout Plain Layout

        names(da) <- c('Time', 'ymin', 'ymax')
\end_layout

\begin_layout Plain Layout

        names(db) <- c('Time', 'ymin', 'ymax')
\end_layout

\begin_layout Plain Layout

        da$PanelGroup <- labelP[1]
\end_layout

\begin_layout Plain Layout

        db$PanelGroup <- labelP[2]
\end_layout

\begin_layout Plain Layout

        d <- rbind(db, da)
\end_layout

\begin_layout Plain Layout

        g <-
\end_layout

\begin_layout Plain Layout

          g + geom_ribbon(
\end_layout

\begin_layout Plain Layout

            data = d,
\end_layout

\begin_layout Plain Layout

            aes(
\end_layout

\begin_layout Plain Layout

              x = Time,
\end_layout

\begin_layout Plain Layout

              ymin = ymin,
\end_layout

\begin_layout Plain Layout

              ymax = ymax
\end_layout

\begin_layout Plain Layout

            ),
\end_layout

\begin_layout Plain Layout

            colour = 'grey',
\end_layout

\begin_layout Plain Layout

            alpha = 0.15,
\end_layout

\begin_layout Plain Layout

            inherit.aes = FALSE
\end_layout

\begin_layout Plain Layout

          )
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      g <- g + theme_WAC(1) + theme(legend.position = 'none')
\end_layout

\begin_layout Plain Layout

      if (returnCospectrum) {
\end_layout

\begin_layout Plain Layout

        CS <-
\end_layout

\begin_layout Plain Layout

          sqrt(P$coh[, 1] * P$spec[, 1] * P$spec[, 2] / (1 + tan(P$phase[,
 1]) ^
\end_layout

\begin_layout Plain Layout

                                                           2))
\end_layout

\begin_layout Plain Layout

        v1 <- SmoothInterp(.data[, .Var1], .Length = 0)
\end_layout

\begin_layout Plain Layout

        v2 <- SmoothInterp(.data[, .Var2], .Length = 0)
\end_layout

\begin_layout Plain Layout

        v1 <- detrend(data.frame(Time = .data$Time, v1))
\end_layout

\begin_layout Plain Layout

        v2 <- detrend(data.frame(Time = .data$Time, v2))
\end_layout

\begin_layout Plain Layout

        ff1 <- fft(v1)
\end_layout

\begin_layout Plain Layout

        ff2 <- fft(v2)
\end_layout

\begin_layout Plain Layout

        G <- Re(ff1 * Conj(ff2)) / nrow(.data)
\end_layout

\begin_layout Plain Layout

        GQ <- Im(ff1 * Conj(ff2)) / nrow(.data)
\end_layout

\begin_layout Plain Layout

        N <- nrow(.data) %/% 2
\end_layout

\begin_layout Plain Layout

        S1 <- Re(ff1 * Conj(ff1) / nrow(.data))
\end_layout

\begin_layout Plain Layout

        S2 <- Re(ff2 * Conj(ff2) / nrow(.data))
\end_layout

\begin_layout Plain Layout

        G <- G[2:(N + 1)]
\end_layout

\begin_layout Plain Layout

        GQ <- GQ[2:(N + 1)]
\end_layout

\begin_layout Plain Layout

        S1 <- S1[2:(N + 1)]
\end_layout

\begin_layout Plain Layout

        S2 <- S2[2:(N + 1)]
\end_layout

\begin_layout Plain Layout

        frq <- c(1:N) * Rate / nrow(.data)
\end_layout

\begin_layout Plain Layout

        spec1 <- 2 * S1 / Rate
\end_layout

\begin_layout Plain Layout

        spec2 <- 2 * S2 / Rate
\end_layout

\begin_layout Plain Layout

        cospec <- 2 * G / Rate
\end_layout

\begin_layout Plain Layout

        quad <- 2 * GQ / Rate
\end_layout

\begin_layout Plain Layout

        # cospectrum - i * quadrature = (gain spectrum) * exp(i*(phase spectrum)
)
\end_layout

\begin_layout Plain Layout

        # sqrt(cospectrum^2 + quadrature^2) is the amplitude or gain spectrum
\end_layout

\begin_layout Plain Layout

        return(data.frame(
\end_layout

\begin_layout Plain Layout

          freq = frq,
\end_layout

\begin_layout Plain Layout

          cospec = cospec,
\end_layout

\begin_layout Plain Layout

          quad = quad,
\end_layout

\begin_layout Plain Layout

          spec1 = spec1,
\end_layout

\begin_layout Plain Layout

          spec2 = spec2
\end_layout

\begin_layout Plain Layout

        ))
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        return(g)
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

RX <- CohPhase(DT, 'TTRR', 'DH', plotType = 'Ranadu')
\end_layout

\begin_layout Plain Layout

SB <- 200
\end_layout

\begin_layout Plain Layout

RXX <- CohPhase(DT1, 'TTRR', 'DH', plotType = 'Ranadu', smoothBins = SB)
\end_layout

\begin_layout Plain Layout

Z <-
\end_layout

\begin_layout Plain Layout

  capture.output (Vr <-
\end_layout

\begin_layout Plain Layout

                    SmoothInterp(detrend (DT1[, c('Time', 'TTRR')]), .Length
 = 0))
\end_layout

\begin_layout Plain Layout

Z <-
\end_layout

\begin_layout Plain Layout

  capture.output (VrC <-
\end_layout

\begin_layout Plain Layout

                    SmoothInterp(detrend (DT1[, c('Time', 'DH')]), .Length
 = 0))
\end_layout

\begin_layout Plain Layout

Rate <- attr(DT1, 'Rate')
\end_layout

\begin_layout Plain Layout

vcv <- cbind(ts(Vr, frequency = Rate), ts(VrC, frequency = Rate))
\end_layout

\begin_layout Plain Layout

P <- spec.pgram(
\end_layout

\begin_layout Plain Layout

  vcv,
\end_layout

\begin_layout Plain Layout

  detrend = FALSE,
\end_layout

\begin_layout Plain Layout

  fast = TRUE,
\end_layout

\begin_layout Plain Layout

  plot = FALSE,
\end_layout

\begin_layout Plain Layout

  spans = 25
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

df1 <- data.frame(P$coh, log(P$freq))
\end_layout

\begin_layout Plain Layout

df2 <- data.frame (P$phase, log(P$freq))
\end_layout

\begin_layout Plain Layout

pf1 <- binStats (df1, bins = SB)
\end_layout

\begin_layout Plain Layout

pf2 <- binStats (df2, bins = SB)
\end_layout

\begin_layout Plain Layout

## Use DH2 to get the time-response-corrected-RT Q
\end_layout

\begin_layout Plain Layout

RX1 <- CohP(DT1, 'TTRR', 'DH', plotType = 'Ranadu', smoothBins = SB)
\end_layout

\begin_layout Plain Layout

RX2 <- CohP(DT2, 'TTRR', 'DH', plotType = 'Ranadu', smoothBins = SB)
\end_layout

\begin_layout Plain Layout

RX3 <- CohP(DT3, 'TTRR', 'DH', plotType = 'Ranadu', smoothBins = SB)
\end_layout

\begin_layout Plain Layout

RX4 <- CohP(DT4, 'TTRR', 'DH', plotType = 'Ranadu', smoothBins = SB)
\end_layout

\begin_layout Plain Layout

RX5 <- CohP(DT5, 'TTRR', 'DH', plotType = 'Ranadu', smoothBins = SB)
\end_layout

\begin_layout Plain Layout

RX6 <- CohP(DT6, 'TTRR', 'DH', plotType = 'Ranadu', smoothBins = SB)
\end_layout

\begin_layout Plain Layout

phase <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

nphase <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

phase2 <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

ar <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

ar2 <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

nar <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

for (RX in list(RX1, RX2, RX3, RX4, RX5, RX6)) {
\end_layout

\begin_layout Plain Layout

  for (i in 2:nrow(RX)) {
\end_layout

\begin_layout Plain Layout

    phase[RX$BIN.1[i]] <- phase[RX$BIN.1[i]] + RX$P.phase[i]
\end_layout

\begin_layout Plain Layout

    nphase[RX$BIN.1[i]] <- nphase[RX$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

    phase2[RX$BIN.1[i]] <- phase2[RX$BIN.1[i]] + RX$P.phase[i] ^ 2
\end_layout

\begin_layout Plain Layout

    ar[RX$BIN.1[i]] <-
\end_layout

\begin_layout Plain Layout

      ar[RX$BIN.1[i]] + sqrt(RX$P.spec...1.[i] / RX$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

    ar2[RX$BIN.1[i]] <-
\end_layout

\begin_layout Plain Layout

      ar2[RX$BIN.1[i]] + (RX$P.spec...1.[i] / RX$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

    nar[RX$BIN.1[i]] <- nar[RX$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

nphase[nphase == 0] <- 1
\end_layout

\begin_layout Plain Layout

nar[nar == 0] <- 1
\end_layout

\begin_layout Plain Layout

mphase <- phase / nphase
\end_layout

\begin_layout Plain Layout

mphase2 <- phase2 / nphase
\end_layout

\begin_layout Plain Layout

sdp <- sqrt(mphase2 - mphase ^ 2)
\end_layout

\begin_layout Plain Layout

mphase <- mphase * 180 / pi
\end_layout

\begin_layout Plain Layout

sdp <- sdp * 180 / pi
\end_layout

\begin_layout Plain Layout

sdp <- sdp * 2 / sqrt(nphase)
\end_layout

\begin_layout Plain Layout

ar <- ar / nar
\end_layout

\begin_layout Plain Layout

ar2 <- ar2 / nar
\end_layout

\begin_layout Plain Layout

sdr <- sqrt(ar2 - ar ^ 2)
\end_layout

\begin_layout Plain Layout

sdr <- sdr * 2 / sqrt(nar)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
The unheated Rosemount 102E4AL sensor
\begin_inset CommandInset label
LatexCommand label
name "subsec:The-unheated-Rosemount"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Segment
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
start
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
end
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6:50:00
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7:00:00
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7:33:00
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7:43:00
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10:46:00
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10:56:00
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11:42:00
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11:52:00
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12:43:00
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12:53:00
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13:30:00
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13:40:00
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Flight segments from flight 3 of the VOCALS project, 21 October 2008.
 Listed times are UTC.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To characterize the response of the Rosemount 102E4AL sensor, six ten-minute
 low level flight segments in the marine boundary layer from one flight
 of the NCAR/NSF C-130 in the 
\begin_inset Quotes eld
\end_inset

VOCALS
\begin_inset Quotes erd
\end_inset

 project (
\begin_inset CommandInset citation
LatexCommand citet
key "wood2011vamos"
literal "false"

\end_inset

), which studied low-level clouds over the Pacific Ocean near Chile, were
 selected that had simular flight conditions including the intensity of
 the turbulence.
 The time intervals are listed in Table 1.
 For each flight segment, the phase and amplitude ratio between the measurement
 and the dynamic heating term were calculated using the R routine 
\begin_inset Quotes eld
\end_inset

spec.pgram()
\begin_inset Quotes erd
\end_inset

 with 25-point modified Daniell smoothing, and the results for all six segments
 were averaged in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(SB,0)}
\end_layout

\end_inset

 logarithmically spaced intervals in frequency.
 The results for the average phase are shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:Vphase}
\end_layout

\end_inset

a.
 The theoretical curve is based on best-fit parameters as determined from
 these measurements and those of the amplitude ratio, discussed next.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

include=FALSE, echo=FALSE
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

## special ggplotWAC mod for this plot:
\end_layout

\begin_layout Plain Layout

ggplotWACA <- function (.data, col="blue", xlab="TIME [UTC]", 
\end_layout

\begin_layout Plain Layout

                       ylab="", lwd=1, lty=1, logxy='',
\end_layout

\begin_layout Plain Layout

                       position=NA, lmargin=NA, ylim=NA,
\end_layout

\begin_layout Plain Layout

                       legend.position=c(0.5, 0.92), 
\end_layout

\begin_layout Plain Layout

                       panels=1,
\end_layout

\begin_layout Plain Layout

                       labelL=NA, labelP=NA, 
\end_layout

\begin_layout Plain Layout

                       gtitle=NA, theme.version=0, ...) {
\end_layout

\begin_layout Plain Layout

  if (!is.data.frame (.data)) {
\end_layout

\begin_layout Plain Layout

    print ("Error, first argument to ggplotWAC must be a data.frame")
\end_layout

\begin_layout Plain Layout

  } else {
\end_layout

\begin_layout Plain Layout

    if (!is.expression(ylab) && (ylab == "")) {
\end_layout

\begin_layout Plain Layout

      ylab <- names(.data)[2]
\end_layout

\begin_layout Plain Layout

      # print (attr(.data[, ylab], 'label'))
\end_layout

\begin_layout Plain Layout

      if (!is.null (ylbl <- attr(.data[, ylab], 'label'))) {
\end_layout

\begin_layout Plain Layout

        ylab <- ylbl
\end_layout

\begin_layout Plain Layout

        ## Convert to appropriate expressions where needed:
\end_layout

\begin_layout Plain Layout

        if (grepl('
\backslash

\backslash
[deg C
\backslash

\backslash
]', ylab)) {
\end_layout

\begin_layout Plain Layout

          ylab <- sub ('
\backslash

\backslash
[deg C
\backslash

\backslash
]', '', ylab)
\end_layout

\begin_layout Plain Layout

          ylab <- bquote(paste(.(ylab),' [','
\backslash
u00b0','C]'))
\end_layout

\begin_layout Plain Layout

        } else if (grepl('m
\backslash

\backslash
^-3
\backslash

\backslash
]', ylab)) {
\end_layout

\begin_layout Plain Layout

          ylab <- sub ('m
\backslash

\backslash
^-3
\backslash

\backslash
]', '', ylab)
\end_layout

\begin_layout Plain Layout

          ylab <- bquote(paste(.(ylab),m^-3, ']'))
\end_layout

\begin_layout Plain Layout

        } else if (grepl('degree
\backslash

\backslash
]', ylab)) {
\end_layout

\begin_layout Plain Layout

          ylab <- sub ('degree
\backslash

\backslash
]', '', ylab)
\end_layout

\begin_layout Plain Layout

          ylab <- bquote(paste(.(ylab),'
\backslash
u00b0',']'))
\end_layout

\begin_layout Plain Layout

        } else if (grepl('m s
\backslash

\backslash
^-2
\backslash

\backslash
]', ylab)) {
\end_layout

\begin_layout Plain Layout

          ylab <- sub('m s
\backslash

\backslash
^-2
\backslash

\backslash
]', '', ylab)
\end_layout

\begin_layout Plain Layout

          ylab <- bquote(paste(.(ylab),'m ',s^-2,']'))
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    ## protect against all-missing variables
\end_layout

\begin_layout Plain Layout

    for (j in 2:min(6, ncol(.data))) {
\end_layout

\begin_layout Plain Layout

      if (!any (!is.na (.data[, j]))) {
\end_layout

\begin_layout Plain Layout

        .data[1, j] <- -32767.
\end_layout

\begin_layout Plain Layout

        .data[2, j] <- 32767.
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if (!is.na(position[1])) {
\end_layout

\begin_layout Plain Layout

      h <- 0.9/position[2]
\end_layout

\begin_layout Plain Layout

      yp <- 0.05+(position[1]-0.5)*h
\end_layout

\begin_layout Plain Layout

      if (position[1] == 1) {
\end_layout

\begin_layout Plain Layout

        hh <- h+0.1
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        hh <- h
\end_layout

\begin_layout Plain Layout

        yp <- yp + 0.05
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      vp <- viewport(width=1, height=hh, x=0.5, y=yp)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    yrange <- c(min(.data[ ,2], na.rm=TRUE), max(.data[ ,2], na.rm=TRUE))
\end_layout

\begin_layout Plain Layout

    if (ncol(.data) > 2) {
\end_layout

\begin_layout Plain Layout

      for (j in 3:min(6, ncol(.data))) {
\end_layout

\begin_layout Plain Layout

        if (any (!is.na(.data[ ,j]))) {
\end_layout

\begin_layout Plain Layout

          yl <- min(.data[ ,j], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

          yh <- max(.data[ ,j], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

          if (yl < yrange[1]) {yrange[1] <- yl}
\end_layout

\begin_layout Plain Layout

          if (yh > yrange[2]) {yrange[2] <- yh}
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    nv <- names (.data); np <- length(nv) - 1
\end_layout

\begin_layout Plain Layout

    if (panels > 1) {
\end_layout

\begin_layout Plain Layout

      np <- np / panels
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if (!is.na(ylim[1])) {yrange <- ylim}
\end_layout

\begin_layout Plain Layout

    if (length(col) == 1 && np > 1) {
\end_layout

\begin_layout Plain Layout

      colrs <- c(col, 'forestgreen', 'red', 'skyblue', 'darkorange')
\end_layout

\begin_layout Plain Layout

      colrs <- colrs[-c((np+1):length(colrs))]
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      colrs <- col
\end_layout

\begin_layout Plain Layout

    } 
\end_layout

\begin_layout Plain Layout

    np <- 2
\end_layout

\begin_layout Plain Layout

    if (panels > 1) {
\end_layout

\begin_layout Plain Layout

      np <- np / panels
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    clr <- nv[-1] 
\end_layout

\begin_layout Plain Layout

    lwd <- c(lwd, rep(1,np)); lwd <- lwd[-c((np+1):length(lwd))]
\end_layout

\begin_layout Plain Layout

    lty <- c(lty, rep(1,np)); lty <- lty[-c((np+1):length(lty))]
\end_layout

\begin_layout Plain Layout

    if (panels == 1) {
\end_layout

\begin_layout Plain Layout

      names(colrs) <- clr
\end_layout

\begin_layout Plain Layout

      names(clr) <- clr
\end_layout

\begin_layout Plain Layout

      names(lwd) <- clr
\end_layout

\begin_layout Plain Layout

      names(lty) <- clr
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    ## now handle the faceting case:
\end_layout

\begin_layout Plain Layout

    if (panels > 1) {
\end_layout

\begin_layout Plain Layout

      DL <- nrow (.data); DC <- ncol(.data) - 1
\end_layout

\begin_layout Plain Layout

      lines_per_panel <- DC / panels
\end_layout

\begin_layout Plain Layout

      if (is.na(labelP[1])) {
\end_layout

\begin_layout Plain Layout

        labelP <- 'panel1'
\end_layout

\begin_layout Plain Layout

        for (k in 2:panels) {
\end_layout

\begin_layout Plain Layout

          labelP <- c(labelP, sprintf('panel%d',k))
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      VarGroup <- rep (gl (lines_per_panel, DL, labels=labelL), panels)
\end_layout

\begin_layout Plain Layout

      PanelGroup <- gl (panels, lines_per_panel*DL, labels=labelP)
\end_layout

\begin_layout Plain Layout

      dd <- data.frame(reshape2::melt(.data, 1, factorsAsStrings=TRUE), VarGroup,
 PanelGroup)
\end_layout

\begin_layout Plain Layout

      colrs <- rep(colrs, panels)
\end_layout

\begin_layout Plain Layout

      lwd <- rep(lwd, panels)
\end_layout

\begin_layout Plain Layout

      lty <- rep(lty, panels)
\end_layout

\begin_layout Plain Layout

      lvl <- levels(dd$VarGroup)
\end_layout

\begin_layout Plain Layout

      g <- with(dd, ggplot (dd, aes(Time, value, colour=VarGroup, linetype=VarGr
oup)))
\end_layout

\begin_layout Plain Layout

      g <- g + geom_path (aes(size=VarGroup), na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

      g <- g + scale_size_manual ('', labels=lvl, breaks=lvl, values = lwd)
\end_layout

\begin_layout Plain Layout

      g <- g + scale_linetype_manual ('', labels=lvl, breaks=lvl, values
 = lty)
\end_layout

\begin_layout Plain Layout

      g <- g + scale_colour_manual('', labels = lvl, breaks=lvl, values
 = colrs)
\end_layout

\begin_layout Plain Layout

      g <- g + facet_grid (PanelGroup ~ ., scales='free_y', drop=TRUE, labeller
 = label_parsed)
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      a <- sprintf ("aes (x=%s)", names(.data)[1])
\end_layout

\begin_layout Plain Layout

      g <- ggplot (data=.data, eval(parse(text=a)))
\end_layout

\begin_layout Plain Layout

      # g <- ggplot (data=.data, aes(x=eval (parse (text=names(.data)[1]))))
\end_layout

\begin_layout Plain Layout

      g <- g + ylim (yrange)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if (names(.data)[1] == "Time") {
\end_layout

\begin_layout Plain Layout

      g <- g + xlab ("Time [UTC]")
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      g <- g + xlab (names(.data)[1])
\end_layout

\begin_layout Plain Layout

    } 
\end_layout

\begin_layout Plain Layout

    if (!is.expression(ylab) && ylab == '') {
\end_layout

\begin_layout Plain Layout

      ylab <- names (.data)[2]
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    g <- g + ylab(ylab)
\end_layout

\begin_layout Plain Layout

    if (panels == 1) {
\end_layout

\begin_layout Plain Layout

      for (j in 1:min(np, 5)) {
\end_layout

\begin_layout Plain Layout

        a <- sprintf ("aes (y=%s, colour='%s', size='%s', linetype='%s')",
 
\end_layout

\begin_layout Plain Layout

                      clr[j], clr[j], clr[j], clr[j])
\end_layout

\begin_layout Plain Layout

        g <- g + geom_path (eval (parse (text=a)), na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      g <- g + scale_size_manual ("", labels=clr, breaks=clr, values = lwd)
\end_layout

\begin_layout Plain Layout

      g <- g + scale_linetype_manual ("", labels=clr, breaks=clr, values
 = lty)
\end_layout

\begin_layout Plain Layout

      g <- g + scale_colour_manual("", labels = clr, breaks=clr, values
 = colrs)
\end_layout

\begin_layout Plain Layout

      # g <- g + guides(colour = guide_legend(reverse=TRUE),
\end_layout

\begin_layout Plain Layout

      #                 linetype=guide_legend(reverse=TRUE),
\end_layout

\begin_layout Plain Layout

      #                 size=guide_legend(reverse=TRUE))
\end_layout

\begin_layout Plain Layout

      # print (c(clr, colrs, lwd, lty))
\end_layout

\begin_layout Plain Layout

      # print (names(colrs))
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if (length(gtitle) > 1) {
\end_layout

\begin_layout Plain Layout

      g <- g + ggtitle (gtitle)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    g <- g + theme_WAC(theme.version)
\end_layout

\begin_layout Plain Layout

    if (panels > 1) {
\end_layout

\begin_layout Plain Layout

      g <- g + theme(axis.text.x = element_text (size=11.5, margin=margin(15,0,0,0)
))
\end_layout

\begin_layout Plain Layout

      g <- g + theme(axis.title.x = element_text (size=12))
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if (is.na(legend.position[1])) {
\end_layout

\begin_layout Plain Layout

      g <- g + theme (legend.position='none')
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      g <- g + theme(legend.position=legend.position)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if (!is.na(position[1])) {
\end_layout

\begin_layout Plain Layout

      if (position[1] != 1) {
\end_layout

\begin_layout Plain Layout

        g <- g + theme(axis.title.x=element_blank(), axis.text.x=element_blank())
\end_layout

\begin_layout Plain Layout

        g <- g + theme(axis.title.y=element_text(size=12), 
\end_layout

\begin_layout Plain Layout

                       axis.text.y=element_text(size=12))
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        g <- g + theme(axis.title.y=element_text(size=12), 
\end_layout

\begin_layout Plain Layout

                       axis.text.y=element_text(size=12),
\end_layout

\begin_layout Plain Layout

                       axis.text.x=element_text(size=12),
\end_layout

\begin_layout Plain Layout

                       axis.title.x=element_text(size=12))
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if (!is.na(lmargin)) {
\end_layout

\begin_layout Plain Layout

      ## these should match values in theme_WAC()
\end_layout

\begin_layout Plain Layout

      g <- g + theme (plot.margin=unit(c(0.3,0.3,1.1,lmargin),"lines"))
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    ## preserve .data in the parent environment for plotting
\end_layout

\begin_layout Plain Layout

    # .data <<- .data
\end_layout

\begin_layout Plain Layout

    if (!is.na(position[1])) {
\end_layout

\begin_layout Plain Layout

      print (g, vp=vp)
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      return (g)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    ## suppressMessages(ggsave (.plotfile, g))
\end_layout

\begin_layout Plain Layout

    # suppressWarnings (print (g))
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    ## left from plotWAC: implement someday?
\end_layout

\begin_layout Plain Layout

    #       if (!is.expression(xlab)) {
\end_layout

\begin_layout Plain Layout

    #         # get data.rate
\end_layout

\begin_layout Plain Layout

    #         data.rate <- 1
\end_layout

\begin_layout Plain Layout

    #         itg <- x[!is.na(x[,1]), 1]  # protect against missing values
 at start
\end_layout

\begin_layout Plain Layout

    #         if ((itg[2]-itg[1]) <= 0.04) {data.rate <- 25}
\end_layout

\begin_layout Plain Layout

    #         if ((itg[2]-itg[1]) <= 0.02) {data.rate <- 50}
\end_layout

\begin_layout Plain Layout

    #         
\end_layout

\begin_layout Plain Layout

    #         # print (sprintf (" data.rate is %d", data.rate))
\end_layout

\begin_layout Plain Layout

    #         if (xlab == "TIME [UTC]") {
\end_layout

\begin_layout Plain Layout

    #           if (length(x[, 1]) < 180*data.rate+2) {          # needs
 revision for high-rate data
\end_layout

\begin_layout Plain Layout

    #             axis.POSIXct(1, x[, 1], format='%H:%M:%S', tck=0.02)
\end_layout

\begin_layout Plain Layout

    #           } else {
\end_layout

\begin_layout Plain Layout

    #             axis.POSIXct(1,x[, 1], format='%H:%M', tck=0.02)
\end_layout

\begin_layout Plain Layout

    #           }
\end_layout

\begin_layout Plain Layout

    #           axis.POSIXct(3,x[, 1], labels=NA, tck=0.02)
\end_layout

\begin_layout Plain Layout

    #         } else {
\end_layout

\begin_layout Plain Layout

    #           axis(1,tck=0.02)
\end_layout

\begin_layout Plain Layout

    #           axis(3,labels=NA,tck=0.02)
\end_layout

\begin_layout Plain Layout

    #         }
\end_layout

\begin_layout Plain Layout

    #       } else {
\end_layout

\begin_layout Plain Layout

    #         axis(1,tck=0.02)
\end_layout

\begin_layout Plain Layout

    #         axis(3,labels=NA,tck=0.02)
\end_layout

\begin_layout Plain Layout

    #       }
\end_layout

\begin_layout Plain Layout

    #       if ('y' %in% logxy) {
\end_layout

\begin_layout Plain Layout

    #         axis(2,at=aty,labels=labs)
\end_layout

\begin_layout Plain Layout

    #       } else {
\end_layout

\begin_layout Plain Layout

    #         axis(2,tck=0.02)
\end_layout

\begin_layout Plain Layout

    #       }
\end_layout

\begin_layout Plain Layout

    #       axis(4,labels=NA,tck=0.02)
\end_layout

\begin_layout Plain Layout

    #     } 
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<Vphase, include=TRUE, echo=FALSE, fig.height=4.5>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

df <- data.frame(frq = exp(pf2$xc), 
\end_layout

\begin_layout Plain Layout

                 mphase = mphase,
\end_layout

\begin_layout Plain Layout

                 sdp = sdp)
\end_layout

\begin_layout Plain Layout

df <- df[df$frq > 0.01, ]
\end_layout

\begin_layout Plain Layout

df <- df[df$sdp > 0, ]
\end_layout

\begin_layout Plain Layout

df <- df[df$frq < 12, ]
\end_layout

\begin_layout Plain Layout

frq <- exp(pf2$xc[nar > 0])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Param5 <- Param1
\end_layout

\begin_layout Plain Layout

Param5$tau2 <- 0.6
\end_layout

\begin_layout Plain Layout

H5 <- LTphase(df$frq, Param5)
\end_layout

\begin_layout Plain Layout

cTF5 <- H5$Amp
\end_layout

\begin_layout Plain Layout

phiTF5 <- H5$Phase
\end_layout

\begin_layout Plain Layout

# df$Amp5 <- cTF5
\end_layout

\begin_layout Plain Layout

# plot(df$frq, df$mphase, type='p', pch=20, col='blue', log='x', xlim=c(1.e-2,
 15),
\end_layout

\begin_layout Plain Layout

#   xlab='frequency [Hz]', ylab='phase, RTRR x Q [degrees]', ylim=c(-80,
 9))
\end_layout

\begin_layout Plain Layout

# arrows(df$frq, df$mphase-df$sdp, df$frq, df$mphase+df$sdp, length=0.05,
 angle=90, code=3)
\end_layout

\begin_layout Plain Layout

g <- ggplot(df, aes(x=frq, y=mphase))+geom_point()
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab (bquote('phase [' ~ degree * ']'))
\end_layout

\begin_layout Plain Layout

g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=4),
\end_layout

\begin_layout Plain Layout

         labels = trans_format("log10", math_format(expr = 10^.x))) + xlab('frequ
ency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = "bt")
\end_layout

\begin_layout Plain Layout

g <- g + geom_errorbar(aes(ymin=mphase-sdp, ymax=mphase+sdp), width=0.06)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfAP, aes(x=Time, y=Phase), col='forestgreen', lwd=1.5)
\end_layout

\begin_layout Plain Layout

g1 <- g + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

frq <- seq(0.01, 25, by=0.01)
\end_layout

\begin_layout Plain Layout

dfr <- data.frame(frq=exp(pf2$xc), mrspec=ar, sdr=sdr)
\end_layout

\begin_layout Plain Layout

dfr <- dfr[dfr$frq > 0.04, ]
\end_layout

\begin_layout Plain Layout

dfr <- dfr[dfr$sdr > 0, ]
\end_layout

\begin_layout Plain Layout

dfr <- dfr[dfr$frq < 12, ]
\end_layout

\begin_layout Plain Layout

frq <- exp(pf2$xc[nar > 0])
\end_layout

\begin_layout Plain Layout

# spec1 <- spec1[nspec1 > 0]
\end_layout

\begin_layout Plain Layout

# spec2 <- spec2[nspec1 > 0]
\end_layout

\begin_layout Plain Layout

# rspec <- spec1 / spec2
\end_layout

\begin_layout Plain Layout

# plotWAC(data.frame(frq, mrspec), xlab='frequency [Hz]', ylab='amplitude
 ratio RTRR/Q', type='p', 
\end_layout

\begin_layout Plain Layout

#         col='blue', log='x', pch=20, xlim=c(0.1,15), ylim=c(0,1.2))
\end_layout

\begin_layout Plain Layout

# HR <- LTphase(frq, Param1)
\end_layout

\begin_layout Plain Layout

# P <- Param1
\end_layout

\begin_layout Plain Layout

# P$tau2 <- 0.84
\end_layout

\begin_layout Plain Layout

# HR2 <- LTphase(frq, P)
\end_layout

\begin_layout Plain Layout

# lines(frq, (HR2$Amp)^2, col='forestgreen', lwd=2)
\end_layout

\begin_layout Plain Layout

# lines(frq, (HR$Amp)^2, col='darkorange', lwd=2, lty=2)
\end_layout

\begin_layout Plain Layout

Param5 <- Param1
\end_layout

\begin_layout Plain Layout

Param5$tau2 <- 0.6
\end_layout

\begin_layout Plain Layout

H5 <- LTphase(dfr$frq, Param5)
\end_layout

\begin_layout Plain Layout

cTF5 <- H5$Amp
\end_layout

\begin_layout Plain Layout

phiTF5 <- H5$Phase
\end_layout

\begin_layout Plain Layout

dfr$Amp5 <- cTF5
\end_layout

\begin_layout Plain Layout

g <- ggplot(dfr, aes(x=frq, y=mrspec))+geom_point()
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab ('amplitude ratio')
\end_layout

\begin_layout Plain Layout

g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=4),
\end_layout

\begin_layout Plain Layout

         labels = trans_format("log10", math_format(expr = 10^.x))) + xlab('frequ
ency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = "bt")
\end_layout

\begin_layout Plain Layout

g <- g + geom_errorbar(aes(ymin=mrspec-sdr, ymax=mrspec+sdr), width=0.06)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfAP, aes(x=Time, y=Amp, col='best', lty='best'),
 lwd=1.5)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfr, aes(x=frq, y=Amp5, col='tau2=0.6', lty='tau2=0.6'),
 lwd=1.2)
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  g + scale_colour_manual (
\end_layout

\begin_layout Plain Layout

    name = 'fit: ',
\end_layout

\begin_layout Plain Layout

    values = c("best" = "forestgreen", "tau2=0.6" = "darkorange")
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

g <- g + scale_linetype_manual (name = 'fit: ', 
\end_layout

\begin_layout Plain Layout

                                values = c('best' = 1, 'tau2=0.6'=2))
\end_layout

\begin_layout Plain Layout

g2 <- g + ylim(0, 1.3) + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

grid.newpage()
\end_layout

\begin_layout Plain Layout

position <- c(1, 2)
\end_layout

\begin_layout Plain Layout

      h <- 0.9/position[2]
\end_layout

\begin_layout Plain Layout

      yp <- 0.05+(position[1]-0.5)*h
\end_layout

\begin_layout Plain Layout

      if (position[1] == 1) {
\end_layout

\begin_layout Plain Layout

        hh <- h+0.1
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        hh <- h
\end_layout

\begin_layout Plain Layout

        yp <- yp + 0.05
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      vp1 <- viewport(width=1, height=hh, x=0.5, y=yp)
\end_layout

\begin_layout Plain Layout

position <- c(2, 2)
\end_layout

\begin_layout Plain Layout

      h <- 0.9/position[2]
\end_layout

\begin_layout Plain Layout

      yp <- 0.05+(position[1]-0.5)*h
\end_layout

\begin_layout Plain Layout

      if (position[1] == 1) {
\end_layout

\begin_layout Plain Layout

        hh <- h+0.1
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        hh <- h + 0.125
\end_layout

\begin_layout Plain Layout

        yp <- yp - 0.07
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      vp2 <- viewport(width=1, height=hh, x=0.5, y=yp)
\end_layout

\begin_layout Plain Layout

g2 <- g2 + theme(plot.margin=unit(c(0.3,0.3,1.1,1.7),"lines"))
\end_layout

\begin_layout Plain Layout

suppressWarnings(print(g1, vp=vp2))
\end_layout

\begin_layout Plain Layout

suppressWarnings(print(g2, vp=vp1))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Phase and amplitude ratio (or gain) for the measured recovery temperature
 relative to dynamic heating.
\end_layout

\end_inset

(top): Phase of measured recovery temperature relative to dynamic heating,
 for the measurements (with error bars) and for the theoretical response
 for the best-fit parameters (green line).
 The error bars indicate two-standard-deviation ranges in the mean at each
 plotted point.
 Data from the  flight segments listed in Table 1.
\begin_inset Newline newline
\end_inset

(bottom): The ratio of the spectral amplitude for the measurement of recovery
 temperature (
\begin_inset Formula $T_{m}(t)$
\end_inset

) to that for dynamic heating (
\begin_inset Formula $Q$
\end_inset

), shown as the plotted data points.
 There are additional data points at frequencies below about 0.04 Hz that
 do not appear in this plot because they lie above the upper limit for the
 ordinate.
 The green line is the prediction from the transfer function determined
 from the best-fit values matching the phase lag between these variables,
 and the dashed orange line is a similar result with the second time constant
 
\begin_inset Formula $\tau_{2}$
\end_inset

 increased from 0.447 to 0.6
\begin_inset space ~
\end_inset

s to illustrate sensitivity to this parameter.
\begin_inset CommandInset label
LatexCommand label
name "fig:Vphase"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<checkAmplitude, include=FALSE, fig.pos='t', fig.height = 3.5, fig.cap='The
 ratio of the spectral amplitude for the measurement of recovery temperature
 ($T_m(t)$) to that for dynamic heating ($Q$), shown as the plotted data
 points.
 There are additional data points at frequencies below about 0.04 Hz that
 do not appear in this plot because they lie above the upper limit for the
 ordinate.
 The green line is the prediction from the transfer function determined
 from the best-fit values matching the phase lag between these variables,
 and the dashed orange line is a similar result with the second time constant
 $
\backslash

\backslash
tau_2$ increased from 0.447 to 0.6 s to illustrate sensitivity to this parameter.'>
>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

dfr <- data.frame(frq=exp(pf2$xc), mrspec=ar, sdr=sdr)
\end_layout

\begin_layout Plain Layout

dfr <- dfr[dfr$frq > 0.01, ]
\end_layout

\begin_layout Plain Layout

dfr <- dfr[dfr$sdr > 0, ]
\end_layout

\begin_layout Plain Layout

dfr <- dfr[dfr$frq < 12, ]
\end_layout

\begin_layout Plain Layout

frq <- exp(pf2$xc[nar > 0])
\end_layout

\begin_layout Plain Layout

# spec1 <- spec1[nspec1 > 0]
\end_layout

\begin_layout Plain Layout

# spec2 <- spec2[nspec1 > 0]
\end_layout

\begin_layout Plain Layout

# rspec <- spec1 / spec2
\end_layout

\begin_layout Plain Layout

# plotWAC(data.frame(frq, mrspec), xlab='frequency [Hz]', ylab='amplitude
 ratio RTRR/Q', type='p', 
\end_layout

\begin_layout Plain Layout

#         col='blue', log='x', pch=20, xlim=c(0.1,15), ylim=c(0,1.2))
\end_layout

\begin_layout Plain Layout

# HR <- LTphase(frq, Param1)
\end_layout

\begin_layout Plain Layout

# P <- Param1
\end_layout

\begin_layout Plain Layout

# P$tau2 <- 0.84
\end_layout

\begin_layout Plain Layout

# HR2 <- LTphase(frq, P)
\end_layout

\begin_layout Plain Layout

# lines(frq, (HR2$Amp)^2, col='forestgreen', lwd=2)
\end_layout

\begin_layout Plain Layout

# lines(frq, (HR$Amp)^2, col='darkorange', lwd=2, lty=2)
\end_layout

\begin_layout Plain Layout

Param5 <- Param1
\end_layout

\begin_layout Plain Layout

Param5$tau2 <- 0.6
\end_layout

\begin_layout Plain Layout

H5 <- LTphase(dfr$frq, Param5)
\end_layout

\begin_layout Plain Layout

cTF5 <- H5$Amp
\end_layout

\begin_layout Plain Layout

phiTF5 <- H5$Phase
\end_layout

\begin_layout Plain Layout

dfr$Amp5 <- cTF5
\end_layout

\begin_layout Plain Layout

g <- ggplot(dfr, aes(x=frq, y=mrspec))+geom_point()
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab ('amplitude ratio')
\end_layout

\begin_layout Plain Layout

g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=4),
\end_layout

\begin_layout Plain Layout

         labels = trans_format("log10", math_format(expr = 10^.x))) + xlab('frequ
ency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = "bt")
\end_layout

\begin_layout Plain Layout

g <- g + geom_errorbar(aes(ymin=mrspec-sdr, ymax=mrspec+sdr), width=0.06)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfAP, aes(x=Time, y=Amp, col='best', lty='best'))
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfr, aes(x=frq, y=Amp5, col='tau2=0.6', lty='tau2=0.6'))
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  g + scale_colour_manual (
\end_layout

\begin_layout Plain Layout

    name = 'fit: ',
\end_layout

\begin_layout Plain Layout

    values = c("best" = "forestgreen", "tau2=0.6" = "darkorange")
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

g <- g + scale_linetype_manual (name = 'fit: ', 
\end_layout

\begin_layout Plain Layout

                                values = c('best' = 1, 'tau2=0.6'=2))
\end_layout

\begin_layout Plain Layout

suppressWarnings(print(g + ylim(0, 1.3) + theme_WAC(1)))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The ratio of the amplitude of the response to that of the dynamic-heating
 signal, used as an estimate of the gain of the transfer function, is shown
 in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:Vphase}
\end_layout

\end_inset

b.
 It is useful to consider both the amplitude and phase when determining
 the response parameters because, as shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:LTsolution}
\end_layout

\end_inset

, the amplitude of the transfer function is more sensitive to 
\begin_inset Formula $\tau_{2}$
\end_inset

 than the phase but 
\begin_inset Formula $\tau_{1}$
\end_inset

 is a very sensitive predictor of the phase at high frequency.
 For the set of favored parameters, Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:Vphase}
\end_layout

\end_inset

b shows the standard prediction and another with 
\begin_inset Formula $\tau_{2}$
\end_inset

 set to 0.6
\begin_inset space ~
\end_inset

s instead, to show the sensitivity of this result to that parameter.
 The best prediction based on the measured phases consistently underestimates
 the ratio of spectra for frequencies below about 0.1
\begin_inset space ~
\end_inset

Hz and above about 3
\begin_inset space ~
\end_inset

Hz but is reasonably consistent with the observed ratio between 0.1
\begin_inset space ~
\end_inset

Hz and 3
\begin_inset space ~
\end_inset

Hz.
 Below 0.1
\begin_inset space ~
\end_inset

Hz it appears likely that the sensor is responding to real fluctuations
 in temperature not attributable to dynamic heating, as would be expected
 at these low frequencies.
 Above 3
\begin_inset space ~
\end_inset

Hz the prediction is much too low, probably because there is noise or other
 spurious variance in 
\begin_inset Formula $T_{m}(t)$
\end_inset

 not caused by dynamic heating.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
The orange dashed line, showing the result when 
\begin_inset Formula $\tau_{2}$
\end_inset

 is decreased to 0.4
\begin_inset space ~
\end_inset

s, is a much better fit.
 This suggests that the second time constant determined from the fit to
 the phase is overestimated, so this revised value for 
\begin_inset Formula $\tau_{2}$
\end_inset

 will be interpreted as the best value.
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
However, the previous standard parameters as represented by the green line
 will continue to be used as the best estimate because the spectral ratio
 is more easily confounded, especially by departures of the data toward
 higher values, by extraneous sources of variance in 
\begin_inset Formula $T_{m}(t)$
\end_inset

 not produced by 
\begin_inset Formula $Q$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<fitCoefs, include=TRUE, echo=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Param2 <- Param1
\end_layout

\begin_layout Plain Layout

## Restrict dfr frequencies:
\end_layout

\begin_layout Plain Layout

dfr <- dfr[dfr$frq > 0.1 & dfr$frq < 3, ]
\end_layout

\begin_layout Plain Layout

minFn <- function(V) {
\end_layout

\begin_layout Plain Layout

  Param2$a <<- V[1]
\end_layout

\begin_layout Plain Layout

  Param2$tau1 <<- V[2]
\end_layout

\begin_layout Plain Layout

  Param2$tau2 <<- V[3]
\end_layout

\begin_layout Plain Layout

  Chisq <- 0
\end_layout

\begin_layout Plain Layout

  for (i in 1:nrow(df)) {
\end_layout

\begin_layout Plain Layout

    Chisq <- Chisq + (df$mphase[i] - LTphase(df$frq[i], Param2)$Phase)^2
 / df$sdp[i]^2
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  for (i in 1:nrow(dfr)) {
\end_layout

\begin_layout Plain Layout

    Chisq <- Chisq + (dfr$mrspec[i] - LTphase(dfr$frq[i], Param2)$Amp)^2
 / dfr$sdr[i]^2
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return (Chisq)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

A <- optim (c(Param2$a, Param2$tau1, Param2$tau2), minFn, hessian=TRUE)
\end_layout

\begin_layout Plain Layout

best <- A$par
\end_layout

\begin_layout Plain Layout

Herror <- solve(A$hessian / 4)  # factor of 4 because 2-sigma errors were
 used?
\end_layout

\begin_layout Plain Layout

uncLimits <- sqrt(diag(Herror))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The fit procedure used 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:responseAmp"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:responsePhase"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to find the theoretical value of the amplitude ratio and phase at each
 frequency represented in the observations.
 For assumed values of the three parameters 
\begin_inset Formula $a$
\end_inset

, 
\begin_inset Formula $\tau_{1}$
\end_inset

 and 
\begin_inset Formula $\tau_{2}$
\end_inset

, a chi-square was calculated from the differences between these theoretical
 values and the observed values.
 The frequencies used for the fit were 0.01 to 12
\begin_inset space ~
\end_inset

Hz for the measurements of phase and 0.1 to 3
\begin_inset space ~
\end_inset

Hz for the measurements of amplitude ratio, to avoid regions where effects
 other than dynamic heating appear to bias the measurements.
 Then a search procedure varied these parameters to seek the minimum value
 of the chi-square.
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The code can be found in the 
\begin_inset Quotes eld
\end_inset

Rnw
\begin_inset Quotes erd
\end_inset

 document that generates the present document.
 It used the 
\begin_inset Quotes eld
\end_inset

optim()
\begin_inset Quotes erd
\end_inset

 function from the R 
\begin_inset Quotes eld
\end_inset

stats
\begin_inset Quotes erd
\end_inset

 package produced by the 
\begin_inset CommandInset citation
LatexCommand citet
key "Rlanguage"
literal "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset

 The resulting values were 
\begin_inset Formula $a=$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(best[1], 2)}
\end_layout

\end_inset

, 
\begin_inset Formula $\tau_{1}=$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(best[2], 3)}
\end_layout

\end_inset

 and 
\begin_inset Formula $\tau_{2}=$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(best[3], 2)}
\end_layout

\end_inset

.
 The chi-square for the fit is about 18 times larger than expected if the
 fit represents the measurements to measurement uncertainty, so it is difficult
 to assign uncertainty limits to this result on the basis of this fit because
 of this not-understood excess chi-square, but the fit minimum distinguished
 nearby values to about three significant digits in all three parameters.
 The Hessian from the fit implies that the results with standard uncertainties
 are 
\begin_inset Formula $a=$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(best[1], 3)}
\end_layout

\end_inset


\begin_inset Formula $\pm$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(uncLimits[1], 3)}
\end_layout

\end_inset

, 
\begin_inset Formula $\tau_{1}=$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(best[2], 4)}
\end_layout

\end_inset


\begin_inset Formula $\pm$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(uncLimits[2], 4)}
\end_layout

\end_inset

 and 
\begin_inset Formula $\tau_{2}=$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(best[3], 2)}
\end_layout

\end_inset


\begin_inset Formula $\pm$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(uncLimits[3], 2)}
\end_layout

\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
As shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:LTsolution}
\end_layout

\end_inset

, the phase of the response at high frequency is very sensitive to 
\begin_inset Formula $\tau_{1}$
\end_inset

 while the amplitude of the response near 0.3
\begin_inset space ~
\end_inset

Hz is sensitive to 
\begin_inset Formula $\tau_{2}$
\end_inset

.
 The fit is therefore better constrained by combining the two parts of the
 response function.
 These parameters led to the transfer function shown earlier in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:LTsolution}
\end_layout

\end_inset

 and used as the reference values for the unheated Rosemount 102E4AL in
 this study.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<correctRT, include=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Integrate to find the support temperature Ts:
\end_layout

\begin_layout Plain Layout

a <- Param1$a
\end_layout

\begin_layout Plain Layout

tau1 <- Param1$tau1
\end_layout

\begin_layout Plain Layout

tau2 <- Param1$tau2
\end_layout

\begin_layout Plain Layout

## RT is the working solution; Ts is the support temperature
\end_layout

\begin_layout Plain Layout

DT$Ts <- DT$RT
\end_layout

\begin_layout Plain Layout

Rate <- attr (DT, 'Rate')
\end_layout

\begin_layout Plain Layout

DT$DTMDT <- c(0, diff(DT$TTRR, 2), 0) * Rate / 2
\end_layout

\begin_layout Plain Layout

# DT$DTMDT <- (DT$DTMDT + c(0, DT$DTMDT[1:(nrow(DT)-1)])) / 2
\end_layout

\begin_layout Plain Layout

# DT$DTMDT <- as.vector (signal::filter(signal::sgolay(1, 3, m=1), DT$TTRR))
 * Rate
\end_layout

\begin_layout Plain Layout

fS <- function(y, i) {  # Eq.
 Ts3
\end_layout

\begin_layout Plain Layout

  ((1/a) * (tau1 * DT$DTMDT[i] + DT$TTRR[i] - (1-a) * y) - y) / (Rate *
 tau2)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DT$Ts <- rk4.integrate (fS, DT$Ts[1], 1:nrow(DT))
\end_layout

\begin_layout Plain Layout

DT$RT <- (1/a) * (tau1 * DT$DTMDT + DT$TTRR - (1-a) * DT$Ts)
\end_layout

\begin_layout Plain Layout

DT %>% select(Time, TTRR, RT, Ts) %>% 
\end_layout

\begin_layout Plain Layout

       selectTime(114500, 114505) %>% 
\end_layout

\begin_layout Plain Layout

       plotWAC()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To complete the iteration discussed earlier, the measured recovery temperature
 was then corrected via method 1 from Appendix
\begin_inset space ~
\end_inset

A, using the parameters from this first fit, to find a prediction for the
 actual recovery temperature 
\begin_inset Formula $T_{r}(t)$
\end_inset

.
 After recalculating 
\begin_inset Formula $Q$
\end_inset

 using 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:DHterm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 with that estimate of 
\begin_inset Formula $T_{r}(t)$
\end_inset

 in place of 
\begin_inset Formula $T_{m}(t)$
\end_inset

, the calculation of phase and amplitude was repeated and the results were
 fitted again by adjusting the fit parameters.
 Only very minor changes arose from this procedure even after one iteration,
 but the iterated result is the one used here to represent the unheated
 Rosemount 102E4AL sensor.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<GVcheck>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## This chunk checks GV measurements for consistency with the previous results
 from the C-130,
\end_layout

\begin_layout Plain Layout

## with results reasonably consistent with those results.
 Decided that they don't merit a
\end_layout

\begin_layout Plain Layout

## separate result for the GV.
\end_layout

\begin_layout Plain Layout

DSX <- getNetCDF(file.path(DataDirectory(), 'SOCRATES/rf15h.nc'),
\end_layout

\begin_layout Plain Layout

                 standardVariables(c('ATF1', 'ATH1', 'ATH2')), 55200, 62000)
\end_layout

\begin_layout Plain Layout

DCX <- getNetCDF(file.path(DataDirectory(), 'CSET/rf05h.nc'),
\end_layout

\begin_layout Plain Layout

                 standardVariables(c('ATF1', 'ATH1', 'ATH2')), 175000, 205000)
\end_layout

\begin_layout Plain Layout

rf.txt <- attr(DSX$ATF1, 'RecoveryFactor')
\end_layout

\begin_layout Plain Layout

rf <- gsub('mach', 'MACHX', rf.txt)
\end_layout

\begin_layout Plain Layout

rf <- gsub(' log', ' * log', rf)
\end_layout

\begin_layout Plain Layout

rf <- gsub(' 
\backslash

\backslash
(', ' * 
\backslash

\backslash
(', rf)
\end_layout

\begin_layout Plain Layout

rf <- with(DSX, eval(parse(text=rf)))
\end_layout

\begin_layout Plain Layout

rf2.txt <- attr(DSX$ATH1, 'RecoveryFactor')
\end_layout

\begin_layout Plain Layout

rf2 <- gsub('mach', 'MACHX', rf2.txt)
\end_layout

\begin_layout Plain Layout

rf2 <- gsub(' log', ' * log', rf2)
\end_layout

\begin_layout Plain Layout

rf2 <- gsub(' 
\backslash

\backslash
(', ' * 
\backslash

\backslash
(', rf2)
\end_layout

\begin_layout Plain Layout

rf2 <- with(DSX, eval(parse(text=rf2)))
\end_layout

\begin_layout Plain Layout

DSX$RTF1 <- DSX$ATF1 + rf * DSX$TASX^2 / 2010
\end_layout

\begin_layout Plain Layout

DSX$RTF1 <- SmoothInterp(DSX$RTF1, .Length=0)
\end_layout

\begin_layout Plain Layout

DSX$RTH1 <- DSX$ATH1 + rf2 * DSX$TASX^2 / 2010
\end_layout

\begin_layout Plain Layout

DSX$RTH1 <- SmoothInterp(DSX$RTH1, .Length=0)
\end_layout

\begin_layout Plain Layout

XXA <- rf * DSX$MACHX^2 / 5
\end_layout

\begin_layout Plain Layout

DSX$Q <- (DSX$RTF1 + 273.15) * XXA / (1 + XXA)
\end_layout

\begin_layout Plain Layout

DSX$Q <- SmoothInterp(DSX$Q, .Length=0)
\end_layout

\begin_layout Plain Layout

DSX$Q <- ShiftInTime(DSX$Q, .rate=25, .shift=-10)
\end_layout

\begin_layout Plain Layout

rf.txt <- attr(DCX$ATF1, 'RecoveryFactor')
\end_layout

\begin_layout Plain Layout

rf <- gsub('mach', 'MACHX', rf.txt)
\end_layout

\begin_layout Plain Layout

rf <- gsub(' log', ' * log', rf)
\end_layout

\begin_layout Plain Layout

rf <- gsub(' 
\backslash

\backslash
(', ' * 
\backslash

\backslash
(', rf)
\end_layout

\begin_layout Plain Layout

rf <- with(DCX, eval(parse(text=rf)))
\end_layout

\begin_layout Plain Layout

rf2.txt <- attr(DCX$ATH1, 'RecoveryFactor')
\end_layout

\begin_layout Plain Layout

rf2 <- gsub('mach', 'MACHX', rf2.txt)
\end_layout

\begin_layout Plain Layout

rf2 <- gsub(' log', ' * log', rf2)
\end_layout

\begin_layout Plain Layout

rf2 <- gsub(' 
\backslash

\backslash
(', ' * 
\backslash

\backslash
(', rf2)
\end_layout

\begin_layout Plain Layout

rf2 <- with(DCX, eval(parse(text=rf2)))
\end_layout

\begin_layout Plain Layout

DCX$RTF1 <- DCX$ATF1 + rf * DCX$TASX^2 / 2010
\end_layout

\begin_layout Plain Layout

DCX$RTF1 <- SmoothInterp(DCX$RTF1, .Length=0)
\end_layout

\begin_layout Plain Layout

DCX$RTH1 <- DCX$ATH1 + rf2 * DCX$TASX^2 / 2010
\end_layout

\begin_layout Plain Layout

DCX$RTH1 <- SmoothInterp(DCX$RTH1, .Length=0)
\end_layout

\begin_layout Plain Layout

XXA <- rf * DCX$MACHX^2 / 5
\end_layout

\begin_layout Plain Layout

DCX$Q <- (DCX$RTF1 + 273.15) * XXA / (1 + XXA)
\end_layout

\begin_layout Plain Layout

DCX$Q <- SmoothInterp(DCX$Q, .Length=0)
\end_layout

\begin_layout Plain Layout

DCX$Q <- ShiftInTime(DCX$Q, .rate=25, .shift=-10)
\end_layout

\begin_layout Plain Layout

## May need to revise this with corrected RT in second iteration
\end_layout

\begin_layout Plain Layout

# RX <- CohPhase(DSA, 'RTF1', 'Q', plotType='Ranadu')
\end_layout

\begin_layout Plain Layout

SB <- 100
\end_layout

\begin_layout Plain Layout

DSX$RT <- DSX$RTF1
\end_layout

\begin_layout Plain Layout

DCX$RT <- DCX$RTF1
\end_layout

\begin_layout Plain Layout

## Next is for Z adjustment later
\end_layout

\begin_layout Plain Layout

DZ <- rbind(DSX %>% selectTime(55200, 60200),
\end_layout

\begin_layout Plain Layout

            DSX %>% selectTime(60500, 61500),
\end_layout

\begin_layout Plain Layout

            DCX %>% selectTime(175200, 180200),
\end_layout

\begin_layout Plain Layout

            DCX %>% selectTime(194530, 195530),
\end_layout

\begin_layout Plain Layout

            DCX %>% selectTime(203717, 204717))
\end_layout

\begin_layout Plain Layout

DSA <- DSX %>% selectTime(55200, 60200)
\end_layout

\begin_layout Plain Layout

RXA <- DSX %>% selectTime(55200, 60200) %>% CohP('RT', 'Q', plotType='Ranadu',
 smoothBins=SB)
\end_layout

\begin_layout Plain Layout

RXB <- DSX %>% selectTime(60500, 61500) %>% CohP('RT', 'Q', plotType='Ranadu',
 smoothBins=SB)
\end_layout

\begin_layout Plain Layout

RXC <- DCX %>% selectTime(175200, 180200) %>% CohP('RT', 'Q', plotType='Ranadu',
 smoothBins=SB)
\end_layout

\begin_layout Plain Layout

RXD <- DCX %>% selectTime(194530, 195530) %>% CohP('RT', 'Q', plotType='Ranadu',
 smoothBins=SB)
\end_layout

\begin_layout Plain Layout

RXE <- DCX %>% selectTime(203717, 204717) %>% CohP('RT', 'Q', plotType='Ranadu',
 smoothBins=SB)
\end_layout

\begin_layout Plain Layout

## May need to revise this with corrected RT in second iteration
\end_layout

\begin_layout Plain Layout

Z <- capture.output (Vr <- SmoothInterp(detrend (DSA[, c('Time', 'RT')]),
 .Length=0))
\end_layout

\begin_layout Plain Layout

Z <- capture.output (VrC <- SmoothInterp(detrend (DSA[, c('Time', 'Q')]),
 .Length=0))
\end_layout

\begin_layout Plain Layout

Rate <- attr(DSA, 'Rate')
\end_layout

\begin_layout Plain Layout

vcv <- cbind(ts(Vr, frequency=Rate), ts(VrC, frequency=Rate))
\end_layout

\begin_layout Plain Layout

P <- spec.pgram(vcv, detrend=FALSE, fast=TRUE, plot=FALSE, spans=25)
\end_layout

\begin_layout Plain Layout

df1SF <- data.frame(P$coh, log(P$freq))
\end_layout

\begin_layout Plain Layout

df2SF <- data.frame (P$phase, log(P$freq))
\end_layout

\begin_layout Plain Layout

pf1SF <- binStats (df1SF, bins=SB)
\end_layout

\begin_layout Plain Layout

pf2SF <- binStats (df2SF, bins=SB)
\end_layout

\begin_layout Plain Layout

phaseSF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

nphaseSF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

phase2SF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

arSF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

ar2SF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

narSF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

for (RX in list(RXA, RXB, RXC, RXD, RXE)) {
\end_layout

\begin_layout Plain Layout

  for (i in 2:nrow(RX)) {
\end_layout

\begin_layout Plain Layout

    phaseSF[RX$BIN.1[i]] <- phaseSF[RX$BIN.1[i]] + RX$P.phase[i]
\end_layout

\begin_layout Plain Layout

    nphaseSF[RX$BIN.1[i]] <- nphaseSF[RX$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

    phase2SF[RX$BIN.1[i]] <- phase2SF[RX$BIN.1[i]] + RX$P.phase[i]^2
\end_layout

\begin_layout Plain Layout

    arSF[RX$BIN.1[i]] <- arSF[RX$BIN.1[i]] + sqrt(RX$P.spec...1.[i] / RX$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

    ar2SF[RX$BIN.1[i]] <- ar2SF[RX$BIN.1[i]] + (RX$P.spec...1.[i] / RX$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

    narSF[RX$BIN.1[i]] <- narSF[RX$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

nphaseSF[nphaseSF == 0] <- 1
\end_layout

\begin_layout Plain Layout

narSF[narSF == 0] <- 1
\end_layout

\begin_layout Plain Layout

mphaseSF <- phaseSF/nphaseSF
\end_layout

\begin_layout Plain Layout

mphase2SF <- phase2SF/nphaseSF
\end_layout

\begin_layout Plain Layout

sdpSF <- sqrt(mphase2SF - mphaseSF^2)
\end_layout

\begin_layout Plain Layout

mphaseSF <- mphaseSF * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpSF <- sdpSF * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpSF <- sdpSF * 2 / sqrt(nphaseSF)
\end_layout

\begin_layout Plain Layout

arSF <- arSF / narSF
\end_layout

\begin_layout Plain Layout

ar2SF <- ar2SF / narSF
\end_layout

\begin_layout Plain Layout

b <- ar2SF - arSF^2
\end_layout

\begin_layout Plain Layout

b[near(b, 0)] <- 0
\end_layout

\begin_layout Plain Layout

sdrSF <- sqrt(b)
\end_layout

\begin_layout Plain Layout

sdrSF <- sdrSF * 2 / sqrt(narSF)
\end_layout

\begin_layout Plain Layout

dfSF <- data.frame(frq=exp(pf2SF$xc), mphase=mphaseSF, sdp=sdpSF)
\end_layout

\begin_layout Plain Layout

dfSF <- dfSF[dfSF$frq > 0.05, ]
\end_layout

\begin_layout Plain Layout

dfSF <- dfSF[dfSF$sdp > 0, ]
\end_layout

\begin_layout Plain Layout

dfSF <- dfSF[dfSF$frq < 8, ]
\end_layout

\begin_layout Plain Layout

dfrSF <- data.frame(frq=exp(pf2SF$xc), mrspec=arSF, sdr=sdrSF)
\end_layout

\begin_layout Plain Layout

dfrSF <- dfrSF[dfrSF$frq > 0.05, ]
\end_layout

\begin_layout Plain Layout

dfrSF <- dfrSF[dfrSF$sdr > 0, ]
\end_layout

\begin_layout Plain Layout

dfrSF <- dfrSF[dfrSF$frq < 8, ]
\end_layout

\begin_layout Plain Layout

frq <- exp(pf2SF$xc)
\end_layout

\begin_layout Plain Layout

Parm <- Param1
\end_layout

\begin_layout Plain Layout

minFn <- function(V) {
\end_layout

\begin_layout Plain Layout

  Parm$a <<- V[1]
\end_layout

\begin_layout Plain Layout

  Parm$tau1 <<- V[2]
\end_layout

\begin_layout Plain Layout

  Parm$tau2 <<- V[3]
\end_layout

\begin_layout Plain Layout

  Chisq <- 0
\end_layout

\begin_layout Plain Layout

  for (i in 1:nrow(dfSF)) {
\end_layout

\begin_layout Plain Layout

    Chisq <- Chisq + (dfSF$mphase[i] - LTphase(dfSF$frq[i], Parm)$Phase)^2
 / dfSF$sdp[i]^2
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  for (i in 1:nrow(dfrSF)) {
\end_layout

\begin_layout Plain Layout

    Chisq <- Chisq + (dfrSF$mrspec[i] - LTphase(dfrSF$frq[i], Parm)$Amp)^2
 / dfrSF$sdr[i]^2
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return (Chisq)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

ASF <- optim (c(Parm$a, Parm$tau1, Parm$tau2), minFn, hessian=TRUE)
\end_layout

\begin_layout Plain Layout

bestSF <- ASF$par
\end_layout

\begin_layout Plain Layout

HerrorSF <- solve(ASF$hessian / 4)  # factor of 4 because 2-sigma errors
 were used?
\end_layout

\begin_layout Plain Layout

uncLimitsSF <- sqrt(diag(HerrorSF))
\end_layout

\begin_layout Plain Layout

print(bestSF)
\end_layout

\begin_layout Plain Layout

HSF <- LTphase(dfrSF$frq, Parm)
\end_layout

\begin_layout Plain Layout

dfrSF$Amp <- HSF$Amp
\end_layout

\begin_layout Plain Layout

dfrSF$Phase <- HSF$Phase
\end_layout

\begin_layout Plain Layout

ParamSF <- Param2
\end_layout

\begin_layout Plain Layout

ParGV <- Parm
\end_layout

\begin_layout Plain Layout

rhozero <- 1013.25 * 100 / (287.05 * 288.15)
\end_layout

\begin_layout Plain Layout

MRHO <- MachNumber(DZ$PSXC, DZ$QCXC) * DZ$PSXC * 100 / 
\end_layout

\begin_layout Plain Layout

        (287.05 * (273.15 + DZ$ATX)) / rhozero
\end_layout

\begin_layout Plain Layout

ParGV$tau1 <- ParGV$tau1 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ 0.6
\end_layout

\begin_layout Plain Layout

ParGV$tau2 <- ParGV$tau2 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ 0.6
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

g <- ggplot(dfSF, aes(x=frq, y=mphase))+geom_point()
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab ('phase RTF1 x Q [degrees]')
\end_layout

\begin_layout Plain Layout

g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=4),
\end_layout

\begin_layout Plain Layout

                       labels = trans_format("log10", math_format(expr =
 10^.x))) + xlab('frequency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = "bt")
\end_layout

\begin_layout Plain Layout

g <- g + geom_errorbar(aes(ymin=mphase-sdp, ymax=mphase+sdp), width=0.06)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfrSF, aes(x=frq, y=Phase), col='forestgreen')
\end_layout

\begin_layout Plain Layout

# g <- g + geom_path(data=dfAPSF, aes(x=Time, y=Phase), col='darkorange')
\end_layout

\begin_layout Plain Layout

g + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

frq <- exp(pf2SF$xc[narSF > 0])
\end_layout

\begin_layout Plain Layout

# spec1 <- spec1[nspec1 > 0]
\end_layout

\begin_layout Plain Layout

# spec2 <- spec2[nspec1 > 0]
\end_layout

\begin_layout Plain Layout

# rspec <- spec1 / spec2
\end_layout

\begin_layout Plain Layout

# plotWAC(data.frame(frq, mrspec), xlab='frequency [Hz]', ylab='amplitude
 ratio RTRR/Q', type='p', 
\end_layout

\begin_layout Plain Layout

#         col='blue', log='x', pch=20, xlim=c(0.1,15), ylim=c(0,1.2))
\end_layout

\begin_layout Plain Layout

# HR <- LTphase(frq, Param1)
\end_layout

\begin_layout Plain Layout

# P <- Param1
\end_layout

\begin_layout Plain Layout

# P$tau2 <- 0.84
\end_layout

\begin_layout Plain Layout

# HR2 <- LTphase(frq, P)
\end_layout

\begin_layout Plain Layout

# lines(frq, (HR2$Amp)^2, col='forestgreen', lwd=2)
\end_layout

\begin_layout Plain Layout

# lines(frq, (HR$Amp)^2, col='darkorange', lwd=2, lty=2)
\end_layout

\begin_layout Plain Layout

g <- ggplot(dfrSF, aes(x=frq, y=mrspec))+geom_point()
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab ('amplitude ratio RTF1 / Q')
\end_layout

\begin_layout Plain Layout

g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=2),
\end_layout

\begin_layout Plain Layout

                       labels = trans_format("log10", math_format(expr =
 10^.x))) + xlab('frequency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = "bt")
\end_layout

\begin_layout Plain Layout

g <- g + geom_errorbar(aes(ymin=mrspec-sdr, ymax=mrspec+sdr), width=0.06)
\end_layout

\begin_layout Plain Layout

# g <- g + geom_path(data=dfAPSF, aes(x=Time, y=Amp), col='darkorange')
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfrSF, aes(x=frq, y=Amp), col='forestgreen')
\end_layout

\begin_layout Plain Layout

suppressWarnings(print(g + ylim(0, 1.3) + theme_WAC(1)))
\end_layout

\begin_layout Plain Layout

CohPhase(DSA, 'RTF1', 'Q')
\end_layout

\begin_layout Plain Layout

DSA %>% select(Time, TASX, RTF1, Q, ATF1) %>% VSpec()
\end_layout

\begin_layout Plain Layout

print(bestSF)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<S11a>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DS11 <- getNetCDF(file.path(DataDirectory(), 'SOCRATES/SOCRATESrf11h.nc'),
 
\end_layout

\begin_layout Plain Layout

                  standardVariables(c('ATF1', 'ATH1')), 34850, 35900)
\end_layout

\begin_layout Plain Layout

# DS11 <- DS11 %>% selectTime(44300, 44800)
\end_layout

\begin_layout Plain Layout

dfAPSF <- dfAP[dfAP$Time > 0.5 & dfAP$Time < 8, ]
\end_layout

\begin_layout Plain Layout

## Revise the calculation of dynamic heating to avoid dependence on AT:
\end_layout

\begin_layout Plain Layout

rf.txt <- attr(DS11$ATF1, 'RecoveryFactor')
\end_layout

\begin_layout Plain Layout

rf <- gsub('mach', 'MACHX', rf.txt)
\end_layout

\begin_layout Plain Layout

rf <- gsub(' log', ' * log', rf)
\end_layout

\begin_layout Plain Layout

rf <- gsub(' 
\backslash

\backslash
(', ' * 
\backslash

\backslash
(', rf)
\end_layout

\begin_layout Plain Layout

rf <- with(DS11, eval(parse(text=rf)))
\end_layout

\begin_layout Plain Layout

## RTF1 is not in the netCDF file so recalculate it:
\end_layout

\begin_layout Plain Layout

DS11$RTF1 <- DS11$ATF1 + rf * DS11$TASX^2 / 2010
\end_layout

\begin_layout Plain Layout

DS11$RTF1 <- SmoothInterp(DS11$RTF1, .Length=0)
\end_layout

\begin_layout Plain Layout

## Now correct it using standard parameters:
\end_layout

\begin_layout Plain Layout

## Integrate to find the support temperature Ts:
\end_layout

\begin_layout Plain Layout

CorrectT <- FALSE
\end_layout

\begin_layout Plain Layout

# CorrectT <- TRUE
\end_layout

\begin_layout Plain Layout

if (CorrectT) {
\end_layout

\begin_layout Plain Layout

  a <- Param1$a
\end_layout

\begin_layout Plain Layout

  tau1 <- Param1$tau1
\end_layout

\begin_layout Plain Layout

  tau2 <- Param1$tau2
\end_layout

\begin_layout Plain Layout

  ## RT is the working solution; Ts is the support temperature
\end_layout

\begin_layout Plain Layout

  DS11$Ts <- DS11$RTF1
\end_layout

\begin_layout Plain Layout

  Rate <- attr (DS11, 'Rate')
\end_layout

\begin_layout Plain Layout

  DS11$DTMDT <- c(0, diff(DS11$RTF1, 2), 0) * Rate / 2
\end_layout

\begin_layout Plain Layout

  # DT$DTMDT <- (DT$DTMDT + c(0, DT$DTMDT[1:(nrow(DT)-1)])) / 2
\end_layout

\begin_layout Plain Layout

  # DT$DTMDT <- as.vector (signal::filter(signal::sgolay(1, 3, m=1), DT$TTRR))
 * Rate
\end_layout

\begin_layout Plain Layout

  fS <- function(y, i) {  # Eq.
 Ts3
\end_layout

\begin_layout Plain Layout

    ((1/a) * (tau1 * DS11$DTMDT[i] + DS11$RTF1[i] - (1-a) * y) - y) / (Rate
 * tau2)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  DS11$Ts <- rk4.integrate (fS, DS11$Ts[1], 1:nrow(DS11))
\end_layout

\begin_layout Plain Layout

  DS11$RT <- (1/a) * (tau1 * DS11$DTMDT + DS11$RTF1 - (1-a) * DS11$Ts)
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  DS11$RT <- DS11$RTF1
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

XXA <- rf * DS11$MACHX^2 / 5
\end_layout

\begin_layout Plain Layout

DS11$Q <- (DS11$RT + 273.15) * XXA / (1 + XXA)
\end_layout

\begin_layout Plain Layout

DS11$Q <- SmoothInterp(DS11$Q, .Length=0)
\end_layout

\begin_layout Plain Layout

## May need to revise this with corrected RT in second iteration
\end_layout

\begin_layout Plain Layout

RX <- CohPhase(DS11, 'RT', 'Q', plotType='Ranadu')
\end_layout

\begin_layout Plain Layout

SB <- 90
\end_layout

\begin_layout Plain Layout

Z <- capture.output (Vr <- SmoothInterp(detrend (DS11[, c('Time', 'RT')]),
 .Length=0))
\end_layout

\begin_layout Plain Layout

Z <- capture.output (VrC <- SmoothInterp(detrend (DS11[, c('Time', 'Q')]),
 .Length=0))
\end_layout

\begin_layout Plain Layout

Rate <- attr(DS11, 'Rate')
\end_layout

\begin_layout Plain Layout

vcv <- cbind(ts(Vr, frequency=Rate), ts(VrC, frequency=Rate))
\end_layout

\begin_layout Plain Layout

P <- spec.pgram(vcv, detrend=FALSE, fast=TRUE, plot=FALSE, spans=25)
\end_layout

\begin_layout Plain Layout

df1SF <- data.frame(P$coh, log(P$freq))
\end_layout

\begin_layout Plain Layout

df2SF <- data.frame (P$phase, log(P$freq))
\end_layout

\begin_layout Plain Layout

pf1SF <- binStats (df1SF, bins=SB)
\end_layout

\begin_layout Plain Layout

pf2SF <- binStats (df2SF, bins=SB)
\end_layout

\begin_layout Plain Layout

## Use DH2 to get the time-response-corrected-RT Q
\end_layout

\begin_layout Plain Layout

RX1 <- CohP(DS11, 'RT', 'Q', plotType='Ranadu', smoothBins=SB)
\end_layout

\begin_layout Plain Layout

phaseSF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

nphaseSF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

phase2SF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

arSF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

ar2SF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

narSF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

for (RX in list(RX1)) {
\end_layout

\begin_layout Plain Layout

  for (i in 2:nrow(RX)) {
\end_layout

\begin_layout Plain Layout

    phaseSF[RX$BIN.1[i]] <- phaseSF[RX$BIN.1[i]] + RX$P.phase[i]
\end_layout

\begin_layout Plain Layout

    nphaseSF[RX$BIN.1[i]] <- nphaseSF[RX$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

    phase2SF[RX$BIN.1[i]] <- phase2SF[RX$BIN.1[i]] + RX$P.phase[i]^2 
\end_layout

\begin_layout Plain Layout

    arSF[RX$BIN.1[i]] <- arSF[RX$BIN.1[i]] + sqrt(RX$P.spec...1.[i] / RX$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

    ar2SF[RX$BIN.1[i]] <- ar2SF[RX$BIN.1[i]] + (RX$P.spec...1.[i] / RX$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

    narSF[RX$BIN.1[i]] <- narSF[RX$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

nphaseSF[nphaseSF == 0] <- 1
\end_layout

\begin_layout Plain Layout

narSF[narSF == 0] <- 1
\end_layout

\begin_layout Plain Layout

mphaseSF <- phaseSF/nphaseSF
\end_layout

\begin_layout Plain Layout

mphase2SF <- phase2SF/nphaseSF
\end_layout

\begin_layout Plain Layout

sdpSF <- sqrt(mphase2SF - mphaseSF^2)
\end_layout

\begin_layout Plain Layout

mphaseSF <- mphaseSF * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpSF <- sdpSF * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpSF <- sdpSF * 2 / sqrt(nphaseSF)
\end_layout

\begin_layout Plain Layout

arSF <- arSF / narSF
\end_layout

\begin_layout Plain Layout

ar2SF <- ar2SF / narSF
\end_layout

\begin_layout Plain Layout

b <- ar2SF - arSF^2
\end_layout

\begin_layout Plain Layout

b[near(b, 0)] <- 0
\end_layout

\begin_layout Plain Layout

sdrSF <- sqrt(b)
\end_layout

\begin_layout Plain Layout

sdrSF <- sdrSF * 2 / sqrt(narSF)
\end_layout

\begin_layout Plain Layout

dfSF <- data.frame(frq=exp(pf2SF$xc), mphase=mphaseSF, sdp=sdpSF)
\end_layout

\begin_layout Plain Layout

dfSF <- dfSF[dfSF$frq > 0.5, ]
\end_layout

\begin_layout Plain Layout

dfSF <- dfSF[dfSF$sdp > 0, ]
\end_layout

\begin_layout Plain Layout

dfSF <- dfSF[dfSF$frq < 8, ]
\end_layout

\begin_layout Plain Layout

dfrSF <- data.frame(frq=exp(pf2SF$xc), mrspec=arSF, sdr=sdrSF)
\end_layout

\begin_layout Plain Layout

dfrSF <- dfrSF[dfrSF$frq > 0.5, ]
\end_layout

\begin_layout Plain Layout

dfrSF <- dfrSF[dfrSF$sdr > 0, ]
\end_layout

\begin_layout Plain Layout

dfrSF <- dfrSF[dfrSF$frq < 8, ]
\end_layout

\begin_layout Plain Layout

frq <- exp(pf2SF$xc)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Param2 <- Param1
\end_layout

\begin_layout Plain Layout

minFn <- function(V) {
\end_layout

\begin_layout Plain Layout

  Param2$a <<- V[1]
\end_layout

\begin_layout Plain Layout

  Param2$tau1 <<- V[2]
\end_layout

\begin_layout Plain Layout

  Param2$tau2 <<- V[3]
\end_layout

\begin_layout Plain Layout

  Chisq <- 0
\end_layout

\begin_layout Plain Layout

  for (i in 1:nrow(dfSF)) {
\end_layout

\begin_layout Plain Layout

    Chisq <- Chisq + (dfSF$mphase[i] - LTphase(dfSF$frq[i], Param2)$Phase)^2
 / dfSF$sdp[i]^2
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  for (i in 1:nrow(dfrSF)) {
\end_layout

\begin_layout Plain Layout

    Chisq <- Chisq + (dfrSF$mrspec[i] - LTphase(dfrSF$frq[i], Param2)$Amp)^2
 / dfrSF$sdr[i]^2
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return (Chisq)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

ASF <- optim (c(Param2$a, Param2$tau1, Param2$tau2), minFn, method='L-BFGS-B',
 lower=0, upper=1, hessian=TRUE)
\end_layout

\begin_layout Plain Layout

bestSF <- ASF$par
\end_layout

\begin_layout Plain Layout

HerrorSF <- solve(ASF$hessian / 4)  # factor of 4 because 2-sigma errors
 were used?
\end_layout

\begin_layout Plain Layout

uncLimitsSF <- sqrt(diag(HerrorSF))
\end_layout

\begin_layout Plain Layout

HSF <- LTphase(dfSF$frq, Param2)
\end_layout

\begin_layout Plain Layout

dfSF$Amp <- HSF$Amp
\end_layout

\begin_layout Plain Layout

dfSF$Phase <- HSF$Phase
\end_layout

\begin_layout Plain Layout

ParamSF <- Param2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

g <- ggplot(dfSF, aes(x=frq, y=mphase))+geom_point()
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab ('phase RTF1 x Q [degrees]')
\end_layout

\begin_layout Plain Layout

g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=4),
\end_layout

\begin_layout Plain Layout

                       labels = trans_format("log10", math_format(expr =
 10^.x))) + xlab('frequency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = "bt")
\end_layout

\begin_layout Plain Layout

g <- g + geom_errorbar(aes(ymin=mphase-sdp, ymax=mphase+sdp), width=0.06)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfSF, aes(x=frq, y=Phase), col='forestgreen')
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfAPSF, aes(x=Time, y=Phase), col='darkorange')
\end_layout

\begin_layout Plain Layout

g + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

frq <- exp(pf2SF$xc[narSF > 0])
\end_layout

\begin_layout Plain Layout

# spec1 <- spec1[nspec1 > 0]
\end_layout

\begin_layout Plain Layout

# spec2 <- spec2[nspec1 > 0]
\end_layout

\begin_layout Plain Layout

# rspec <- spec1 / spec2
\end_layout

\begin_layout Plain Layout

# plotWAC(data.frame(frq, mrspec), xlab='frequency [Hz]', ylab='amplitude
 ratio RTRR/Q', type='p', 
\end_layout

\begin_layout Plain Layout

#         col='blue', log='x', pch=20, xlim=c(0.1,15), ylim=c(0,1.2))
\end_layout

\begin_layout Plain Layout

# HR <- LTphase(frq, Param1)
\end_layout

\begin_layout Plain Layout

# P <- Param1
\end_layout

\begin_layout Plain Layout

# P$tau2 <- 0.84
\end_layout

\begin_layout Plain Layout

# HR2 <- LTphase(frq, P)
\end_layout

\begin_layout Plain Layout

# lines(frq, (HR2$Amp)^2, col='forestgreen', lwd=2)
\end_layout

\begin_layout Plain Layout

# lines(frq, (HR$Amp)^2, col='darkorange', lwd=2, lty=2)
\end_layout

\begin_layout Plain Layout

g <- ggplot(dfrSF, aes(x=frq, y=mrspec))+geom_point()
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab ('amplitude ratio RTF1 / Q')
\end_layout

\begin_layout Plain Layout

g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=2),
\end_layout

\begin_layout Plain Layout

                       labels = trans_format("log10", math_format(expr =
 10^.x))) + xlab('frequency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = "bt")
\end_layout

\begin_layout Plain Layout

g <- g + geom_errorbar(aes(ymin=mrspec-sdr, ymax=mrspec+sdr), width=0.06)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfAPSF, aes(x=Time, y=Amp), col='darkorange')
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfSF, aes(x=frq, y=Amp), col='forestgreen')
\end_layout

\begin_layout Plain Layout

suppressWarnings(print(g + ylim(0, 1.3) + theme_WAC(1)))
\end_layout

\begin_layout Plain Layout

print(bestSF)
\end_layout

\begin_layout Plain Layout

rhozero <- 1013.25*100/(287.05*288.15)
\end_layout

\begin_layout Plain Layout

MRHOGV <- MachNumber(DS11$PSXC, DS11$QCXC) * DS11$PSXC * 100 / (287.05 *
 
\end_layout

\begin_layout Plain Layout

                   (273.15 + DS11$ATX)) / rhozero
\end_layout

\begin_layout Plain Layout

ParamSF$tau1 <- ParamSF$tau1 * (mean(MRHOGV, na.rm=TRUE) / 0.3)^0.6
\end_layout

\begin_layout Plain Layout

ParamSF$tau2 <- ParamSF$tau2 * (mean(MRHOGV, na.rm=TRUE) / 0.3)^0.6
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The airflow and typical flow angles approaching a sensor can affect its
 response, so the results might change when installed on a different location
 or a different aircraft.
 Therefore a similar evaluation examined the response of this same sensor
 when flown on the NSF/NCAR GV, which flies significantly faster than the
 C-130.
 The results of a study using a combined low-level dataset from the SOCRATES
 (
\begin_inset CommandInset citation
LatexCommand citet
key "mcfarquhar2014southern"
literal "false"

\end_inset

) and CSET (
\begin_inset CommandInset citation
LatexCommand citet
key "albrecht2019cloud"
literal "false"

\end_inset

) experiments, which were flown over the Pacific Ocean, were similar to
 but slightly different from the coefficients determined on the C-130, with
 both time constants a little smaller than found for the C-130 (
\begin_inset Formula $\tau_{1}=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(ParGV$tau1, 3)}
\end_layout

\end_inset

 and 
\begin_inset Formula $\tau_{2}=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(ParGV$tau2, 2)}
\end_layout

\end_inset

).
 This might be expected at greater airspeed, as discussed in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Expected-dependence-on"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The preceding results characterize the measurement on the NSF/NCAR C-130
 research aircraft.
 The airflow at the sensor may vary depending on its location on the aircraft
 or on which aircraft is used, so it is useful to consider another case
 where the sensor is installed on the GV.
 The case selected was a low-level flight segment from the SOCRATES research
 project, flight 3, 3:48:50 to 3:59:00 UTC\SpecialChar endofsentence
 The preceding analysis was repeated,
 with the result that the best-fit parameters were 
\begin_inset Formula $a=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestSF[1], 2)}
\end_layout

\end_inset

, 
\begin_inset Formula $\tau_{1}=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestSF[2], 3)}
\end_layout

\end_inset

 and 
\begin_inset Formula $\tau_{2}$
\end_inset

=
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestSF[3], 3)}
\end_layout

\end_inset

.
 The second time constant is significantly greater that that found previously
 for the C-130, but otherwise these are reasonably consistent with the previous
 results.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Heated sensors
\begin_inset CommandInset label
LatexCommand label
name "subsec:Heated-sensors"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<SOCrf08, include=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DS <- getNetCDF('/Data/SOCRATES/SOCRATESrf08h.nc', 
\end_layout

\begin_layout Plain Layout

        standardVariables(c('ATF1', 'ATH1', 'ATH2', 'RTF1', 'RTH1', 'RTH2')),
\end_layout

\begin_layout Plain Layout

        45600, 50100)
\end_layout

\begin_layout Plain Layout

DS$TASX <- SmoothInterp(DS$TASX, .Length=0)
\end_layout

\begin_layout Plain Layout

DS$Q <- DS$TASX^2 / 2010
\end_layout

\begin_layout Plain Layout

DS$ATX <- DS$ATF1
\end_layout

\begin_layout Plain Layout

DS$AT <- reviseDH(DS, ParamSF, 0.985)
\end_layout

\begin_layout Plain Layout

DS$AT <- SmoothInterp(DS$AT, .Length=0)
\end_layout

\begin_layout Plain Layout

## Small time adjustment seems useful?
\end_layout

\begin_layout Plain Layout

# DS$Q <- ShiftInTime(DS$Q, .shift=-25, .rate=25)
\end_layout

\begin_layout Plain Layout

DS <- DS %>% selectTime(45600, 50100)
\end_layout

\begin_layout Plain Layout

DS$RHOCP <- 100 * DS$PSXC / (287.05 * 278) * 1005
\end_layout

\begin_layout Plain Layout

DS$RHOCP <- SmoothInterp(DS$RHOCP, .Length=0)
\end_layout

\begin_layout Plain Layout

SB <- 50
\end_layout

\begin_layout Plain Layout

Z <- capture.output (Vr <- SmoothInterp(detrend (DS[, c('Time', 'RTH1')]),
 .Length=0))
\end_layout

\begin_layout Plain Layout

Z <- capture.output (VrB <- SmoothInterp(detrend (DS[, c('Time', 'RTH2')]),
 .Length=0))
\end_layout

\begin_layout Plain Layout

Z <- capture.output (VrF <- SmoothInterp(detrend (DS[, c('Time', 'RTF1')]),
 .Length=0))
\end_layout

\begin_layout Plain Layout

Z <- capture.output (VrC <- SmoothInterp(detrend (DS[, c('Time', 'Q')]),
 .Length=0))
\end_layout

\begin_layout Plain Layout

Rate <- attr(DS, 'Rate')
\end_layout

\begin_layout Plain Layout

vcv <- cbind(ts(Vr, frequency=Rate), ts(VrC, frequency=Rate))
\end_layout

\begin_layout Plain Layout

P <- spec.pgram(vcv, detrend=FALSE, fast=TRUE, plot=FALSE, spans=25)
\end_layout

\begin_layout Plain Layout

vcv <- cbind(ts(VrB, frequency=Rate), ts(VrC, frequency=Rate))
\end_layout

\begin_layout Plain Layout

PB <- spec.pgram(vcv, detrend=FALSE, fast=TRUE, plot=FALSE, spans=25)
\end_layout

\begin_layout Plain Layout

vcv <- cbind(ts(VrF, frequency=Rate), ts(VrC, frequency=Rate))
\end_layout

\begin_layout Plain Layout

PF <- spec.pgram(vcv, detrend=FALSE, fast=TRUE, plot=FALSE, spans=25)
\end_layout

\begin_layout Plain Layout

dfHS <- data.frame(P$coh, log(P$freq))
\end_layout

\begin_layout Plain Layout

dfHSB <- data.frame(PB$coh, log(PB$freq))
\end_layout

\begin_layout Plain Layout

dfHSF <- data.frame(PF$coh, log(PF$freq))
\end_layout

\begin_layout Plain Layout

pfHS <- binStats (dfHS, bins=SB)
\end_layout

\begin_layout Plain Layout

RXHS <- CohP(DS, 'RTH1', 'Q', plotType='Ranadu', smoothBins=SB)
\end_layout

\begin_layout Plain Layout

pfHSB <- binStats (dfHSB, bins=SB)
\end_layout

\begin_layout Plain Layout

RXHSB <- CohP(DS, 'RTH2', 'Q', plotType='Ranadu', smoothBins=SB)
\end_layout

\begin_layout Plain Layout

pfHSF <- binStats (dfHSF, bins=SB)
\end_layout

\begin_layout Plain Layout

RXHSF <- CohP(DS, 'RTF1', 'Q', plotType='Ranadu', smoothBins=SB)
\end_layout

\begin_layout Plain Layout

phaseHS <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

nphaseHS <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

phase2HS <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

arHS <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

ar2HS <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

narHS <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

RXHS$P.spec...1.[RXHS$P.spec...1.
 < 0] <- 0
\end_layout

\begin_layout Plain Layout

phaseHSB <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

nphaseHSB <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

phase2HSB <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

arHSB <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

ar2HSB <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

narHSB <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

RXHSB$P.spec...1.[RXHSB$P.spec...1.
 < 0] <- 0
\end_layout

\begin_layout Plain Layout

phaseHSF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

nphaseHSF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

phase2HSF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

arHSF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

ar2HSF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

narHSF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

RXHSF$P.spec...1.[RXHSF$P.spec...1.
 < 0] <- 0
\end_layout

\begin_layout Plain Layout

for (i in 2:nrow(RXHS)) {
\end_layout

\begin_layout Plain Layout

  phaseHS[RXHS$BIN.1[i]] <- phaseHS[RXHS$BIN.1[i]]+RXHS$P.phase[i]
\end_layout

\begin_layout Plain Layout

  nphaseHS[RXHS$BIN.1[i]] <- nphaseHS[RXHS$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

  phase2HS[RXHS$BIN.1[i]] <- phase2HS[RXHS$BIN.1[i]]+RXHS$P.phase[i]^2 
\end_layout

\begin_layout Plain Layout

  arHS[RXHS$BIN.1[i]] <- arHS[RXHS$BIN.1[i]] + 
\end_layout

\begin_layout Plain Layout

             sqrt(RXHS$P.spec...1.[i] / RXHS$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

  ar2HS[RXHS$BIN.1[i]] <- ar2HS[RXHS$BIN.1[i]] + 
\end_layout

\begin_layout Plain Layout

             (RXHS$P.spec...1.[i] / RXHS$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

  narHS[RXHS$BIN.1[i]] <- narHS[RXHS$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

  phaseHSB[RXHSB$BIN.1[i]] <- phaseHSB[RXHSB$BIN.1[i]]+RXHSB$P.phase[i]
\end_layout

\begin_layout Plain Layout

  nphaseHSB[RXHSB$BIN.1[i]] <- nphaseHSB[RXHSB$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

  phase2HSB[RXHSB$BIN.1[i]] <- phase2HSB[RXHSB$BIN.1[i]]+RXHSB$P.phase[i]^2
 
\end_layout

\begin_layout Plain Layout

  arHSB[RXHSB$BIN.1[i]] <- arHSB[RXHSB$BIN.1[i]] + 
\end_layout

\begin_layout Plain Layout

             sqrt(RXHSB$P.spec...1.[i] / RXHSB$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

  ar2HSB[RXHSB$BIN.1[i]] <- ar2HSB[RXHSB$BIN.1[i]] + 
\end_layout

\begin_layout Plain Layout

             (RXHSB$P.spec...1.[i] / RXHSB$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

  narHSB[RXHSB$BIN.1[i]] <- narHSB[RXHSB$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

  phaseHSF[RXHSF$BIN.1[i]] <- phaseHSF[RXHSF$BIN.1[i]]+RXHSF$P.phase[i]
\end_layout

\begin_layout Plain Layout

  nphaseHSF[RXHSF$BIN.1[i]] <- nphaseHSF[RXHSF$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

  phase2HSF[RXHSF$BIN.1[i]] <- phase2HSF[RXHSF$BIN.1[i]]+RXHSF$P.phase[i]^2
 
\end_layout

\begin_layout Plain Layout

  arHSF[RXHSF$BIN.1[i]] <- arHSF[RXHSF$BIN.1[i]] + 
\end_layout

\begin_layout Plain Layout

             sqrt(RXHSF$P.spec...1.[i] / RXHSF$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

  ar2HSF[RXHSF$BIN.1[i]] <- ar2HSF[RXHSF$BIN.1[i]] + 
\end_layout

\begin_layout Plain Layout

             (RXHSF$P.spec...1.[i] / RXHSF$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

  narHSF[RXHSF$BIN.1[i]] <- narHSF[RXHSF$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

narHS[narHS <= 0] <- 1
\end_layout

\begin_layout Plain Layout

nphaseHS[nphaseHS == 0] <- 1
\end_layout

\begin_layout Plain Layout

mphaseHS <- phaseHS/nphaseHS
\end_layout

\begin_layout Plain Layout

mphase2HS <- phase2HS/nphaseHS
\end_layout

\begin_layout Plain Layout

sdpHS <- sqrt(mphase2HS - mphaseHS^2)
\end_layout

\begin_layout Plain Layout

mphaseHS <- mphaseHS * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpHS <- sdpHS * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpHS <- sdpHS * 2 / sqrt(nphaseHS)
\end_layout

\begin_layout Plain Layout

arHS <- arHS / narHS
\end_layout

\begin_layout Plain Layout

ar2HS <- ar2HS / narHS
\end_layout

\begin_layout Plain Layout

b <- ar2HS - arHS^2
\end_layout

\begin_layout Plain Layout

b[near(b, 0)] <- 0
\end_layout

\begin_layout Plain Layout

sdrHS <- sqrt(b)
\end_layout

\begin_layout Plain Layout

sdrHS <- sdrHS * 2 / sqrt(narHS)
\end_layout

\begin_layout Plain Layout

narHSB[narHSB <= 0] <- 1
\end_layout

\begin_layout Plain Layout

nphaseHSB[nphaseHSB == 0] <- 1
\end_layout

\begin_layout Plain Layout

mphaseHSB <- phaseHSB/nphaseHSB
\end_layout

\begin_layout Plain Layout

mphase2HSB <- phase2HSB/nphaseHSB
\end_layout

\begin_layout Plain Layout

sdpHSB <- sqrt(mphase2HSB - mphaseHSB^2)
\end_layout

\begin_layout Plain Layout

mphaseHSB <- mphaseHSB * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpHSB <- sdpHSB * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpHSB <- sdpHSB * 2 / sqrt(nphaseHSB)
\end_layout

\begin_layout Plain Layout

arHSB <- arHSB / narHSB
\end_layout

\begin_layout Plain Layout

ar2HSB <- ar2HSB / narHSB
\end_layout

\begin_layout Plain Layout

b <- ar2HSB - arHSB^2
\end_layout

\begin_layout Plain Layout

b[near(b, 0)] <- 0
\end_layout

\begin_layout Plain Layout

sdrHSB <- sqrt(b)
\end_layout

\begin_layout Plain Layout

sdrHSB <- sdrHSB * 2 / sqrt(narHSB)
\end_layout

\begin_layout Plain Layout

narHSF[narHSF <= 0] <- 1
\end_layout

\begin_layout Plain Layout

nphaseHSF[nphaseHSF == 0] <- 1
\end_layout

\begin_layout Plain Layout

mphaseHSF <- phaseHSF/nphaseHSF
\end_layout

\begin_layout Plain Layout

mphase2HSF <- phase2HSF/nphaseHSF
\end_layout

\begin_layout Plain Layout

sdpHSF <- sqrt(mphase2HSF - mphaseHSF^2)
\end_layout

\begin_layout Plain Layout

mphaseHSF <- mphaseHSF * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpHSF <- sdpHSF * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpHSF <- sdpHSF * 2 / sqrt(nphaseHSF)
\end_layout

\begin_layout Plain Layout

arHSF <- arHSF / narHSF
\end_layout

\begin_layout Plain Layout

ar2HSF <- ar2HSF / narHSF
\end_layout

\begin_layout Plain Layout

b <- ar2HSF - arHSF^2
\end_layout

\begin_layout Plain Layout

b[near(b, 0)] <- 0
\end_layout

\begin_layout Plain Layout

sdrHSF <- sqrt(b)
\end_layout

\begin_layout Plain Layout

sdrHSF <- sdrHSF * 2 / sqrt(narHSF)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Measurements from two slower sensors, a heated Goodrich/Rosemount 102 sensor
 and a similar 
\begin_inset CommandInset href
LatexCommand href
name "“Harco Model 100009-1 Deiced TAT”"
target "https://www.eol.ucar.edu/instruments/heated-ambient-temperature-sensor"
literal "false"

\end_inset

 (HARCO) sensor, have also been evaluated, but only the latter is discussed
 here because they have similar response.
 The spectral variance for both these measurements has apparent rapid attenuatio
n beginning at about 0.1
\begin_inset space ~
\end_inset

Hz, as shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:HARCOSpec}
\end_layout

\end_inset

, and the response is attenuated seriously above about 1
\begin_inset space ~
\end_inset

Hz.
\end_layout

\begin_layout Standard
Attempts to use the same three-parameter representation of the transfer
 function relative to dynamic heating led to unsatisfactory fits, so a different
 approach is used here.
 Because the evaluation in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-unheated-Rosemount"
plural "false"
caps "false"
noprefix "false"

\end_inset

 provides a good representation of the unheated Rosemount 102E4AL sensor,
 the measurements from that sensor, corrected as described in Appendix A,
 were used as the reference for the assumed-correct recovery temperature.
 Then the phase and amplitude ratio were found for the transfer function
 required to produce the heated-probe measurements from the unheated-probe
 measurements.
 This did not require any assumptions about equations or parameters determining
 the transfer function.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<extraUHR, include=FALSE, echo=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# SB <- 30
\end_layout

\begin_layout Plain Layout

Z <- capture.output (Vr <- SmoothInterp(detrend (DT1[, c('Time', 'TTWH')]),
 .Length=0))
\end_layout

\begin_layout Plain Layout

Z <- capture.output (VrC <- SmoothInterp(detrend (DT1[, c('Time', 'DH')]),
 .Length=0))
\end_layout

\begin_layout Plain Layout

Rate <- attr(DT1, 'Rate')
\end_layout

\begin_layout Plain Layout

vcv <- cbind(ts(Vr, frequency=Rate), ts(VrC, frequency=Rate))
\end_layout

\begin_layout Plain Layout

P <- spec.pgram(vcv, detrend=FALSE, fast=TRUE, plot=FALSE, spans=25)
\end_layout

\begin_layout Plain Layout

df1W <- data.frame(P$coh, log(P$freq))
\end_layout

\begin_layout Plain Layout

pf1W <- binStats (df1W, bins=SB)
\end_layout

\begin_layout Plain Layout

RX1W <- CohP(DT1, 'TTWH', 'RT', plotType='Ranadu', smoothBins=SB)
\end_layout

\begin_layout Plain Layout

RX2W <- CohP(DT2, 'TTWH', 'RT', plotType='Ranadu', smoothBins=SB)
\end_layout

\begin_layout Plain Layout

RX3W <- CohP(DT3, 'TTWH', 'RT', plotType='Ranadu', smoothBins=SB)
\end_layout

\begin_layout Plain Layout

RX4W <- CohP(DT4, 'TTWH', 'RT', plotType='Ranadu', smoothBins=SB)
\end_layout

\begin_layout Plain Layout

RX5W <- CohP(DT5, 'TTWH', 'RT', plotType='Ranadu', smoothBins=SB)
\end_layout

\begin_layout Plain Layout

# RX6W <- CohP(DT6, 'TTWH', 'DH', plotType='Ranadu', smoothBins=SB)
\end_layout

\begin_layout Plain Layout

phaseW <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

nphaseW <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

phase2W <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

arW <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

ar2W <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

narW <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

for (RX in list(RX1W, RX2W, RX3W, RX4W, RX5W)) {
\end_layout

\begin_layout Plain Layout

  for (i in 2:nrow(RX)) {
\end_layout

\begin_layout Plain Layout

    phaseW[RX$BIN.1[i]] <- phaseW[RX$BIN.1[i]]+RX$P.phase[i]
\end_layout

\begin_layout Plain Layout

    nphaseW[RX$BIN.1[i]] <- nphaseW[RX$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

    phase2W[RX$BIN.1[i]] <- phase2W[RX$BIN.1[i]]+RX$P.phase[i]^2 
\end_layout

\begin_layout Plain Layout

    arW[RX$BIN.1[i]] <- arW[RX$BIN.1[i]] + sqrt(RX$P.spec...1.[i] / RX$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

    ar2W[RX$BIN.1[i]] <- ar2W[RX$BIN.1[i]] + (RX$P.spec...1.[i] / RX$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

    narW[RX$BIN.1[i]] <- narW[RX$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

nphaseW[nphaseW == 0] <- 1
\end_layout

\begin_layout Plain Layout

mphaseW <- phaseW/nphaseW
\end_layout

\begin_layout Plain Layout

mphase2W <- phase2W/nphaseW
\end_layout

\begin_layout Plain Layout

sdpW <- sqrt(mphase2W - mphaseW^2)
\end_layout

\begin_layout Plain Layout

mphaseW <- mphaseW * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpW <- sdpW * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpW <- sdpW * 2 / sqrt(nphaseW)
\end_layout

\begin_layout Plain Layout

arW <- arW / narW
\end_layout

\begin_layout Plain Layout

ar2W <- ar2W / narW
\end_layout

\begin_layout Plain Layout

sdrW <- sqrt(ar2W - arW^2)
\end_layout

\begin_layout Plain Layout

sdrW <- sdrW * 2 / sqrt(narW)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The standard HARCO sensor was not flown on the same flight used to study
 the Rosemount sensor in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-unheated-Rosemount"
plural "false"
caps "false"
noprefix "false"

\end_inset

, so a different research flight will be used from the SOCRATES experiment.
 This flight segment was in modest turbulence (with eddy dissipation rate
 of approximately 
\begin_inset Formula $10^{-3}\mathrm{m}^{2}\mathrm{s^{-3}}$
\end_inset

) at low level and with an airspeed variance spectrum reasonably consistent
 with expectations for an inertial sub-range.
 Two sensors producing the measurements RTH1 and RTH1 are enclosed in the
 same housing.
 The characteristics are very similar so both will be evaluated here.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<RTH1Spec, include=FALSE, echo=FALSE, fig.pos='t', fig.height=4, fig.cap='Spectral
 variance $P(
\backslash

\backslash
nu)$ weighted by frequency ($
\backslash

\backslash
nu$) for the recovery temperature measured by a heated  and by an unheated
 Rosemount sensor.
 The background includes orange dotted lines denoting $-2/3$ slope and the
 wavelength scale is determined from the average airspeed.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# g <- VSpec(DT, 'TTWH', spans=99, ylim=c(1.e-6, 1))
\end_layout

\begin_layout Plain Layout

# suppressWarnings(print(VSpec(DT, 'TTRR', add=g, spans=99) + theme_WAC(1)))
\end_layout

\begin_layout Plain Layout

DT$temperature <- DT$TTWH
\end_layout

\begin_layout Plain Layout

DT %>% select(Time, TASX, temperature, TTRR) %>% 
\end_layout

\begin_layout Plain Layout

       VSpec(spans=199, VLabel=c('heated', 'unheated'), 
\end_layout

\begin_layout Plain Layout

             xlim=c(0.03, 12), ylim=c(4.e-7, 0.01), 
\end_layout

\begin_layout Plain Layout

             method='MEM', poles=100, smoothBins=200) + 
\end_layout

\begin_layout Plain Layout

  theme_WAC(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<tfHR, include=FALSE, eval=FALSE, fig.height=3.6, fig.pos='p', fig.cap='Transfer
 function for the heated Rosemount 102 sensor, based on measurements from
 the NSF/NCAR C-130 in the VOCALS project.
 Because the results showed high variability and inconsistency for frequencies
 above 1 Hz, only results for frequencies below that limit are shown.
 See the text for the fitted equations producing these curves.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

frq <- seq(0.01, 1.1, by=0.01)
\end_layout

\begin_layout Plain Layout

dfAPW <- data.frame('Time' = frq)
\end_layout

\begin_layout Plain Layout

dfAPW$Amp <- cfr[1]+cfr[2]*log(frq)+cfr[3]*log(frq)^3+cfr[4]*log(frq)^5
\end_layout

\begin_layout Plain Layout

dfAPW$Amp[dfAPW$Time < 0.09] <- 1 
\end_layout

\begin_layout Plain Layout

APW <- LTphase(dfAPW$Time, Param2)
\end_layout

\begin_layout Plain Layout

dfAPW$Amp2 <- APW$Amp
\end_layout

\begin_layout Plain Layout

dfAPW$Phase <- cf[1]+cf[2]*log(frq)+cf[3]*log(frq)^2+cf[4]*atan(frq)
\end_layout

\begin_layout Plain Layout

dfAPW$Phase2 <- APW$Phase
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  ggplotWAC(
\end_layout

\begin_layout Plain Layout

    dfAPW,
\end_layout

\begin_layout Plain Layout

    panels = 2,
\end_layout

\begin_layout Plain Layout

    labelP = c('    Amplitude', 'Phase [degrees]'),
\end_layout

\begin_layout Plain Layout

    labelL = c('lfit', '3-par')
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab(bquote('transfer function H(' * nu
 ~ ')'))
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  g + scale_x_log10(
\end_layout

\begin_layout Plain Layout

    breaks = trans_breaks("log10", function(x)
\end_layout

\begin_layout Plain Layout

      10 ^ x, n = 3),
\end_layout

\begin_layout Plain Layout

    labels = trans_format("log10", math_format(expr = 10 ^ .x))
\end_layout

\begin_layout Plain Layout

  ) + xlab('frequency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = 'tb')
\end_layout

\begin_layout Plain Layout

g <- g + theme_WAC(1) + theme(legend.position = c(0.3, 0.65))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<checkH, include=TRUE, fig.cap='The ratio of the spectral amplitude for
 the measurement of recovery temperature ($T_m(t)$) from the heated HARCO
 sensor to that for dynamic heating ($Q$), shown as the plotted data points.
 The green line is the prediction from the transfer function determined
 from the best-fit values matching the phase lag and amplitude ratio between
 these variables.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

g <- ggplot(dfrH, aes(x=frq, y=mrspec))+geom_point()
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab ('amplitude ratio RTH1 / Q')
\end_layout

\begin_layout Plain Layout

g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=1),
\end_layout

\begin_layout Plain Layout

         labels = trans_format("log10", math_format(expr = 10^.x))) + xlab('frequ
ency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = "bt")
\end_layout

\begin_layout Plain Layout

g <- g + geom_errorbar(aes(ymin=mrspec-sdr, ymax=mrspec+sdr), width=0.02)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=HH, aes(x=frq, y=Amp), col='forestgreen')
\end_layout

\begin_layout Plain Layout

suppressWarnings(print(g + ylim(0, 1.05) + theme_WAC(1)))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<HARCOSpec, include = TRUE, fig.height=3, fig.pos='t', fig.cap='Spectral variance
 $P(
\backslash

\backslash
nu)$ weighted by frequency ($
\backslash

\backslash
nu$) for the recovery temperature measured by a heated  HARCO and an unheated
 Rosemount sensor.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DCX$temperature <- DCX$RT
\end_layout

\begin_layout Plain Layout

DCX %>% selectTime(175200, 180200) %>% select(Time, TASX, temperature, RTH1)
 %>%
\end_layout

\begin_layout Plain Layout

        VSpec(VLabel=c('unheated', 'HARCO'), ylim=c(1.e-6, 0.1)) +
\end_layout

\begin_layout Plain Layout

        ylab(bquote('spectral variance ' ~ nu * 'P(' * nu * ')')) +    
\end_layout

\begin_layout Plain Layout

        theme_WAC(1) + theme(legend.position=c(0.7, 0.9))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Extra
inverted 0
status open

\begin_layout Standard
Measurements from the first five flight segments listed in Table
\begin_inset space ~
\end_inset

1 were used for characterization of the heated Rosemount 102 sensor.
 (The last segment was excluded because some of the measurements from the
 heated sensor were missing.) The spectral variance for the recovery-temperature
 measurement from the heated sensor has apparent rapid attenuation beginning
 at about 0.2
\begin_inset space ~
\end_inset

Hz, as shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:RTH1Spec}
\end_layout

\end_inset

, and the response is attenuated seriously above about 1
\begin_inset space ~
\end_inset

Hz.
 The measured phase lag of the measurement behind the measurement from the
 unheated Rosemount 102E4AL sensor is shown in the bottom panel of Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:phaseG}
\end_layout

\end_inset

 and the corresponding estimate of the gain is shown in the top panel.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<phaseG, include = FALSE, fig.show = 'asis', fig.height = 6, fig.cap = 'The
 phase (top) and gain (bottom) of the transfer function determined for the
 heated Rosemount 102 sensor (variable TTWH) and the recovery temperature
 obtained by applying transfer-function corrections to the measurments from
 the unheated Rosemount 102E4AL sensor (variable RT).
 Error bars are two-standard-deviation estimates of the uncertainty in the
 mean values shown by plotted circles.
 Because the results showed high variability and inconsistency for frequencies
 above 1 Hz, only results for frequencies below that limit are shown.
 The fits are described in the text.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

dfW <- data.frame(frq=exp(pf1W$xc), mphase=mphaseW, sdp=sdpW)
\end_layout

\begin_layout Plain Layout

dfrW <- data.frame(frq=exp(pf1W$xc), mrspec=arW, sdr=sdrW)
\end_layout

\begin_layout Plain Layout

dfW <- dfW[dfW$frq > 0.01 & dfW$frq <= 1, ]
\end_layout

\begin_layout Plain Layout

dfrW <- dfrW[dfrW$frq > 0.01 & dfrW$frq <= 1, ]
\end_layout

\begin_layout Plain Layout

Param2 <- Param1
\end_layout

\begin_layout Plain Layout

Param2$tau1 <- 0.5
\end_layout

\begin_layout Plain Layout

Param2$tau2 <- 0.8
\end_layout

\begin_layout Plain Layout

minFn <- function(V) {
\end_layout

\begin_layout Plain Layout

  Param2$a <<- V[1]
\end_layout

\begin_layout Plain Layout

  Param2$tau1 <<- V[2]
\end_layout

\begin_layout Plain Layout

  Param2$tau2 <<- V[3]
\end_layout

\begin_layout Plain Layout

  Chisq <- 0
\end_layout

\begin_layout Plain Layout

  for (i in 1:nrow(dfW)) {
\end_layout

\begin_layout Plain Layout

    Chisq <- Chisq + (dfW$mphase[i] - LTphase(dfW$frq[i], Param2)$Phase)^2
 / dfW$sdp[i]^2
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  for (i in 1:nrow(dfrW)) {
\end_layout

\begin_layout Plain Layout

    Chisq <- Chisq + (dfrW$mrspec[i] - LTphase(dfrW$frq[i], Param2)$Amp)^2
 / dfrW$sdr[i]^2
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return (Chisq)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

AW <- optim (c(Param2$a, Param2$tau1, Param2$tau2), minFn, hessian=TRUE)
\end_layout

\begin_layout Plain Layout

bestW <- AW$par
\end_layout

\begin_layout Plain Layout

HerrorW <- solve(AW$hessian / 4)  # factor of 4 because 2-sigma errors were
 used?
\end_layout

\begin_layout Plain Layout

uncLimitsW <- sqrt(diag(HerrorW))
\end_layout

\begin_layout Plain Layout

g <- ggplot(dfW, aes(x=frq, y=mphase))+geom_point()
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab (bquote('phase [' ~ degree * ']'))
\end_layout

\begin_layout Plain Layout

g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=2),
\end_layout

\begin_layout Plain Layout

                       labels = trans_format("log10", math_format(expr =
 10^.x))) + xlab('frequency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = "bt")
\end_layout

\begin_layout Plain Layout

g <- g + geom_errorbar(aes(ymin=mphase-sdp, ymax=mphase+sdp), width=0.05)
\end_layout

\begin_layout Plain Layout

# g <- g + geom_path(data=dfW, aes(x=frq, y=mphase), col='forestgreen')
\end_layout

\begin_layout Plain Layout

cf <- coef(lm(data=dfW, mphase ~ log(frq)+I(log(frq)^2)+I(atan(frq))))
\end_layout

\begin_layout Plain Layout

dfW$Ph <- cf[1]+cf[2]*log(dfW$frq)+cf[3]*log(dfW$frq)^2+cf[4]*atan(dfW$frq)
\end_layout

\begin_layout Plain Layout

dfW$PhLT <- LTphase(dfW$frq, Param2)$Phase
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfW, aes(x=frq, y=Ph, col='lfit', lty='lfit'))
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfW, aes(x=frq, y=PhLT, col='3-par', lty='3-par'))
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  g + scale_colour_manual (
\end_layout

\begin_layout Plain Layout

    name = 'fit: ',
\end_layout

\begin_layout Plain Layout

    values = c("lfit" = "forestgreen", "3-par" = "blue")
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

g <- g + scale_linetype_manual (name = 'fit: ', 
\end_layout

\begin_layout Plain Layout

                                values = c('lfit' = 4, '3-par'=1))
\end_layout

\begin_layout Plain Layout

g1 <- g + theme_WAC(1) + theme(legend.position = c(0.75, 0.75),
\end_layout

\begin_layout Plain Layout

                                legend.direction = 'vertical')
\end_layout

\begin_layout Plain Layout

g <- ggplot(dfrW, aes(x=frq, y=mrspec))+geom_point()
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab ('amplitude ratio TTWH / RT')
\end_layout

\begin_layout Plain Layout

g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=2),
\end_layout

\begin_layout Plain Layout

         labels = trans_format("log10", math_format(expr = 10^.x))) + xlab('frequ
ency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = "bt")
\end_layout

\begin_layout Plain Layout

g <- g + geom_errorbar(aes(ymin=mrspec-sdr, ymax=mrspec+sdr), width=0.05)
\end_layout

\begin_layout Plain Layout

# g <- g + geom_path(data=dfAP, aes(x=Time, y=Amp), col='forestgreen')
\end_layout

\begin_layout Plain Layout

# g <- g + geom_path(data=dfr, aes(x=frq, y=Amp5), col='darkorange', lty=2)
\end_layout

\begin_layout Plain Layout

cfr <- coef(lm(data=dfrW[dfrW$frq > 0.07, ], mrspec ~ log(frq) + I(log(frq)^3)
 + 
\end_layout

\begin_layout Plain Layout

               I(log(frq)^5)))
\end_layout

\begin_layout Plain Layout

dfrW$G <- cfr[1] + cfr[2] * log(dfrW$frq)    + 
\end_layout

\begin_layout Plain Layout

           cfr[3] * log(dfrW$frq)^3 + cfr[4] * log(dfrW$frq)^5
\end_layout

\begin_layout Plain Layout

dfrW$G[dfrW$frq < 0.08] <- 1
\end_layout

\begin_layout Plain Layout

dfrW$GLT <- LTphase(dfrW$frq, Param2)$Amp
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfrW, aes(x=frq, y=G, col='lfit', lty='lfit'))
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfrW, aes(x=frq, y=GLT, col='3-par', lty='3-par'))
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  g + scale_colour_manual (
\end_layout

\begin_layout Plain Layout

    name = 'fit: ',
\end_layout

\begin_layout Plain Layout

    values = c("lfit" = "forestgreen", "3-par" = "blue")
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

g <- g + scale_linetype_manual (name = 'fit: ', 
\end_layout

\begin_layout Plain Layout

                                values = c('lfit' = 4, '3-par'=1))
\end_layout

\begin_layout Plain Layout

g2 <- g + ylim(0, 1.2) + theme_WAC(1) + theme(legend.position = c(0.75, 0.8))
\end_layout

\begin_layout Plain Layout

# suppressWarnings(print(g + ylim(0, 1.2) + theme_WAC(1) + 
\end_layout

\begin_layout Plain Layout

#                        theme(legend.position = c(0.75, 0.9))))
\end_layout

\begin_layout Plain Layout

g2 <- g2 + theme(plot.margin=unit(c(0.5,0.3,1.1,1.8),"lines"))  ## small adjustment
 for alignment
\end_layout

\begin_layout Plain Layout

grid.newpage()
\end_layout

\begin_layout Plain Layout

vp2 <- viewport(y=unit(0.61, 'npc'), height=unit(0.5, 'npc'),layout.pos.row=2)
\end_layout

\begin_layout Plain Layout

vp1 <- viewport(y=unit(0.25, 'npc'), height=unit(0.5, 'npc'),layout.pos.row=1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

print(g2, vp=vp2)
\end_layout

\begin_layout Plain Layout

print(g1, vp=vp1)
\end_layout

\begin_layout Plain Layout

grid.newpage()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Extra
inverted 0
status open

\begin_layout Standard
No combination of the three fit parameters {
\begin_inset Formula $a,\,\tau_{1},\,\tau_{2}$
\end_inset

} entering the transfer-function equations 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:responseAmp"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:responsePhase"
plural "false"
caps "false"
noprefix "false"

\end_inset

 provides a satisfactory representation of the measurements in those two
 plots, although the best fit (shown as the 
\begin_inset Quotes eld
\end_inset

3-par
\begin_inset Quotes erd
\end_inset

 line) for the values {
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestW[1], 2)}
\end_layout

\end_inset

,
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestW[2], 2)}
\end_layout

\end_inset

,
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestW[3], 2)}
\end_layout

\end_inset

} provides a fair approximation.
 Those figures show that the fit is inadequate (chisquare of over 16,000
 for 40 degrees of freedom) so it appears that for this sensor heat transfer
 is still more complicated than can be represented by the differential equations
 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

, perhaps because there are other paths by which heat can be transferred
 to or from the sensing wire.
 The small value for the parameter 
\begin_inset Formula $a$
\end_inset

 suggests that most of the heat transferred to or from the wire is through
 routes other than direct conduction from the air.
\end_layout

\begin_layout Standard
Rather than seeking a more complicated representation of the transfer function,
 it can be represented instead by the lines in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:phaseG}
\end_layout

\end_inset

 labeled 
\begin_inset Quotes eld
\end_inset

lfit
\begin_inset Quotes erd
\end_inset

, fits to the measurements in terms of 
\begin_inset Formula $x=\log_{e}(\nu/\nu_{0})$
\end_inset

 where 
\begin_inset Formula $\nu=\omega/(2\pi)$
\end_inset

 is the frequency and 
\begin_inset Formula $\nu_{0}=1\,\mathrm{Hz}$
\end_inset

:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\mathrm{for}\,\nu>0.08\,\mathrm{Hz,\,\,}H(\omega)=(h_{0}+h_{1}x+h_{2}x^{3}+h_{3}x^{5}+h_{3}\arctan(\nu/\nu_{0}))e^{i\phi(\omega)}\label{eq:lfitR}
\end{equation}

\end_inset


\begin_inset Formula 
\[
\mathrm{for\:\nu\leq0.08\,\mathrm{Hz},\quad}H(\omega)=1
\]

\end_inset


\begin_inset Formula 
\[
\phi(\omega)=p_{0}+p_{1}x+p_{2}x^{2}+p_{3}\arctan(\nu/\nu_{0})
\]

\end_inset

The coefficients obtained by fitting to the observations are 
\begin_inset Formula $h_{0-3}=$
\end_inset

{
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{round(cfr[1], 3)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{round(cfr[2], 3)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{round(cfr[3], 4)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{round(cfr[4], 5)}$
\end_layout

\end_inset

} and 
\begin_inset Formula $p_{0-3}=$
\end_inset

{
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{round(cf[1], 1)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{format(cf[2], digits=1, nsmall=1)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{format(cf[3], digits=2, nsmall=2)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{round(cf[4], 1)}$
\end_layout

\end_inset

}.
 These equations are the basis for the 
\begin_inset Quotes eld
\end_inset

lfit
\begin_inset Quotes erd
\end_inset

 lines plotted in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:phaseG}
\end_layout

\end_inset

.
 For negative frequencies, the values of 
\begin_inset Formula $H(\omega)$
\end_inset

 are the complex conjugate of the values listed above.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Extra
inverted 0
status open

\begin_layout Standard
The reason that the three-parameter fit is unacceptable is that there is
 conflict between the constraints imposed by the amplitude ratio and the
 phase, such that either could be represented reasonably but not both.
 The actual transfer function has some complex features, including frequencies
 where the phase shift reaches values below 
\begin_inset Formula $-90^{\circ}$
\end_inset

 (not possible for a simple exponential time response) and values of the
 phase shift of about 
\begin_inset Formula $-36^{\circ}$
\end_inset

 at 0.1
\begin_inset space ~
\end_inset

Hz where the amplitude ratio remains near unity.
 The amplitude decreases to 
\begin_inset Formula $e^{-1}$
\end_inset

 at about 0.4
\begin_inset space ~
\end_inset

Hz, as would be the case for a first-order time constant of about 1
\begin_inset space ~
\end_inset

s, so this could be considered another measure of the response.
 However, that value does not extrapolate well to other frequencies and
 the phase shift at 0.4
\begin_inset space ~
\end_inset

Hz is approximately 
\begin_inset Formula $-90^{\circ}$
\end_inset

, which would indicate that the measurement of a real contribution to sensible-h
eat flux at this frequency would be zero.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Project / Flight
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
start [UTC]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
end [UTC]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CSET / 5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2015-07-14 17:52:00
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
18:02:00
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CSET / 5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2015-07-14 19:45:30
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
19:55:30
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CSET / 5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2015-07-14 20:37:17
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20:47:17
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SOCRATES / 15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2018-02-24 5:52:00
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6:02:00
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SOCRATES / 15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2018-02-24 6:05:00
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6:15:00
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Flight segments used to determine the response characteristics of a heated
 HARCO sensor.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Boundary-layer flight segments from the SOCRATES and CSET projects (referenced
 earlier in connection with the unheated probe) were compiled into one data
 set from the flight periods shown in Table
\begin_inset space ~
\end_inset

2.
 An unheated Rosemount 102E4AL sensor was also onboard, so corrected measurement
s from that sensor were used as the reference against which to determine
 the gain and phase of the transfer function.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<GVHARCO, include = TRUE, fig.height = 5>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SB <- 50
\end_layout

\begin_layout Plain Layout

RXA <- DSX %>% selectTime(55200, 60200) %>% CohP('RTH1', 'RT', plotType='Ranadu'
, smoothBins=SB)
\end_layout

\begin_layout Plain Layout

RXB <- DSX %>% selectTime(60500, 61500) %>% CohP('RTH1', 'RT', plotType='Ranadu'
, smoothBins=SB)
\end_layout

\begin_layout Plain Layout

RXC <- DCX %>% selectTime(175200, 180200) %>% CohP('RTH1', 'RT', plotType='Ranad
u', smoothBins=SB)
\end_layout

\begin_layout Plain Layout

RXD <- DCX %>% selectTime(194530, 195530) %>% CohP('RTH1', 'RT', plotType='Ranad
u', smoothBins=SB)
\end_layout

\begin_layout Plain Layout

RXE <- DCX %>% selectTime(203717, 204717) %>% CohP('RTH1', 'RT', plotType='Ranad
u', smoothBins=SB)
\end_layout

\begin_layout Plain Layout

## May need to revise this with corrected RT in second iteration
\end_layout

\begin_layout Plain Layout

Z <- capture.output (Vr <- SmoothInterp(detrend (DSA[, c('Time', 'RTH1')]),
 .Length=0))
\end_layout

\begin_layout Plain Layout

Z <- capture.output (VrC <- SmoothInterp(detrend (DSA[, c('Time', 'RT')]),
 .Length=0))
\end_layout

\begin_layout Plain Layout

Rate <- attr(DSA, 'Rate')
\end_layout

\begin_layout Plain Layout

vcv <- cbind(ts(Vr, frequency=Rate), ts(VrC, frequency=Rate))
\end_layout

\begin_layout Plain Layout

P <- spec.pgram(vcv, detrend=FALSE, fast=TRUE, plot=FALSE, spans=25)
\end_layout

\begin_layout Plain Layout

df1SH <- data.frame(P$coh, log(P$freq))
\end_layout

\begin_layout Plain Layout

df2SH <- data.frame (P$phase, log(P$freq))
\end_layout

\begin_layout Plain Layout

pf1SH <- binStats (df1SH, bins=SB)
\end_layout

\begin_layout Plain Layout

pf2SH <- binStats (df2SH, bins=SB)
\end_layout

\begin_layout Plain Layout

phaseSH <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

nphaseSH <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

phase2SH <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

arSH <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

ar2SH <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

narSH <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

for (RX in list(RXA, RXB, RXC, RXD, RXE)) {
\end_layout

\begin_layout Plain Layout

  for (i in 2:nrow(RX)) {
\end_layout

\begin_layout Plain Layout

    phaseSH[RX$BIN.1[i]] <- phaseSH[RX$BIN.1[i]] + RX$P.phase[i]
\end_layout

\begin_layout Plain Layout

    nphaseSH[RX$BIN.1[i]] <- nphaseSH[RX$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

    phase2SH[RX$BIN.1[i]] <- phase2SH[RX$BIN.1[i]] + RX$P.phase[i]^2
\end_layout

\begin_layout Plain Layout

    arSH[RX$BIN.1[i]] <- arSH[RX$BIN.1[i]] + sqrt(RX$P.spec...1.[i] / RX$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

    ar2SH[RX$BIN.1[i]] <- ar2SH[RX$BIN.1[i]] + (RX$P.spec...1.[i] / RX$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

    narSH[RX$BIN.1[i]] <- narSH[RX$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

nphaseSH[nphaseSH == 0] <- 1
\end_layout

\begin_layout Plain Layout

narSH[narSH == 0] <- 1
\end_layout

\begin_layout Plain Layout

mphaseSH <- phaseSH/nphaseSH
\end_layout

\begin_layout Plain Layout

mphase2SH <- phase2SH/nphaseSH
\end_layout

\begin_layout Plain Layout

sdpSH <- sqrt(mphase2SH - mphaseSH^2)
\end_layout

\begin_layout Plain Layout

mphaseSH <- mphaseSH * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpSH <- sdpSH * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpSH <- sdpSH * 2 / sqrt(nphaseSH)
\end_layout

\begin_layout Plain Layout

arSH <- arSH / narSH
\end_layout

\begin_layout Plain Layout

ar2SH <- ar2SH / narSH
\end_layout

\begin_layout Plain Layout

b <- ar2SH - arSH^2
\end_layout

\begin_layout Plain Layout

b[near(b, 0)] <- 0
\end_layout

\begin_layout Plain Layout

sdrSH <- sqrt(b)
\end_layout

\begin_layout Plain Layout

sdrSH <- sdrSH * 2 / sqrt(narSH)
\end_layout

\begin_layout Plain Layout

dfSH <- data.frame(frq=exp(pf2SH$xc), mphase=mphaseSH, sdp=sdpSH)
\end_layout

\begin_layout Plain Layout

dfSH <- dfSH[dfSH$frq > 0.01, ]
\end_layout

\begin_layout Plain Layout

dfSH <- dfSH[dfSH$sdp > 0, ]
\end_layout

\begin_layout Plain Layout

dfSH <- dfSH[dfSH$frq < 2, ]
\end_layout

\begin_layout Plain Layout

dfrSH <- data.frame(frq=exp(pf2SH$xc), mrspec=arSH, sdr=sdrSH)
\end_layout

\begin_layout Plain Layout

dfrSH <- dfrSH[dfrSH$frq > 0.01, ]
\end_layout

\begin_layout Plain Layout

dfrSH <- dfrSH[dfrSH$sdr > 0, ]
\end_layout

\begin_layout Plain Layout

dfrSH <- dfrSH[dfrSH$frq < 2, ]
\end_layout

\begin_layout Plain Layout

frq <- exp(pf2SH$xc)
\end_layout

\begin_layout Plain Layout

Parm <- Param1
\end_layout

\begin_layout Plain Layout

Parm$a <- 0.1
\end_layout

\begin_layout Plain Layout

Parm$tau1 <- 0.1
\end_layout

\begin_layout Plain Layout

Parm$tau2 <- 1.5
\end_layout

\begin_layout Plain Layout

minFn <- function(V) {
\end_layout

\begin_layout Plain Layout

  Parm$a <<- V[1]
\end_layout

\begin_layout Plain Layout

  Parm$tau1 <<- V[2]
\end_layout

\begin_layout Plain Layout

  Parm$tau2 <<- V[3]
\end_layout

\begin_layout Plain Layout

  Chisq <- 0
\end_layout

\begin_layout Plain Layout

  for (i in 1:nrow(dfSH)) {
\end_layout

\begin_layout Plain Layout

    Chisq <- Chisq + (dfSH$mphase[i] - LTphase(dfSH$frq[i], Parm)$Phase)^2
 / dfSH$sdp[i]^2
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  for (i in 1:nrow(dfrSH)) {
\end_layout

\begin_layout Plain Layout

    Chisq <- Chisq + (dfrSH$mrspec[i] - LTphase(dfrSH$frq[i], Parm)$Amp)^2
 / dfrSH$sdr[i]^2
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return (Chisq)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

ASH <- optim (c(Parm$a, Parm$tau1, Parm$tau2), minFn, method='L-BFGS-B',
 
\end_layout

\begin_layout Plain Layout

              lower=0, hessian=TRUE)
\end_layout

\begin_layout Plain Layout

bestSH <- ASH$par
\end_layout

\begin_layout Plain Layout

HerrorSH <- solve(ASH$hessian / 4)  # factor of 4 because 2-sigma errors
 were used?
\end_layout

\begin_layout Plain Layout

uncLimitsSH <- sqrt(diag(HerrorSH))
\end_layout

\begin_layout Plain Layout

# print(bestSH)
\end_layout

\begin_layout Plain Layout

HSH <- LTphase(dfrSH$frq, Parm)
\end_layout

\begin_layout Plain Layout

dfrSH$Amp <- HSH$Amp
\end_layout

\begin_layout Plain Layout

dfrSH$Phase <- HSH$Phase
\end_layout

\begin_layout Plain Layout

ParamSH <- Param2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

g <- ggplot(dfSH, aes(x=frq, y=mphase))+geom_point(size=1.3)
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab (bquote('phase [' * degree * ']'))
\end_layout

\begin_layout Plain Layout

g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=2),
\end_layout

\begin_layout Plain Layout

                       labels = trans_format("log10", math_format(expr =
 10^.x))) + xlab('frequency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = "bt")
\end_layout

\begin_layout Plain Layout

g <- g + geom_errorbar(aes(ymin=mphase-2*sdp, ymax=mphase+2*sdp), width=0.08)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfrSH, aes(x=frq, y=Phase), col='forestgreen')
\end_layout

\begin_layout Plain Layout

cf <- coef(lm(data=dfSH, mphase ~ log(frq)+I(log(frq)^2)+I(atan(frq))))
\end_layout

\begin_layout Plain Layout

dfSH$Ph <- cf[1]+cf[2]*log(dfSH$frq) + cf[3]*log(dfSH$frq)^2 + 
\end_layout

\begin_layout Plain Layout

           cf[4]*atan(dfSH$frq)
\end_layout

\begin_layout Plain Layout

dfSH$PhLT <- LTphase(dfSH$frq, Parm)$Phase
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfSH, aes(x=frq, y=Ph, col='lfit', lty='lfit'),
 lwd = 1.2)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfSH, aes(x=frq, y=PhLT, col='3-par', lty='3-par'),
 lwd = 1.2)
\end_layout

\begin_layout Plain Layout

# g <- g + geom_path(data=dfAPSH, aes(x=Time, y=Phase), col='darkorange')
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  g + scale_colour_manual (
\end_layout

\begin_layout Plain Layout

    name = 'fit: ',
\end_layout

\begin_layout Plain Layout

    values = c("lfit" = "forestgreen", "3-par" = "blue")
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

g <- g + scale_linetype_manual (name = 'fit: ', 
\end_layout

\begin_layout Plain Layout

                                values = c('lfit' = 4, '3-par'=1))
\end_layout

\begin_layout Plain Layout

g1 <- g + theme_WAC(1) + theme(legend.position = c(0.75, 0.75),
\end_layout

\begin_layout Plain Layout

                               legend.direction = 'vertical')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

frq <- exp(pf2SH$xc[narSH > 0])
\end_layout

\begin_layout Plain Layout

g <- ggplot(dfrSH, aes(x=frq, y=mrspec))+geom_point(size=1.3)
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab ('amplitude ratio')
\end_layout

\begin_layout Plain Layout

g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=2),
\end_layout

\begin_layout Plain Layout

                       labels = trans_format("log10", math_format(expr =
 10^.x))) + xlab('frequency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = "bt")
\end_layout

\begin_layout Plain Layout

g <- g + geom_errorbar(aes(ymin=mrspec-2*sdr, ymax=mrspec+2*sdr), width=0.08)
\end_layout

\begin_layout Plain Layout

# g <- g + geom_path(data=dfAPSH, aes(x=Time, y=Amp), col='darkorange')
\end_layout

\begin_layout Plain Layout

cfr <- coef(lm(data=dfrSH, mrspec ~ log(frq) + I(log(frq)^3) + 
\end_layout

\begin_layout Plain Layout

               I(log(frq)^5)))
\end_layout

\begin_layout Plain Layout

cfr <- coef(lm(data=dfrSH, mrspec ~ log(frq) + I(log(frq)^3) +
\end_layout

\begin_layout Plain Layout

            I(log(frq)^4)+I(log(frq)^5)))
\end_layout

\begin_layout Plain Layout

fr <- log(dfrSH$frq)
\end_layout

\begin_layout Plain Layout

dfrSH$G <- cfr[1] + fr * (cfr[2] + fr * fr * (cfr[3] + fr * (cfr[4] + 
\end_layout

\begin_layout Plain Layout

                     fr * cfr[5])))
\end_layout

\begin_layout Plain Layout

dfrSH$G[dfrSH$frq < 0.024] <- 1
\end_layout

\begin_layout Plain Layout

dfrSH$GLT <- LTphase(dfrSH$frq, Parm)$Amp
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfrSH, aes(x=frq, y=G, col='lfit', lty='lfit'),
 lwd = 1.2)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfrSH, aes(x=frq, y=GLT, col='3-par', lty='3-par'),
 lwd = 1.2)
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  g + scale_colour_manual (
\end_layout

\begin_layout Plain Layout

    name = 'fit: ',
\end_layout

\begin_layout Plain Layout

    values = c("lfit" = "forestgreen", "3-par" = "blue")
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

g <- g + scale_linetype_manual (name = 'fit: ', 
\end_layout

\begin_layout Plain Layout

                                values = c('lfit' = 4, '3-par'=1))
\end_layout

\begin_layout Plain Layout

g2 <- g + ylim(0, 1.1) + theme_WAC(1) + theme(legend.position = 'none')
\end_layout

\begin_layout Plain Layout

g2 <- g2 + theme(plot.margin=unit(c(0.3, 0.3, 1.1, 2.15), "lines"))  ## small
 adjustment for alignment
\end_layout

\begin_layout Plain Layout

g2 <- g2 + theme(axis.title.y = element_text(vjust = 4))
\end_layout

\begin_layout Plain Layout

g1 <- g1 + theme(axis.title.y = element_text(vjust = 0))
\end_layout

\begin_layout Plain Layout

grid.newpage()
\end_layout

\begin_layout Plain Layout

vp2 <- viewport(y=unit(0.57, 'npc'), height=unit(0.51, 'npc'),           
       
\end_layout

\begin_layout Plain Layout

                layout.pos.row=2)
\end_layout

\begin_layout Plain Layout

vp1 <- viewport(y=unit(0.25, 'npc'), height=unit(0.5, 'npc'),layout.pos.row=1)
\end_layout

\begin_layout Plain Layout

print(g1, vp=vp2)
\end_layout

\begin_layout Plain Layout

print(g2, vp=vp1)
\end_layout

\begin_layout Plain Layout

grid.newpage()
\end_layout

\begin_layout Plain Layout

# suppressWarnings(print(g + ylim(0, 1.3) + theme(legend.position = c(0.75,
 0.9)) + theme_WAC(1)))
\end_layout

\begin_layout Plain Layout

# CohPhase(DSA, 'RTH1', 'RTF1')
\end_layout

\begin_layout Plain Layout

# DSA %>% select(Time, TASX, RTH1, RT, ATH1) %>% VSpec()
\end_layout

\begin_layout Plain Layout

# print(bestSH)
\end_layout

\begin_layout Plain Layout

## Save for later use:
\end_layout

\begin_layout Plain Layout

cfHARCO <- cf
\end_layout

\begin_layout Plain Layout

cfrHARCO <- cfr
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
The phase and gain for the transfer function characterizing a heated HARCO
 temperature sensor.
 
\end_layout

\end_inset

The phase (top) and gain (bottom) for the transfer function characterizing
 a heated HARCO temperature sensor.
 The measurements are indicated by error bars that show two-standard-deviation
 limits from the mean value).
 Two fits to the measurements, one based on the three-parameter representation
 (
\begin_inset Quotes eld
\end_inset

3-par
\begin_inset Quotes erd
\end_inset

) and one on a polynomial fit (
\begin_inset Quotes eld
\end_inset

lfit
\begin_inset Quotes erd
\end_inset

), are described in the text.
\begin_inset CommandInset label
LatexCommand label
name "fig:GVHARCO"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The measured phase and amplitude ratio for this data set are shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:GVHARCO}
\end_layout

\end_inset

.
 The fits for the response function defined by 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:responseAmp"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:responsePhase"
plural "false"
caps "false"
noprefix "false"

\end_inset

 are shown as the blue lines labeled 
\begin_inset Quotes eld
\end_inset

3-par
\begin_inset Quotes erd
\end_inset

 in that figure.
 The fitted values for {
\begin_inset Formula $a,\,\tau_{1},\,\tau_{2}$
\end_inset

} were {0, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestSH[2], 2)}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestSH[3], 2)}
\end_layout

\end_inset

}, and to obtain this result the fit had to be constrained to keep 
\begin_inset Formula $a$
\end_inset

 non-negative.
 A value of zero for the parameter 
\begin_inset Formula $a$
\end_inset

 would indicate that no heat is transferred from the sensing wire to the
 air, but instead all is transferred to the support which has a relatively
 slow characteristic response.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
The transfer function and typical variance spectrum for the heated Rosemount
 102 sensor is quite similar to this plot, , and the typical variance spectrum
 shows a decrease with frequency similar to that in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:HARCOSpec}
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The three-parameter fit is not consistent with the measurement errors even
 though it provides an approximate representation of the transfer function.
 The apparent reason is that there is conflict between the constraints imposed
 by the amplitude ratio and the phase, such that either could be represented
 reasonably but not both.
 The actual transfer function has some complex features, including frequencies
 where the phase shift reaches values below 
\begin_inset Formula $-90^{\circ}$
\end_inset

 (not possible for a simple exponential time response) and values of the
 phase shift of about 
\begin_inset Formula $-38^{\circ}$
\end_inset

 at 0.1
\begin_inset space ~
\end_inset

Hz where the amplitude ratio is still high (about 0.75).
 The amplitude decreases to 
\begin_inset Formula $e^{-1}$
\end_inset

 at about 0.34
\begin_inset space ~
\end_inset

Hz, as would be the case for a first-order time constant of about 1.3
\begin_inset space ~
\end_inset

s, so this could be considered another measure of the response.
 However, that value does not extrapolate well to other frequencies and
 the phase shift at 0.34
\begin_inset space ~
\end_inset

Hz is approximately 
\begin_inset Formula $-73^{\circ}$
\end_inset

, which would indicate that the measurement of a real contribution to sensible-h
eat flux at this frequency would be only about 10% of the correct value.
\end_layout

\begin_layout Standard
Because the three-parameter fit distorted the measured result, fits in the
 logarithm of the frequency were used to provide a better representation
 of the measurements, as shown by the dashed green lines labeled 
\begin_inset Quotes eld
\end_inset

lfit
\begin_inset Quotes erd
\end_inset

.
 Those fits are given by these equations and coefficients, with 
\begin_inset Formula $x=\log_{e}(\nu/\nu_{0})$
\end_inset

 where 
\begin_inset Formula $\nu$
\end_inset

 is the frequency, 
\begin_inset Formula $\omega=2\pi\nu$
\end_inset

 and 
\begin_inset Formula $\nu_{0}=1\,\mathrm{Hz}$
\end_inset

:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\mathrm{for}\,\nu>0.024\,\mathrm{Hz,\,\,}H(\omega)=(h_{0}+h_{1}x+h_{2}x^{3}+h_{3}x^{4}+h_{4}x^{5})e^{i\phi(\omega)}\label{eq:lfitH}
\end{equation}

\end_inset


\begin_inset Formula 
\[
\mathrm{for\:\nu\leq0.024\,\mathrm{Hz},\quad}H(\omega)=1
\]

\end_inset


\begin_inset Formula 
\[
\phi(\omega)=p_{0}+p_{1}x+p_{2}x^{2}+p_{3}\arctan(\nu/\nu_{0})
\]

\end_inset

The coefficients obtained by fitting to the observations are 
\begin_inset Formula $h_{0-4}=$
\end_inset

{
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{round(cfr[1], 3)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{round(cfr[2], 3)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{format(cfr[3], digits=3, nsmall=4)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{round(cfr[4], 4)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{round(cfr[5], 5)}$
\end_layout

\end_inset

} and 
\begin_inset Formula $p_{0-3}=$
\end_inset

{
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{round(cf[1], 1)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{round(cf[2], 1)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{round(cf[3], 2)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{round(cf[4], 1)}$
\end_layout

\end_inset

}.
 This fit can be used to represent the transfer function better than the
 three-parameter fit (with negative-frequency values defined as the complex
 conjugate of the values at the corresponding positive frequency), although
 the fit needs to be modified above about 2
\begin_inset space ~
\end_inset

Hz because those values were not constrained by the measurements.
 A suggested modification is to duplicate the value at 2
\begin_inset space ~
\end_inset

Hz to higher frequencies; this appears to be adequate because there is so
 little variance measured by this sensor at these frequencies, as shown
 by Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:RTH1Spec}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
For the contribution of these measurements to fits to determine the response
 parameters, measurements of phase were used only for frequencies from 0.05
 to 1
\begin_inset space ~
\end_inset

Hz and those of amplitude ratio only for frequencies from 0.13 to 1
\begin_inset space ~
\end_inset

Hz.
 The fit does not appear to be as consistent with the measured values as
 the fit for the unheated Rosemount
\begin_inset Foot
status open

\begin_layout Plain Layout
Chi-square 405 for 36 degrees of freedom.
\end_layout

\end_inset

, especially in regard to the amplitude, perhaps indicating that the two-differe
ntial-equation representation of the response is incomplete in this case.
 The best-fit parameters indicated for this sensor are 
\begin_inset Formula $a=$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestHS[1], 2)}
\end_layout

\end_inset

, 
\begin_inset Formula $\tau_{1}=$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestHS[2], 2)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

s and 
\begin_inset Formula $\tau_{2}=$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestHS[3], 2)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

s for sensor 1 (RTH1) and 
\begin_inset Formula $a=$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestHSB[1], 2)}
\end_layout

\end_inset

, 
\begin_inset Formula $\tau_{1}=$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestHSB[2], 2)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

s and 
\begin_inset Formula $\tau_{2}=$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestHSB[3], 2)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

s for sensor 2 (RTH2).
 The best fit indicates that most heat transfer from or to the wire comes
 from the support and only a smaller fraction is contributed by the air
 itself.
 However, this is still a two-time-constant fit because the support responds
 to the air temperature and the wire separately responds to the support
 temperature.
 This leads to phase shifts more negative than 
\begin_inset Formula $-90^{\circ}$
\end_inset

, which would not be possible for a single-time-constant response.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Expected dependence on flight conditions
\begin_inset CommandInset label
LatexCommand label
name "subsec:Expected-dependence-on"

\end_inset


\end_layout

\begin_layout Standard
Based on measurements in a wind tunnel, 
\begin_inset CommandInset citation
LatexCommand citet
key "GoodrichTR5755"
literal "false"

\end_inset

 indicated that the fast-response characteristic time 
\begin_inset Formula $\tau_{1}$
\end_inset

 for the unheated Rosemount 102E4AL sensor varies approximately as 
\begin_inset Formula $\log(Z^{-0.6})$
\end_inset

 where 
\begin_inset Formula $Z=M\rho_{a}/\rho_{s}$
\end_inset

 with 
\begin_inset Formula $M$
\end_inset

 the Mach number, 
\begin_inset Formula $\rho_{a}$
\end_inset

 the air density and 
\begin_inset Formula $\rho_{0}$
\end_inset

 the air density under standard conditions.
 The mean value of 
\begin_inset Formula $Z$
\end_inset

 for the flight segments used to find the best-fit parameters was 
\begin_inset Formula $Z=0.3$
\end_inset

, so this suggests that the first characteristic time for that sensor is
 best represented by
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\tau_{1}^{\prime}(Z)=\tau_{1}\left(\frac{0.3}{Z}\right)^{0.6}\,\,\,.\label{eq:tau1prime}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
For GV flight conditions, 
\begin_inset Formula $Z$
\end_inset

 can vary from about 0.18 to 0.38, so this suggests a range for 
\begin_inset Formula $\tau_{1}$
\end_inset

 from 0.029 to 0.046
\begin_inset space ~
\end_inset

s.
\end_layout

\end_inset

 There is no similar evidence for 
\begin_inset Formula $\tau_{2}$
\end_inset

, but it might be expected to have similar dependence because this is approximat
ely the Reynolds number dependence and the Nusselt number characterizing
 ventilated heat transfer often is represented by a power-law relationship
 to the Reynolds number.
 If both heat transfer terms scale similarly, it might be expected that
 
\begin_inset Formula $a$
\end_inset

 will be unchanged.
\end_layout

\begin_layout Standard
For these reasons, the time parameters obtained in preceding sections have
 been adjusted to a reference value of 
\begin_inset Formula $Z=0.3$
\end_inset

 in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Parameters"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 For other conditions, it is suggested that the best estimate will be to
 multiply 
\begin_inset Formula $\tau_{1}$
\end_inset

 and 
\begin_inset Formula $\tau_{2}$
\end_inset

 by 
\begin_inset Formula $(0.3/Z)^{0.6}$
\end_inset

.
 (Having these parameters vary is in conflict with the 
\begin_inset Quotes eld
\end_inset

LTI
\begin_inset Quotes erd
\end_inset

 assumption leading to the transfer function, but these variations are minor
 over short times so incorporating this variation should produce reasonable
 results.)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<adjustP, include=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

rhozero <- 1013.25 * 100 / (287.05 * 288.15)
\end_layout

\begin_layout Plain Layout

MRHO <- MachNumber(DZV$PSXC, DZV$QCXC) * DZV$PSXC * 100 / 
\end_layout

\begin_layout Plain Layout

        (287.05 * (273.15 + DZV$ATX)) / rhozero
\end_layout

\begin_layout Plain Layout

Param1$tau1 <- Param1$tau1 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ 0.6
\end_layout

\begin_layout Plain Layout

Param1$tau2 <- Param1$tau2 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ 0.6
\end_layout

\begin_layout Plain Layout

MRHO <- MachNumber(DS$PSXC, DS$QCXC) * DS$PSXC * 100 / 
\end_layout

\begin_layout Plain Layout

        (287.05 * (273.15 + DS$ATX)) / rhozero
\end_layout

\begin_layout Plain Layout

# ParamHS$tau1 <- ParamHS$tau1 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ 0.6
\end_layout

\begin_layout Plain Layout

# ParamHS$tau2 <- ParamHS$tau2 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ 0.6
\end_layout

\begin_layout Plain Layout

# ParamHSB$tau1 <- ParamHSB$tau1 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ 0.6
\end_layout

\begin_layout Plain Layout

# ParamHSB$tau2 <- ParamHSB$tau2 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ 0.6
\end_layout

\begin_layout Plain Layout

bestSH[2] <- bestSH[2] * (mean(MRHO, na.rm = TRUE) / 0.3) ^ 0.6
\end_layout

\begin_layout Plain Layout

bestSH[3] <- bestSH[3] * (mean(MRHO, na.rm = TRUE) / 0.3) ^ 0.6
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
sensor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\begin_inset Formula $a$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\begin_inset Formula $\tau_{1}$
\end_inset


\series default
 [s]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\begin_inset Formula $\tau_{2}$
\end_inset


\series default
 [s]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
unheated Rosemount 102E4ALon C-130
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(Param1$a, 2)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(Param1$tau1, 3)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(Param1$tau2,2)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
unheated Rosemount 102E4AL on GV
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{format(ParGV$a, digits=2, nsmall=2)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(ParGV$tau1, 3)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{format(ParGV$tau2, digits=2, nsmall=2)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
heated HARCO
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{format(bestSH[1], digits=1, nsmall=1)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{format(bestSH[2], digits=2, nsmall=2)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{format(bestSH[3], digits=2, nsmall=2)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Parameters for the time response of available temperature sensors on the
 NSF/NCAR aircraft, adjusted to 
\begin_inset Formula $Z=0.3$
\end_inset

.
 For other conditions, scale as represented for 
\begin_inset Formula $\tau_{1}^{\prime}$
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:tau1prime"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\begin_inset CommandInset label
LatexCommand label
name "tab:Parameters"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\lang english
heated Rosemount 102 on C-130		
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
\lang american

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{format(bestW[1], digits=2, nsmall=2)}
\end_layout

\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\lang english
	
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
\lang american

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{format(bestW[2], digits=2, nsmall=2)}
\end_layout

\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\lang english
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
\lang american

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{format(bestW[3], digits=2, nsmall=2)}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
heated Rosemount on C-130
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(ParamW$a, 2)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(ParamW$tau1, 2)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(ParamW$tau2, 2)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Response to a step change
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<VOCALSrf03, include=FALSE, echo=FALSE, fig.height=4, fig.cap='Temperature
 measured during descent through an inversion capping the marine boundary
 layer, from VOCALS flight 3, starting at 8:13:50 UTC.
 The descent rate was approximately 5 m/s.
 The dashed red line shows a dry-adiabatic lapse rate in the marine boundary
 layer, and the dashed blue line is a reference line indicating the location
 of the top of the boundary layer.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Data <-
\end_layout

\begin_layout Plain Layout

  getNetCDF(
\end_layout

\begin_layout Plain Layout

    file.path(DataDirectory(), 'VOCALS/VOCALSrf03h.nc'),
\end_layout

\begin_layout Plain Layout

    c(
\end_layout

\begin_layout Plain Layout

      'PALT',
\end_layout

\begin_layout Plain Layout

      'GGALT_NTL',
\end_layout

\begin_layout Plain Layout

      'ATX',
\end_layout

\begin_layout Plain Layout

      'ATRL',
\end_layout

\begin_layout Plain Layout

      'ATRR',
\end_layout

\begin_layout Plain Layout

      'ATWH',
\end_layout

\begin_layout Plain Layout

      'DPXC',
\end_layout

\begin_layout Plain Layout

      'PSXC',
\end_layout

\begin_layout Plain Layout

      'QCXC',
\end_layout

\begin_layout Plain Layout

      'TTRR'
\end_layout

\begin_layout Plain Layout

    )
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

Data %>% select(Time, PALT, ATRR) %>% 
\end_layout

\begin_layout Plain Layout

  selectTime(81350, 81358) %>%
\end_layout

\begin_layout Plain Layout

  select(ATRR) %>% 
\end_layout

\begin_layout Plain Layout

  plot(
\end_layout

\begin_layout Plain Layout

    type = 'b',
\end_layout

\begin_layout Plain Layout

    pch = 20,
\end_layout

\begin_layout Plain Layout

    ylab = bquote('ATRR [' * degree ~ 'C]'),
\end_layout

\begin_layout Plain Layout

    xlab = 'sample number',
\end_layout

\begin_layout Plain Layout

    col = 'blue'
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

x <- 0:250
\end_layout

\begin_layout Plain Layout

y <- 6.9 - x * 5 / 25 * 10 / 1000
\end_layout

\begin_layout Plain Layout

lines(x, y, col = 'red', lty = 2)
\end_layout

\begin_layout Plain Layout

abline(v = 10, col = 'black', lty = 2)
\end_layout

\begin_layout Plain Layout

## Get Z for scaling the time constants:
\end_layout

\begin_layout Plain Layout

rhozero <- 1013.25 * 100 / (287.05 * 288.15)
\end_layout

\begin_layout Plain Layout

Z <- MachNumber(Data$PSXC, Data$QCXC) * 100 * Data$PSXC /
\end_layout

\begin_layout Plain Layout

  (287.05 * (273.15 + Data$ATRR)) / rhozero
\end_layout

\begin_layout Plain Layout

ParamS <- ParamSF
\end_layout

\begin_layout Plain Layout

ParamS$tau1 <- ParamS$tau1 * (mean(Z, na.rm = TRUE) / 0.3) ^ 0.6
\end_layout

\begin_layout Plain Layout

ParamS$tau2 <- ParamS$tau2 * (mean(Z, na.rm = TRUE) / 0.3) ^ 0.6
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<tfit, include=TRUE, echo=FALSE, fig.pos='t', fig.scap = 'Temperature measured
 at 25 Hz during descent through an inversion capping the marine boundary
 layer', fig.cap='(blue dots): Temperature measured at 25 Hz during descent
 through an inversion capping the marine boundary layer, from VOCALS flight
 3, starting at 8:13:50 UTC.
 The descent rate was approximately 5 m/s.
 The dashed red line shows a dry-adiabatic lapse rate in the marine boundary
 layer, and the dashed black line is a reference line indicating the location
 of the top of the boundary layer.The  prediction using the parameters listed
 in the text is shown as the magenta line, mostly over the blue dots representin
g the measurements.
 The dashed brown line is the calculated temperature of the support that
 contacts the sensing wire.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Data %>% select(Time, PALT, ATRR) %>% 
\end_layout

\begin_layout Plain Layout

  selectTime(81350, 81358) %>% 
\end_layout

\begin_layout Plain Layout

  select(ATRR) %>% 
\end_layout

\begin_layout Plain Layout

  plot(
\end_layout

\begin_layout Plain Layout

    type = 'b',
\end_layout

\begin_layout Plain Layout

    pch = 20,
\end_layout

\begin_layout Plain Layout

    ylab = bquote('temperature [' * degree ~ 'C]'),
\end_layout

\begin_layout Plain Layout

    xlab = 'sample number @ 25 Hz',
\end_layout

\begin_layout Plain Layout

    col = 'blue'
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

x <- 0:200
\end_layout

\begin_layout Plain Layout

y <- 6.9 - x * 5 / 25 * 10 / 1000
\end_layout

\begin_layout Plain Layout

lines(x[11:200], y[11:200], col = 'red', lty = 2)
\end_layout

\begin_layout Plain Layout

lines(c(10, 10), c(y[11], 14.3), col = 'black', lty = 2)
\end_layout

\begin_layout Plain Layout

xx <- 0:2000
\end_layout

\begin_layout Plain Layout

yy <- 6.9 - xx * 5 / 250 * 10 / 1000
\end_layout

\begin_layout Plain Layout

yy[1:110] <- 14.30
\end_layout

\begin_layout Plain Layout

# calculate the response, given tau:
\end_layout

\begin_layout Plain Layout

tau <- 0.05
\end_layout

\begin_layout Plain Layout

taua <- 0.09
\end_layout

\begin_layout Plain Layout

tau2 <- 0.90
\end_layout

\begin_layout Plain Layout

tau2a <- 1.0
\end_layout

\begin_layout Plain Layout

a <- 0.62
\end_layout

\begin_layout Plain Layout

aa <- 0.65
\end_layout

\begin_layout Plain Layout

tau <- Param1$tau1
\end_layout

\begin_layout Plain Layout

# tau2 <- Param1$tau2
\end_layout

\begin_layout Plain Layout

tau2a <- 1.1
\end_layout

\begin_layout Plain Layout

taua <- 0.05
\end_layout

\begin_layout Plain Layout

a <- Param1$a
\end_layout

\begin_layout Plain Layout

a <- ParamS$a
\end_layout

\begin_layout Plain Layout

tau1 <- ParamS$tau1
\end_layout

\begin_layout Plain Layout

tau2 <- ParamS$tau2
\end_layout

\begin_layout Plain Layout

tau1a <- 0.06
\end_layout

\begin_layout Plain Layout

tau2a <- 1.3
\end_layout

\begin_layout Plain Layout

aa <- a - 0.02
\end_layout

\begin_layout Plain Layout

ym <- yy
\end_layout

\begin_layout Plain Layout

ymf <- ym
\end_layout

\begin_layout Plain Layout

yr <- yy
\end_layout

\begin_layout Plain Layout

yra <- yy
\end_layout

\begin_layout Plain Layout

for (i in 2:2000) {
\end_layout

\begin_layout Plain Layout

  yr[i] <- yr[i - 1] + (yy[i] - yr[i - 1]) * 0.004 / tau2
\end_layout

\begin_layout Plain Layout

  yra[i] <- yra[i - 1] + (yy[i] - yra[i - 1]) * 0.004 / tau2a
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

for (i in 2:2000) {
\end_layout

\begin_layout Plain Layout

  ym[i] <-
\end_layout

\begin_layout Plain Layout

    ym[i - 1] + (a * yy[i] + (1 - a) * yr[i] - ym[i - 1]) * 0.004 / tau1
\end_layout

\begin_layout Plain Layout

  ymf[i] <-
\end_layout

\begin_layout Plain Layout

    ymf[i - 1] + (aa * yy[i] + (1 - aa) * yra[i] - ymf[i - 1]) * 0.004 /
 tau1a
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

lines(xx / 10, ym, col = 'magenta', lwd = 2, lty=1)
\end_layout

\begin_layout Plain Layout

# lines(xx / 10, ymf, col = 'darkorange', lwd = 2)
\end_layout

\begin_layout Plain Layout

lines(xx / 10,
\end_layout

\begin_layout Plain Layout

      yr,
\end_layout

\begin_layout Plain Layout

      col = 'brown',
\end_layout

\begin_layout Plain Layout

      lwd = 2,
\end_layout

\begin_layout Plain Layout

      lty = 2)
\end_layout

\begin_layout Plain Layout

legend('topright', legend=c('measured','predicted', 'support'),
\end_layout

\begin_layout Plain Layout

       lwd=c(2, 2, 2), lty=c(1, 1, 2),
\end_layout

\begin_layout Plain Layout

       col=c('blue', 'magenta', 'brown'),
\end_layout

\begin_layout Plain Layout

       pch = c(19, NA, NA))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Previous studies have mostly used sharp temperature changes in the atmosphere,
 for example from climbs through the inversion at the top of a boundary
 layer, to study the time response.
 A search of representative VOCALS climbs and descents through inversions
 capping the marine boundary layer found that almost all have measurable
 structure and are not discrete transitions, but there was one near-ideal
 example.
 Figure 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:tfit}
\end_layout

\end_inset

 shows the time history of the measured temperature for 8
\begin_inset space ~
\end_inset

s from VOCALS flight 3, starting at 8:13:50 UTC, when the aircraft descended
 through the top of the marine boundary layer at approximately 1000
\begin_inset space ~
\end_inset

ft/min (around 5
\begin_inset space ~
\end_inset

m/s).
 The temperature structure in this case was remarkably consistent with a
 near-constant temperature above the inversion and a near-adiabatic temperature
 structure below the inversion.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<VOCALSrf03, include=TRUE, echo=FALSE, fig.height=4, fig.cap='Temperature
 measured during descent through an inversion capping the marine boundary
 layer, from VOCALS flight 3, starting at 8:13:50 UTC.
 The descent rate was approximately 5 m/s.
 The dashed red line shows a dry-adiabatic lapse rate in the marine boundary
 layer, and the dashed blue line is a reference line indicating the location
 of the top of the boundary layer.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Data <- getNetCDF(file.path(DataDirectory(), 'VOCALS/VOCALSrf03h.nc'), c('PALT',
 'GGALT_NTL', 'ATX', 'ATRL', 'ATRR', 'ATWH', 'DPXC', 'PSXC', 'QCXC', 'TTRR'))
\end_layout

\begin_layout Plain Layout

# Data %>% select(Time, PALT, ATX) %>% selectTime(81349, 81351) %>% select(Time,
 ATX) %>% plot()
\end_layout

\begin_layout Plain Layout

# Data %>% select(Time, PALT, ATX) %>% selectTime(81349, 81351) %>% select(Time,
 ATX) %>% plot(type='b', pch=20)
\end_layout

\begin_layout Plain Layout

# Data %>% select(Time, PALT, ATX) %>% selectTime(81350, 81351) %>% select(Time,
 ATX) %>% plot(type='b', pch=20)
\end_layout

\begin_layout Plain Layout

# Data %>% select(Time, PALT, ATRR) %>% selectTime(81350, 81351) %>% select(Time
, ATRR) %>% plot(type='b', pch=20) 
\end_layout

\begin_layout Plain Layout

Data %>% select(Time, PALT, ATRR) %>% selectTime(81350, 81358) %>% select(ATRR)
 %>% plot(type='b', pch=20, ylab='ATRR', xlab='sample number', col='blue')
\end_layout

\begin_layout Plain Layout

x <- 0:250
\end_layout

\begin_layout Plain Layout

y <- 6.9-x*5/25*10/1000 
\end_layout

\begin_layout Plain Layout

lines(x, y, col='red', lty=2) 
\end_layout

\begin_layout Plain Layout

abline(v=10, col='black', lty=2) 
\end_layout

\begin_layout Plain Layout

## Get Z for scaling the time constants: 
\end_layout

\begin_layout Plain Layout

rhozero <- 1013.25*100/(287.05*288.15) 
\end_layout

\begin_layout Plain Layout

Z <- MachNumber(Data$PSXC, Data$QCXC) * 100 * Data$PSXC / 
\end_layout

\begin_layout Plain Layout

     (287.05 * (273.15 + Data$ATRR)) / rhozero 
\end_layout

\begin_layout Plain Layout

ParamS <- Param1 
\end_layout

\begin_layout Plain Layout

ParamS$tau1 <- ParamS$tau1 * (mean(Z, na.rm=TRUE) / 0.3)^0.6 
\end_layout

\begin_layout Plain Layout

ParamS$tau2 <- ParamS$tau2 * (mean(Z, na.rm=TRUE) / 0.3)^0.6
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<<tfit, include=TRUE, echo=FALSE, fig.height=4, fig.cap='The 25 Hz measurements
 from the previous figure (blue dots) and the predictions using the parameters
 listed in the text (green line).
 The dashed brown line is the calculated temperature of the support that
 contacts the sensing wire.
 Also shown as the orange line is the result if the parameters are changed
 to $a=0.713$, $
\backslash

\backslash
tau_1$=0.06 s and $
\backslash

\backslash
tau_2$=1.3 s.'>>=
\end_layout

\begin_layout Plain Layout

Data %>% select(Time, PALT, ATRR) %>% selectTime(81350, 81358) %>% select(ATRR)
 %>% plot(type='b', pch=20, ylab='ATRR', xlab='sample number', col='blue')
 x <- 0:200 y <- 6.9-x*5/25*10/1000 lines(x[11:200], y[11:200], col='red',
 lty=2) lines(c(10,10), c(y[11], 14.3), col='black', lty=2) xx <- 0:2000
 yy <- 6.9 - xx * 5 / 250 * 10 / 1000 yy[1:110] <- 14.30 # calculate the response,
 given tau: tau <- 0.05 taua <- 0.09 tau2 <- 0.90 tau2a <- 1.0 a <- 0.62 aa <-
 0.65 tau <- Param1$tau1 # tau2 <- Param1$tau2 tau2a <- 1.1 taua <- 0.05 a
 <- Param1$a a <- ParamS$a tau1 <- ParamS$tau1 tau2 <- ParamS$tau2 tau1a
 <- 0.06 tau2a <- 1.3 aa <- a - 0.02 ym <- yy ymf <- ym yr <- yy yra <- yy
 for (i in 2:2000) {   yr[i] <- yr[i-1] + (yy[i] - yr[i-1]) * 0.004 / tau2
   yra[i] <- yra[i-1] + (yy[i] - yra[i-1]) * 0.004 / tau2a } for (i in 2:2000)
 {   ym[i] <- ym[i-1] + (a * yy[i] + (1-a) * yr[i] - ym[i-1]) * 0.004 / tau1
    ymf[i] <- ymf[i-1] + (aa * yy[i] + (1-aa) * yra[i] - ymf[i-1]) * 0.004
 / tau1a  } lines(xx/10, ym, col='forestgreen', lwd=2) lines(xx/10, ymf,
 col='darkorange', lwd=2) lines(xx/10, yr, col='brown', lwd=2, lty=2)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

The suggested measurand history, if the discontinuity at the inversion is
 discrete, is that shown by the dashed black and dashed red lines, x(t)=
\backslash
{14.3, 6.878, 6.876, 6.874, 6.872, 6.870, 6.868, 6.866, 6.864, 6.862, 6.860, ...
\backslash
} for t=
\backslash
{10, 11, 12, ...
\backslash
}.
 The predicted time response from 
\backslash
eqref{eq:Tm} for assumed time constants as given in Table 1 for the unheated
 Rosemount 102E4AL sensor adjusted for air density and flight speed ($a=0.733$,
 $
\backslash
tau_{1}=0.030$~s and $
\backslash
tau_{2}=0.43$~s) is shown as the green line in Fig.~
\backslash
ref{fig:tfit}.
 The predicted response is significantly faster than that of the observations,
 and the fit to observations can be improved by adjusting the time constants
 as listed in the figure caption.
 The adjusted values needed to match the observations are so far outside
 estimated uncertainty limits for the parameters that it seems likely that
 the actual temperature at the top of the boundary layer is not as sharply
 discontinuous as assumed but is smoothed by some mixing.
 The rapid initial change does supports a small value of $
\backslash
tau_{1}$, and the results may suggest a longer time constant for the support
 structure, but this evidence is weak in comparison to that arising from
 the phase and amplitude ratio obtained for dynamic heating.
 
\end_layout

\begin_layout Plain Layout


\backslash
subsection{Application to a speed run}
\end_layout

\begin_layout Plain Layout

Because the assumed response of the support is characterized by a simple
 time constant, during the speed run the support will lag in temperature
 by $
\backslash
tau_{2}$.
 Then, from 
\backslash
eqref{eq:Tm}, $T_{m}(t)$ will lag by $
\backslash
tau_{1}$ behind the temperature to which the sensor responds, which is $aT(t)+(1
-a)T(t-
\backslash
tau_{2})$.
 For a ramp input such that $T(t)=T_{0}+kt$, the solution to 
\backslash
eqref{eq:Tm} is that the measured temperature $T_{m}(t)$ lags $T(t)$ by
 $
\backslash
psi$, so that $T_{m}(t)=T_{0}+k(t-
\backslash
psi)$.
 Then
\backslash

\backslash
 
\backslash
[ k
\backslash
tau_{1}=a(T_{0}+kt)+(1-a)(T_{0}+k(t-
\backslash
tau_{2})-T_{0}-kt+k
\backslash
psi 
\backslash
]
\end_layout

\begin_layout Plain Layout

which requires the recovery-temperature lag to be
\backslash

\backslash
 
\backslash
begin{equation} 
\backslash
psi=
\backslash
tau_{1}+(1-a)
\backslash
tau_{2}
\backslash
label{eq:delta} 
\backslash
end{equation}
\end_layout

\begin_layout Plain Layout

<<SRDW, include=TRUE, fig.height=4.2, fig.cap='History of the airspeed during
 a segment of flight 15 from the DEEPWAVE project.'>>=
\end_layout

\begin_layout Plain Layout

Project <- 'DEEPWAVE' Flight <- 'rf15h' startTime <- 32300 endTime <- 32815
 fname <- file.path(DataDirectory(), Project, '/', Project,   Flight,'.nc',
 fsep='') FI <- DataFileInfo(fname, LLrange=FALSE) iv <- which(grepl('^RT',
 FI$Variables)) ProjDir <- Project VL <- c('TASX', 'EWX', 'PSXC', 'RTX',
 'RTH1', 'RTH2', 'RTF1', 'ATX',   'GGALT', 'PITCH', 'ADIFR', 'QCF', 'AKRD',
 'WIC', 'QCXC') VL <- c(VL, FI$Variables[iv]) VL <- unique(VL) DSR <- getNetCDF
 (sprintf ('%s%s/%s%s.nc', DataDirectory (),   ProjDir, Project, Flight),
 VL,    Start=startTime, End=endTime) DSR %>% select(Time, TASX) %>% selectTime(
32310, 32700) %>% plotWAC() ## Find the average Z: (but there is significant
 Mach number variation...) Z <- MachNumber(DSR$PSXC, DSR$QCXC) * 100 * DSR$PSXC
 / (287.05 * (273.15 + DSR$ATX)) / rhozero ParamS <- Param1 ParamS$tau1 <-
 ParamS$tau1 * (mean(Z, na.rm=TRUE) / 0.3)^0.6 ParamS$tau2 <- ParamS$tau2 *
 (mean(Z, na.rm=TRUE) / 0.3)^0.6 ParamWZ <- ParamW ParamHZ <- ParamHS ParamWZ$tau1
 <- ParamW$tau1 * (mean(Z, na.rm=TRUE) / 0.3)^0.6 ParamHZ$tau1 <- ParamHZ$tau1
 * (mean(Z, na.rm=TRUE) / 0.3)^0.6 ParamWZ$tau2 <- ParamW$tau2 * (mean(Z, na.rm=TRUE
) / 0.3)^0.6 ParamHZ$tau2 <- ParamHZ$tau2 * (mean(Z, na.rm=TRUE) / 0.3)^0.6
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

For the Rosemount 102E4AL, the fitted values from the previous subsection
 would then cause a lag
\end_layout

\begin_layout Plain Layout

y <- 6.9-x*5/25*10/1000
\end_layout

\begin_layout Plain Layout

lines(x, y, col='red', lty=2)
\end_layout

\begin_layout Plain Layout

abline(v=10, col='black', lty=2)
\end_layout

\begin_layout Plain Layout

## Get Z for scaling the time constants:
\end_layout

\begin_layout Plain Layout

rhozero <- 1013.25*100/(287.05*288.15)
\end_layout

\begin_layout Plain Layout

Z <- MachNumber(Data$PSXC, Data$QCXC) * 100 * Data$PSXC / (287.05 * (273.15
 + Data$ATRR)) / rhozero
\end_layout

\begin_layout Plain Layout

ParamS <- Param1
\end_layout

\begin_layout Plain Layout

ParamS$tau1 <- ParamS$tau1 * (mean(Z, na.rm=TRUE) / 0.3)^0.6
\end_layout

\begin_layout Plain Layout

ParamS$tau2 <- ParamS$tau2 * (mean(Z, na.rm=TRUE) / 0.3)^0.6
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Also shown as the orange line is the result if the parameters are changed
 to $a=0.713$, $
\backslash

\backslash
tau_1$=0.06 s and $
\backslash

\backslash
tau_2$=1.3 s.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The suggested measurand history, if the discontinuity at the inversion is
 discrete, is that shown by the dashed black and dashed red lines.
\begin_inset Note Note
status open

\begin_layout Plain Layout
, x(t)={14.3, 6.878, 6.876, 6.874, 6.872, 6.870, 6.868, 6.866, 6.864, 6.862, 6.860,
 ...} for t={10, 11, 12, ...}
\end_layout

\end_inset

.
 The predicted time response from 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for assumed time constants for the unheated Rosemount 102E4AL sensor adjusted
 for air density and flight speed is shown as the magenta line in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:tfit}
\end_layout

\end_inset

.
 The predicted response is consistent with the observations and supports
 the approximate validity of the parameters determined from fits to the
 response to dynamic heating.
\begin_inset Branch expanded
inverted 0
status open

\begin_layout Subsection
Application to a 
\begin_inset Quotes eld
\end_inset

speed run
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Another situation where a temperature lag can be observed is when the airspeed
 changes during level flight and causes a change in dynamic heating.
 An example is shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:SRDW}
\end_layout

\end_inset

, where the airspeed was increased steadily in level flight from near the
 lower limit of the flight envelope to near the upper limit and then was
 decreased back to the starting value.
 A plot of recovery temperature should also increase and decrease as the
 dynamic heating changes, but with a lag caused by the sensor response.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The assumed model provided by 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 leads to a prediction of the time lag.
 Because the assumed response of the support is characterized by a simple
 time constant, during the speed run the support will lag in temperature
 by 
\begin_inset Formula $\tau_{2}$
\end_inset

.
 Then, from 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

, 
\begin_inset Formula $T_{m}(t)$
\end_inset

 will lag by 
\begin_inset Formula $\tau_{1}$
\end_inset

 behind the temperature to which the sensor responds, which is 
\begin_inset Formula $aT(t)+(1-a)T(t-\tau_{2})$
\end_inset

.
 For a ramp input such that 
\begin_inset Formula $T(t)=T_{0}+kt$
\end_inset

, the solution to 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is that the measured temperature 
\begin_inset Formula $T_{m}(t)$
\end_inset

 lags 
\begin_inset Formula $T(t)$
\end_inset

 by 
\begin_inset Formula $\psi$
\end_inset

, so that 
\begin_inset Formula $T_{m}(t)=T_{0}+k(t-\psi)$
\end_inset

.
 Then
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
k\tau_{1}=a(T_{0}+kt)+(1-a)(T_{0}+k(t-\tau_{2})-T_{0}-kt+k\psi
\]

\end_inset


\end_layout

\begin_layout Plain Layout
which requires the recovery-temperature lag to be
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\psi=\tau_{1}+(1-a)\tau_{2}\label{eq:delta}
\end{equation}

\end_inset


\end_layout

\end_inset

 This lag will produce hysteresis in the measured temperature during the
 speed run.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<SRDW, include=TRUE, fig.pos='t', fig.height=3.2, fig.cap='History of the airspeed
 during a  
\begin_inset Quotes eld
\end_inset

speed-run
\begin_inset Quotes erd
\end_inset

 maneuver where the airspeed varied during level flight over the available
 speed range of the aircraft.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Project <- 'DEEPWAVE'
\end_layout

\begin_layout Plain Layout

Flight <- 'rf15h'
\end_layout

\begin_layout Plain Layout

startTime <- 32300
\end_layout

\begin_layout Plain Layout

endTime <- 32815
\end_layout

\begin_layout Plain Layout

fname <- file.path(DataDirectory(), Project, '/', Project,
\end_layout

\begin_layout Plain Layout

                   Flight, '.nc', fsep = '')
\end_layout

\begin_layout Plain Layout

FI <- DataFileInfo(fname, LLrange = FALSE)
\end_layout

\begin_layout Plain Layout

iv <- which(grepl(
\begin_inset Quotes eld
\end_inset

^RT
\begin_inset Quotes erd
\end_inset

, FI$Variables))
\end_layout

\begin_layout Plain Layout

ProjDir <- Project
\end_layout

\begin_layout Plain Layout

VL <- c(
\end_layout

\begin_layout Plain Layout

  'TASX',
\end_layout

\begin_layout Plain Layout

  'EWX',
\end_layout

\begin_layout Plain Layout

  'PSXC',
\end_layout

\begin_layout Plain Layout

  'RTX',
\end_layout

\begin_layout Plain Layout

  'RTH1',
\end_layout

\begin_layout Plain Layout

  'RTH2',
\end_layout

\begin_layout Plain Layout

  'RTF1',
\end_layout

\begin_layout Plain Layout

  'ATX',
\end_layout

\begin_layout Plain Layout

  'GGALT',
\end_layout

\begin_layout Plain Layout

  'PITCH',
\end_layout

\begin_layout Plain Layout

  'ADIFR',
\end_layout

\begin_layout Plain Layout

  'QCF',
\end_layout

\begin_layout Plain Layout

  'AKRD',
\end_layout

\begin_layout Plain Layout

  'WIC',
\end_layout

\begin_layout Plain Layout

  'QCXC'
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

VL <- c(VL, FI$Variables[iv])
\end_layout

\begin_layout Plain Layout

VL <- unique(VL)
\end_layout

\begin_layout Plain Layout

DSR <- getNetCDF (
\end_layout

\begin_layout Plain Layout

  sprintf ('%s%s/%s%s.nc', DataDirectory (),
\end_layout

\begin_layout Plain Layout

           ProjDir, Project, Flight),
\end_layout

\begin_layout Plain Layout

  VL,
\end_layout

\begin_layout Plain Layout

  Start = startTime,
\end_layout

\begin_layout Plain Layout

  End = endTime
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

DSR %>% select(Time, TASX) %>% 
\end_layout

\begin_layout Plain Layout

  selectTime(32310, 32700) %>% 
\end_layout

\begin_layout Plain Layout

  plotWAC()
\end_layout

\begin_layout Plain Layout

## Find the average Z: (but there is significant Mach number variation...)
\end_layout

\begin_layout Plain Layout

Z <- MachNumber(DSR$PSXC, DSR$QCXC) * 100 * DSR$PSXC / 
\end_layout

\begin_layout Plain Layout

     (287.05 * (273.15 + DSR$ATX)) / rhozero
\end_layout

\begin_layout Plain Layout

ParamS <- Param1
\end_layout

\begin_layout Plain Layout

ParamS$tau1 <- ParamS$tau1 * (mean(Z, na.rm = TRUE) / 0.3) ^ -0.6
\end_layout

\begin_layout Plain Layout

ParamS$tau2 <- ParamS$tau2 * (mean(Z, na.rm = TRUE) / 0.3) ^ -0.6
\end_layout

\begin_layout Plain Layout

ParamHZ <- Param1
\end_layout

\begin_layout Plain Layout

ParamHZ$tau1 <- ParamHZ$tau1 * (mean(Z, na.rm = TRUE) / 0.3) ^ -0.6
\end_layout

\begin_layout Plain Layout

ParamHZ$tau2 <- ParamHZ$tau2 * (mean(Z, na.rm = TRUE) / 0.3) ^ -0.6
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Extra
inverted 0
status open

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<XTR>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

ParamWZ <- ParamW
\end_layout

\begin_layout Plain Layout

ParamWZ$tau1 <- ParamW$tau1 * (mean(Z, na.rm = TRUE) / 0.3) ^ -0.6
\end_layout

\begin_layout Plain Layout

ParamWZ$tau2 <- ParamW$tau2 * (mean(Z, na.rm = TRUE) / 0.3) ^ -0.6
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
For the Rosemount 102E4AL, the fitted values from Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-unheated-Rosemount"
plural "false"
caps "false"
noprefix "false"

\end_inset

 would then cause a lag of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(Param1$tau1+(1-Param1$a)*Param1$tau2, 2)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

s, which is hard to detect.
\begin_inset Branch Extra
inverted 0
status open

\begin_layout Standard
For the heated Rosemount the expected lag is about 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestW[2]+(1-bestW[1])*bestW[3], 2)}
\end_layout

\end_inset

.
\end_layout

\end_inset

For the heated HARCO sensor the predicted lag would be 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestSH[2]+(1-bestSH[1])*bestSH[3], 2)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

s, which is easily observed.
\end_layout

\end_inset

Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:SRRTH1delay}
\end_layout

\end_inset

a shows this hysteresis, which appears as the difference between the segment
 with increasing speed and that with decreasing speed.
\begin_inset Note Note
status open

\begin_layout Plain Layout
The delay can be estimated by shifting the measurements later in time and
 repeating the fit to search for the smallest standard deviation about the
 fitted line.
 The smallest standard deviation occurs for a shift of 2.225
\begin_inset space ~
\end_inset

s, larger than the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(ParamHZ$tau1+(1-ParamHZ$a)*ParamHZ$tau2, 2)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

s expected from the phase-lag analysis.
\end_layout

\end_inset

 A correction based on simply shifting the measurements in time works reasonably
 but doesn't take into account that the Mach number and hence the time parameter
s vary significantly during the speed run.
 A better test of the time-response parameters is to apply the first correction
 scheme outlined in Appendix
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-resulting-transfer"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to the measurements, with varying response parameters dependent on the
 Mach number.
 The specific correction equation used is 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:HARCOsoln"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:srRTH1delay}
\end_layout

\end_inset

b shows that the delay is mostly removed by this procedure.
 The residual standard deviation about the regression fit for recovery temperatu
re as a function of 
\begin_inset Formula $V^{2}/(2C_{p})$
\end_inset

 is reduced from 
\begin_inset Formula $0.26^{\circ}$
\end_inset

C before correction to 
\begin_inset Formula $0.10^{\circ}$
\end_inset

C after correction.
 The minimum standard deviation results from increasing the time constants
 an additional 10%, so measurements from this speed-run maneuver are consistent
 with the predicted time response as found in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Heated-sensors"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to within about this uncertainty.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<SRnodelay, include=FALSE, fig.cap='The recovery temperature measured by
 a heated HARCO sensor during the speed-run maneuver shown in the previous
 figure.
 The abscissa is the dynamic-heating term without the recovery factor, where
 $V$ is the airspeed and $Cp$ is the specific heat at constant pressure.
 The measurements while the airspeed was increasing are shown by the green
 line and those for decreasing airspeed by the red line.
 The dashed orange line indicates the regression fit, with standard deviation
 about the fit of 0.26$^{
\backslash

\backslash
circ}$C.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Cp <- SpecificHeats (DSR$EWX / DSR$PSXC)[, 1]
\end_layout

\begin_layout Plain Layout

DSR$X <- DSR$TASX ^ 2 / (2 * Cp)
\end_layout

\begin_layout Plain Layout

Rate <- 1
\end_layout

\begin_layout Plain Layout

if (grepl('h', Flight)) {
\end_layout

\begin_layout Plain Layout

  Rate <- 25
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

DSR$RT <- DSR$RTH1
\end_layout

\begin_layout Plain Layout

DSS <- DSR
\end_layout

\begin_layout Plain Layout

DSR <- DSR %>% selectTime(32310, 32700)
\end_layout

\begin_layout Plain Layout

DSR <- transferAttributes(DSS, DSR)
\end_layout

\begin_layout Plain Layout

cf <- coef(fm <- lm (RT ~ X, data = DSR))
\end_layout

\begin_layout Plain Layout

rms <- summary(fm)$sigma
\end_layout

\begin_layout Plain Layout

RTSEL <- 'RTH1'
\end_layout

\begin_layout Plain Layout

xp <- c(min(DSR$X, na.rm = TRUE), max(DSR$X, na.rm = TRUE))
\end_layout

\begin_layout Plain Layout

yp <- cf[1] + cf[2] * xp
\end_layout

\begin_layout Plain Layout

d <- data.frame(xp = xp, yp = yp)
\end_layout

\begin_layout Plain Layout

Xlab <- expression(paste(V ^ 2, '/(2', C[p], ')', sep = ''))
\end_layout

\begin_layout Plain Layout

dX <- c(0, diff(DSR$X))
\end_layout

\begin_layout Plain Layout

dXS <- SmoothInterp(dX)
\end_layout

\begin_layout Plain Layout

DSR$RT2 <- DSR$RT
\end_layout

\begin_layout Plain Layout

DSR$RT1 <- DSR$RT
\end_layout

\begin_layout Plain Layout

DSR$RT2[dXS <= 0] <- NA  # Don't plot decreasing-speed as green
\end_layout

\begin_layout Plain Layout

DSR$RT1[dXS >= 0] <- NA
\end_layout

\begin_layout Plain Layout

delay <- 0
\end_layout

\begin_layout Plain Layout

g <- ggplot (data = DSR, aes(x = X, y = RT))
\end_layout

\begin_layout Plain Layout

if (Rate == 1) {
\end_layout

\begin_layout Plain Layout

  g <- g + geom_point(colour = 'blue')
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(aes(y = RT1, colour = 'decreasing'),
\end_layout

\begin_layout Plain Layout

                   na.rm = TRUE,
\end_layout

\begin_layout Plain Layout

                   lwd = 1.1)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(aes(y = RT2, colour = 'increasing'),
\end_layout

\begin_layout Plain Layout

                   lwd = 1.1,
\end_layout

\begin_layout Plain Layout

                   na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(
\end_layout

\begin_layout Plain Layout

  data = d,
\end_layout

\begin_layout Plain Layout

  aes(x = xp, y = yp),
\end_layout

\begin_layout Plain Layout

  colour = 'darkorange',
\end_layout

\begin_layout Plain Layout

  lwd = 1.5,
\end_layout

\begin_layout Plain Layout

  lty = 2
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

# g <-
\end_layout

\begin_layout Plain Layout

#  g + ggtitle(sprintf(
\end_layout

\begin_layout Plain Layout

#    'sensor is %s; fit coefficients %.1f %.2f rms %.3f; no delay',
\end_layout

\begin_layout Plain Layout

#    RTSEL,
\end_layout

\begin_layout Plain Layout

#    cf[1],
\end_layout

\begin_layout Plain Layout

#    cf[2],
\end_layout

\begin_layout Plain Layout

#    rms
\end_layout

\begin_layout Plain Layout

#  ))
\end_layout

\begin_layout Plain Layout

g <- g + scale_colour_manual (
\end_layout

\begin_layout Plain Layout

  name = 'airspeed: ',
\end_layout

\begin_layout Plain Layout

  values = c("increasing" = "forestgreen", "decreasing" = "blue")
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

# print (sprintf('RTX is %s; fit coefficients %.3f %.3f rms %.2f; delay %d
 ms',
\end_layout

\begin_layout Plain Layout

#   RTSEL, cf[1], cf[2], rms, input$sliderSR))
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  g + ylab(expression(paste('Recovery Temperature [', degree, 'C]'))) +
 
\end_layout

\begin_layout Plain Layout

  xlab(Xlab) + 
\end_layout

\begin_layout Plain Layout

  theme_WAC(1)
\end_layout

\begin_layout Plain Layout

g1 <- g + theme(plot.title = element_text(size = 12))
\end_layout

\begin_layout Plain Layout

DXX <- DSR  ## save for the next chunk
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<srRTH1delay, include=TRUE, fig.height=3.3, fig.width=6.5, fig.cap='The recovery
 temperature as measured by a heated HARCO sensor during the speed-run maneuver
 shown in the previous figure (a) and the same measurement after correction
 (b).
 The abscissa is the dynamic-heating term without the recovery factor, where
 $V$ is the airspeed and $Cp$ is the specific heat at constant pressure.
 The measurements while the airspeed was increasing are shown by the green
 lines and those for decreasing airspeed by the blue lines.
 The dashed orange lines indicate the regression fits, with standard deviation
 about the fit of 0.26$^{
\backslash

\backslash
circ}$C (uncorrected) and 0.10$^{
\backslash

\backslash
circ}$C (after correction).'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

delay <- -2200
\end_layout

\begin_layout Plain Layout

DSR <- DSS
\end_layout

\begin_layout Plain Layout

MRHO <- MachNumber(DSR$PSXC, DSR$QCXC) * DSR$PSXC * 100 / 
\end_layout

\begin_layout Plain Layout

        (287.05 * (273.15 + DSR$ATX)) / rhozero
\end_layout

\begin_layout Plain Layout

a <- bestSH[1]
\end_layout

\begin_layout Plain Layout

tau1 <- bestSH[2] * (0.3 / MRHO) ^ 0.6  ## Note that these are variable
\end_layout

\begin_layout Plain Layout

tau2 <- bestSH[3] * (0.3 / MRHO) ^ 0.6
\end_layout

\begin_layout Plain Layout

## RT is the working solution
\end_layout

\begin_layout Plain Layout

Rate <- attr (DSR, 'Rate')
\end_layout

\begin_layout Plain Layout

DSR$DTMDT <- c(0, diff(DSR$RTH1, 2), 0) * Rate / 2
\end_layout

\begin_layout Plain Layout

DSR$DTM2DT2 <- (c(diff(DSR$RTH1), 0) - c(0, diff(DSR$RTH1))) * Rate^2
\end_layout

\begin_layout Plain Layout

DSR$RT <- (tau1 + tau2) * DSR$DTMDT + DSR$RTH1 + tau1 * tau2 * DSR$DTM2DT2
\end_layout

\begin_layout Plain Layout

# DSR$RT <- ShiftInTime(DSR[, RTSEL], .rate=Rate, .shift = delay)
\end_layout

\begin_layout Plain Layout

DSR <- DSR %>% selectTime(32310, 32700)
\end_layout

\begin_layout Plain Layout

DSR <- transferAttributes(DSS, DSR)
\end_layout

\begin_layout Plain Layout

N <- 2^13  ## encompasses the speed run
\end_layout

\begin_layout Plain Layout

Nby2 <- N / 2
\end_layout

\begin_layout Plain Layout

N1 <- (N - nrow(DSR)) %/% 2
\end_layout

\begin_layout Plain Layout

N2 <- N - nrow(DSR) - N1
\end_layout

\begin_layout Plain Layout

RTH1 <- c(rep(DSR$RTH1[1], N1), DSR$RTH1, rep(DSR$RTH1[nrow(DSR)], N2))
\end_layout

\begin_layout Plain Layout

ff1 <- fft(RTH1)
\end_layout

\begin_layout Plain Layout

RTH <- Re(fft(ff1, inverse=TRUE)) / N
\end_layout

\begin_layout Plain Layout

df <- Rate / N
\end_layout

\begin_layout Plain Layout

frq <- c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
\end_layout

\begin_layout Plain Layout

fr <- log(frq[1:(Nby2+1)])
\end_layout

\begin_layout Plain Layout

## Get the transfer function from the fitted parameterized form:
\end_layout

\begin_layout Plain Layout

Ph <- cfHARCO[1] + cfHARCO[2] * fr + 
\end_layout

\begin_layout Plain Layout

           cfHARCO[3] * fr^2 + cfHARCO[4] * atan(frq[1:(Nby2+1)])
\end_layout

\begin_layout Plain Layout

Ph[1] <- 0
\end_layout

\begin_layout Plain Layout

G <- cfrHARCO[1] + fr * (cfrHARCO[2] + fr * fr * (cfrHARCO[3] + 
\end_layout

\begin_layout Plain Layout

           fr * (cfrHARCO[4] + fr * cfrHARCO[5])))
\end_layout

\begin_layout Plain Layout

G[frq[1:length(fr)] < 0.024] <- 1
\end_layout

\begin_layout Plain Layout

G[frq[1:length(fr)] > 2] <- G[which.min(abs(frq-2))]
\end_layout

\begin_layout Plain Layout

H <- rep(complex(modulus=0), N)
\end_layout

\begin_layout Plain Layout

H[1:(Nby2+1)] <- complex(modulus=G, argument=Ph * pi / 180)
\end_layout

\begin_layout Plain Layout

H[(Nby2+2):N] <- rev(Conj(H[2:Nby2]))
\end_layout

\begin_layout Plain Layout

RTC <- Re(fft(ff1 / H, inverse = TRUE)) / N
\end_layout

\begin_layout Plain Layout

DSR$RTC <- RTC[(N1+1):(N-N2)]
\end_layout

\begin_layout Plain Layout

cf <- coef(fm <- lm (RT ~ X, data = DSR))
\end_layout

\begin_layout Plain Layout

xp <- c(min(DSR$X, na.rm = TRUE), max(DSR$X, na.rm = TRUE))
\end_layout

\begin_layout Plain Layout

yp <- cf[1] + cf[2] * xp
\end_layout

\begin_layout Plain Layout

d <- data.frame(xp = xp, yp = yp)
\end_layout

\begin_layout Plain Layout

rms <- summary(fm)$sigma
\end_layout

\begin_layout Plain Layout

DSR$RT2C <- DSR$RT
\end_layout

\begin_layout Plain Layout

DSR$RT1C <- DSR$RT
\end_layout

\begin_layout Plain Layout

DSR$RT2C[dXS <= 0] <- NA  # Don't plot decreasing-speed as green
\end_layout

\begin_layout Plain Layout

DSR$RT1C[dXS >= 0] <- NA
\end_layout

\begin_layout Plain Layout

# DXX$RT1C <- DSR$RT1C
\end_layout

\begin_layout Plain Layout

# DXX$RT2C <- DSR$RT2C
\end_layout

\begin_layout Plain Layout

# DXX$Time <- DXX$X
\end_layout

\begin_layout Plain Layout

# g <- DXX %>% select(Time, RT1, RT2, RT1C, RT2C) %>%
\end_layout

\begin_layout Plain Layout

#              ggplotWAC(panels=2, labelP=c)'      uncorrected', 
\end_layout

\begin_layout Plain Layout

#              '      corrected'), labelL=c('decreasing', 'increasing'))
 + 
\end_layout

\begin_layout Plain Layout

#        xlab(Xlab) 
\end_layout

\begin_layout Plain Layout

g <- ggplot (data = DSR, aes(x = X, y = RT))
\end_layout

\begin_layout Plain Layout

if (Rate == 1) {
\end_layout

\begin_layout Plain Layout

  g <- g + geom_point(colour = 'blue')
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(aes(y = RT1C, colour = 'decreasing'),
\end_layout

\begin_layout Plain Layout

                   na.rm = TRUE,
\end_layout

\begin_layout Plain Layout

                   lwd = 1.2)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(aes(y = RT2C, colour = 'increasing'),
\end_layout

\begin_layout Plain Layout

                   lwd = 1.2,
\end_layout

\begin_layout Plain Layout

                   na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(
\end_layout

\begin_layout Plain Layout

  data = d,
\end_layout

\begin_layout Plain Layout

  aes(x = xp, y = yp),
\end_layout

\begin_layout Plain Layout

  colour = 'darkorange',
\end_layout

\begin_layout Plain Layout

  lwd = 1.5,
\end_layout

\begin_layout Plain Layout

  lty = 2
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  g + scale_colour_manual (
\end_layout

\begin_layout Plain Layout

    name = 'airspeed: ',
\end_layout

\begin_layout Plain Layout

    values = c("increasing" = "forestgreen", "decreasing" = "blue")
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

# print (sprintf('RTX is %s; fit coefficients %.3f %.3f rms %.2f; delay %d
 ms',
\end_layout

\begin_layout Plain Layout

#   RTSEL, cf[1], cf[2], rms, input$sliderSR))
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  g + ylab(expression(paste('Recovery Temperature [', degree, 'C]'))) +
 xlab(Xlab) + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

g2 <- g + theme(plot.title = element_text(size = 12))
\end_layout

\begin_layout Plain Layout

g1 <- g1 + theme(legend.position=c(0.99, 0.92))
\end_layout

\begin_layout Plain Layout

g2 <- g2 + theme(legend.position = 'none')
\end_layout

\begin_layout Plain Layout

g1 <- g1 + ylim(c(-11, 4.5))
\end_layout

\begin_layout Plain Layout

g2 <- g2 + ylim(c(-11, 4.5))
\end_layout

\begin_layout Plain Layout

g2 <- g2 + ylab('')
\end_layout

\begin_layout Plain Layout

g1 <- g1 + annotate('text', x=8, y=3, label='(a)', size=5)
\end_layout

\begin_layout Plain Layout

g2 <- g2 + annotate('text', x=17, y=3, label='(b)', size=5)
\end_layout

\begin_layout Plain Layout

grid.newpage()
\end_layout

\begin_layout Plain Layout

vp1 <- viewport(width=0.57, height=0.9, x=0.25, y=0.45)
\end_layout

\begin_layout Plain Layout

vp2 <- viewport(width=0.57, height=0.9, x=0.68, y=0.45)
\end_layout

\begin_layout Plain Layout

# grid.rect(0.5, 0.5, width = unit(5, "npc"), name = 'a', vp = vp1)
\end_layout

\begin_layout Plain Layout

# grid.rect(0.5, 0.5, width = unit(5, "npc"), name = 'b', vp = vp2)
\end_layout

\begin_layout Plain Layout

plot(g2, vp=vp2)
\end_layout

\begin_layout Plain Layout

plot(g1, vp=vp1)
\end_layout

\begin_layout Plain Layout

# grid.newpage()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Branch Extra
inverted 0
status open

\begin_layout Subsection
The measured temperature in an inertial sub-range
\end_layout

\begin_layout Standard
One further check of the time-constant parameters can be obtained by comparing
 the slope of the spectral variance of the recovery temperature to the expected
 slope in an inertial sub-range.
 Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:VCLS2}
\end_layout

\end_inset

 shows an example of the measured variance spectrum for the recovery temperature
 measured during a low-level flight segment similar to those used to determine
 the phase lag in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-unheated-Rosemount"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The turbulent air motions in this region are consistent with expectations
 for an inertial sub-range, so it might be expected that the slope would
 conform to the expected 
\begin_inset Formula $-5/3$
\end_inset

 slope (or 
\begin_inset Formula $-2/3$
\end_inset

 in this spectrum that is weighted by the frequency).
 The measured spectrum (for TTRR) decreases a little more rapidly with frequency
 than expected but does not appear to be as far from the expected slope
 as would be expected from the transfer function, for example on the basis
 of Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:LTsolution}
\end_layout

\end_inset

.
 If the spectrum is corrected according to the transfer function, the result,
 shown as the variable 
\begin_inset Quotes eld
\end_inset

TTRRC,
\begin_inset Quotes erd
\end_inset

 has significant excess variance above about 2
\begin_inset space ~
\end_inset

Hz.
 The spectral variance as measured and as corrected both appear to be too
 high.
 This is not understood but appears to indicate that there is some spurious
 contribution to the variance at 2
\begin_inset space ~
\end_inset

Hz and above.
 This was also evident in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:checkAmplitude}
\end_layout

\end_inset

, where some source of variance other than dynamic heating appears to contribute
 to the amplitude fluctuations above 3
\begin_inset space ~
\end_inset

Hz.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<VCLS2, include=TRUE, echo=FALSE, fig.cap='The variance spectrum for the
 recovery temperature measured by a Rosemount 102E4AL sensor during a flight
 segment from VOCALS C-130 flight 3, 11:39:00 -- 11:52:00 UTC.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

D <- getNetCDF(
\end_layout

\begin_layout Plain Layout

  file.path(DataDirectory(), 'VOCALS/VOCALSrf03h.nc'),
\end_layout

\begin_layout Plain Layout

  c('TASX', 'PALT', 'TTRR', 'ATRR'),
\end_layout

\begin_layout Plain Layout

  113800,
\end_layout

\begin_layout Plain Layout

  115300
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

D$DH <- D$TASX ^ 2 / 2010
\end_layout

\begin_layout Plain Layout

DT <- D %>% selectTime(113900, 115200)
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  VSpecC(
\end_layout

\begin_layout Plain Layout

    DT,
\end_layout

\begin_layout Plain Layout

    'TTRR',
\end_layout

\begin_layout Plain Layout

    spans = 99,
\end_layout

\begin_layout Plain Layout

    xlim = c(0.01, 15),
\end_layout

\begin_layout Plain Layout

    ylim = c(1.e-5, 1.e-1)
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

DT$TTRRC <- DT$TTRR
\end_layout

\begin_layout Plain Layout

VSpecC(DT,
\end_layout

\begin_layout Plain Layout

       'TTRRC',
\end_layout

\begin_layout Plain Layout

       add = g,
\end_layout

\begin_layout Plain Layout

       corrected = TRUE,
\end_layout

\begin_layout Plain Layout

       Par = Param1) + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

# g <- VSpec(DT, 'ATRR', spans=99, add=g)
\end_layout

\begin_layout Plain Layout

# VSpec(DT, 'DH', spans=99, add=g) + theme_WAC()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<specialVSpec>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## SPECIAL FOR SHOWING TRANSFER-FUNCTION MOD
\end_layout

\begin_layout Plain Layout

VSpecC <-
\end_layout

\begin_layout Plain Layout

  function (.data,
\end_layout

\begin_layout Plain Layout

            .Variable = NA,
\end_layout

\begin_layout Plain Layout

            VLabel = NA,
\end_layout

\begin_layout Plain Layout

            col = NA,
\end_layout

\begin_layout Plain Layout

            type = 'spectrum',
\end_layout

\begin_layout Plain Layout

            corrected = FALSE,
\end_layout

\begin_layout Plain Layout

            method = NA,
\end_layout

\begin_layout Plain Layout

            xlim = NA,
\end_layout

\begin_layout Plain Layout

            ylim = NA,
\end_layout

\begin_layout Plain Layout

            Par = NA,
\end_layout

\begin_layout Plain Layout

            # c(0.001, 15), ylim=c(0.0001,1),
\end_layout

\begin_layout Plain Layout

            spans = 49,
\end_layout

\begin_layout Plain Layout

            ae = 0.2,
\end_layout

\begin_layout Plain Layout

            smoothBins = 0,
\end_layout

\begin_layout Plain Layout

            segLength = 512,
\end_layout

\begin_layout Plain Layout

            poles = 50,
\end_layout

\begin_layout Plain Layout

            resolution = 0.0001,
\end_layout

\begin_layout Plain Layout

            showErrors = 0,
\end_layout

\begin_layout Plain Layout

            WavelengthScale = TRUE,
\end_layout

\begin_layout Plain Layout

            ADD = NA,
\end_layout

\begin_layout Plain Layout

            add = NA,
\end_layout

\begin_layout Plain Layout

            EDR = FALSE,
\end_layout

\begin_layout Plain Layout

            WACtheme = NA) {
\end_layout

\begin_layout Plain Layout

    if (!is.data.frame(.data)) {
\end_layout

\begin_layout Plain Layout

      # See if the first argument can be split into a data.frame and a variable:
\end_layout

\begin_layout Plain Layout

      X <- substitute(.data)
\end_layout

\begin_layout Plain Layout

      if (is.call(X)) {
\end_layout

\begin_layout Plain Layout

        V <- try(eval(X), silent = TRUE)
\end_layout

\begin_layout Plain Layout

        if (grepl('Error', V[[1]])) {
\end_layout

\begin_layout Plain Layout

          V <- eval(plyr::as.quoted(X))  # eval(X) for names()
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        if (is.character(V[1])) {
\end_layout

\begin_layout Plain Layout

          
\end_layout

\begin_layout Plain Layout

        } else {
\end_layout

\begin_layout Plain Layout

          V <- plyr::as.quoted(X)
\end_layout

\begin_layout Plain Layout

          if (is.symbol(V[[1]])) {
\end_layout

\begin_layout Plain Layout

            V <- vapply(V, deparse, 'character')
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        V <- plyr::as.quoted(X)
\end_layout

\begin_layout Plain Layout

        if (is.symbol(V[[1]])) {
\end_layout

\begin_layout Plain Layout

          V <- vapply(V, deparse, 'character')
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      # print (c('first argument evaluates to', V))
\end_layout

\begin_layout Plain Layout

      # Extract data.frame:
\end_layout

\begin_layout Plain Layout

      .data <- get(V[[1]])
\end_layout

\begin_layout Plain Layout

      .Variable <- V[[2]]
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    # print(str(.data))
\end_layout

\begin_layout Plain Layout

    if (is.data.frame(.data)) {
\end_layout

\begin_layout Plain Layout

      ## must be true, or exit.
 Needs to contain Time and TASX
\end_layout

\begin_layout Plain Layout

      ## in addition to .Variable
\end_layout

\begin_layout Plain Layout

      nm <- names(.data)
\end_layout

\begin_layout Plain Layout

      V <- try(is.na(.Variable), silent = TRUE)
\end_layout

\begin_layout Plain Layout

      if (grepl('Error', V[[1]])) {
\end_layout

\begin_layout Plain Layout

        X <- substitute(.Variable)
\end_layout

\begin_layout Plain Layout

        if (is.call(X)) {
\end_layout

\begin_layout Plain Layout

          V <- try(eval(X), silent = TRUE)
\end_layout

\begin_layout Plain Layout

          if (grepl('Error', V[[1]])) {
\end_layout

\begin_layout Plain Layout

            V <- eval(plyr::as.quoted(X))  # eval(X) for names()
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          if (is.character(V[1])) {
\end_layout

\begin_layout Plain Layout

            
\end_layout

\begin_layout Plain Layout

          } else {
\end_layout

\begin_layout Plain Layout

            V <- plyr::as.quoted(X)
\end_layout

\begin_layout Plain Layout

            if (is.symbol(V[[1]])) {
\end_layout

\begin_layout Plain Layout

              V <- vapply(V, deparse, 'character')
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        } else {
\end_layout

\begin_layout Plain Layout

          V <- plyr::as.quoted(X)
\end_layout

\begin_layout Plain Layout

          if (is.symbol(V[[1]])) {
\end_layout

\begin_layout Plain Layout

            V <- vapply(V, deparse, 'character')
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        .Variable <- V
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      if (is.na(.Variable[1])) {
\end_layout

\begin_layout Plain Layout

        nm <- nm[-which('Time' == nm)]
\end_layout

\begin_layout Plain Layout

        nm <- nm[-which('TASX' == nm)]
\end_layout

\begin_layout Plain Layout

        .Variable <- nm
\end_layout

\begin_layout Plain Layout

        if (length(.Variable) > 3) {
\end_layout

\begin_layout Plain Layout

          .Variable <- .Variable[1:3]
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      print('VSpec ERROR: first argument is not a data.frame.')
\end_layout

\begin_layout Plain Layout

      return (NA)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if (is.null(attr(.data, 'Rate'))) {
\end_layout

\begin_layout Plain Layout

      print ('VSpec warning: Rate attribute missing from data.frame, so using
 Rate=1')
\end_layout

\begin_layout Plain Layout

      Rate <- 1
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      Rate <- attr(.data, 'Rate')
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if (is.na(xlim[1])) {
\end_layout

\begin_layout Plain Layout

      if (Rate == 1) {
\end_layout

\begin_layout Plain Layout

        xlim <- c(0.001, 1)
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        xlim <- c(0.001, 15)
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if (is.na(ylim[1])) {
\end_layout

\begin_layout Plain Layout

      ylim <- c(1.e-4, 1.)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if (!is.na(method)) {
\end_layout

\begin_layout Plain Layout

      type <- method
\end_layout

\begin_layout Plain Layout

    }  ## method over-rides if present
\end_layout

\begin_layout Plain Layout

    for (.V in .Variable) {
\end_layout

\begin_layout Plain Layout

      if (.V %in% names(.data)) {
\end_layout

\begin_layout Plain Layout

        NV <- which(.V == .Variable)
\end_layout

\begin_layout Plain Layout

        Z <- capture.output (v <- detrend (.data[, c('Time', .V)]))
\end_layout

\begin_layout Plain Layout

        if (!is.na(VLabel[1]) &&
\end_layout

\begin_layout Plain Layout

            length(VLabel) >= NV) {
\end_layout

\begin_layout Plain Layout

          ## use this alternate name in legend
\end_layout

\begin_layout Plain Layout

          V <- VLabel[NV]
\end_layout

\begin_layout Plain Layout

        } else {
\end_layout

\begin_layout Plain Layout

          V <- .V
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        print(sprintf(
\end_layout

\begin_layout Plain Layout

          'VSpec ERROR: Variable %s is not in the supplied data.frame',
\end_layout

\begin_layout Plain Layout

          .V
\end_layout

\begin_layout Plain Layout

        ))
\end_layout

\begin_layout Plain Layout

        return (NA)
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      if (type != 'spectrum' &&
\end_layout

\begin_layout Plain Layout

          type != 'Welch' && type != 'MEM' && type != 'mem') {
\end_layout

\begin_layout Plain Layout

        print (sprintf ('type %s is unavailable; using type=spectrum', type))
\end_layout

\begin_layout Plain Layout

        type <- 'spectrum'
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      siglim <- 1  ## 1-sigma error limits
\end_layout

\begin_layout Plain Layout

      if (type == 'spectrum') {
\end_layout

\begin_layout Plain Layout

        if (!is.null(spans[1])) {
\end_layout

\begin_layout Plain Layout

          if (!(spans[1] %% 2)) {
\end_layout

\begin_layout Plain Layout

            spans[1] <- spans[1] + 1
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          if (spans[1] <= 5) {
\end_layout

\begin_layout Plain Layout

            spans <- NULL
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        S <-
\end_layout

\begin_layout Plain Layout

          spectrum (ts(
\end_layout

\begin_layout Plain Layout

            SmoothInterp(v, .maxGap = 1000 * Rate, .Length = 0),
\end_layout

\begin_layout Plain Layout

            frequency = Rate
\end_layout

\begin_layout Plain Layout

          ),
\end_layout

\begin_layout Plain Layout

          span = spans,
\end_layout

\begin_layout Plain Layout

          plot = FALSE)
\end_layout

\begin_layout Plain Layout

        freq <- S$freq
\end_layout

\begin_layout Plain Layout

        if (corrected) {
\end_layout

\begin_layout Plain Layout

          ARX <- LTphase(freq, Par)
\end_layout

\begin_layout Plain Layout

          S$spec <- S$spec / ARX$Amp ^ 2
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        fpf <- 2 * S$spec * freq
\end_layout

\begin_layout Plain Layout

      } else if (type == 'Welch') {
\end_layout

\begin_layout Plain Layout

        ## bspec section
\end_layout

\begin_layout Plain Layout

        ## force segLength to a power of 2
\end_layout

\begin_layout Plain Layout

        segl <- segLength
\end_layout

\begin_layout Plain Layout

        rsl <- log(segl) / log(2)
\end_layout

\begin_layout Plain Layout

        ns <- round (rsl)
\end_layout

\begin_layout Plain Layout

        if (2 ^ ns != segl) {
\end_layout

\begin_layout Plain Layout

          if (2 ^ ns > segl) {
\end_layout

\begin_layout Plain Layout

            segl <- 2 ^ (ns - 1)
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          else {
\end_layout

\begin_layout Plain Layout

            segl <- 2 ^ (ns + 1)
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          segLength <- segl
\end_layout

\begin_layout Plain Layout

          print (sprintf ('reset segLength to %d', segLength))
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        S2 <-
\end_layout

\begin_layout Plain Layout

          bspec::welchPSD (
\end_layout

\begin_layout Plain Layout

            ts(SmoothInterp(v, .Length = 0), frequency = Rate),
\end_layout

\begin_layout Plain Layout

            seglength = segLength,
\end_layout

\begin_layout Plain Layout

            windowfun = bspec::hammingwindow
\end_layout

\begin_layout Plain Layout

          )
\end_layout

\begin_layout Plain Layout

        # ci <- quantile.bspec(BSP, probs = c(0.025, 0.975),
\end_layout

\begin_layout Plain Layout

        #   two.sided = FALSE)
\end_layout

\begin_layout Plain Layout

        coverage <- 0.683
\end_layout

\begin_layout Plain Layout

        tail <- 1 - coverage
\end_layout

\begin_layout Plain Layout

        df <- 2 * 9 * S2$segments / 11 ##1.768849
\end_layout

\begin_layout Plain Layout

        upper.quantile <-
\end_layout

\begin_layout Plain Layout

          1 - tail * pchisq(df, df, lower.tail = FALSE)
\end_layout

\begin_layout Plain Layout

        lower.quantile <- tail * pchisq(df, df)
\end_layout

\begin_layout Plain Layout

        ci <- 1 / (qchisq(c(upper.quantile, lower.quantile), df) / df)
\end_layout

\begin_layout Plain Layout

        df <- 1.46 * (S2$segments + 1)
\end_layout

\begin_layout Plain Layout

        lower.limit <- qchisq (pnorm(-siglim), df) / df
\end_layout

\begin_layout Plain Layout

        upper.limit <- qchisq (pnorm(siglim), df) / df
\end_layout

\begin_layout Plain Layout

        # ci <- 0.5 + (ci-0.5) / sqrt(9 * S2$segments / 11)
\end_layout

\begin_layout Plain Layout

        # print (sprintf ('ci2=%.3f -- %.3f segments %d', ci[1], ci[2], S2$segment
s))
\end_layout

\begin_layout Plain Layout

        freq <- S2$frequency[-1]
\end_layout

\begin_layout Plain Layout

        fpf <- S2$power[-1] * freq
\end_layout

\begin_layout Plain Layout

      } else if (type == 'MEM' || type == 'mem') {
\end_layout

\begin_layout Plain Layout

        ## MEM section
\end_layout

\begin_layout Plain Layout

        A <- memCoef (v, poles)
\end_layout

\begin_layout Plain Layout

        ld <- nrow(.data)
\end_layout

\begin_layout Plain Layout

        fmin <- log (Rate / ld)
\end_layout

\begin_layout Plain Layout

        fmax <- log (0.5 * Rate)
\end_layout

\begin_layout Plain Layout

        bins <- as.integer (1 / resolution)
\end_layout

\begin_layout Plain Layout

        df <- (fmax - fmin) / bins
\end_layout

\begin_layout Plain Layout

        fdtl <- fmin + df * (0:bins)
\end_layout

\begin_layout Plain Layout

        freq <- exp (fdtl)
\end_layout

\begin_layout Plain Layout

        psComplex <- memEstimate (freq / Rate, A) / Rate
\end_layout

\begin_layout Plain Layout

        ps <- 2 * Rate * Mod (psComplex) ^ 2
\end_layout

\begin_layout Plain Layout

        fpf <- freq * ps
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      tasAverage <- mean(.data$TASX, na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

      if (EDR) {
\end_layout

\begin_layout Plain Layout

        ps <- fpf / freq
\end_layout

\begin_layout Plain Layout

        fpf <- (2 * pi / tasAverage) * (1.5 * ps) ^ 1.5 * freq ^ 2.5
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      if (smoothBins > 9) {
\end_layout

\begin_layout Plain Layout

        bs1 <- binStats(data.frame(fpf, log(freq)), bins = smoothBins)
\end_layout

\begin_layout Plain Layout

        bs1 <-
\end_layout

\begin_layout Plain Layout

          rbind (bs1,
\end_layout

\begin_layout Plain Layout

                 data.frame(
\end_layout

\begin_layout Plain Layout

                   xc = bs1$xc[nrow(bs1)],
\end_layout

\begin_layout Plain Layout

                   ybar = bs1$ybar[nrow(bs1)],
\end_layout

\begin_layout Plain Layout

                   sigma = bs1$sigma[nrow(bs1)],
\end_layout

\begin_layout Plain Layout

                   nb = 1
\end_layout

\begin_layout Plain Layout

                 ))
\end_layout

\begin_layout Plain Layout

        bs1 <- bs1[!is.na(bs1$ybar), ]
\end_layout

\begin_layout Plain Layout

        freq <- exp(bs1$xc)
\end_layout

\begin_layout Plain Layout

        fpf <- bs1$ybar
\end_layout

\begin_layout Plain Layout

        bs1$sigma <- ifelse (bs1$nb > 2, bs1$sigma / sqrt(bs1$nb), NA)
\end_layout

\begin_layout Plain Layout

        rna <- is.na(bs1$sigma)
\end_layout

\begin_layout Plain Layout

        bs1$sigma[rna] <- bs1$ybar[rna] / 2
\end_layout

\begin_layout Plain Layout

        # bs1 <<- bs1
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      if (.V == .Variable[1]) {
\end_layout

\begin_layout Plain Layout

        DF <- data.frame(freq, fpf)
\end_layout

\begin_layout Plain Layout

      } else if (.V == .Variable[2]) {
\end_layout

\begin_layout Plain Layout

        DF$fpf2 <- fpf
\end_layout

\begin_layout Plain Layout

      } else if (.V == .Variable[3]) {
\end_layout

\begin_layout Plain Layout

        DF$fpf3 <- fpf
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    VL <- .Variable
\end_layout

\begin_layout Plain Layout

    if (!is.na(VLabel[1])) {
\end_layout

\begin_layout Plain Layout

      VL <- VLabel
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if (is.na(col[1])) {
\end_layout

\begin_layout Plain Layout

      col = c("blue", "forestgreen", "black", "darkorange")
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if (!is.na(add[1])) {
\end_layout

\begin_layout Plain Layout

      ADD <- add
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    for (.V in .Variable) {
\end_layout

\begin_layout Plain Layout

      NV <- which(.V == .Variable)
\end_layout

\begin_layout Plain Layout

      if (is.na(ADD[1])) {
\end_layout

\begin_layout Plain Layout

        if (NV == 1) {
\end_layout

\begin_layout Plain Layout

          ## first call: redefine VSpecDF
\end_layout

\begin_layout Plain Layout

          try(rm(list = names(VSpecEnv), envir = VSpecEnv), silent = TRUE)
\end_layout

\begin_layout Plain Layout

          VSpecEnv$Variable <- .Variable
\end_layout

\begin_layout Plain Layout

          assign('VSpecDF1', DF, envir = VSpecEnv)
\end_layout

\begin_layout Plain Layout

          labx <- 'frequency [Hz]'
\end_layout

\begin_layout Plain Layout

          if (EDR) {
\end_layout

\begin_layout Plain Layout

            # laby <- sprintf('eddy dissipation rate for %s', .V)
\end_layout

\begin_layout Plain Layout

            laby <-
\end_layout

\begin_layout Plain Layout

              expression(paste("eddy dissipation rate [m" ^ "2", "s" ^ "-3",
 "]"))
\end_layout

\begin_layout Plain Layout

          } else {
\end_layout

\begin_layout Plain Layout

            laby <- sprintf('variance spectrum fP(f) for %s', .V)
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          g <- ggplot(data = DF)
\end_layout

\begin_layout Plain Layout

          g <-
\end_layout

\begin_layout Plain Layout

            g + geom_path (aes(
\end_layout

\begin_layout Plain Layout

              x = freq,
\end_layout

\begin_layout Plain Layout

              y = fpf,
\end_layout

\begin_layout Plain Layout

              colour = VL[1]
\end_layout

\begin_layout Plain Layout

            ),
\end_layout

\begin_layout Plain Layout

            data = DF,
\end_layout

\begin_layout Plain Layout

            na.rm = TRUE) +
\end_layout

\begin_layout Plain Layout

            xlab(labx) + ylab (laby)
\end_layout

\begin_layout Plain Layout

          .clinesVSpec <- col[1]
\end_layout

\begin_layout Plain Layout

          names(.clinesVSpec) <- VL[1]
\end_layout

\begin_layout Plain Layout

          VSpecEnv$clinesVSpec <- .clinesVSpec
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        if (NV == 2) {
\end_layout

\begin_layout Plain Layout

          g <-
\end_layout

\begin_layout Plain Layout

            g + geom_path (aes(
\end_layout

\begin_layout Plain Layout

              x = freq,
\end_layout

\begin_layout Plain Layout

              y = fpf2,
\end_layout

\begin_layout Plain Layout

              colour = VL[2]
\end_layout

\begin_layout Plain Layout

            ),
\end_layout

\begin_layout Plain Layout

            data = DF,
\end_layout

\begin_layout Plain Layout

            na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

          cl2 <- ifelse (length(col) >= 2, col[2], 'forestgreen')
\end_layout

\begin_layout Plain Layout

          names(cl2) <- VL[2]
\end_layout

\begin_layout Plain Layout

          .clinesVSpec <- c(VSpecEnv$clinesVSpec, cl2)
\end_layout

\begin_layout Plain Layout

          VSpecEnv$clinesVSpec <- .clinesVSpec
\end_layout

\begin_layout Plain Layout

        } else if (NV == 3) {
\end_layout

\begin_layout Plain Layout

          g <-
\end_layout

\begin_layout Plain Layout

            g + geom_path (aes(
\end_layout

\begin_layout Plain Layout

              x = freq,
\end_layout

\begin_layout Plain Layout

              y = fpf3,
\end_layout

\begin_layout Plain Layout

              colour = VL[3]
\end_layout

\begin_layout Plain Layout

            ),
\end_layout

\begin_layout Plain Layout

            data = DF,
\end_layout

\begin_layout Plain Layout

            na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

          cl3 <- ifelse (length(col) >= 3, col[3], 'black')
\end_layout

\begin_layout Plain Layout

          names(cl3) <- VL[3]
\end_layout

\begin_layout Plain Layout

          .clinesVSpec <- c(VSpecEnv$clinesVSpec, cl3)
\end_layout

\begin_layout Plain Layout

          VSpecEnv$clinesVSpec <- .clinesVSpec
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        ## assign name based on elements in clinesVSpec
\end_layout

\begin_layout Plain Layout

        N <- length(VSpecEnv$clinesVSpec) + 1
\end_layout

\begin_layout Plain Layout

        nc <- names(VSpecEnv$clinesVSpec)
\end_layout

\begin_layout Plain Layout

        .clinesVSpec <- c(VSpecEnv$clinesVSpec, col[N])
\end_layout

\begin_layout Plain Layout

        names(.clinesVSpec) <- c(nc, V)
\end_layout

\begin_layout Plain Layout

        VSpecEnv$clinesVSpec <- .clinesVSpec
\end_layout

\begin_layout Plain Layout

        VName <- sprintf('VSpecDF%d', N)
\end_layout

\begin_layout Plain Layout

        assign(VName, DF, pos = VSpecEnv)
\end_layout

\begin_layout Plain Layout

        if (N == 2) {
\end_layout

\begin_layout Plain Layout

          VSpecEnv$VSpecVar2 <- V
\end_layout

\begin_layout Plain Layout

          g <-
\end_layout

\begin_layout Plain Layout

            ADD + geom_path (
\end_layout

\begin_layout Plain Layout

              aes(
\end_layout

\begin_layout Plain Layout

                x = freq,
\end_layout

\begin_layout Plain Layout

                y = fpf,
\end_layout

\begin_layout Plain Layout

                colour = VSpecEnv$VSpecVar2
\end_layout

\begin_layout Plain Layout

              ),
\end_layout

\begin_layout Plain Layout

              data = get(VName, envir = VSpecEnv),
\end_layout

\begin_layout Plain Layout

              na.rm = TRUE
\end_layout

\begin_layout Plain Layout

            )
\end_layout

\begin_layout Plain Layout

        } else if (N == 3) {
\end_layout

\begin_layout Plain Layout

          VSpecEnv$VSpecVar3 <- V
\end_layout

\begin_layout Plain Layout

          g <-
\end_layout

\begin_layout Plain Layout

            ADD + geom_path (
\end_layout

\begin_layout Plain Layout

              aes(
\end_layout

\begin_layout Plain Layout

                x = freq,
\end_layout

\begin_layout Plain Layout

                y = fpf,
\end_layout

\begin_layout Plain Layout

                colour = VSpecEnv$VSpecVar3
\end_layout

\begin_layout Plain Layout

              ),
\end_layout

\begin_layout Plain Layout

              data = get(VName, envir = VSpecEnv),
\end_layout

\begin_layout Plain Layout

              na.rm = TRUE
\end_layout

\begin_layout Plain Layout

            )
\end_layout

\begin_layout Plain Layout

        } else if (N == 4) {
\end_layout

\begin_layout Plain Layout

          VSpecEnv$VSpecVar4 <- V
\end_layout

\begin_layout Plain Layout

          g <-
\end_layout

\begin_layout Plain Layout

            ADD + geom_path (
\end_layout

\begin_layout Plain Layout

              aes(
\end_layout

\begin_layout Plain Layout

                x = freq,
\end_layout

\begin_layout Plain Layout

                y = fpf,
\end_layout

\begin_layout Plain Layout

                colour = VSpecEnv$VSpecVar4
\end_layout

\begin_layout Plain Layout

              ),
\end_layout

\begin_layout Plain Layout

              data = get(VName, envir = VSpecEnv),
\end_layout

\begin_layout Plain Layout

              na.rm = TRUE
\end_layout

\begin_layout Plain Layout

            )
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    g <-
\end_layout

\begin_layout Plain Layout

      suppressMessages(g + scale_colour_manual (name = '', values = .clinesVSpec)
)
\end_layout

\begin_layout Plain Layout

    # print (.clinesVSpec)
\end_layout

\begin_layout Plain Layout

    if (showErrors > 0) {
\end_layout

\begin_layout Plain Layout

      if (smoothBins > 9) {
\end_layout

\begin_layout Plain Layout

        bse <-
\end_layout

\begin_layout Plain Layout

          data.frame(
\end_layout

\begin_layout Plain Layout

            x = exp(bs1$xc),
\end_layout

\begin_layout Plain Layout

            ymin = bs1$ybar - showErrors * bs1$sigma,
\end_layout

\begin_layout Plain Layout

            ymax = bs1$ybar + showErrors * bs1$sigma
\end_layout

\begin_layout Plain Layout

          )
\end_layout

\begin_layout Plain Layout

        bse$ymin[bse$ymin < ylim[1]] <- ylim[1]
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        coverage <-
\end_layout

\begin_layout Plain Layout

          pnorm(showErrors) - pnorm(-showErrors)  ## 1-sigma, 0.68269
\end_layout

\begin_layout Plain Layout

        tail <- 1 - coverage
\end_layout

\begin_layout Plain Layout

        if (type == 'spectrum') {
\end_layout

\begin_layout Plain Layout

          df <- S$df
\end_layout

\begin_layout Plain Layout

        } else if (type == 'Welch') {
\end_layout

\begin_layout Plain Layout

          df <- 1.46 * (S2$segments + 1)
\end_layout

\begin_layout Plain Layout

        } else if (type == 'MEM') {
\end_layout

\begin_layout Plain Layout

          df <- length(v) / poles
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        uq <- 1 - tail * pchisq(df, df, lower.tail = FALSE)
\end_layout

\begin_layout Plain Layout

        lq <- tail * pchisq(df, df, lower.tail = TRUE)
\end_layout

\begin_layout Plain Layout

        ci <- 1 / (qchisq(c(uq, lq), df) / df)
\end_layout

\begin_layout Plain Layout

        lower.limit <- qchisq (pnorm(-showErrors), df) / df
\end_layout

\begin_layout Plain Layout

        upper.limit <- qchisq (pnorm(showErrors), df) / df
\end_layout

\begin_layout Plain Layout

        bse <-
\end_layout

\begin_layout Plain Layout

          data.frame(x = freq,
\end_layout

\begin_layout Plain Layout

                     ymin = lower.limit * fpf,
\end_layout

\begin_layout Plain Layout

                     ymax = upper.limit * fpf)
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      # g <- g + geom_ribbon(data=bs1, aes(x=exp(xc), ymin=max(ylim[1],
 ybar-showErrors*sigma), ymax=ybar+showErrors*sigma),
\end_layout

\begin_layout Plain Layout

      #   fill='cyan', alpha=0.25, show.legend=FALSE, inherit.aes=FALSE, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

      g <- g + geom_ribbon(
\end_layout

\begin_layout Plain Layout

        data = bse,
\end_layout

\begin_layout Plain Layout

        aes(x = x, ymin = ymin, ymax = ymax),
\end_layout

\begin_layout Plain Layout

        fill = 'gray50',
\end_layout

\begin_layout Plain Layout

        alpha = 0.5,
\end_layout

\begin_layout Plain Layout

        show.legend = FALSE,
\end_layout

\begin_layout Plain Layout

        inherit.aes = FALSE,
\end_layout

\begin_layout Plain Layout

        na.rm = TRUE
\end_layout

\begin_layout Plain Layout

      )
\end_layout

\begin_layout Plain Layout

      # bs1$xc <- exp(bs1$xc)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if (is.na(ADD[1])) {
\end_layout

\begin_layout Plain Layout

      g <-
\end_layout

\begin_layout Plain Layout

        g + # scale_x_log10(
\end_layout

\begin_layout Plain Layout

          # breaks = trans_breaks("log10", function(x)
\end_layout

\begin_layout Plain Layout

            # 10 ^ x, n = 4),
\end_layout

\begin_layout Plain Layout

          #limits = xlim,
\end_layout

\begin_layout Plain Layout

          # labels = trans_format("log10", math_format(10 ^ .x))
\end_layout

\begin_layout Plain Layout

        # ) +
\end_layout

\begin_layout Plain Layout

        scale_y_log10(
\end_layout

\begin_layout Plain Layout

          breaks = trans_breaks("log10", function(x)
\end_layout

\begin_layout Plain Layout

            10 ^ x, n = 4),
\end_layout

\begin_layout Plain Layout

          #limits = ylim,
\end_layout

\begin_layout Plain Layout

          labels = trans_format("log10", math_format(10 ^ .x))
\end_layout

\begin_layout Plain Layout

        ) +
\end_layout

\begin_layout Plain Layout

        annotation_logticks(sides = 'trbl') +
\end_layout

\begin_layout Plain Layout

        coord_cartesian(xlim = xlim, ylim = ylim)
\end_layout

\begin_layout Plain Layout

      # g <- g + theme(panel.grid.minor = element_line(colour = "black"))
\end_layout

\begin_layout Plain Layout

      if (EDR) {
\end_layout

\begin_layout Plain Layout

        ## add line showing highest-decade average EDR
\end_layout

\begin_layout Plain Layout

        imx <- length(freq)
\end_layout

\begin_layout Plain Layout

        imn <- which (freq > freq[imx] / 20)[1]
\end_layout

\begin_layout Plain Layout

        aveEDR <- mean(fpf[imn:imx], na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

        ttl <- sprintf ('EDR=%.2e', aveEDR)
\end_layout

\begin_layout Plain Layout

        DFL <- data.frame(x = c(freq[imn], freq[imx]), y = rep(aveEDR, 2))
\end_layout

\begin_layout Plain Layout

        g <-
\end_layout

\begin_layout Plain Layout

          g + geom_path(data = DFL,
\end_layout

\begin_layout Plain Layout

                        aes(x = x, y = y),
\end_layout

\begin_layout Plain Layout

                        lwd = 1.5,
\end_layout

\begin_layout Plain Layout

                        colour = 'red')
\end_layout

\begin_layout Plain Layout

        g <- g + ggtitle (bquote(.(ttl) ~ ' m' ^ 2 ~ 's' ^ -3))
\end_layout

\begin_layout Plain Layout

        # g <- g + ggtitle(sprintf(' mean eddy dissipation rate %.2e m^2/s^3',
 aveEDR))
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        for (i in (-8:0)) {
\end_layout

\begin_layout Plain Layout

          a = ae * 10.
 ^ (i * (2 / 3)) * tasAverage ^ (2 / 3)
\end_layout

\begin_layout Plain Layout

          lw = ifelse(i == -4, 1.2, 0.5)
\end_layout

\begin_layout Plain Layout

          DFL <-
\end_layout

\begin_layout Plain Layout

            data.frame(x = xlim, y = c(a / xlim[1] ^ (2 / 3), a / xlim[2]
 ^ (2 / 3)))
\end_layout

\begin_layout Plain Layout

          # print(DFL)
\end_layout

\begin_layout Plain Layout

          g <-
\end_layout

\begin_layout Plain Layout

            g + geom_path (
\end_layout

\begin_layout Plain Layout

              data = DFL,
\end_layout

\begin_layout Plain Layout

              aes(x = x, y = y),
\end_layout

\begin_layout Plain Layout

              colour = 'darkorange',
\end_layout

\begin_layout Plain Layout

              lwd = lw,
\end_layout

\begin_layout Plain Layout

              lty = 3
\end_layout

\begin_layout Plain Layout

            )
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      if (WavelengthScale) {
\end_layout

\begin_layout Plain Layout

        yl <- c(ylim[1] * 1.2, ylim[1] * 1.5)
\end_layout

\begin_layout Plain Layout

        lclr <- 'slategrey'
\end_layout

\begin_layout Plain Layout

        for (j1 in c(10, 100, 1000, 10000, 100000)) {
\end_layout

\begin_layout Plain Layout

          DFL2 <- data.frame(x = rep(tasAverage / j1, 2), y = yl)
\end_layout

\begin_layout Plain Layout

          g <-
\end_layout

\begin_layout Plain Layout

            g + geom_path(
\end_layout

\begin_layout Plain Layout

              data = DFL2,
\end_layout

\begin_layout Plain Layout

              aes(x = x, y = y),
\end_layout

\begin_layout Plain Layout

              colour = lclr,
\end_layout

\begin_layout Plain Layout

              lwd = 1.0
\end_layout

\begin_layout Plain Layout

            )
\end_layout

\begin_layout Plain Layout

          if (j1 != 100000) {
\end_layout

\begin_layout Plain Layout

            for (j2 in 2:9) {
\end_layout

\begin_layout Plain Layout

              DFL2 <- data.frame(x = rep(tasAverage / (j1 * j2), 2), y =
 yl)
\end_layout

\begin_layout Plain Layout

              g <-
\end_layout

\begin_layout Plain Layout

                g + geom_path(
\end_layout

\begin_layout Plain Layout

                  data = DFL2,
\end_layout

\begin_layout Plain Layout

                  aes(x = x, y = y),
\end_layout

\begin_layout Plain Layout

                  colour = lclr,
\end_layout

\begin_layout Plain Layout

                  lwd = 0.6
\end_layout

\begin_layout Plain Layout

                )
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        DFL2 <-
\end_layout

\begin_layout Plain Layout

          data.frame (x = tasAverage * c(1 / 10, 1 / 100000), y = rep(yl[1],
 2))
\end_layout

\begin_layout Plain Layout

        g <-
\end_layout

\begin_layout Plain Layout

          g + geom_path(data = DFL2,
\end_layout

\begin_layout Plain Layout

                        aes(x = x, y = y),
\end_layout

\begin_layout Plain Layout

                        colour = lclr,
\end_layout

\begin_layout Plain Layout

                        lwd = 1.0)
\end_layout

\begin_layout Plain Layout

        g <- g + annotate(
\end_layout

\begin_layout Plain Layout

          "text",
\end_layout

\begin_layout Plain Layout

          x = tasAverage * c(1 / 100000, 1 / 10000, 1 / 1000, 1 / 100, 1
 /
\end_layout

\begin_layout Plain Layout

                               10),
\end_layout

\begin_layout Plain Layout

          y = rep(yl[2] * 1.5, 5),
\end_layout

\begin_layout Plain Layout

          label = c("100 km", "10 km", "1 km", "0.1 km", " "),
\end_layout

\begin_layout Plain Layout

          colour = lclr
\end_layout

\begin_layout Plain Layout

        )
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      # g <- g + theme_WAC()
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if (!is.na(WACtheme)) {
\end_layout

\begin_layout Plain Layout

      g <- g + theme_WAC()
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return(g)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Uses of the transfer functions
\end_layout

\begin_layout Standard
The transfer functions have two potential uses: (i) to predict how airborne
 thermometers will respond; and (ii) to correct measurements to compensate
 for the time response of the sensors.
 The two sections that follow are examples of these two uses.
 In the next section, the transfer functions are used to assess how sensors
 respond to dynamic heating and to develop appropriate correction schemes.
 Then the following section applies the transfer functions to improve measuremen
ts of the flux of sensible heat.
\end_layout

\begin_layout Standard
\begin_inset Branch expanded
inverted 0
status open

\begin_layout Standard
It is also possible to make corrections to the measurements for other purposes.
 Once the transfer functions are determined, the correction procedures use
 standard techniques, as discussed in Appendix A.
 These are suited to standard measurements made from most research aircraft
 and so can have general community utility.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The preceding discussion has focused on the recovery temperature that is
 the measurand, as expressed by 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:recoveryTemperature"
plural "false"
caps "false"
noprefix "false"

\end_inset

, because the sensor responds to that temperature.
 Corrections should be made to the measurement of the recovery temperature,
 here represented by 
\begin_inset Formula $T_{m}$
\end_inset

, to obtain an improved estimate of the measurand.
 It is an error to apply the corrections to the air temperature after correction
 for dynamic heating (as in, e.g., 
\begin_inset CommandInset citation
LatexCommand citet
key "mccarthy1973method"
literal "false"

\end_inset

, 
\begin_inset CommandInset citation
LatexCommand citet
key "InverarityJTech2000"
literal "false"

\end_inset

, 
\begin_inset CommandInset citation
LatexCommand citet
key "nicholls1978measurements"
literal "false"

\end_inset

 and others) because then the correction is applied also to the dynamic-heating
 term to which it does not apply.
 This will introduce noise into the calculated air temperature if the sensor
 cannot respond fully to fluctuations in dynamic heating.
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
The contributions to the air temperature 
\begin_inset Formula $T_{a}$
\end_inset

 in terms of Fourier transforms is
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\hat{T}_{a}=\hat{T}_{r}-\hat{Q}=\hat{T}_{m}/H-\hat{Q}
\]

\end_inset

It is an error to apply the correction to the derived air temperature 
\begin_inset Formula $T_{a}$
\end_inset

, which would use the correction term 
\begin_inset Formula $(\hat{T}_{m}-\hat{Q})/H$
\end_inset

.
 as has been done by, e.g., 
\begin_inset CommandInset citation
LatexCommand citet
key "mccarthy1973method"
literal "false"

\end_inset

, 
\begin_inset CommandInset citation
LatexCommand citet
key "InverarityJTech2000"
literal "false"

\end_inset

, 
\begin_inset CommandInset citation
LatexCommand citet
key "nicholls1978measurements"
literal "false"

\end_inset

 and others.
 In the latter correction, the contribution of dynamic heating is amplified
 by division by the transfer function 
\begin_inset Newline newline
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Correcting for Dynamic Heating
\begin_inset CommandInset label
LatexCommand label
name "sec:Correcting-for-Dynamic"

\end_inset


\end_layout

\begin_layout Standard
Airborne thermometers sense the recovery temperature produced when air is
 compressed as it enters the housing.
 Data-processing algorithms used to produce data archives from most airborne
 measurement platforms subtract an independent estimate of dynamic heating
 to obtain a resulting measurement of the ambient air temperature.
 The dynamic-heating term can exceed 
\begin_inset Formula $20^{\circ}\mathrm{C}$
\end_inset

 at jet-aircraft flight speeds, so the correction is large and fluctuations
 in this term are often the dominant source of variations in the recovery
 temperature.
 As described in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Dynamic-heating"
plural "false"
caps "false"
noprefix "false"

\end_inset

, when the sensor cannot respond to fluctuations in dynamic heating, this
 procedure introduces errors and excess noise into the resulting air temperature.
 A modified correction procedure is proposed here that instead corrects
 for dynamic heating only after filtering to match the response of the temperatu
re sensor.
 This removes a significant source of error present in many temperature
 measurements made from research aircraft.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<reinit, echo=FALSE,include=FALSE>>=
\end_layout

\begin_layout Plain Layout

# Is this needed still?
\end_layout

\begin_layout Plain Layout

reviseDH <-
\end_layout

\begin_layout Plain Layout

  function (.data, P, alphaR) {
\end_layout

\begin_layout Plain Layout

    # P is Param1, e.g.; alphaR is recovery factor
\end_layout

\begin_layout Plain Layout

    .data$Q <- .data$TASX ^ 2 / 2010
\end_layout

\begin_layout Plain Layout

    aV <- P$a
\end_layout

\begin_layout Plain Layout

    tau1V <- P$tau1
\end_layout

\begin_layout Plain Layout

    tau2V <- P$tau2
\end_layout

\begin_layout Plain Layout

    Rate <- attr (.data, 'Rate')
\end_layout

\begin_layout Plain Layout

    fS <- function(y, i) {
\end_layout

\begin_layout Plain Layout

      (.data$Q[i] - y) / (tau2V * Rate)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    fM <- function (y, i) {
\end_layout

\begin_layout Plain Layout

      (aV * .data$Q[i] + (1 - aV) * TsQ[i] - y) / (Rate * tau1V)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    TsQ <- rk4.integrate (fS, .data$Q[1], 1:nrow(.data))
\end_layout

\begin_layout Plain Layout

    Qp <- rk4.integrate (fM, .data$Q[1], 1:nrow(.data))
\end_layout

\begin_layout Plain Layout

    return (.data$ATX + alphaR * (.data$Q - Qp))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

## This is a special version with features not in the standard Ranadu version
\end_layout

\begin_layout Plain Layout

CohP <-
\end_layout

\begin_layout Plain Layout

  function (.data,
\end_layout

\begin_layout Plain Layout

            .Var1,
\end_layout

\begin_layout Plain Layout

            .Var2,
\end_layout

\begin_layout Plain Layout

            col = 'blue',
\end_layout

\begin_layout Plain Layout

            spans = 25,
\end_layout

\begin_layout Plain Layout

            smoothBins = 50,
\end_layout

\begin_layout Plain Layout

            plotType = 'ggplot',
\end_layout

\begin_layout Plain Layout

            showErrors = 0,
\end_layout

\begin_layout Plain Layout

            returnCospectrum = FALSE) {
\end_layout

\begin_layout Plain Layout

    if (is.data.frame(.data)) {
\end_layout

\begin_layout Plain Layout

      if (.Var1 %in% names(.data)) {
\end_layout

\begin_layout Plain Layout

        Z <-
\end_layout

\begin_layout Plain Layout

          capture.output (Vr <-
\end_layout

\begin_layout Plain Layout

                            SmoothInterp(detrend (.data[, c('Time', .Var1)]),
 .Length = 0))
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        print(sprintf(
\end_layout

\begin_layout Plain Layout

          'CohPhase ERROR: Variable %s is not in the supplied data.frame',
\end_layout

\begin_layout Plain Layout

          .Var1
\end_layout

\begin_layout Plain Layout

        ))
\end_layout

\begin_layout Plain Layout

        return (NA)
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      if (.Var2 %in% names(.data)) {
\end_layout

\begin_layout Plain Layout

        Z <-
\end_layout

\begin_layout Plain Layout

          capture.output (VrC <-
\end_layout

\begin_layout Plain Layout

                            SmoothInterp(detrend (.data[, c('Time', .Var2)]),
 .Length = 0))
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        print(sprintf(
\end_layout

\begin_layout Plain Layout

          'CohPhase ERROR: Variable %s is not in the supplied data.frame',
\end_layout

\begin_layout Plain Layout

          .Var2
\end_layout

\begin_layout Plain Layout

        ))
\end_layout

\begin_layout Plain Layout

        return (NA)
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      print('CohPhase ERROR: first argument is not a data.frame.')
\end_layout

\begin_layout Plain Layout

      return (NA)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if (is.null(attr(.data, 'Rate'))) {
\end_layout

\begin_layout Plain Layout

      print ('CohPhase warning: Rate attribute missing from data.frame, so
 using Rate=1')
\end_layout

\begin_layout Plain Layout

      Rate <- 1
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      Rate <- attr(.data, 'Rate')
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    vcv <- cbind(ts(Vr, frequency = Rate), ts(VrC, frequency = Rate))
\end_layout

\begin_layout Plain Layout

    P <-
\end_layout

\begin_layout Plain Layout

      spec.pgram(
\end_layout

\begin_layout Plain Layout

        vcv,
\end_layout

\begin_layout Plain Layout

        detrend = FALSE,
\end_layout

\begin_layout Plain Layout

        fast = TRUE,
\end_layout

\begin_layout Plain Layout

        plot = FALSE,
\end_layout

\begin_layout Plain Layout

        spans = spans
\end_layout

\begin_layout Plain Layout

      )
\end_layout

\begin_layout Plain Layout

    df1 <- data.frame(P$coh, log(P$freq))
\end_layout

\begin_layout Plain Layout

    df2 <- data.frame (P$phase, log(P$freq))
\end_layout

\begin_layout Plain Layout

    df3 <- data.frame (P$spec[, 1], log(P$freq))
\end_layout

\begin_layout Plain Layout

    df4 <- data.frame (P$spec[, 2], log(P$freq))
\end_layout

\begin_layout Plain Layout

    pf1 <- binStats (df1, bins = smoothBins)
\end_layout

\begin_layout Plain Layout

    pf2 <- binStats (df2, bins = smoothBins)
\end_layout

\begin_layout Plain Layout

    pf3 <- binStats (df3, bins = smoothBins)
\end_layout

\begin_layout Plain Layout

    pf4 <- binStats (df4, bins = smoothBins)
\end_layout

\begin_layout Plain Layout

    pf1 <- pf1[!is.na (pf1$ybar),]
\end_layout

\begin_layout Plain Layout

    pf2 <- pf2[!is.na (pf2$ybar),]
\end_layout

\begin_layout Plain Layout

    pf3 <- pf3[!is.na (pf3$ybar),]
\end_layout

\begin_layout Plain Layout

    pf4 <- pf4[!is.na (pf4$ybar),]
\end_layout

\begin_layout Plain Layout

    # pf1$sigma[pf1$nb > 1] <- pf1$sigma[pf1$nb > 1] / sqrt(pf1$nb[pf1$nb
 > 2])
\end_layout

\begin_layout Plain Layout

    pf1$sigma[pf1$nb <= 1] <- NA # pf1$ybar[pf1$nb <= 1] * 0.5
\end_layout

\begin_layout Plain Layout

    # pf2$sigma[pf2$nb > 1] <- pf2$sigma[pf2$nb > 1] / sqrt(pf2$nb[pf2$nb
 > 2])
\end_layout

\begin_layout Plain Layout

    pf2$sigma[pf2$nb <= 1] <- NA # pf2$ybar[pf2$nb <= 1] * 0.5is
\end_layout

\begin_layout Plain Layout

    if (plotType != 'ggplot') {
\end_layout

\begin_layout Plain Layout

      pf1 <- binStats (df1, bins = smoothBins, addBin = TRUE)
\end_layout

\begin_layout Plain Layout

      pf2 <- binStats (df2, bins = smoothBins, addBin = TRUE)
\end_layout

\begin_layout Plain Layout

      pf3 <- binStats (df3, bins = smoothBins, addBin = TRUE)
\end_layout

\begin_layout Plain Layout

      pf4 <- binStats (df4, bins = smoothBins, addBin = TRUE)
\end_layout

\begin_layout Plain Layout

      return(cbind(pf1, pf2, pf3, pf4)[, c(2, 1, 3, 4, 6, 7, 10)])
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      d2 <-
\end_layout

\begin_layout Plain Layout

        data.frame(
\end_layout

\begin_layout Plain Layout

          Time = exp(pf1$xc),
\end_layout

\begin_layout Plain Layout

          coherence = pf1$ybar,
\end_layout

\begin_layout Plain Layout

          phase = pf2$ybar * 180 / pi,
\end_layout

\begin_layout Plain Layout

          clo = (pf1$ybar - showErrors * pf1$sigma),
\end_layout

\begin_layout Plain Layout

          chi = pf1$ybar + showErrors * pf1$sigma,
\end_layout

\begin_layout Plain Layout

          plo = (pf2$ybar - showErrors * pf2$sigma) * 180 / pi,
\end_layout

\begin_layout Plain Layout

          phi = (pf2$ybar + showErrors * pf2$sigma) * 180 / pi
\end_layout

\begin_layout Plain Layout

        )
\end_layout

\begin_layout Plain Layout

      d2$clo[!is.na(d2$clo) & (d2$clo < 0)] <- 0
\end_layout

\begin_layout Plain Layout

      labelP <- c('coherence', 'phase [degrees]')
\end_layout

\begin_layout Plain Layout

      g <- ggplotWAC(
\end_layout

\begin_layout Plain Layout

        d2[, c(1, 2, 3)],
\end_layout

\begin_layout Plain Layout

        panels = 2,
\end_layout

\begin_layout Plain Layout

        labelP = labelP,
\end_layout

\begin_layout Plain Layout

        col = col,
\end_layout

\begin_layout Plain Layout

        lwd = c(1.0),
\end_layout

\begin_layout Plain Layout

        lty = c(1),
\end_layout

\begin_layout Plain Layout

        xlab = 'freq'
\end_layout

\begin_layout Plain Layout

      )
\end_layout

\begin_layout Plain Layout

      g <-
\end_layout

\begin_layout Plain Layout

        g + xlab('frequency [Hz]') + ylab (sprintf ('%s x %s', .Var1, .Var2))
\end_layout

\begin_layout Plain Layout

      g <-
\end_layout

\begin_layout Plain Layout

        g + scale_x_log10(
\end_layout

\begin_layout Plain Layout

          breaks = trans_breaks("log10", function(x)
\end_layout

\begin_layout Plain Layout

            10 ^ x, n = 4),
\end_layout

\begin_layout Plain Layout

          labels = trans_format("log10", math_format(expr = 10 ^ .x))
\end_layout

\begin_layout Plain Layout

        ) + xlab('frequency [Hz]')
\end_layout

\begin_layout Plain Layout

      if (showErrors > 0 && smoothBins > 5) {
\end_layout

\begin_layout Plain Layout

        da <- data.frame(d2[, c(1, 4, 5)])
\end_layout

\begin_layout Plain Layout

        db <- data.frame(d2[, c(1, 6, 7)])
\end_layout

\begin_layout Plain Layout

        names(da) <- c('Time', 'ymin', 'ymax')
\end_layout

\begin_layout Plain Layout

        names(db) <- c('Time', 'ymin', 'ymax')
\end_layout

\begin_layout Plain Layout

        da$PanelGroup <- labelP[1]
\end_layout

\begin_layout Plain Layout

        db$PanelGroup <- labelP[2]
\end_layout

\begin_layout Plain Layout

        d <- rbind(db, da)
\end_layout

\begin_layout Plain Layout

        g <-
\end_layout

\begin_layout Plain Layout

          g + geom_ribbon(
\end_layout

\begin_layout Plain Layout

            data = d,
\end_layout

\begin_layout Plain Layout

            aes(
\end_layout

\begin_layout Plain Layout

              x = Time,
\end_layout

\begin_layout Plain Layout

              ymin = ymin,
\end_layout

\begin_layout Plain Layout

              ymax = ymax
\end_layout

\begin_layout Plain Layout

            ),
\end_layout

\begin_layout Plain Layout

            colour = 'grey',
\end_layout

\begin_layout Plain Layout

            alpha = 0.15,
\end_layout

\begin_layout Plain Layout

            inherit.aes = FALSE
\end_layout

\begin_layout Plain Layout

          )
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      g <- g + theme_WAC(1) + theme(legend.position = 'none')
\end_layout

\begin_layout Plain Layout

      if (returnCospectrum) {
\end_layout

\begin_layout Plain Layout

        CS <-
\end_layout

\begin_layout Plain Layout

          sqrt(P$coh[, 1] * P$spec[, 1] * P$spec[, 2] / (1 + tan(P$phase[,
 1]) ^
\end_layout

\begin_layout Plain Layout

                                                           2))
\end_layout

\begin_layout Plain Layout

        v1 <- SmoothInterp(.data[, .Var1], .Length = 0)
\end_layout

\begin_layout Plain Layout

        v2 <- SmoothInterp(.data[, .Var2], .Length = 0)
\end_layout

\begin_layout Plain Layout

        v1 <- detrend(data.frame(Time = .data$Time, v1))
\end_layout

\begin_layout Plain Layout

        v2 <- detrend(data.frame(Time = .data$Time, v2))
\end_layout

\begin_layout Plain Layout

        ff1 <- fft(v1)
\end_layout

\begin_layout Plain Layout

        ff2 <- fft(v2)
\end_layout

\begin_layout Plain Layout

        G <- Re(ff1 * Conj(ff2)) / nrow(.data)
\end_layout

\begin_layout Plain Layout

        GQ <- Im(ff1 * Conj(ff2)) / nrow(.data)
\end_layout

\begin_layout Plain Layout

        N <- nrow(.data) %/% 2
\end_layout

\begin_layout Plain Layout

        S1 <- Re(ff1 * Conj(ff1) / nrow(.data))
\end_layout

\begin_layout Plain Layout

        S2 <- Re(ff2 * Conj(ff2) / nrow(.data))
\end_layout

\begin_layout Plain Layout

        G <- G[2:(N + 1)]
\end_layout

\begin_layout Plain Layout

        GQ <- GQ[2:(N + 1)]
\end_layout

\begin_layout Plain Layout

        S1 <- S1[2:(N + 1)]
\end_layout

\begin_layout Plain Layout

        S2 <- S2[2:(N + 1)]
\end_layout

\begin_layout Plain Layout

        frq <- c(1:N) * Rate / nrow(.data)
\end_layout

\begin_layout Plain Layout

        spec1 <- 2 * S1 / Rate
\end_layout

\begin_layout Plain Layout

        spec2 <- 2 * S2 / Rate
\end_layout

\begin_layout Plain Layout

        cospec <- 2 * G / Rate
\end_layout

\begin_layout Plain Layout

        quad <- 2 * GQ / Rate
\end_layout

\begin_layout Plain Layout

        # cospectrum - i * quadrature = (gain spectrum) * exp(i*(phase spectrum)
)
\end_layout

\begin_layout Plain Layout

        # sqrt(cospectrum^2 + quadrature^2) is the amplitude or gain spectrum
\end_layout

\begin_layout Plain Layout

        return(data.frame(
\end_layout

\begin_layout Plain Layout

          freq = frq,
\end_layout

\begin_layout Plain Layout

          cospec = cospec,
\end_layout

\begin_layout Plain Layout

          quad = quad,
\end_layout

\begin_layout Plain Layout

          spec1 = spec1,
\end_layout

\begin_layout Plain Layout

          spec2 = spec2
\end_layout

\begin_layout Plain Layout

        ))
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        return(g)
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

a <- 0.733 # 0.713
\end_layout

\begin_layout Plain Layout

tau1 <- 0.0308  # 0.0335
\end_layout

\begin_layout Plain Layout

tau2 <- 0.447
\end_layout

\begin_layout Plain Layout

Param <- list(
\end_layout

\begin_layout Plain Layout

  a = a,
\end_layout

\begin_layout Plain Layout

  tau1 = tau1,
\end_layout

\begin_layout Plain Layout

  tau2 = tau2
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

Param1 <- Param
\end_layout

\begin_layout Plain Layout

ParamSH <- Param
\end_layout

\begin_layout Plain Layout

ParamSH$a <- 0
\end_layout

\begin_layout Plain Layout

ParamSH$tau1 <- 0.05681167 
\end_layout

\begin_layout Plain Layout

ParamSH$tau2 <- 1.25078040
\end_layout

\begin_layout Plain Layout

ParamSF <- Param
\end_layout

\begin_layout Plain Layout

ParamSF$a <- 0.652
\end_layout

\begin_layout Plain Layout

ParamSF$tau1 <- 0.0295
\end_layout

\begin_layout Plain Layout

ParamSF$tau2 <- 1.04
\end_layout

\begin_layout Plain Layout

source('./chunks/rk4.integrate.R')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\lang english
\begin_inset ERT
status open

\begin_layout Plain Layout

<<S15, include=TRUE, fig.scap = 'The weighted variance spectrum as a function
 of frequency $
\backslash

\backslash
nu$ for the recovery temperature measured by a Rosemount 102E4AL sensor.',
 fig.cap='The weighted variance spectrum as a function of frequency $
\backslash

\backslash
nu$ for the recovery temperature measured by a Rosemount 102E4AL sensor.
 The spectra for the dynamic-heating term and for the calculated air temperature
 after this correction is applied are also shown.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DS <-
\end_layout

\begin_layout Plain Layout

  getNetCDF('/Data/SOCRATES/SOCRATESrf15h.nc',
\end_layout

\begin_layout Plain Layout

            standardVariables(c('ATF1', 'UXC')),
\end_layout

\begin_layout Plain Layout

            60000,
\end_layout

\begin_layout Plain Layout

            61500)
\end_layout

\begin_layout Plain Layout

rf.txt <- attr(DS$ATF1, 'RecoveryFactor')
\end_layout

\begin_layout Plain Layout

rf <- gsub('mach', 'MACHX', rf.txt)
\end_layout

\begin_layout Plain Layout

rf <- gsub(' log', ' * log', rf)
\end_layout

\begin_layout Plain Layout

rf <- gsub(' 
\backslash

\backslash
(', ' * 
\backslash

\backslash
(', rf)
\end_layout

\begin_layout Plain Layout

rf <- with(DS, eval(parse(text=rf)))
\end_layout

\begin_layout Plain Layout

rf <- SmoothInterp(rf, .Length = 0)
\end_layout

\begin_layout Plain Layout

## RTF1 is not in the netCDF file so recalculate it:
\end_layout

\begin_layout Plain Layout

DS$RTF1 <- DS$ATF1 + rf * DS$TASX^2 / 2010
\end_layout

\begin_layout Plain Layout

DS$TASX <- SmoothInterp(DS$TASX, .Length = 0)
\end_layout

\begin_layout Plain Layout

DS$Q <- rf * DS$TASX ^ 2 / 2010
\end_layout

\begin_layout Plain Layout

DS$ATX <- DS$ATF1  ## Replace ATX, based on ATH1 in netCDF file
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DS$RT <- DS$RTF1
\end_layout

\begin_layout Plain Layout

DS$AT <- DS$ATF1
\end_layout

\begin_layout Plain Layout

# g <-
\end_layout

\begin_layout Plain Layout

#   VSpec(
\end_layout

\begin_layout Plain Layout

#     DS,
\end_layout

\begin_layout Plain Layout

#     'RTF1',
\end_layout

\begin_layout Plain Layout

#     spans = 99,
\end_layout

\begin_layout Plain Layout

#     xlim = c(0.01, 15),
\end_layout

\begin_layout Plain Layout

#     ylim = c(1.e-5, 1.e-1)
\end_layout

\begin_layout Plain Layout

#   )
\end_layout

\begin_layout Plain Layout

# g <- VSpec(DS, 'ATF1', spans = 99, add = g)
\end_layout

\begin_layout Plain Layout

# VSpec(DS, 'Q', spans = 99, add = g) + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

xlim <- c(0.08, 12)
\end_layout

\begin_layout Plain Layout

## Using VSpecC only because it doesn't set scale_x and want to set
\end_layout

\begin_layout Plain Layout

## it specially here:
\end_layout

\begin_layout Plain Layout

DS %>% Rmutate(Tr = RT, Ta = AT) %>%
\end_layout

\begin_layout Plain Layout

       select(Time, TASX, Tr, Ta, Q) %>%
\end_layout

\begin_layout Plain Layout

       VSpecC(VLabel = c('recovery temp.', 'air temp.', 'dynamic heating'),
\end_layout

\begin_layout Plain Layout

             spans = 99, xlim = xlim, ylim=c(1.e-5, 0.03)) +
\end_layout

\begin_layout Plain Layout

       suppressWarnings(
\end_layout

\begin_layout Plain Layout

       scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x, n=2),
 
\end_layout

\begin_layout Plain Layout

                     labels = trans_format("log10", math_format(10^.x))))
 +
\end_layout

\begin_layout Plain Layout

      theme_WAC(1) +
\end_layout

\begin_layout Plain Layout

      theme(legend.position=c(0.75, 0.75),
\end_layout

\begin_layout Plain Layout

      plot.margin=unit(c(0.3,0.3,1.1,1.3),"lines"),
\end_layout

\begin_layout Plain Layout

      legend.background=element_rect(colour='black', size=0.3, fill="ivory"),
\end_layout

\begin_layout Plain Layout

      legend.direction="vertical", 
\end_layout

\begin_layout Plain Layout

      legend.key.width=unit(1.3,'lines'), legend.key.height=unit(0.7,'lines'),
\end_layout

\begin_layout Plain Layout

      legend.text=element_text(size=12)) +
\end_layout

\begin_layout Plain Layout

      guides(colour = guide_legend(reverse = TRUE, '  legend:')) +
\end_layout

\begin_layout Plain Layout

      ylab(bquote('spectral variance ' * nu * 'P(' * nu * ')'))
\end_layout

\begin_layout Plain Layout

DS$AT <- reviseDH(DS, Param1, rf)
\end_layout

\begin_layout Plain Layout

DS$AT <- SmoothInterp(DS$AT, .Length = 0)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:S15}
\end_layout

\end_inset

 illustrates the problem.
 The measurements are from a low-level flight segment over the ocean where
 other indications are reasonably consistent with an inertial sub-range.
 The slope of the temperature variance spectrum would be expected to be
 -5/3 (or -2/3 in this plot where the spectrum is weighted by the frequency).
 The variance spectrum of the measured recovery temperature has a steeper
 slope than this but that would be expected if the time response attenuates
 the signal at higher frequencies.
 However, the variance spectrum for the estimated ambient temperature appears
 to have a substantial amount of high-frequency contamination.
 This matches the high-frequency portion of the spectrum for dynamic heating.
 If the sensor measured the correct recovery temperature its spectrum should
 exceed that of the ambient temperature, as is the case around 0.1 to 0.5
\begin_inset space ~
\end_inset

Hz, so that the subtraction of dynamic heating would produce smaller variance
 in the measured ambient temperature.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Later figures (Figs.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:ATATF}
\end_layout

\end_inset

a and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:ATATF}
\end_layout

\end_inset

b) will show anecdotal examples of the errors introduced by the conventional
 correction.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The transfer function shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:LTsolution}
\end_layout

\end_inset

 indicates that the response to fluctuations at 5
\begin_inset space ~
\end_inset

Hz is only about 50% of the imposed amplitude, and at 10
\begin_inset space ~
\end_inset

Hz the response is only about 35%.
 Furthermore, the phase at 10
\begin_inset space ~
\end_inset

Hz is shifted by about 
\begin_inset Formula $62^{\circ}$
\end_inset

.
 Using the measurement of dynamic heating 
\begin_inset Formula $Q$
\end_inset

 as specified by 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:DHterm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to correct the measured recovery temperature will therefore over-correct
 and produce erroneous fluctuations in the measured air temperature unless
 
\begin_inset Formula $Q$
\end_inset

 is filtered to represent the sensor response.
\end_layout

\begin_layout Standard
Data processing should therefore apply a correction that represents how
 dynamic heating affects the sensor, and that correction should not include
 fluctuations at frequencies to which the sensor does not respond.
 The approach followed here is therefore to use the transfer function to
 characterize the response of an airborne temperature sensor to dynamic
 heating so that only that response is subtracted from the measurement.
 This is made possible by the assumed linearity in response of the sensor,
 which is required if this part of the response is to be separated from
 the more general response to the combination of dynamic heating and true
 fluctuations in temperature.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<LT, include = FALSE, fig.height=3.7, fig.cap = 'The amplitude and phase for
 the frequency domain transfer function of a Rosemount 102E4AL temperature
 sensor.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

frq <- seq(0.01, 25, by = 0.01)
\end_layout

\begin_layout Plain Layout

Phi <- rep(0, length(frq))
\end_layout

\begin_layout Plain Layout

H <- rep(0, length(frq))
\end_layout

\begin_layout Plain Layout

a <- 0.733 # 0.713
\end_layout

\begin_layout Plain Layout

tau1 <- 0.0308  # 0.0335
\end_layout

\begin_layout Plain Layout

tau2 <- 0.447
\end_layout

\begin_layout Plain Layout

zeta <- -atan(2 * pi * frq * tau2)
\end_layout

\begin_layout Plain Layout

b <- cos(zeta)
\end_layout

\begin_layout Plain Layout

Param <- list(
\end_layout

\begin_layout Plain Layout

  a = a,
\end_layout

\begin_layout Plain Layout

  tau1 = tau1,
\end_layout

\begin_layout Plain Layout

  tau2 = tau2,
\end_layout

\begin_layout Plain Layout

  b = b,
\end_layout

\begin_layout Plain Layout

  zeta = zeta,
\end_layout

\begin_layout Plain Layout

  frq = frq
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

Param1 <- Param
\end_layout

\begin_layout Plain Layout

Param3 <- Param
\end_layout

\begin_layout Plain Layout

Param4 <- Param
\end_layout

\begin_layout Plain Layout

Param3$tau1 <- 0.05
\end_layout

\begin_layout Plain Layout

Param4$tau2 <- 0.6
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Use the Laplace-transform solution
\end_layout

\begin_layout Plain Layout

H1 <- LTphase(frq, Param1)
\end_layout

\begin_layout Plain Layout

cTF <- H1$Amp
\end_layout

\begin_layout Plain Layout

phiTF <- H1$Phase
\end_layout

\begin_layout Plain Layout

H3 <- LTphase(frq, Param3)
\end_layout

\begin_layout Plain Layout

cTF3 <- H3$Amp
\end_layout

\begin_layout Plain Layout

phiTF3 <- H3$Phase
\end_layout

\begin_layout Plain Layout

H4 <- LTphase(frq, Param4)
\end_layout

\begin_layout Plain Layout

cTF4 <- H4$Amp
\end_layout

\begin_layout Plain Layout

phiTF4 <- H4$Phase
\end_layout

\begin_layout Plain Layout

dfAP <- data.frame(
\end_layout

\begin_layout Plain Layout

  'Time' = frq,
\end_layout

\begin_layout Plain Layout

  'Amp' = cTF,
\end_layout

\begin_layout Plain Layout

  'Phase' = phiTF
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

Panel2Label <- bquote('   Phase [' * degree ~ ']')
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  ggplotWAC(
\end_layout

\begin_layout Plain Layout

    dfAP,
\end_layout

\begin_layout Plain Layout

    panels = 2,
\end_layout

\begin_layout Plain Layout

    labelP = c(bquote('    ' ~ 'Amplitude'), Panel2Label)
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab(bquote('transfer function H(' * nu
 ~ ')'))
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  g + scale_x_log10(
\end_layout

\begin_layout Plain Layout

    breaks = trans_breaks("log10", function(x)
\end_layout

\begin_layout Plain Layout

      10 ^ x, n = 4),
\end_layout

\begin_layout Plain Layout

    labels = trans_format("log10", math_format(expr = 10 ^ .x))
\end_layout

\begin_layout Plain Layout

  ) + xlab('frequency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = 'tb')
\end_layout

\begin_layout Plain Layout

g + theme_WAC(1) + theme(legend.position = c(0.3, 0.65))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A revised dynamic-heating adjustment filtered to represent how the sensor
 will respond is denoted 
\begin_inset Formula $Q^{\prime}$
\end_inset

.
 When no correction is applied to the measured recovery temperature 
\begin_inset Formula $T_{m}(t)$
\end_inset

, the ambient temperature 
\begin_inset Formula $T_{a}$
\end_inset

 should be estimated from
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
T_{a}(t)=T_{m}(t)-Q^{\prime}(t)\label{eq:QprimeCorr}
\end{equation}

\end_inset

instead of 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:recoveryTemperature"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The appropriate correction can be obtained from the transfer function in
 several ways, as discussed next.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
This revised adjustment can be obtained by using a numerical solution to
 the differential equations in Part 1, using only 
\begin_inset Formula $Q(t)$
\end_inset

 as the input term.
 However, for the high-frequency components numerical integration must be
 done with considerable attention to accuracy, especially for the unheated
 Rosemount sensor because its characteristic time constant for the wire
 response (
\begin_inset Formula $\tau_{1}$
\end_inset

) is smaller than the time interval between typically used 25-Hz samples.
 For this reason, it is preferable to develop an appropriate digital filter
 that matches the transfer function.
 This also leads to much faster processing.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
A filter for dynamic heating
\begin_inset CommandInset label
LatexCommand label
name "subsec:A-filter-for"

\end_inset


\end_layout

\begin_layout Standard
The impulse response of the sensor can be found from the inverse Fourier
 transform of the transfer function.
 Once that is determined, appropriate moving-average coefficients can be
 found from the impulse response, and those coefficients define a digital
 filter that represents the sensor response.
 The filter used here was determined at a frequency resolution of (1/600)
\begin_inset space ~
\end_inset

Hz, then only the initial 101 and trailing 100 coefficients were retained
 and all other were set to zero.
 Shifting the negative-frequency components to the start of the array gave
 an eight-second sequence that represented the response of the sensor.
 These coefficients were used as a moving-average filter, after which the
 result was shifted forward in time by four seconds to compensate for the
 delay.
 The procedure used here is somewhat arbitrary and a better filter could
 probably be designed, but this filter functions reasonably for 25
\begin_inset space ~
\end_inset

Hz measurements.
 
\begin_inset Branch expanded
inverted 0
status open

\begin_layout Standard
Details including the filter coefficients are provided in Appendix B.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Extra
inverted 0
status open

\begin_layout Standard
The procedure was as follows:
\end_layout

\begin_layout Enumerate
Use the response parameters for the sensor (e.g., for the unheated Rosemount
 102E4AL sensor) and a large set of frequencies spanning the interval from
 
\begin_inset Formula $-12.5$
\end_inset

 to 
\begin_inset Formula $12.5$
\end_inset


\begin_inset space ~
\end_inset

Hz, e.g., with resolution between assumed frequencies of (1/600)
\begin_inset space ~
\end_inset

Hz, in the solution specified by 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:TsSolved"
plural "false"
caps "false"
noprefix "false"

\end_inset

–
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:responsePhase"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to specify the transfer function.
 This solution is stored in a vector with frequencies in the order 0–12.5
\begin_inset space ~
\end_inset

Hz, then 
\begin_inset Formula $-12.5$
\end_inset

 to 
\begin_inset Formula $-(1/600)$
\end_inset

 Hz as needed for the Fourier transform.
\end_layout

\begin_layout Enumerate
The inverse Fourier transform then gave the impulse function at 15,000 delays,
 many of them representing negative delays.
 The values in the central part of this array were mostly very small.
\end_layout

\begin_layout Enumerate
To obtain a manageable number of moving-average coefficients, all values
 in the array representing the impulse function were set to zero for indices
 k with values 
\begin_inset Formula $M+2\leq k\leq N-M$
\end_inset

 where 
\begin_inset Formula $N$
\end_inset

 is the length of the calculated impulse function and 
\begin_inset Formula $M=100$
\end_inset

 to leave 201 non-zero coefficients.
 This gave coefficients spanning about 8 s at 25
\begin_inset space ~
\end_inset

Hz, or a time long compared to the expected impulse response of the sensor.
\end_layout

\begin_layout Enumerate
The upper-100 coefficients represent negative delays in the impulse response
 because of the cyclic nature of the Fourier transform, so the coefficients
 were re-arranged into a sequence with the last-100 coefficients first and
 the initial-101 coefficients moved to the end of the array.
 These coefficients were then moving average coefficients that implement
 a filter matching the transfer function, except for some omitted terms
 outside the 200-coefficient range that are assumed negligible.
\end_layout

\begin_layout Enumerate
The resulting set of moving-average coefficients can then be applied to
 the measured dynamic-heating term 
\begin_inset Formula $Q$
\end_inset

 to produce a filtered version.
\end_layout

\begin_layout Enumerate
The filtered result then needs to be shifted in time by 4
\begin_inset space ~
\end_inset

s to correct for the offset in the filter.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<designFilter, include=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

P <- Param1
\end_layout

\begin_layout Plain Layout

NP <- 15000  ## Assume 10-min segment
\end_layout

\begin_layout Plain Layout

df <- 25 / NP
\end_layout

\begin_layout Plain Layout

df1 <- 1 / NP
\end_layout

\begin_layout Plain Layout

frq <- c(seq(0, 12.5, by=df), seq(-12.5+df, -df, by=df))
\end_layout

\begin_layout Plain Layout

frq1 <- c(seq(0, 0.5, by = df1), seq(-0.5+df1, -df1, by = df1))
\end_layout

\begin_layout Plain Layout

NP <- length(frq)
\end_layout

\begin_layout Plain Layout

NP1 <- length(frq1)
\end_layout

\begin_layout Plain Layout

E <- LTphase(frq, P)
\end_layout

\begin_layout Plain Layout

EH <- LTphase(frq, ParamSH)
\end_layout

\begin_layout Plain Layout

EHB <- LTphase(frq, ParamSH)
\end_layout

\begin_layout Plain Layout

EG <- LTphase(frq, ParamSF)
\end_layout

\begin_layout Plain Layout

E1 <- LTphase(frq1, P)
\end_layout

\begin_layout Plain Layout

EH1 <- LTphase(frq1, ParamSH)
\end_layout

\begin_layout Plain Layout

EHB1 <- LTphase(frq1, ParamSH)
\end_layout

\begin_layout Plain Layout

EG1 <- LTphase(frq1, ParamSF)
\end_layout

\begin_layout Plain Layout

## --------------------------
\end_layout

\begin_layout Plain Layout

G <- complex(modulus=E$Amp, argument=E$Phase * pi / 180)
\end_layout

\begin_layout Plain Layout

NG <- length(G)
\end_layout

\begin_layout Plain Layout

GT <- fft(G, inverse=TRUE) / NG  # get the impulse function
\end_layout

\begin_layout Plain Layout

## Limit to 200 coefficients (8 s at 25 Hz)
\end_layout

\begin_layout Plain Layout

Lshift <- 100
\end_layout

\begin_layout Plain Layout

GT[(Lshift + 2):(NP - Lshift)] <- complex(modulus=0)
\end_layout

\begin_layout Plain Layout

GTT <- GT[GT != complex(modulus=0)]
\end_layout

\begin_layout Plain Layout

## Reorder:
\end_layout

\begin_layout Plain Layout

GTT <- c(GTT[(Lshift + 2):length(GTT)], GTT[1:(Lshift + 1)])
\end_layout

\begin_layout Plain Layout

AR <- signal::Arma(Re(GTT) / sum(Re(GTT)), 1) # Normalize to avoid <1% bias
\end_layout

\begin_layout Plain Layout

## --------------------------
\end_layout

\begin_layout Plain Layout

GG <- complex(modulus=EG$Amp, argument=EG$Phase * pi / 180)
\end_layout

\begin_layout Plain Layout

GTG <- fft(GG, inverse=TRUE) / NG  # get the impulse function
\end_layout

\begin_layout Plain Layout

GTG[(Lshift + 2):(NP - Lshift)] <- complex(modulus=0)
\end_layout

\begin_layout Plain Layout

GTTG <- GTG[GTG != complex(modulus=0)]
\end_layout

\begin_layout Plain Layout

## Reorder:
\end_layout

\begin_layout Plain Layout

GTTG <- c(GTTG[(Lshift + 2):length(GTTG)], GTTG[1:(Lshift + 1)])
\end_layout

\begin_layout Plain Layout

ARG <- signal::Arma(Re(GTTG) / sum(Re(GTTG)), 1) # Normalize to avoid <1%
 bias
\end_layout

\begin_layout Plain Layout

## --------------------------
\end_layout

\begin_layout Plain Layout

GH <- complex(modulus=EH$Amp, argument=EH$Phase * pi / 180)
\end_layout

\begin_layout Plain Layout

NG <- length(GH)
\end_layout

\begin_layout Plain Layout

GTH <- fft(GH, inverse=TRUE) / NG  # get the impulse function
\end_layout

\begin_layout Plain Layout

## Limit to 300 coefficients (12 s at 25 Hz)
\end_layout

\begin_layout Plain Layout

LshiftH <- 150
\end_layout

\begin_layout Plain Layout

GTH[(LshiftH + 2):(NP - LshiftH)] <- complex(modulus=0)
\end_layout

\begin_layout Plain Layout

GTTH <- GTH[GTH != complex(modulus=0)]
\end_layout

\begin_layout Plain Layout

## Reorder:
\end_layout

\begin_layout Plain Layout

GTTH <- c(GTTH[(LshiftH + 2):length(GTTH)], GTTH[1:(LshiftH + 1)])
\end_layout

\begin_layout Plain Layout

ARH <- signal::Arma(Re(GTTH) / sum(Re(GTTH)), 1)
\end_layout

\begin_layout Plain Layout

## --------------------------
\end_layout

\begin_layout Plain Layout

GHB <- complex(modulus=EHB$Amp, argument=EHB$Phase * pi / 180)
\end_layout

\begin_layout Plain Layout

NG <- length(GHB)
\end_layout

\begin_layout Plain Layout

GTHB <- fft(GHB, inverse=TRUE) / NG  # get the impulse function
\end_layout

\begin_layout Plain Layout

## Limit to 300 coefficients (12 s at 25 Hz)
\end_layout

\begin_layout Plain Layout

LshiftH <- 150
\end_layout

\begin_layout Plain Layout

GTHB[(LshiftH + 2):(NP - LshiftH)] <- complex(modulus=0)
\end_layout

\begin_layout Plain Layout

GTTHB <- GTHB[GTHB != complex(modulus=0)]
\end_layout

\begin_layout Plain Layout

## Reorder:
\end_layout

\begin_layout Plain Layout

GTTHB <- c(GTTHB[(LshiftH + 2):length(GTTHB)], GTTHB[1:(LshiftH + 1)])
\end_layout

\begin_layout Plain Layout

ARHB <- signal::Arma(Re(GTTHB) / sum(Re(GTTHB)), 1)
\end_layout

\begin_layout Plain Layout

## --------------------------
\end_layout

\begin_layout Plain Layout

G1 <- complex(modulus=E1$Amp, argument=E1$Phase * pi / 180)
\end_layout

\begin_layout Plain Layout

NG1 <- length(G1)
\end_layout

\begin_layout Plain Layout

GT1 <- fft(G1, inverse=TRUE) / NG1  # get the impulse function
\end_layout

\begin_layout Plain Layout

## Limit to 20 coefficients (20 s at 1 Hz)
\end_layout

\begin_layout Plain Layout

Lshift1 <- 10
\end_layout

\begin_layout Plain Layout

GT1[(Lshift1 + 2):(NP1 - Lshift1)] <- complex(modulus=0)
\end_layout

\begin_layout Plain Layout

GTT1 <- GT1[GT1 != complex(modulus=0)]
\end_layout

\begin_layout Plain Layout

## Reorder:
\end_layout

\begin_layout Plain Layout

GTT1 <- c(GTT1[(Lshift1 + 2):length(GTT1)], GTT1[1:(Lshift1 + 1)])
\end_layout

\begin_layout Plain Layout

AR1 <- signal::Arma(Re(GTT1) / sum(Re(GTT1)), 1)
\end_layout

\begin_layout Plain Layout

## --------------------------
\end_layout

\begin_layout Plain Layout

GH1 <- complex(modulus=EH1$Amp, argument=EH1$Phase * pi / 180)
\end_layout

\begin_layout Plain Layout

NG1 <- length(GH1)
\end_layout

\begin_layout Plain Layout

GTH1 <- fft(GH1, inverse=TRUE) / NG1  # get the impulse function
\end_layout

\begin_layout Plain Layout

LshiftH1 <- 10
\end_layout

\begin_layout Plain Layout

GTH1[(LshiftH1 + 2):(NP1 - LshiftH1)] <- complex(modulus=0)
\end_layout

\begin_layout Plain Layout

GTTH1 <- GTH1[GTH1 != complex(modulus=0)]
\end_layout

\begin_layout Plain Layout

GTTH1 <- c(GTTH1[(LshiftH1 + 2):length(GTTH1)], GTTH1[1:(LshiftH1 + 1)])
\end_layout

\begin_layout Plain Layout

ARH1 <- signal::Arma(Re(GTTH1) / sum(Re(GTTH1)), 1)
\end_layout

\begin_layout Plain Layout

## --------------------------
\end_layout

\begin_layout Plain Layout

GHB1 <- complex(modulus=EHB1$Amp, argument=EHB1$Phase * pi / 180)
\end_layout

\begin_layout Plain Layout

NG1 <- length(GHB1)
\end_layout

\begin_layout Plain Layout

GTHB1 <- fft(GHB1, inverse=TRUE) / NG1  # get the impulse function
\end_layout

\begin_layout Plain Layout

LshiftH1 <- 10
\end_layout

\begin_layout Plain Layout

GTHB1[(LshiftH1 + 2):(NP1 - LshiftH1)] <- complex(modulus=0)
\end_layout

\begin_layout Plain Layout

GTTHB1 <- GTHB1[GTHB1 != complex(modulus=0)]
\end_layout

\begin_layout Plain Layout

GTTHB1 <- c(GTTHB1[(LshiftH1 + 2):length(GTTHB1)], GTTHB1[1:(LshiftH1 +
 1)])
\end_layout

\begin_layout Plain Layout

ARHB1 <- signal::Arma(Re(GTTHB1) / sum(Re(GTTHB1)), 1)
\end_layout

\begin_layout Plain Layout

## --------------------------
\end_layout

\begin_layout Plain Layout

GG1 <- complex(modulus=EG1$Amp, argument=EG1$Phase * pi / 180)
\end_layout

\begin_layout Plain Layout

NG1 <- length(GG1)
\end_layout

\begin_layout Plain Layout

GTG1 <- fft(GG1, inverse=TRUE) / NG1  # get the impulse function
\end_layout

\begin_layout Plain Layout

LshiftH1 <- 10
\end_layout

\begin_layout Plain Layout

GTG1[(LshiftH1 + 2):(NP1 - LshiftH1)] <- complex(modulus=0)
\end_layout

\begin_layout Plain Layout

GTTG1 <- GTG1[GTG1 != complex(modulus=0)]
\end_layout

\begin_layout Plain Layout

GTTG1 <- c(GTTG1[(LshiftH1 + 2):length(GTTG1)], GTTG1[1:(LshiftH1 + 1)])
\end_layout

\begin_layout Plain Layout

ARG1 <- signal::Arma(Re(GTTG1) / sum(Re(GTTG1)), 1)
\end_layout

\begin_layout Plain Layout

save(AR, ARH, ARHB, ARG, AR1, ARH1, ARHB1, ARG1, Lshift, LshiftH, Lshift1,
 LshiftH1,
\end_layout

\begin_layout Plain Layout

     file='AR.Rdata')
\end_layout

\begin_layout Plain Layout

## --------------------------
\end_layout

\begin_layout Plain Layout

# DF2$QF <- as.vector(signal::filter(AR, DF2$Q))
\end_layout

\begin_layout Plain Layout

# DF2$QF <- ShiftInTime(DF2$QF, .shift=(-(Lshift + 1) * 40), .rate = 25)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plotImpulse, include=TRUE, fig.height=4>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

layout(matrix(1:2, ncol=1), widths=c(8,8), heights=c(6.5,8))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1, oma=c(1.1,0,0,0))
\end_layout

\begin_layout Plain Layout

dP1 <- data.frame(Time = (1 : 100) * 0.04, R = Re(GT[1:100]), 
\end_layout

\begin_layout Plain Layout

                 H = 10*Re(GTH[1:100]))
\end_layout

\begin_layout Plain Layout

plotWAC(dP1, xlab='Time [s]', ylab='impulse response', lwd = c(2, 2), 
\end_layout

\begin_layout Plain Layout

        lty = c(1, 2), legend.position = NA)
\end_layout

\begin_layout Plain Layout

legend(2, 0.3, legend=c('Rosemount', 'HARCO x 10'), 
\end_layout

\begin_layout Plain Layout

       col=c('blue', 'forestgreen'), lwd=c(2,2), lty=c(1,2))
\end_layout

\begin_layout Plain Layout

abline(h=0, lty=2) 
\end_layout

\begin_layout Plain Layout

text(4, 0.3, labels='(a)', cex=1.5)
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

dP2 <- data.frame(Time = (0 : 200) * 0.04, R = Re(GTT), 
\end_layout

\begin_layout Plain Layout

                 H = 10 * Re(GTTH[51 :251]))
\end_layout

\begin_layout Plain Layout

plotWAC(dP2, xlab='Time [s]', ylab='filter coef.', lwd = c(2, 2), 
\end_layout

\begin_layout Plain Layout

        lty = c(1, 2), legend.position = NA)
\end_layout

\begin_layout Plain Layout

legend(0.5, 0.3, legend=c('Rosemount', 'HARCO x 10'), 
\end_layout

\begin_layout Plain Layout

       col=c('blue', 'forestgreen'), lwd=c(2,2), lty=c(1,2))
\end_layout

\begin_layout Plain Layout

abline(h=0, lty=2)
\end_layout

\begin_layout Plain Layout

text(8, 0.3, labels='(b)', cex=1.5)
\end_layout

\begin_layout Plain Layout

layout(matrix(1:1, ncol=1), widths=c(8), heights=c(5.5))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
The impulse response function found from the inverse Fourier transform of
 the transfer function for the unheated Rosemount 102E4AL sensor and for
 the heated HARCO sensor , and the filter functions determined from those
 impulse response functions.
\end_layout

\end_inset

(a) The impulse response function found from the inverse Fourier transform
 of the transfer function for the unheated Rosemount 102E4AL sensor (Rosemount)
 and for the heated HARCO sensor (HARCO), using the response parameters
 from Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Parameters"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The impulse response for the HARCO sensor is multiplied by 10.
\begin_inset Newline newline
\end_inset

(b) A filter function (moving-average coefficients spanning 8 s) obtained
 from the impulse response function.
 The filtered result must be shifted forward in time by 4 s to compensate
 for the delay introduced by the filter.
 The coefficients are multiplied by 10 for the HARCO sensor.
\begin_inset CommandInset label
LatexCommand label
name "fig:plotImpulse"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:plotImpulse}
\end_layout

\end_inset

a shows the impulse function for the unheated Rosemount and heated HARCO
 sensors, and Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:plotImpulse}
\end_layout

\end_inset

b shows corresponding moving-average coefficients for a filter obtained
 from this impulse function.
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
It would be useful to check if the causal filter from only the coefficients
 shown in the first figure performs adequately, because that could be implemente
d in sequential processing.
\end_layout

\end_inset

 – checked this; doesn't work
\end_layout

\end_inset

 There is significant ringing in the filter for the Rosemount sensor because
 the shorter time constant for the sensor, 0.03
\begin_inset space ~
\end_inset

s, is smaller than the time between 25-Hz samples.
 The impulse response for the slower HARCO sensor leads to a much broader
 impulse response function.
 Both sets of moving-average coefficients sum to more than 0.99 as calculated
 but were then normalized to sum to 1.0.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\lang english
The result obtained by using this filter for measurements from the unheated
 Rosemount 102E4AL sensor is illustrated in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:Integration}
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Other filtering methods
\end_layout

\begin_layout Standard
Two other calculations can produce the appropriately filtered response to
 dynamic heating 
\begin_inset Formula $Q^{\prime}(t)$
\end_inset

:
\end_layout

\begin_layout Enumerate
Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:theTransferFn"
plural "false"
caps "false"
noprefix "false"

\end_inset

 showed that the transfer function is represented reasonably by the solution
 to two coupled differential equations.
 Numerical integration of those equations can then produce the predicted
 response of the sensor to dynamic heating.
 The equations from Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Theory"
plural "false"
caps "false"
noprefix "false"

\end_inset

, revised to apply to dynamic heating, are these:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\frac{dQ_{qs}(t)}{dt}=\frac{Q(t)-Q_{qs}(t)}{\tau_{2}}\label{eq:Ts-1}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
\frac{dQ^{\prime}(t)}{dt}=\frac{\left\{ aQ(t)+(1-a)Q_{qs}(t)\right\} -Q^{\prime}(t)}{\tau_{1}}\label{eq:Tm-1}
\end{equation}

\end_inset

where the first equation describes the effect of dynamic heating on the
 support structure of the temperature sensor, leading to support-structure
 variations in temperature of 
\begin_inset Formula $Q_{qs}(t).$
\end_inset

 and the second describes the response of the sensing wire to the combined
 effects of this influence on the support temperature and the dynamic-heating
 term.
 This separation relies on the linearity of the underlying equations, which
 makes it possible to represent the effect of dynamic heating in isolation
 from real fluctuations in temperature.
 Euler integration of these differential equations led to erroneous results
 at high frequency arising from inadequate resolution in the integration,
 so a fourth-order Runge-Kutta integration
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The integration method was fourth-order Runge-Kutta with adjustment of the
 time step to control the estimated tolerance during the integration.
 The method was based on 
\begin_inset CommandInset citation
LatexCommand citet
key "cash1990variable"
literal "false"

\end_inset

.
 The integration was also tested with the R routine 
\begin_inset Quotes eld
\end_inset

rmutil::runge.kutta
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand citet
key "runge.kutta"
literal "false"

\end_inset

.
 See the Workflow document for additional details.
\end_layout

\end_inset

 
\end_layout

\end_inset

 with dynamic adjustment of the time step, as described by 
\begin_inset CommandInset citation
LatexCommand citet
key "cash1990variable"
literal "false"

\end_inset

, was used.
\end_layout

\begin_layout Enumerate
The response specified by the frequency-domain transfer function 
\begin_inset Formula $H(\nu)$
\end_inset

 can be realized by Fourier transforms, by first calculating the Fourier
 transform of the dynamic-heating signal (here denoted 
\begin_inset Formula $\hat{Q}(\nu)=\mathcal{F}(Q(t))$
\end_inset

 where 
\begin_inset Formula $\mathcal{F}$
\end_inset

 denotes the Fourier transform) and then using the inverse Fourier transform
 (
\begin_inset Formula $\mathcal{F}^{-1}$
\end_inset

) to estimate the sensor response:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
Q^{\prime}(t)=\mathcal{F}^{-1}(H(\nu)\hat{Q}(\nu))
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
(Data from SOCRATES flight 15, 6:02:00 to 6:13:00 UTC.)
\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<Integration, include=TRUE, echo=FALSE, fig.width=4.1, out.width='0.48
\backslash

\backslash
linewidth', fig.show='hold', messages = FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# DS is the data.frame, which includes Q
\end_layout

\begin_layout Plain Layout

a <- ParamSF$a
\end_layout

\begin_layout Plain Layout

tau1 <- ParamSF$tau1
\end_layout

\begin_layout Plain Layout

tau2 <- ParamSF$tau2
\end_layout

\begin_layout Plain Layout

DS$RT <- DS$RTF1
\end_layout

\begin_layout Plain Layout

DS$TsQ <- DS$RT
\end_layout

\begin_layout Plain Layout

DS$Qp <- DS$Q
\end_layout

\begin_layout Plain Layout

Rate <- attr (DS, 'Rate')
\end_layout

\begin_layout Plain Layout

fS <- function(y, i) {
\end_layout

\begin_layout Plain Layout

  (DS$Q[i] - y) / (Rate * tau2)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

fM <- function (y, i) {
\end_layout

\begin_layout Plain Layout

  (a * DS$Q[i] + (1 - a) * DS$TsQ[i] - y) / (Rate * tau1)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

DS$TsQ <- rk4.integrate (fS, DS$Q[1], 1:nrow(DS))
\end_layout

\begin_layout Plain Layout

DS$Qp <- rk4.integrate (fM, DS$Q[1], 1:nrow(DS))
\end_layout

\begin_layout Plain Layout

DS$QF <- as.vector(signal::filter(ARG, DS$Q))
\end_layout

\begin_layout Plain Layout

DS$QF <- ShiftInTime(DS$QF, .shift=-Lshift * 40, .rate=25)
\end_layout

\begin_layout Plain Layout

ft <- fft(DS$Q[1:(nrow(DS)-1)])
\end_layout

\begin_layout Plain Layout

df <- 25 / length(ft)
\end_layout

\begin_layout Plain Layout

frq <- c(0, seq(df, 12.5, by = df), seq(-12.5 + df, -df, by = df))
\end_layout

\begin_layout Plain Layout

ATF <- LTphase(frq, ParamSF)
\end_layout

\begin_layout Plain Layout

H <- complex(modulus = ATF$Amp, argument = ATF$Phase * pi / 180)
\end_layout

\begin_layout Plain Layout

ftq <- ft * H
\end_layout

\begin_layout Plain Layout

DS$Qft <- c(Re(fft(ftq, inverse=TRUE) / length(ft)), 0)
\end_layout

\begin_layout Plain Layout

DS$Qft[nrow(DS)] <- mean(DS$Qft, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

g <- DS %>% selectTime(60200, 61300) %>% 
\end_layout

\begin_layout Plain Layout

            select(Time, TASX, Q, QF, Qft) %>% 
\end_layout

\begin_layout Plain Layout

            VSpecC(VLabel=c('Q', 'filter', 'FFT'), spans = 151,
\end_layout

\begin_layout Plain Layout

            xlim = xlim, ylim = c(1.e-5, 0.008))
\end_layout

\begin_layout Plain Layout

g <- VSpecC(DS, 'Qp', VLabel='DiffEq', spans = 151, add = g) + theme_WAC(1)
 +
\end_layout

\begin_layout Plain Layout

       annotate('text', x=8, y=0.002, label='(a)', size=5) +
\end_layout

\begin_layout Plain Layout

       suppressWarnings(
\end_layout

\begin_layout Plain Layout

       scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x, n=2),
 
\end_layout

\begin_layout Plain Layout

                     labels = trans_format("log10", math_format(10^.x))))
 +
\end_layout

\begin_layout Plain Layout

       theme(legend.text=element_text(size=11))
\end_layout

\begin_layout Plain Layout

suppressWarnings(print(g))
\end_layout

\begin_layout Plain Layout

# g <- VSpec(DS, 'Q', ylim = c(1.e-6, 0.1))
\end_layout

\begin_layout Plain Layout

# g <- VSpec(DS, 'QF', add = g)
\end_layout

\begin_layout Plain Layout

# VSpec(DS, 'Qp', add = g) + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

DS$AT <- DS$RT - DS$QF
\end_layout

\begin_layout Plain Layout

g2 <- DS %>% select(Time, TASX, AT, RT, ATF1) %>%
\end_layout

\begin_layout Plain Layout

       VSpecC(VLabel = c('air temp.
 with filt.
 Q', 'msrd recovery temp.',
\end_layout

\begin_layout Plain Layout

                        'air temp.
 with std.
 Q'), spans = 151,
\end_layout

\begin_layout Plain Layout

             xlim = xlim, ylim = c(1.e-5, 0.05)) +
\end_layout

\begin_layout Plain Layout

       annotate('text', x=0.1, y=0.02, label='(b)', size=5) +
\end_layout

\begin_layout Plain Layout

       suppressWarnings(
\end_layout

\begin_layout Plain Layout

       scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x, n=2),
 
\end_layout

\begin_layout Plain Layout

                     labels = trans_format("log10", math_format(10^.x))))
 +
\end_layout

\begin_layout Plain Layout

       theme_WAC(1) +
\end_layout

\begin_layout Plain Layout

      theme(legend.position=c(0.65, 0.75),
\end_layout

\begin_layout Plain Layout

      plot.margin=unit(c(0.3,0.3,1.1,1.3),"lines"),
\end_layout

\begin_layout Plain Layout

      legend.background=element_rect(colour='black', size=0.3, fill="ivory"),
\end_layout

\begin_layout Plain Layout

      legend.direction="vertical", 
\end_layout

\begin_layout Plain Layout

      legend.key.width=unit(1.3,'lines'), legend.key.height=unit(0.7,'lines'),
\end_layout

\begin_layout Plain Layout

      legend.text=element_text(size=12)) +
\end_layout

\begin_layout Plain Layout

      guides(colour = guide_legend(reverse = TRUE, '  legend:')) +
\end_layout

\begin_layout Plain Layout

      ylab(bquote('spectral variance ' * nu * 'P(' * nu * ')'))
\end_layout

\begin_layout Plain Layout

  suppressWarnings(print(g2))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
For an unheated Rosemount 102E4AL sensor, variance spectra for the dynamic-heati
ng term after application of three different filters.
 Also, variance spectra for the measurement of recovery temperature and
 ambient temperature calculated using the filtered dynamic-heating term.
 
\end_layout

\end_inset

Variance spectra for the unheated Rosemount 102E4AL sensor, for the same
 flight segment used for Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:S15}
\end_layout

\end_inset

.
\begin_inset Newline newline
\end_inset

Left, (a): The dynamic-heating term (
\begin_inset Quotes eld
\end_inset

Q:) and for the filtered term obtained by integrating the differential equations
 for the derivatives (
\begin_inset Quotes eld
\end_inset

DiffEq
\begin_inset Quotes erd
\end_inset

), by Fourier transformation with application of the transfer function (
\begin_inset Quotes eld
\end_inset

FFT
\begin_inset Quotes erd
\end_inset

), or applying the digital filter (
\begin_inset Quotes eld
\end_inset

filter
\begin_inset Quotes erd
\end_inset

).
 The result for the latter is so close to that for 
\begin_inset Quotes eld
\end_inset

FFT
\begin_inset Quotes erd
\end_inset

 that it is obscured in this plot.
\begin_inset Newline newline
\end_inset

Right, (b): The measurement of recovery temperature and ambient temperature
 calculated using the filtered dynamic-heating term.
 The original variable for ambient temperature based on standard processing
 is also shown.
\begin_inset CommandInset label
LatexCommand label
name "fig:Integration"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<revisedT, include=TRUE, echo=FALSE, fig.pos='pt', fig.cap='Variance spectra
 for the measurement of recovery temperature from the unheated Rosemount
 102E4AL sensor and for the ambient temperature calculated using the filtered
 dynamic-heating term.
 The original variable for ambient temperature based on standard processing
 is also shown.
 The flight segment is the same as used for Fig.
\backslash

\backslash
 7.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DS$AT <- DS$RT - DS$QF
\end_layout

\begin_layout Plain Layout

DS %>% select(Time, TASX, AT, RT, ATF1) %>%
\end_layout

\begin_layout Plain Layout

       VSpec(VLabel = c('air temp.
 with filt.
 Q', 'msrd recovery temp.',
\end_layout

\begin_layout Plain Layout

                        'air temp.
 with std.
 Q'), 
\end_layout

\begin_layout Plain Layout

             xlim = xlim, ylim = c(1.e-5, 0.05)) +
\end_layout

\begin_layout Plain Layout

       theme_WAC(1) +
\end_layout

\begin_layout Plain Layout

      theme(legend.position=c(0.75, 0.75),
\end_layout

\begin_layout Plain Layout

      plot.margin=unit(c(0.3,0.3,1.1,1.3),"lines"),
\end_layout

\begin_layout Plain Layout

      legend.background=element_rect(colour='black', size=0.3, fill="ivory"),
\end_layout

\begin_layout Plain Layout

      legend.direction="vertical", 
\end_layout

\begin_layout Plain Layout

      legend.key.width=unit(1.3,'lines'), legend.key.height=unit(0.7,'lines'),
\end_layout

\begin_layout Plain Layout

      legend.text=element_text(size=12)) +
\end_layout

\begin_layout Plain Layout

      guides(colour = guide_legend(reverse = TRUE, '  legend:')) +
\end_layout

\begin_layout Plain Layout

      ylab(bquote('spectral variance ' * nu * 'P(' * nu * ')'))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:Integration}
\end_layout

\end_inset

a shows the variance spectra that result from all three methods when applied
 to measurements from an unheated Rosemount 102E4AL sensor.
 The modified variance spectrum obtained by integration of the underlying
 differential equations is shown as the orange line (
\begin_inset Quotes eld
\end_inset

DiffEq
\begin_inset Quotes erd
\end_inset

) in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:Integration}
\end_layout

\end_inset

a.
 The dynamic-heating correction is appropriately attenuated at high frequency
 after this integration.
 The results obtained after filtering as described in the Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:A-filter-for"
plural "false"
caps "false"
noprefix "false"

\end_inset

, labeled 
\begin_inset Quotes eld
\end_inset

filter
\begin_inset Quotes erd
\end_inset

, or after Fourier transformation, labeled 
\begin_inset Quotes eld
\end_inset

FFT
\begin_inset Quotes erd
\end_inset

, are overlapping so as to be indistinguishable in this plot.
 These corrected estimates of the dynamic heating are attenuated even more
 than the result from numerical integration and are in better agreement
 with the predicted effect of the transfer function, which for example predicts
 attenuation of the variance spectrum by a factor of 0.096 for the component
 with frequency 10
\begin_inset space ~
\end_inset

Hz.
 The numerical integration was closer to the results of the filter if the
 measurements are interpolated to 125
\begin_inset space ~
\end_inset

Hz with 25-Hz smoothing, integrated, and then resampled to obtain 25
\begin_inset space ~
\end_inset

Hz measurements.
 This indicated that the discrepancy in results is attributable to accumulating
 numerical errors in the integration, but the integration became awkwardly
 slow when performed at 125-Hz resolution.
 The equivalence of the results from the digital filter and from Fourier
 transformation with application of the transfer function supports the validity
 of these results and suggests that these are preferable and equivalent
 methods for filtering dynamic heating to match the response of the temperature
 sensor.
\begin_inset Note Note
status open

\begin_layout Plain Layout
An advantage of this integration method is that it could be applied using
 only present and past measurements and so is suited to the sequential processin
g used for NCAR/RAF data processing.
 As used here, however, a center estimate of the derivative is used and
 that requires knowledge of the value of 
\begin_inset Formula $Q$
\end_inset

 one second ahead of the reference time.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A revised estimate of the ambient air temperature was calculated using 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:QprimeCorr"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and the corrected dynamic-heating term 
\begin_inset Formula $Q^{\prime}$
\end_inset

.
 The spectral variance for this air temperature, shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:Integration}
\end_layout

\end_inset

b as the blue line, is improved considerably at high frequency vs.
\begin_inset space ~
\end_inset

that using the standard correction.
\end_layout

\begin_layout Standard

\lang english
\begin_inset ERT
status open

\begin_layout Plain Layout

<<WECANX, include=TRUE, echo=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DWECAN <- getNetCDF('/Data/WECAN/WECANrf17h.nc', standardVariables(c('RTH1',
\end_layout

\begin_layout Plain Layout

                    'ATH1', 'RTF1', 'ATF1')), 180400, 183500)   # 182600,182900)
\end_layout

\begin_layout Plain Layout

DWECAN$Q <- DWECAN$TASX^2 / 2010
\end_layout

\begin_layout Plain Layout

SB <- 50
\end_layout

\begin_layout Plain Layout

Z <- capture.output (Vr <- SmoothInterp(detrend (DWECAN[, c('Time', 'RTH1')]),
 .Length=0))
\end_layout

\begin_layout Plain Layout

Z <- capture.output (VrC <- SmoothInterp(detrend (DWECAN[, c('Time', 'Q')]),
 .Length=0))
\end_layout

\begin_layout Plain Layout

Rate <- attr(DWECAN, 'Rate')
\end_layout

\begin_layout Plain Layout

vcv <- cbind(ts(Vr, frequency=Rate), ts(VrC, frequency=Rate))
\end_layout

\begin_layout Plain Layout

P <- spec.pgram(vcv, detrend=FALSE, fast=TRUE, plot=FALSE, spans=25)
\end_layout

\begin_layout Plain Layout

dfH <- data.frame(P$coh, log(P$freq))
\end_layout

\begin_layout Plain Layout

pfH <- binStats (dfH, bins=SB)
\end_layout

\begin_layout Plain Layout

RXH <- CohP(DWECAN, 'RTH1', 'Q', plotType='Ranadu', smoothBins=SB)
\end_layout

\begin_layout Plain Layout

phaseH <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

nphaseH <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

phase2H <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

arH <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

ar2H <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

narH <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

RXH$P.spec...1.[RXH$P.spec...1.
 < 0] <- 0
\end_layout

\begin_layout Plain Layout

for (i in 2:nrow(RXH)) {
\end_layout

\begin_layout Plain Layout

  phaseH[RXH$BIN.1[i]] <- phaseH[RXH$BIN.1[i]]+RXH$P.phase[i]
\end_layout

\begin_layout Plain Layout

  nphaseH[RXH$BIN.1[i]] <- nphaseH[RXH$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

  phase2H[RXH$BIN.1[i]] <- phase2H[RXH$BIN.1[i]]+RXH$P.phase[i]^2 
\end_layout

\begin_layout Plain Layout

  arH[RXH$BIN.1[i]] <- arH[RXH$BIN.1[i]] + 
\end_layout

\begin_layout Plain Layout

             sqrt(RXH$P.spec...1.[i] / RXH$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

  ar2H[RXH$BIN.1[i]] <- ar2H[RXH$BIN.1[i]] + 
\end_layout

\begin_layout Plain Layout

             (RXH$P.spec...1.[i] / RXH$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

  narH[RXH$BIN.1[i]] <- narH[RXH$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

narH[narH <= 0] <- 1
\end_layout

\begin_layout Plain Layout

nphaseH[nphaseH == 0] <- 1
\end_layout

\begin_layout Plain Layout

mphaseH <- phaseH/nphaseH
\end_layout

\begin_layout Plain Layout

mphase2H <- phase2H/nphaseH
\end_layout

\begin_layout Plain Layout

sdpH <- sqrt(mphase2H - mphaseH^2)
\end_layout

\begin_layout Plain Layout

mphaseH <- mphaseH * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpH <- sdpH * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpH <- sdpH * 2 / sqrt(nphaseH)
\end_layout

\begin_layout Plain Layout

arH <- arH / narH
\end_layout

\begin_layout Plain Layout

ar2H <- ar2H / narH
\end_layout

\begin_layout Plain Layout

sdrH <- sqrt(ar2H - arH^2)
\end_layout

\begin_layout Plain Layout

sdrH <- sdrH * 2 / sqrt(narH)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In the case of the heated sensors, the revision is still more significant
 because they respond more slowly.
 Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:HarcoQ}
\end_layout

\end_inset

a shows the result of filtering the dynamic-heating term for a heated HARCO
 sensor.
 The result of integration (
\begin_inset Quotes eld
\end_inset

DiffEq
\begin_inset Quotes erd
\end_inset

) and the digital filter (
\begin_inset Quotes eld
\end_inset

filter
\begin_inset Quotes erd
\end_inset

) are almost identical so there is no evidence of the numerical problems
 that were encountered with the integration for the unheated Rosemount sensor.
 The difference vs.
\begin_inset space ~
\end_inset

the original is quite dramatic even at 1
\begin_inset space ~
\end_inset

Hz, and the errors are significant for all frequencies above about 0.1
\begin_inset space ~
\end_inset

Hz.
 Because either corrected variance spectrum represents how the temperature
 sensor responds to the actual fluctuations, subtracting the actual fluctuations
 in dynamic heating instead of the filtered fluctuations introduces substantial
 erroneous variability into the calculated air temperature.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<HarcoQ, include=TRUE, echo=FALSE, fig.height=3.5, fig.width=4.1, out.width='0.48
\backslash

\backslash
linewidth', fig.show='hold', messages = FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

a <- 0.733
\end_layout

\begin_layout Plain Layout

tau1 <- 0.299
\end_layout

\begin_layout Plain Layout

tau2 <- 0.433
\end_layout

\begin_layout Plain Layout

DWECAN$RT <- SmoothInterp(DWECAN$RTH1, .Length = 0)
\end_layout

\begin_layout Plain Layout

DWECAN$TsQ <- DWECAN$RT
\end_layout

\begin_layout Plain Layout

DWECAN$Q <- SmoothInterp(DWECAN$Q, .Length = 0)  ## avoid missing values
\end_layout

\begin_layout Plain Layout

Rate <- attr (DWECAN, 'Rate')
\end_layout

\begin_layout Plain Layout

rhozero <- 1013.25 * 100 / (287.05 * 288.15)
\end_layout

\begin_layout Plain Layout

MRHO <- MachNumber(DWECAN$PSXC, DWECAN$QCXC) * DWECAN$PSXC * 100 /
\end_layout

\begin_layout Plain Layout

                  (287.05 * (273.15 + DWECAN$ATX)) / rhozero
\end_layout

\begin_layout Plain Layout

MRHO <- SmoothInterp(MRHO, .Length=0)
\end_layout

\begin_layout Plain Layout

a <- ParamSH$a
\end_layout

\begin_layout Plain Layout

tau1 <- ParamSH$tau1 * (MRHO / 0.3) ^ 0.6  ## Note that these are variable
\end_layout

\begin_layout Plain Layout

tau2 <- ParamSH$tau2 * (MRHO / 0.3) ^ 0.6
\end_layout

\begin_layout Plain Layout

Rate <- attr (DWECAN, 'Rate')
\end_layout

\begin_layout Plain Layout

DWECAN$TsQ <- DWECAN$Q
\end_layout

\begin_layout Plain Layout

DWECAN$Qp <- DWECAN$Q
\end_layout

\begin_layout Plain Layout

fS <- function(y, i) {
\end_layout

\begin_layout Plain Layout

  (DWECAN$Q[i] - y) / (Rate * tau2[i])
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

fM <- function (y, i) {
\end_layout

\begin_layout Plain Layout

  (a * DWECAN$Q[i] + (1 - a) * DWECAN$TsQ[i] - y) / (Rate * tau1[i])
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

DWECAN$TsQ <- rk4.integrate (fS, DWECAN$Q[1], 1:nrow(DWECAN))
\end_layout

\begin_layout Plain Layout

DWECAN$Qp <- rk4.integrate (fM, DWECAN$Q[1], 1:nrow(DWECAN))
\end_layout

\begin_layout Plain Layout

DWECAN$QF <- as.vector(signal::filter(ARH, DWECAN$Q))
\end_layout

\begin_layout Plain Layout

DWECAN$QF <- ShiftInTime(DWECAN$QF, .shift=-LshiftH * 40, .rate=25)
\end_layout

\begin_layout Plain Layout

DWECAN %>% select(Time, TASX, Q, QF, Qp) %>% 
\end_layout

\begin_layout Plain Layout

           VSpecC(VLabel=c('Q', 'filter', 'DiffEq'), 
\end_layout

\begin_layout Plain Layout

                 xlim = xlim, ylim=c(1.e-6,0.8)) +
\end_layout

\begin_layout Plain Layout

       annotate('text', x=0.1, y=0.05, label='(a)', size=5) +
\end_layout

\begin_layout Plain Layout

       suppressWarnings(
\end_layout

\begin_layout Plain Layout

       scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x, n=2),
 
\end_layout

\begin_layout Plain Layout

                     labels = trans_format("log10", math_format(10^.x))))
 +
\end_layout

\begin_layout Plain Layout

           theme_WAC(1) + theme(legend.text=element_text(size=12))
\end_layout

\begin_layout Plain Layout

DWECAN$AT <- DWECAN$RT - DWECAN$QF
\end_layout

\begin_layout Plain Layout

g <- DWECAN %>% select(Time, TASX, AT, RTH1, ATH1) %>%
\end_layout

\begin_layout Plain Layout

      VSpecC(VLabel = c('air temp.
 with filt.
 Q', 'msrd recovery temp.',
\end_layout

\begin_layout Plain Layout

                       'air temp.
 with std.
 Q'), 
\end_layout

\begin_layout Plain Layout

                       xlim = xlim, ylim = c(1.e-6, 0.8)) +
\end_layout

\begin_layout Plain Layout

       annotate('text', x=0.1, y=0.1, label='(b)', size=5) +
\end_layout

\begin_layout Plain Layout

       suppressWarnings(
\end_layout

\begin_layout Plain Layout

       scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x, n=2),
 
\end_layout

\begin_layout Plain Layout

                     labels = trans_format("log10", math_format(10^.x))))
 +
\end_layout

\begin_layout Plain Layout

       theme_WAC(1) +
\end_layout

\begin_layout Plain Layout

      theme(legend.position=c(0.65, 0.8),
\end_layout

\begin_layout Plain Layout

      plot.margin=unit(c(0.3,0.3,1.1,1.3),"lines"),
\end_layout

\begin_layout Plain Layout

      legend.background=element_rect(colour='black', size=0.3, fill="ivory"),
\end_layout

\begin_layout Plain Layout

      legend.direction="vertical", 
\end_layout

\begin_layout Plain Layout

      legend.key.width=unit(1.3,'lines'), legend.key.height=unit(0.7,'lines'),
\end_layout

\begin_layout Plain Layout

      legend.text=element_text(size=12)) +
\end_layout

\begin_layout Plain Layout

      guides(colour = guide_legend('  legend:')) +
\end_layout

\begin_layout Plain Layout

      ylab(bquote('spectral variance ' * nu * 'P(' * nu * ')'))
\end_layout

\begin_layout Plain Layout

suppressWarnings(print(g))
\end_layout

\begin_layout Plain Layout

# g <- VSpec(DWECAN, 'AT', ylim = c(1.e-6, 0.1))
\end_layout

\begin_layout Plain Layout

# g <- VSpec(DWECAN, 'ATH1', add = g)
\end_layout

\begin_layout Plain Layout

# # g <- VSpec(DWECAN, 'RTH1', add = g)
\end_layout

\begin_layout Plain Layout

# suppressWarnings(print (VSpec (DWECAN, 'RTH1', add = g) + theme_WAC(1)
 + 
\end_layout

\begin_layout Plain Layout

# theme(legend.position = c(0.75, 0.93))))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Variance spectra for the heated HARCO sensor: The unmodified dynamic-heating
 term and two filtered terms.
 Also, the air temperature as modified by filtering the dynamic-heating
 term.
\end_layout

\end_inset

Variance spectra for the heated HARCO sensor.
\begin_inset Newline newline
\end_inset

Left, (a): The unmodified dynamic-heating term (
\begin_inset Quotes eld
\end_inset

Q
\begin_inset Quotes erd
\end_inset

) and the two filtered terms.
 The results from solving the differential equations (
\begin_inset Quotes eld
\end_inset

DiffEq
\begin_inset Quotes erd
\end_inset

) or from application of the digital filter (
\begin_inset Quotes eld
\end_inset

filter
\begin_inset Quotes erd
\end_inset

) are overlapping and indistiguishable in this figure.
\begin_inset Newline newline
\end_inset

Right, (b): The air temperature as modified by filtering the dynamic-heating
 term (blue line).
 The other plotted spectra are for the measured recovery temperature and
 the air temperature with the conventional dynamic-heating correction.
\begin_inset CommandInset label
LatexCommand label
name "fig:HarcoQ"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:HarcoQ}
\end_layout

\end_inset

b shows how this affects the spectral variance of the measured air temperature.
 The slow response of this sensor causes the measured recovery temperature
 (green line) to have very low spectral variance when the frequency is above
 1
\begin_inset space ~
\end_inset

Hz, so the variance in the standard air-temperature measurement in this
 frequency range is almost entirely caused by erroneous adjustment for fluctuati
ons in dynamic heating to which the sensor does not respond.
 The correction procedure using a filtered dynamic-heating correction removes
 this excess spectral variance and produces a signal where the variance
 for frequencies above about 0.1
\begin_inset space ~
\end_inset

Hz arises primarily from variance in the measured recovery temperature.
 The variance spectrum for the conventionally processed temperature looks
 approximately as might be expected in an inertial subrange, but the variance
 above about 0.5
\begin_inset space ~
\end_inset

Hz is a false signal that does not arise from real variance in temperature.
 It therefore becomes very important to use this revised processing scheme
 to avoid erroneous measurements even for changes occurring over 5
\begin_inset space ~
\end_inset

s or more.
 The reasonable appearance of the variance spectrum for the standard result
 is misleading because the measurement is not responding to real fluctuations
 in air temperature at high frequency.
 The measurement with filtered dynamic heating is a better indication of
 the measured fluctuations.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
after 8:01:00 UTC for VOCALS flight 3
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<ATATF, include=TRUE, echo=FALSE, fig.height=3,  fig.width=4.1, out.width='0.48
\backslash

\backslash
linewidth', fig.show='hold', messages = FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if (file.exists ('./DVOCALS.Rdata')) {
\end_layout

\begin_layout Plain Layout

  load (file = './DVOCALS.Rdata')
\end_layout

\begin_layout Plain Layout

  DVOCALS <- D
\end_layout

\begin_layout Plain Layout

  DVOCALS$ATC <- DVOCALS$AT
\end_layout

\begin_layout Plain Layout

  DVOCALS$original <- DVOCALS$ATRR
\end_layout

\begin_layout Plain Layout

  DVOCALS$corrected <- DVOCALS$ATC
\end_layout

\begin_layout Plain Layout

  ga <- DVOCALS %>% select(Time, original, corrected) %>% 
\end_layout

\begin_layout Plain Layout

    selectTime(80100, 80104) %>% 
\end_layout

\begin_layout Plain Layout

    ggplotWAC(lwd = c(0.6, 1.4), legend.position = c(0.5, 0.25)) +
\end_layout

\begin_layout Plain Layout

    ylab(bquote('temperature [' * degree * 'C]')) +
\end_layout

\begin_layout Plain Layout

    xlab('time [s]') +
\end_layout

\begin_layout Plain Layout

    theme(legend.direction="vertical") + 
\end_layout

\begin_layout Plain Layout

    guides(color=guide_legend("air T:"), size = guide_legend("air T:"),
\end_layout

\begin_layout Plain Layout

           linetype = guide_legend(
\begin_inset Quotes eld
\end_inset

air T:
\begin_inset Quotes erd
\end_inset

))
\end_layout

\begin_layout Plain Layout

    print (ga + annotate('text', x = DVOCALS$Time[getIndex(DVOCALS, 80100)]
 + 0.4, y=15.092, label='(a)', size=5))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

DWECAN$MACHX <- SmoothInterp (DWECAN$MACHX, .Length = 0)
\end_layout

\begin_layout Plain Layout

DWECAN$ATH1 <- SmoothInterp (DWECAN$ATH1, .Length = 0)
\end_layout

\begin_layout Plain Layout

alphaR2 <-
\end_layout

\begin_layout Plain Layout

  0.988 + 0.053 * log10(DWECAN$MACHX) +
\end_layout

\begin_layout Plain Layout

  0.090 * (log10(DWECAN$MACHX)) ^ 2 +
\end_layout

\begin_layout Plain Layout

  0.091 * (log10(DWECAN$MACHX)) ^ 3
\end_layout

\begin_layout Plain Layout

DWECAN$corrected <- DWECAN$ATH1 + alphaR2 * (DWECAN$Q - DWECAN$Qp)
\end_layout

\begin_layout Plain Layout

DWECAN$original <- DWECAN$ATH1
\end_layout

\begin_layout Plain Layout

gb <- DWECAN %>% select(Time, original, corrected) %>%
\end_layout

\begin_layout Plain Layout

  selectTime(181300, 181320) %>%
\end_layout

\begin_layout Plain Layout

  ggplotWAC(lwd = c(0.6, 1.4), legend.position = c(0.5, 0.75)) + 
\end_layout

\begin_layout Plain Layout

    ylab(bquote('temperature [' * degree * 'C]')) +
\end_layout

\begin_layout Plain Layout

    xlab('time [s]') + theme(legend.direction='vertical') + 
\end_layout

\begin_layout Plain Layout

    guides(color=guide_legend("air T:"), size = guide_legend("air T:"),
\end_layout

\begin_layout Plain Layout

           linetype = guide_legend(
\begin_inset Quotes eld
\end_inset

air T:
\begin_inset Quotes erd
\end_inset

))
\end_layout

\begin_layout Plain Layout

print(gb + annotate('text', x = DWECAN$Time[getIndex(DWECAN, 181300)] +
 4.2, y=17.12, label='(b)', size=5))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Comparison of the original measured temperature and the same temperature
 after filtering the dynamic-heating correction, for an unheated Rosemount
 102E4AL sensor and a heated HARCO sensor.
 
\end_layout

\end_inset

Comparison of the original measured temperature and the same temperature
 after filtering the dynamic-heating correction:
\begin_inset Newline newline
\end_inset

(left): An unheated Rosemount 102E4AL sensor; (right): A heated HARCO sensor.
 
\begin_inset CommandInset label
LatexCommand label
name "fig:ATATF"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
For the unheated Rosemount 102E4AL sensor, Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:ATATF}
\end_layout

\end_inset

a illustrates the removal of erroneous structure by filtering, and Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:ATATF}
\end_layout

\end_inset

b shows a similar example for the heated HARCO sensor.
 These examples illustrate that the erroneous fluctuations in the uncorrected
 measurements can be important in many potential uses of these measurements
 and should be removed as part of standard processing.
 The effect is particularly significant for the HARCO sensor, for which
 there are large fluctuations in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:ATATF}
\end_layout

\end_inset

b that are caused by fluctuations in dynamic heating to which the sensor
 does not respond.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
For the NSF/NCAR GV, the dynamic-heating term is complicated further by
 resonance in the pressure lines connecting the transducers to the pressure
 sources.
 This is discussed in detail in Appendix B.
\begin_inset Note Note
status open

\begin_layout Plain Layout
That resonance is an additional source of spurious air-temperature noise
 because the resonance occurs only in the pressure lines and so does not
 affect the temperature sensor.
 When they are present, those resonance effects also need to be removed
 from the dynamic-heating term applied to the recovery temperature.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
after 18:13:00 UTC for WECAN flight 17
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<ATATH1, include=FALSE, echo=FALSE, fig.height=3, fig.cap='The original measured
 temperature from a heated HARCO sensor (
\begin_inset Quotes eld
\end_inset

AT
\begin_inset Quotes erd
\end_inset

) and the same temperature after revising the dynamic-heating correction
 (
\begin_inset Quotes eld
\end_inset

ATC
\begin_inset Quotes erd
\end_inset

).'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DWECAN$MACHX <- SmoothInterp (DWECAN$MACHX, .Length = 0)
\end_layout

\begin_layout Plain Layout

DWECAN$ATH1 <- SmoothInterp (DWECAN$ATH1, .Length = 0)
\end_layout

\begin_layout Plain Layout

alphaR2 <-
\end_layout

\begin_layout Plain Layout

  0.988 + 0.053 * log10(DWECAN$MACHX) +
\end_layout

\begin_layout Plain Layout

  0.090 * (log10(DWECAN$MACHX)) ^ 2 +
\end_layout

\begin_layout Plain Layout

  0.091 * (log10(DWECAN$MACHX)) ^ 3
\end_layout

\begin_layout Plain Layout

DWECAN$ATC <- DWECAN$ATH1 + alphaR2 * (DWECAN$Q - DWECAN$Qp)
\end_layout

\begin_layout Plain Layout

DWECAN$AT <- DWECAN$ATH1
\end_layout

\begin_layout Plain Layout

DWECAN %>% select(Time, AT, ATC) %>%
\end_layout

\begin_layout Plain Layout

  selectTime(181300, 181320) %>%
\end_layout

\begin_layout Plain Layout

  ggplotWAC() + ylab(bquote('temperature [' * degree * 'C]')) +
\end_layout

\begin_layout Plain Layout

    xlab('time [s]')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
A measurement of sensible-heat flux would be affected if the errors introduced
 by dynamic-heating are correlated with updraft.
 Incorrect treatment of dynamic heating will introduce a false correlation
 between airspeed and temperature, so any correlation between airspeed and
 updraft will result in an error in the measured sensible-heat flux.
 It is therefore useful to consider if such a correlation is expected or
 can be detected.
\end_layout

\begin_layout Plain Layout
For isotropic turbulence, the absence of a preferred direction requires
 that off-diagonal elements of the Reynolds stress tensor be zero, so a
 correlation is not expected.
 However, conditions producing significant flux of sensible heat are likely
 forced by shear and may therefore not be isotropic, so the assumption of
 isotropy is unnecessarily confining.
 Indeed, examples that follow in the next section have non-zero correlation
 between some wind components, so this change in the treatment of dynamic
 heating will be used in the next section where the flux of sensible heat
 is calculated from the cospectrum of temperature and updraft.
\end_layout

\end_inset


\end_layout

\begin_layout Section
The Flux of Sensible Heat
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The predecessor papers in this series, Parts 1 and 2, characterized the
 time response of some airborne thermometers,by measuring their frequency-domain
 transfer functions and then used those transfer functions to demonstrate
 that conventional data processing introduces errors that are removable.
 This paper considers the implications of those results for measurements
 of the flux of sensible heat.
 In particular, it is shown that one sensor in common use, the unheated
 Rosemount 102E4AL sensor, will miss important parts of the flux if there
 are significant contributions above about 1
\begin_inset space ~
\end_inset

Hz, but the flux cospectrum can be corrected reliably to extend that limit
 to near 10
\begin_inset space ~
\end_inset

Hz.
 For examples of measured fluxes, the correction procedure indicates that
 without this correction the flux measurement would be too small by about
 25%.
 The correction procedure consists of dividing the Fourier transform of
 the temperature by the transfer function for the temperature sensor before
 calculating the cospectrum of temperature and vertical-wind fluctuations.
 Simulation results support the validity of the correction procedure.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Outline of the correction procedure
\begin_inset CommandInset label
LatexCommand label
name "subsec:Outline-correction"

\end_inset


\end_layout

\begin_layout Standard
The measured air temperature 
\begin_inset Formula $T_{a}$
\end_inset

 is normally calculated by subtracting a dynamic-heating correction 
\begin_inset Formula $Q$
\end_inset

 from the measurement: 
\begin_inset Formula $T_{a}=T_{m}-Q$
\end_inset

 where 
\begin_inset Formula $T_{m}$
\end_inset

 is the measured recovery temperature.
 However, here it is desired to correct the resulting measurement on the
 basis of a known transfer function 
\begin_inset Formula $H(\nu)$
\end_inset

 that describes how the sensor responds to the input.
 That input (the measurand) is the recovery temperature 
\begin_inset Formula $T_{r}=T_{a}+Q$
\end_inset

, which differs from the measurement 
\begin_inset Formula $T_{m}$
\end_inset

 when the sensor output lags behind the input.
 The correction procedure therefore should correct the measurement 
\begin_inset Formula $T_{m}$
\end_inset

 to obtain an improved estimate of the recovery temperature and then use
 that corrected estimate of the recovery temperature to find the air temperature.
\end_layout

\begin_layout Standard
Most past studies of temperature corrections (e.g., 
\begin_inset CommandInset citation
LatexCommand citet
key "mccarthy1973method"
literal "false"

\end_inset

, 
\begin_inset CommandInset citation
LatexCommand citet
key "nicholls1978measurements"
literal "false"

\end_inset

, 
\begin_inset CommandInset citation
LatexCommand citet
key "InverarityJTech2000"
literal "false"

\end_inset

) applied corrections instead to the air temperature after correction for
 dynamic heating.
 That applies the full correction for dynamic heating 
\begin_inset Formula $Q$
\end_inset

 without considering that the sensor may respond only partly to high-frequency
 fluctuations in 
\begin_inset Formula $Q$
\end_inset

, which was shown in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Correcting-for-Dynamic"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to lead to erroneous noise in the air temperature.
 Then that noise is amplified by the correction procedure.
 These errors are avoided if corrections are applied instead to the measurement
 of the recovery temperature.
 Then the appropriate amplification of signals restores the fluctuations
 produced by dynamic heating and those fluctuations are appropriately removed
 by subtracting the measured dynamic heating term from the corrected recovery
 temperature.
 
\end_layout

\begin_layout Standard
The procedure used here is as follows:
\end_layout

\begin_layout Enumerate

\bar under
Find the transfer function,
\bar default
 as in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:theTransferFn"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 This is best done for the conditions, sensor, and aircraft that collect
 the measurements to be used for the flux measurement.
\end_layout

\begin_layout Enumerate

\bar under
Find the air temperature
\bar default
 or, equivalently, the Fourier representation of the air temperature.
 In terms of Fourier transforms, denoted here by the symbol 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\hat{}$
\end_inset


\begin_inset Quotes erd
\end_inset

, 
\begin_inset Formula $\hat{T}_{m}(\nu)=H(\nu)\hat{T}_{r}(\nu)$
\end_inset

 so the value of the recovery temperature can be estimated from the inverse
 Fourier transform of 
\begin_inset Formula $\hat{T}_{m}(\nu)/H(\nu)$
\end_inset

.
 The best estimate of the Fourier representation of the air temperature
 is then obtained from 
\begin_inset Formula $\hat{T}_{a}=\hat{T}_{m}(\nu)/H(\nu)-\hat{Q}(\nu)$
\end_inset

.
 This Fourier representation of the air temperature can be multiplied by
 the complex conjugate of the Fourier representation of the updraft to yield
 the cospectrum representing the flux of sensible heat, with an appropriate
 scale factor as specified in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:heatFlux"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The corrected recovery temperature also can be calculated by integrating
 the equations presented in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Theory"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Enumerate

\bar under
Calculate the cumulative cospectrum
\bar default
 for the cross-spectrum of temperature and updraft, with a choice made regarding
 which frequency interval to include.
 This will normally exclude wavelengths longer than a few kilometers.
\end_layout

\begin_layout Enumerate

\bar under
Calculate the flux
\bar default
 from the sum of the resulting cospectrum over an appropriate frequency
 interval.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<initial3, echo=FALSE, include=FALSE>>=
\end_layout

\begin_layout Plain Layout

## This chunk loads some needed R packages and defines a function
\end_layout

\begin_layout Plain Layout

## used for the Laplace-transform solution of the governing
\end_layout

\begin_layout Plain Layout

## differential equations.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

plotRibbon <- TRUE
\end_layout

\begin_layout Plain Layout

xlim <- c(0.01, 15)
\end_layout

\begin_layout Plain Layout

ylim <- c(0.001, 80)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

plotCS <- function(CS, Units, spans=149, fL, wavelengthLimit=2000, 
\end_layout

\begin_layout Plain Layout

                   smoothBins=100, 
\end_layout

\begin_layout Plain Layout

                   xlim=c(0.01,15), ylim=c(0.001,80), 
\end_layout

\begin_layout Plain Layout

                   printTitle=TRUE, CSprevious = NA,
\end_layout

\begin_layout Plain Layout

                   plotRibbon=TRUE, project = NA) {
\end_layout

\begin_layout Plain Layout

  ylab <- bquote(nu *" x flux cospectrum ["*.(Units)*"]")    
\end_layout

\begin_layout Plain Layout

  CSogive <- cumsum(CS$cospec) * CS$freq[1]
\end_layout

\begin_layout Plain Layout

  CSogive <- CSogive[length(CSogive)]-CSogive
\end_layout

\begin_layout Plain Layout

  CS$ogive <- CSogive
\end_layout

\begin_layout Plain Layout

  CS$cospec <- SmoothInterp(CS$cospec, .Length=0)  # treat NAs
\end_layout

\begin_layout Plain Layout

  s25 <- spans %/% 25; s10 <- spans %/% 10; s3 <- spans %/% 3
\end_layout

\begin_layout Plain Layout

  s25 <- s25 + (s25 + 1) %% 2
\end_layout

\begin_layout Plain Layout

  s10 <- s10 + (s10 + 1) %% 2
\end_layout

\begin_layout Plain Layout

  s3 <- s3 + (s3 + 1) %% 2
\end_layout

\begin_layout Plain Layout

  CS$cospec <- zoo::rollapply(CS$cospec, FUN = mean, fill='extend', width
 = s25)
\end_layout

\begin_layout Plain Layout

  CS$cospec[CS$freq > 0.01] <- zoo::rollapply(CS$cospec, FUN = mean, fill='extend
', width = s10)[CS$freq > 0.01]
\end_layout

\begin_layout Plain Layout

  CS$cospec[CS$freq > 0.1] <- zoo::rollapply(CS$cospec, FUN = mean, fill='extend'
, width = s3)[CS$freq > 0.1]
\end_layout

\begin_layout Plain Layout

  CS$cospec[CS$freq > 1] <- zoo::rollapply(CS$cospec, FUN = mean, fill='extend',
 width = spans)[CS$freq > 1]
\end_layout

\begin_layout Plain Layout

  FluxL <- CSogive[which(CS$freq > fL)[1]]
\end_layout

\begin_layout Plain Layout

  Flux <- CSogive[which(CS$freq > 0.01)[1]]
\end_layout

\begin_layout Plain Layout

  attr(CS, 'Flux') <- Flux
\end_layout

\begin_layout Plain Layout

  attr(CS, 'FluxL') <- FluxL
\end_layout

\begin_layout Plain Layout

  attr(CS, 'wavelengthLimit') <- wavelengthLimit
\end_layout

\begin_layout Plain Layout

  ## Construct the plot:
\end_layout

\begin_layout Plain Layout

  CS$ncospec <- -1 * CS$cospec
\end_layout

\begin_layout Plain Layout

  ## Weight by frequency for log-abscissa plot:
\end_layout

\begin_layout Plain Layout

  CS$cospec <- CS$cospec * CS$freq
\end_layout

\begin_layout Plain Layout

  CS$ncospec <- CS$ncospec * CS$freq
\end_layout

\begin_layout Plain Layout

  # plotWAC(CS, xlab='frequency [Hz]', ylab=ylab, log='xy',
\end_layout

\begin_layout Plain Layout

  #     col = c('skyblue', 'forestgreen', 'red'), lwd = c(2, 2, 2), 
\end_layout

\begin_layout Plain Layout

  #     lty = c(1, 2, 1),
\end_layout

\begin_layout Plain Layout

  #     xlim=c(0.05, 15), ylim=c(0.01,250), legend.position=NA)
\end_layout

\begin_layout Plain Layout

  if (smoothBins > 5) {
\end_layout

\begin_layout Plain Layout

    BS <- binStats(data.frame(CS$cospec, log(CS$freq)), bins = smoothBins)
\end_layout

\begin_layout Plain Layout

    # lines(exp(BS$xc), BS$ybar, lwd=2, col='brown')
\end_layout

\begin_layout Plain Layout

    BS$nybar <- -1 * BS$ybar
\end_layout

\begin_layout Plain Layout

    BS$ybar[BS$ybar < 0] <- NA
\end_layout

\begin_layout Plain Layout

    BS$nybar[BS$nybar < 0] <- NA
\end_layout

\begin_layout Plain Layout

    BS$xc <- exp(BS$xc)
\end_layout

\begin_layout Plain Layout

    # lines(exp(BS$xc), BS$nybar, lwd=2, col='magenta')
\end_layout

\begin_layout Plain Layout

    attr(CS, 'smoothed data.frame') <- BS
\end_layout

\begin_layout Plain Layout

    bse <- data.frame(x = BS$xc, ymin = BS$ybar - BS$sigma, ymax = BS$ybar
 + BS$sigma,
\end_layout

\begin_layout Plain Layout

                      yminN = BS$nybar - BS$sigma, ymaxN = BS$nybar + BS$sigma)
\end_layout

\begin_layout Plain Layout

    # lines(exp(BS$xc), BS$nybar, lwd=2, col='magenta')
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  if (smoothBins > 5) {
\end_layout

\begin_layout Plain Layout

    bse$ymin[bse$ymin < ylim[1]] <- ylim[1]
\end_layout

\begin_layout Plain Layout

    bse$yminN[bse$yminN < ylim[1]] <- ylim[1]
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  g <- ggplot(data = CS, aes(x=freq))
\end_layout

\begin_layout Plain Layout

  g <- g + geom_path(aes(y = cospec, colour='cospectrum', linetype='cospectrum')
)
\end_layout

\begin_layout Plain Layout

  g <- g + geom_path(aes(y = ncospec, colour='-cospectrum', linetype='-cospectru
m'))
\end_layout

\begin_layout Plain Layout

  g <- g + geom_path(aes(y = ogive, colour='exceedance', linetype='exceedance'),
 lwd=1.2)
\end_layout

\begin_layout Plain Layout

  if (is.data.frame(CSprevious)) {
\end_layout

\begin_layout Plain Layout

    g <- g + geom_path(data=CSprevious, aes(x = freq, y = ogive,
\end_layout

\begin_layout Plain Layout

                          colour='exceedance'), lty=2, lwd=1.2)
\end_layout

\begin_layout Plain Layout

    if ('ogive2' %in% names(CSprevious)) {
\end_layout

\begin_layout Plain Layout

      g <- g + geom_path(data=CSprevious, aes(x = freq, y = ogive2,
\end_layout

\begin_layout Plain Layout

                          colour='generated', linetype='generated'), lwd=1.3)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  if (smoothBins > 5) {
\end_layout

\begin_layout Plain Layout

    # g <- g + geom_path(data = BS, aes(x=xc, y=ybar), colour='blue', lwd=1.2)
\end_layout

\begin_layout Plain Layout

    # g <- g + geom_path(data = BS, aes(x=xc, y=nybar), colour='deeppink3',
 lwd=1.2)
\end_layout

\begin_layout Plain Layout

    g <- g + geom_point(data = BS, aes(x=xc, y=ybar), colour='black', pch=19)
\end_layout

\begin_layout Plain Layout

    g <- g + geom_point(data = BS, aes(x=xc, y=nybar), colour='darkred',
 pch=19)
\end_layout

\begin_layout Plain Layout

    if (plotRibbon) {
\end_layout

\begin_layout Plain Layout

      # GeomRibbon$handle_na <- function(data, params) {  data }
\end_layout

\begin_layout Plain Layout

      g <- g + geom_ribbon(data=bse, aes(x=x, ymin=ymin, ymax=ymax),
\end_layout

\begin_layout Plain Layout

        fill='blue', alpha=0.2, show.legend=FALSE, inherit.aes=FALSE, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

      g <- g + geom_ribbon(data=bse, aes(x=x, ymin=yminN, ymax=ymaxN),
\end_layout

\begin_layout Plain Layout

                fill='red', alpha=0.2, show.legend=FALSE, inherit.aes=FALSE,
 na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

      # g <- g + geom_path(data=bse, aes(x=x, y=ymin), lty=1, lwd=0.5, col='magen
ta') +
\end_layout

\begin_layout Plain Layout

      #          geom_path(data=bse, aes(x=x, y=ymax), lty=1, lwd=0.5, col='magen
ta')
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  g <- g + geom_path(data=data.frame(x=rep(fL, 2), y=ylim), aes(x=x, y=y),
 linetype=2)
\end_layout

\begin_layout Plain Layout

  g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=4), #limits = xlim, 
\end_layout

\begin_layout Plain Layout

    labels = trans_format("log10", math_format(10^.x))) +
\end_layout

\begin_layout Plain Layout

    scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x, n=4),
 #limits = ylim,             
\end_layout

\begin_layout Plain Layout

      labels = trans_format("log10", math_format(10^.x))) +
\end_layout

\begin_layout Plain Layout

    annotation_logticks(sides='trbl') +
\end_layout

\begin_layout Plain Layout

    coord_cartesian(xlim=xlim, ylim=ylim)
\end_layout

\begin_layout Plain Layout

  g <- g + xlab('frequency [Hz]') + ylab(ylab)
\end_layout

\begin_layout Plain Layout

  g <- suppressWarnings(g + scale_colour_manual (name='', 
\end_layout

\begin_layout Plain Layout

    values=c('cospectrum'='blue', '-cospectrum'='red', 'exceedance'='brown',
\end_layout

\begin_layout Plain Layout

             'generated' = 'forestgreen')))
\end_layout

\begin_layout Plain Layout

  g <- g + scale_linetype_manual (name='', values=c('cospectrum'=1, '-cospectrum
'=1, 'exceedance'=1, 'generated' = 4))
\end_layout

\begin_layout Plain Layout

  g <- g + guides(col=guide_legend(reverse = TRUE), linetype=guide_legend(revers
e = TRUE))
\end_layout

\begin_layout Plain Layout

  ttl <- bquote('Total flux '~.(format(Flux, digits=3))~.(Units)*'; partial
 <'*.(format((wavelengthLimit/1000), digits=2))~'km:'~.(format(FluxL, digits=3))~.(
Units))
\end_layout

\begin_layout Plain Layout

  if (printTitle) {
\end_layout

\begin_layout Plain Layout

    g <- g + labs(title=ttl)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  if(!is.na(project)) {
\end_layout

\begin_layout Plain Layout

    g <- g + annotate('text', x = 4, y=7, label=paste0('(', project, ')'),
 size=4)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  suppressWarnings(print(g + theme_WAC(1) + theme(plot.title = element_text(size=
12)) +
\end_layout

\begin_layout Plain Layout

                             theme(legend.position=c(0.5, 0.91))))
\end_layout

\begin_layout Plain Layout

  g <<- g  ## Save for adding uncorrected cospec for debugging...
\end_layout

\begin_layout Plain Layout

  # par(bg = 'gray95')
\end_layout

\begin_layout Plain Layout

  # plotWAC(data.frame(exp(BSF1$xc), BSF1$ybar, BSF1$nybar), 
\end_layout

\begin_layout Plain Layout

  #   col = c('blue', 'red'), ylab = ylab,
\end_layout

\begin_layout Plain Layout

  #   xlab='frequency [Hz]', log='xy', xlim=c(0.05,15),
\end_layout

\begin_layout Plain Layout

  #   ylim=c(0.01,250), legend.position=NA)
\end_layout

\begin_layout Plain Layout

  # lines(CSF1, col='gray50')
\end_layout

\begin_layout Plain Layout

  # lines(exp(BSF1$xc), BSF1$ybar, col='blue', lwd=2)
\end_layout

\begin_layout Plain Layout

  # lines(exp(BSF1$xc), BSF1$ybar+BSF1$sigma, col='blue', lwd=1)
\end_layout

\begin_layout Plain Layout

  # lines(exp(BSF1$xc), BSF1$ybar-BSF1$sigma, col='blue', lwd=1)
\end_layout

\begin_layout Plain Layout

  return(CS)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Examples of Measured Cospectra and Fluxes
\begin_inset Branch Extra
inverted 0
status open

\begin_layout Subsection
VOCALS example
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<TASX, include = FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

reviseDH <-
\end_layout

\begin_layout Plain Layout

  function (.data, P, alphaR) {
\end_layout

\begin_layout Plain Layout

    # P is Param1, e.g.; alphaR is recovery factor
\end_layout

\begin_layout Plain Layout

    .data$Q <- .data$TASX ^ 2 / 2010
\end_layout

\begin_layout Plain Layout

    aV <- P$a
\end_layout

\begin_layout Plain Layout

    tau1V <- P$tau1
\end_layout

\begin_layout Plain Layout

    tau2V <- P$tau2
\end_layout

\begin_layout Plain Layout

    Rate <- attr (.data, 'Rate')
\end_layout

\begin_layout Plain Layout

    fS <- function(y, i) {
\end_layout

\begin_layout Plain Layout

      (.data$Q[i] - y) / (tau2V * Rate)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    fM <- function (y, i) {
\end_layout

\begin_layout Plain Layout

      (aV * .data$Q[i] + (1 - aV) * TsQ[i] - y) / (Rate * tau1V)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    TsQ <- rk4.integrate (fS, .data$Q[1], 1:nrow(.data))
\end_layout

\begin_layout Plain Layout

    Qp <- rk4.integrate (fM, .data$Q[1], 1:nrow(.data))
\end_layout

\begin_layout Plain Layout

    return (.data$ATX + alphaR * (.data$Q - Qp))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

if (file.exists ('./DVOCALS.Rdata')) {
\end_layout

\begin_layout Plain Layout

  load (file = './DVOCALS.Rdata')
\end_layout

\begin_layout Plain Layout

  DVOCALS <- D
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  D <- getNetCDF(
\end_layout

\begin_layout Plain Layout

    file.path(DataDirectory(), 'VOCALS/VOCALSrf03h.nc'),
\end_layout

\begin_layout Plain Layout

    c(
\end_layout

\begin_layout Plain Layout

      'TASX',
\end_layout

\begin_layout Plain Layout

      'PALT',
\end_layout

\begin_layout Plain Layout

      'TTRR',
\end_layout

\begin_layout Plain Layout

      'ATRR',
\end_layout

\begin_layout Plain Layout

      'TTWH',
\end_layout

\begin_layout Plain Layout

      'WIC',
\end_layout

\begin_layout Plain Layout

      'ATX',
\end_layout

\begin_layout Plain Layout

      'PSXC',
\end_layout

\begin_layout Plain Layout

      'QCXC'
\end_layout

\begin_layout Plain Layout

    )
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

  D$DH <- D$TASX ^ 2 / 2010
\end_layout

\begin_layout Plain Layout

  ## For use later, "filter" the dynamic-heating term and revise the temperature
:
\end_layout

\begin_layout Plain Layout

  alphaR <- attr(D[, 'ATRR'], 'RecoveryFactor')
\end_layout

\begin_layout Plain Layout

  D$AT <- reviseDH(D, Param1, alphaR)
\end_layout

\begin_layout Plain Layout

  ## Find a corrected recovery temperature to use in the estimate of dynamic
 heating:
\end_layout

\begin_layout Plain Layout

  a <- Param1$a
\end_layout

\begin_layout Plain Layout

  tau1 <- Param1$tau1
\end_layout

\begin_layout Plain Layout

  tau2 <- Param1$tau2
\end_layout

\begin_layout Plain Layout

  ## RT is the working solution; Ts is the support temperature
\end_layout

\begin_layout Plain Layout

  D$Ts <- D$TTRR
\end_layout

\begin_layout Plain Layout

  Rate <- attr (D, 'Rate')
\end_layout

\begin_layout Plain Layout

  D$DTMDT <-
\end_layout

\begin_layout Plain Layout

    c(0, diff(D$TTRR, 2), 0) * Rate / 2  ## Average this and one-sample-advanced
\end_layout

\begin_layout Plain Layout

  # D$DTMDT <- (D$DTMDT + c(0, D$DTMDT[1:(nrow(D)-1)])) / 2
\end_layout

\begin_layout Plain Layout

  # DT$DTMDT <- as.vector (signal::filter(signal::sgolay(1, 3, m=1), DT$TTRR))
 * Rate
\end_layout

\begin_layout Plain Layout

  fS <- function(y, i) {
\end_layout

\begin_layout Plain Layout

    # Eq.
 Ts3
\end_layout

\begin_layout Plain Layout

    ((1 / a) * (tau1 * D$DTMDT[i] + D$TTRR[i] - (1 - a) * y) - y) / (Rate
 * tau2)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  D$Ts <- rk4.integrate (fS, D$Ts[1], 1:nrow(D))
\end_layout

\begin_layout Plain Layout

  D$RT <- (1 / a) * (tau1 * D$DTMDT + D$TTRR - (1 - a) * D$Ts)
\end_layout

\begin_layout Plain Layout

  # D %>% select(Time, TTRR, RT, Ts) %>% selectTime(114500, 114505) %>%
 plotWAC()
\end_layout

\begin_layout Plain Layout

  save(D, file = './DVOCALS.Rdata')
\end_layout

\begin_layout Plain Layout

  DVOCALS <- D
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

## Revise the calculation of dynamic heating to avoid dependence on AT:
\end_layout

\begin_layout Plain Layout

D$MACH <- MachNumber(D$PSXC, D$QCXC)
\end_layout

\begin_layout Plain Layout

XXA <- attr(D[, 'ATRR'], 'RecoveryFactor') * D$MACH ^ 2 / 5
\end_layout

\begin_layout Plain Layout

D$DH <- (D$TTRR + 273.15) * XXA / (1 + XXA)
\end_layout

\begin_layout Plain Layout

D$DH2 <- (D$RT + 273.15) * XXA / (1 + XXA)
\end_layout

\begin_layout Plain Layout

## temporary: shift D$AT later in time
\end_layout

\begin_layout Plain Layout

# D$AT <- ShiftInTime (D$AT, .rate=25, .shift=40)
\end_layout

\begin_layout Plain Layout

Tasm <- mean(D$TASX, na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

DT <- D %>% selectTime(113900, 115200)
\end_layout

\begin_layout Plain Layout

# select six boundary-layer segments of 10 min each:
\end_layout

\begin_layout Plain Layout

DT1 <- D %>% selectTime(65000, 70000)
\end_layout

\begin_layout Plain Layout

DT2 <- D %>% selectTime(73300, 74300)
\end_layout

\begin_layout Plain Layout

DT3 <- D %>% selectTime(104600, 105600)
\end_layout

\begin_layout Plain Layout

DT4 <- D %>% selectTime(114200, 115200)  ## 113900, 115200
\end_layout

\begin_layout Plain Layout

DT5 <- D %>% selectTime(124300, 125300)
\end_layout

\begin_layout Plain Layout

DT6 <- D %>% selectTime(133000, 134000)
\end_layout

\begin_layout Plain Layout

# omitting 832-841, 920-951, 955-1005 -- look problematic
\end_layout

\begin_layout Plain Layout

# g <- VSpec(DT, 'TTRR', spans=99, xlim=c(0.01,15), ylim=c(1.e-5, 1.e-1))
\end_layout

\begin_layout Plain Layout

# g <- VSpec(DT, 'ATRR', spans=99, add=g)
\end_layout

\begin_layout Plain Layout

# VSpec(DT, 'DH', spans=99, add=g) + theme_WAC()
\end_layout

\begin_layout Plain Layout

# VSpec(DT, 'TASX', spans = 99, ylim=c(1.e-3, 10)) + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

load(file='AR.Rdata')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The same flight segments from the VOCALS project that were used to characterize
 the transfer function in Part 1 are also used in this first example.
 A composite cospectrum for these measurements was constructed as before,
 averaging six 10-min boundary-layer flight segments of 25
\begin_inset space ~
\end_inset

Hz measurements of recovery temperature, updraft, and dynamic heating.
 This first calculation used the measurements directly, with no corrections
 for the response of the temperature sensor and no adjustment of the dynamic-hea
ting correction, so this would be the conventional measurement without any
 of the changes proposed in the present series of papers.
 The cospectrum for the cross-spectrum between temperature and updraft is
 shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:assembleCospec}
\end_layout

\end_inset

 for the average of the six flight segments.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<assembleCospec, include=TRUE, fig.pos='t', fig.cap='The cospectrum for temperatu
re and updraft, multiplied by the air density and specific heat to convert
 to a cospectrum for the sensible-heat flux, for six 10-min boundary-layer
 flight segments from the VOCALS project.
 The original uncorrected measurements have been used for temperature.
 Positive and negative values of the cospectrum are shown as blue and red,
 respectively, with the sign of the latter changed to permit plotting on
 a logarithmic axis.
 The mean values in logarithmically spaced bins in frequency are shown as
 black and dark red dots, and the shaded ribbon enclosing the dots represents
 a one-standard-deviation range for those bins.
 The brown line labeled 
\begin_inset Quotes eld
\end_inset

exceedance
\begin_inset Quotes erd
\end_inset

 is the complement of the cumulative distribution function for flux; i.e.,
 the flux from all frequencies higher than the plotted value.
 The dashed black line denotes the frequency that corresponds to a wavelength
 of 3 km.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Recalculate AT using the dynamic-heating filter:
\end_layout

\begin_layout Plain Layout

DVOCALS$TASX <- SmoothInterp(DVOCALS$TASX, .Length=0)
\end_layout

\begin_layout Plain Layout

DVOCALS$ATX <- SmoothInterp(DVOCALS$ATX, .Length=0)
\end_layout

\begin_layout Plain Layout

DVOCALS$PSXC <- SmoothInterp(DVOCALS$PSXC, .Length=0)
\end_layout

\begin_layout Plain Layout

DVOCALS$QCXC <- SmoothInterp(DVOCALS$QCXC, .Length=0)
\end_layout

\begin_layout Plain Layout

DVOCALS$MACH <- SmoothInterp(MachNumber(DVOCALS$PSXC, DVOCALS$QCXC), .Length=0)
\end_layout

\begin_layout Plain Layout

DVOCALS$alphaR <- RecoveryFactor(DVOCALS$MACH, 'UNHEATED') 
\end_layout

\begin_layout Plain Layout

## Alas, original processing used 0.95 so duplicate that:
\end_layout

\begin_layout Plain Layout

DVOCALS$alphaR <- rep(0.95, nrow(DVOCALS))
\end_layout

\begin_layout Plain Layout

DVOCALS$Q <- DVOCALS$TASX^2 / (2 * SpecificHeats()[1])
\end_layout

\begin_layout Plain Layout

DVOCALS$QF <- as.vector(signal::filter(AR, DVOCALS$Q))
\end_layout

\begin_layout Plain Layout

DVOCALS$QF <- ShiftInTime(DVOCALS$QF, .shift=-Lshift * 40, .rate=25)
\end_layout

\begin_layout Plain Layout

DVOCALS$AT <- DVOCALS$ATX + DVOCALS$alphaR * (DVOCALS$Q - DVOCALS$QF)
\end_layout

\begin_layout Plain Layout

DVOCALS$WIC <- ShiftInTime(DVOCALS$WIC, .rate=25, .shift=-20)
\end_layout

\begin_layout Plain Layout

D <- DVOCALS
\end_layout

\begin_layout Plain Layout

DT1 <- D %>% selectTime(65000, 70000)
\end_layout

\begin_layout Plain Layout

DT2 <- D %>% selectTime(73300, 74300)
\end_layout

\begin_layout Plain Layout

DT3 <- D %>% selectTime(104600, 105600)
\end_layout

\begin_layout Plain Layout

DT4 <- D %>% selectTime(114200, 115200)  ## 113900, 115200
\end_layout

\begin_layout Plain Layout

DT5 <- D %>% selectTime(124300, 125300)
\end_layout

\begin_layout Plain Layout

DT6 <- D %>% selectTime(133000, 134000)
\end_layout

\begin_layout Plain Layout

Cp <- 1005    # mean(SpecificHeats(DDR$EWX/DDR$PSXC)[,1], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

DTC <- rbind(DT1, DT2, DT3, DT4, DT5, DT6)
\end_layout

\begin_layout Plain Layout

Rho <- mean (100 * DTC$PSXC / ((DTC$ATX + 273.15) * 287.05), na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

sBins <- 100
\end_layout

\begin_layout Plain Layout

# DTC$WIC <- ShiftInTime(DTC$WIC, .rate=25, .shift=-40)
\end_layout

\begin_layout Plain Layout

## The following replaces the 
\begin_inset Quotes eld
\end_inset

flux()
\begin_inset Quotes erd
\end_inset

 function:
\end_layout

\begin_layout Plain Layout

Units  <-  bquote("W" ~ m ^ -2)
\end_layout

\begin_layout Plain Layout

spans <-  49
\end_layout

\begin_layout Plain Layout

scaleFactor <- (Rho * Cp)
\end_layout

\begin_layout Plain Layout

smoothBins <- sBins
\end_layout

\begin_layout Plain Layout

wavelengthLimit <- 3000
\end_layout

\begin_layout Plain Layout

xlim <- c(0.01, 15)
\end_layout

\begin_layout Plain Layout

ylim <- c(1.e-3, 10)
\end_layout

\begin_layout Plain Layout

legend.position <- 'bottomleft'
\end_layout

\begin_layout Plain Layout

plot <- TRUE
\end_layout

\begin_layout Plain Layout

plotRibbon <- TRUE
\end_layout

\begin_layout Plain Layout

printTitle <- TRUE
\end_layout

\begin_layout Plain Layout

Par <- NA
\end_layout

\begin_layout Plain Layout

.A <- 'ATRR'
\end_layout

\begin_layout Plain Layout

.B <- 'TTRR'
\end_layout

\begin_layout Plain Layout

CSprevious <- NA
\end_layout

\begin_layout Plain Layout

Rate <- attr(DVOCALS, 'Rate')
\end_layout

\begin_layout Plain Layout

Tasm <- mean(DTC$TASX, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

fL <- Tasm / wavelengthLimit
\end_layout

\begin_layout Plain Layout

N <- 2^14
\end_layout

\begin_layout Plain Layout

# Get the transfer function:
\end_layout

\begin_layout Plain Layout

Par <- Param1
\end_layout

\begin_layout Plain Layout

a <- Par$a
\end_layout

\begin_layout Plain Layout

tau1 <- Par$tau1
\end_layout

\begin_layout Plain Layout

tau2 <- Par$tau2
\end_layout

\begin_layout Plain Layout

df <- Rate / N
\end_layout

\begin_layout Plain Layout

frq <- c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
\end_layout

\begin_layout Plain Layout

zeta <- -atan(2*pi*frq*tau2)
\end_layout

\begin_layout Plain Layout

b <- cos(zeta)
\end_layout

\begin_layout Plain Layout

## Use the Laplace-transform solution
\end_layout

\begin_layout Plain Layout

C1 <- 1 / (1 + 4 * pi^2 * frq^2 * tau1^2) * 
\end_layout

\begin_layout Plain Layout

        (-(a + (1 - a) * b * cos(zeta)) * 2 * pi * frq * tau1 +
\end_layout

\begin_layout Plain Layout

           (1 - a) * b * sin(zeta)) 
\end_layout

\begin_layout Plain Layout

C2 <- 1 / (1 + 4 * pi^2 * frq^2 * tau1^2) * 
\end_layout

\begin_layout Plain Layout

        ((a + (1 - a) * b * cos(zeta)) + 
\end_layout

\begin_layout Plain Layout

           (1 - a) * b * sin(zeta) * 2 * pi * frq * tau1)
\end_layout

\begin_layout Plain Layout

cTC <- sqrt(C1^2 + C2^2)
\end_layout

\begin_layout Plain Layout

phiTC <- atan2(C1, C2)
\end_layout

\begin_layout Plain Layout

H <- complex(modulus=cTC, argument=phiTC)
\end_layout

\begin_layout Plain Layout

DTC <- data.frame()
\end_layout

\begin_layout Plain Layout

CoSp <- rep(0, N)
\end_layout

\begin_layout Plain Layout

for (.data in list(DT1, DT2, DT3, DT4, DT5, DT6)) {
\end_layout

\begin_layout Plain Layout

  N1 <- (N - nrow(.data)) %/% 2
\end_layout

\begin_layout Plain Layout

  N2 <- N - nrow(.data) - N1
\end_layout

\begin_layout Plain Layout

  WP <- c(rep(0, N1), detrend(.data[, c('Time', 'WIC')]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  TP <- c(rep(0, N1), detrend(.data[, c('Time', .A)]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  RT <- c(rep(0, N1), detrend(.data[, c('Time', .B)]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  Q  <- c(rep(0, N1), detrend(.data[, c('Time', 'Q')]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  ff1 <- fft(TP)
\end_layout

\begin_layout Plain Layout

  ff2 <- fft(WP)
\end_layout

\begin_layout Plain Layout

  ffq <- fft(Q)
\end_layout

\begin_layout Plain Layout

  ffr <- fft(RT)
\end_layout

\begin_layout Plain Layout

  cs <- 2 * Re(ff1 * Conj(ff2)) / (Rate * N)
\end_layout

\begin_layout Plain Layout

  ## Estimate original recovery T and apply corrected dynamic heating:
\end_layout

\begin_layout Plain Layout

  alphaR <- mean(.data$alphaR, na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

  # cs <- 2 * Re((ff1 / H - alphaR * H * ffq) * Conj(ff2)) / (Rate * N)
\end_layout

\begin_layout Plain Layout

  cs <- 2 * Re((ffr - alphaR * ffq) * Conj(ff2)) / (Rate * N)
\end_layout

\begin_layout Plain Layout

 CoSp <- CoSp + cs
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

CoSp <- CoSp * scaleFactor / 6
\end_layout

\begin_layout Plain Layout

Nby2 <- N %/% 2
\end_layout

\begin_layout Plain Layout

CS <- data.frame(freq = frq[2:(Nby2+1)], cospec = CoSp[2:(Nby2+1)])
\end_layout

\begin_layout Plain Layout

plotCS <- function(CS, Units, spans, fL, wavelengthLimit, smoothBins, 
\end_layout

\begin_layout Plain Layout

                   xlim, ylim, printTitle, CSprevious = NA) {
\end_layout

\begin_layout Plain Layout

  ylab <- bquote("f x flux cospectrum ["*.(Units)*"]")    
\end_layout

\begin_layout Plain Layout

  CSogive <- cumsum(CS$cospec) * CS$freq[1]
\end_layout

\begin_layout Plain Layout

  CSogive <- CSogive[length(CSogive)]-CSogive
\end_layout

\begin_layout Plain Layout

  CS$ogive <- CSogive
\end_layout

\begin_layout Plain Layout

  CS$cospec <- SmoothInterp(CS$cospec, .Length=0)  # treat NAs
\end_layout

\begin_layout Plain Layout

  s25 <- spans %/% 25; s10 <- spans %/% 10; s3 <- spans %/% 3
\end_layout

\begin_layout Plain Layout

  s25 <- s25 + (s25 + 1) %% 2
\end_layout

\begin_layout Plain Layout

  s10 <- s10 + (s10 + 1) %% 2
\end_layout

\begin_layout Plain Layout

  s3 <- s3 + (s3 + 1) %% 2
\end_layout

\begin_layout Plain Layout

  CS$cospec <- zoo::rollapply(CS$cospec, FUN = mean, fill='extend', width
 = s25)
\end_layout

\begin_layout Plain Layout

  CS$cospec[CS$freq > 0.01] <- zoo::rollapply(CS$cospec, FUN = mean, fill='extend
', width = s10)[CS$freq > 0.01]
\end_layout

\begin_layout Plain Layout

  CS$cospec[CS$freq > 0.1] <- zoo::rollapply(CS$cospec, FUN = mean, fill='extend'
, width = s3)[CS$freq > 0.1]
\end_layout

\begin_layout Plain Layout

  CS$cospec[CS$freq > 1] <- zoo::rollapply(CS$cospec, FUN = mean, fill='extend',
 width = spans)[CS$freq > 1]
\end_layout

\begin_layout Plain Layout

  FluxL <- CSogive[which(CS$freq > fL)[1]]
\end_layout

\begin_layout Plain Layout

  Flux <- CSogive[which(CS$freq > 0.01)[1]]
\end_layout

\begin_layout Plain Layout

  attr(CS, 'Flux') <- Flux
\end_layout

\begin_layout Plain Layout

  attr(CS, 'FluxL') <- FluxL
\end_layout

\begin_layout Plain Layout

  attr(CS, 'wavelengthLimit') <- wavelengthLimit
\end_layout

\begin_layout Plain Layout

  ## Construct the plot:
\end_layout

\begin_layout Plain Layout

  CS$ncospec <- -1 * CS$cospec
\end_layout

\begin_layout Plain Layout

  ## Weight by frequency for log-abscissa plot:
\end_layout

\begin_layout Plain Layout

  CS$cospec <- CS$cospec * CS$freq
\end_layout

\begin_layout Plain Layout

  CS$ncospec <- CS$ncospec * CS$freq
\end_layout

\begin_layout Plain Layout

  # plotWAC(CS, xlab='frequency [Hz]', ylab=ylab, log='xy',
\end_layout

\begin_layout Plain Layout

  #     col = c('skyblue', 'forestgreen', 'red'), lwd = c(2, 2, 2), 
\end_layout

\begin_layout Plain Layout

  #     lty = c(1, 2, 1),
\end_layout

\begin_layout Plain Layout

  #     xlim=c(0.05, 15), ylim=c(0.01,250), legend.position=NA)
\end_layout

\begin_layout Plain Layout

  if (smoothBins > 5) {
\end_layout

\begin_layout Plain Layout

    BS <- binStats(data.frame(CS$cospec, log(CS$freq)), bins = smoothBins)
\end_layout

\begin_layout Plain Layout

    # lines(exp(BS$xc), BS$ybar, lwd=2, col='brown')
\end_layout

\begin_layout Plain Layout

    BS$nybar <- -1 * BS$ybar
\end_layout

\begin_layout Plain Layout

    BS$ybar[BS$ybar < 0] <- NA
\end_layout

\begin_layout Plain Layout

    BS$nybar[BS$nybar < 0] <- NA
\end_layout

\begin_layout Plain Layout

    BS$xc <- exp(BS$xc)
\end_layout

\begin_layout Plain Layout

    # lines(exp(BS$xc), BS$nybar, lwd=2, col='magenta')
\end_layout

\begin_layout Plain Layout

    attr(CS, 'smoothed data.frame') <- BS
\end_layout

\begin_layout Plain Layout

    bse <- data.frame(x = BS$xc, ymin = BS$ybar - BS$sigma, ymax = BS$ybar
 + BS$sigma,
\end_layout

\begin_layout Plain Layout

                      yminN = BS$nybar - BS$sigma, ymaxN = BS$nybar + BS$sigma)
\end_layout

\begin_layout Plain Layout

    # lines(exp(BS$xc), BS$nybar, lwd=2, col='magenta')
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  if (smoothBins > 5) {
\end_layout

\begin_layout Plain Layout

    bse$ymin[bse$ymin < ylim[1]] <- ylim[1]
\end_layout

\begin_layout Plain Layout

    bse$yminN[bse$yminN < ylim[1]] <- ylim[1]
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  g <- ggplot(data = CS, aes(x=freq))
\end_layout

\begin_layout Plain Layout

  g <- g + geom_path(aes(y = cospec, colour='cospectrum', linetype='cospectrum')
)
\end_layout

\begin_layout Plain Layout

  g <- g + geom_path(aes(y = ncospec, colour='-cospectrum', linetype='-cospectru
m'))
\end_layout

\begin_layout Plain Layout

  g <- g + geom_path(aes(y = ogive, colour='exceedance', linetype='exceedance'),
 lwd=1.2)
\end_layout

\begin_layout Plain Layout

  if (is.data.frame(CSprevious)) {
\end_layout

\begin_layout Plain Layout

    g <- g + geom_path(data=CSprevious, aes(x = freq, y = ogive,
\end_layout

\begin_layout Plain Layout

                          colour='exceedance'), lty=2, lwd=1.2)
\end_layout

\begin_layout Plain Layout

    if ('ogive2' %in% names(CSprevious)) {
\end_layout

\begin_layout Plain Layout

      g <- g + geom_path(data=CSprevious, aes(x = freq, y = ogive2,
\end_layout

\begin_layout Plain Layout

                          colour='generated', linetype='generated'), lwd=1.3)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  if (smoothBins > 5) {
\end_layout

\begin_layout Plain Layout

    # g <- g + geom_path(data = BS, aes(x=xc, y=ybar), colour='blue', lwd=1.2)
\end_layout

\begin_layout Plain Layout

    # g <- g + geom_path(data = BS, aes(x=xc, y=nybar), colour='deeppink3',
 lwd=1.2)
\end_layout

\begin_layout Plain Layout

    g <- g + geom_point(data = BS, aes(x=xc, y=ybar), colour='black', pch=19)
\end_layout

\begin_layout Plain Layout

    g <- g + geom_point(data = BS, aes(x=xc, y=nybar), colour='darkred',
 pch=19)
\end_layout

\begin_layout Plain Layout

    if (plotRibbon) {
\end_layout

\begin_layout Plain Layout

      # GeomRibbon$handle_na <- function(data, params) {  data }
\end_layout

\begin_layout Plain Layout

      g <- g + geom_ribbon(data=bse, aes(x=x, ymin=ymin, ymax=ymax),
\end_layout

\begin_layout Plain Layout

        fill='blue', alpha=0.2, show.legend=FALSE, inherit.aes=FALSE, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

      g <- g + geom_ribbon(data=bse, aes(x=x, ymin=yminN, ymax=ymaxN),
\end_layout

\begin_layout Plain Layout

                fill='red', alpha=0.2, show.legend=FALSE, inherit.aes=FALSE,
 na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

      # g <- g + geom_path(data=bse, aes(x=x, y=ymin), lty=1, lwd=0.5, col='magen
ta') +
\end_layout

\begin_layout Plain Layout

      #          geom_path(data=bse, aes(x=x, y=ymax), lty=1, lwd=0.5, col='magen
ta')
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  g <- g + geom_path(data=data.frame(x=rep(fL, 2), y=ylim), aes(x=x, y=y),
 linetype=2)
\end_layout

\begin_layout Plain Layout

  g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=4), #limits = xlim, 
\end_layout

\begin_layout Plain Layout

    labels = trans_format("log10", math_format(10^.x))) +
\end_layout

\begin_layout Plain Layout

    scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x, n=4),
 #limits = ylim,             
\end_layout

\begin_layout Plain Layout

      labels = trans_format("log10", math_format(10^.x))) +
\end_layout

\begin_layout Plain Layout

    annotation_logticks(sides='trbl') +
\end_layout

\begin_layout Plain Layout

    coord_cartesian(xlim=xlim, ylim=ylim)
\end_layout

\begin_layout Plain Layout

  g <- g + xlab('frequency [Hz]') + ylab(ylab)
\end_layout

\begin_layout Plain Layout

  g <- suppressWarnings(g + scale_colour_manual (name='', 
\end_layout

\begin_layout Plain Layout

    values=c('cospectrum'='blue', '-cospectrum'='red', 'exceedance'='brown',
\end_layout

\begin_layout Plain Layout

             'generated' = 'forestgreen')))
\end_layout

\begin_layout Plain Layout

  g <- g + scale_linetype_manual (name='', values=c('cospectrum'=1, '-cospectrum
'=1, 'exceedance'=1, 'generated' = 4))
\end_layout

\begin_layout Plain Layout

  g <- g + guides(col=guide_legend(reverse = TRUE), linetype=guide_legend(revers
e = TRUE))
\end_layout

\begin_layout Plain Layout

  ttl <- bquote('Total flux '~.(format(Flux, digits=3))~.(Units)*'; partial
 <'*.(format((wavelengthLimit/1000), digits=2))~'km:'~.(format(FluxL, digits=3))~.(
Units))
\end_layout

\begin_layout Plain Layout

  if (printTitle) {
\end_layout

\begin_layout Plain Layout

    g <- g + labs(title=ttl)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  suppressWarnings(print(g + theme_WAC(1) + theme(plot.title = element_text(size=
12)) +
\end_layout

\begin_layout Plain Layout

                             theme(legend.position=c(0.5, 0.91))))
\end_layout

\begin_layout Plain Layout

  g <<- g  ## Save for adding uncorrected cospec for debugging...
\end_layout

\begin_layout Plain Layout

  # par(bg = 'gray95')
\end_layout

\begin_layout Plain Layout

  # plotWAC(data.frame(exp(BSF1$xc), BSF1$ybar, BSF1$nybar), 
\end_layout

\begin_layout Plain Layout

  #   col = c('blue', 'red'), ylab = ylab,
\end_layout

\begin_layout Plain Layout

  #   xlab='frequency [Hz]', log='xy', xlim=c(0.05,15),
\end_layout

\begin_layout Plain Layout

  #   ylim=c(0.01,250), legend.position=NA)
\end_layout

\begin_layout Plain Layout

  # lines(CSF1, col='gray50')
\end_layout

\begin_layout Plain Layout

  # lines(exp(BSF1$xc), BSF1$ybar, col='blue', lwd=2)
\end_layout

\begin_layout Plain Layout

  # lines(exp(BSF1$xc), BSF1$ybar+BSF1$sigma, col='blue', lwd=1)
\end_layout

\begin_layout Plain Layout

  # lines(exp(BSF1$xc), BSF1$ybar-BSF1$sigma, col='blue', lwd=1)
\end_layout

\begin_layout Plain Layout

  return(CS)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

spans <- 51
\end_layout

\begin_layout Plain Layout

CS.orig <- plotCS(CS, Units, spans, fL, wavelengthLimit, smoothBins, 
\end_layout

\begin_layout Plain Layout

                   xlim, ylim, printTitle) 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# X <-
\end_layout

\begin_layout Plain Layout

#   flux(
\end_layout

\begin_layout Plain Layout

#     DTC,
\end_layout

\begin_layout Plain Layout

#     'ATX',
\end_layout

\begin_layout Plain Layout

#     Units = bquote("W" ~ m ^ -2),
\end_layout

\begin_layout Plain Layout

#     spans = 149,
\end_layout

\begin_layout Plain Layout

#     scaleFactor = (Rho * Cp),
\end_layout

\begin_layout Plain Layout

#     smoothBins = sBins,
\end_layout

\begin_layout Plain Layout

#     wavelengthLimit = 3000,
\end_layout

\begin_layout Plain Layout

#     xlim = c(0.01, 15),
\end_layout

\begin_layout Plain Layout

#     ylim = c(1.e-3, 10)
\end_layout

\begin_layout Plain Layout

#   )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

N <- 2^14
\end_layout

\begin_layout Plain Layout

Rate <- attr(DVOCALS, 'Rate')
\end_layout

\begin_layout Plain Layout

# Get the transfer function:
\end_layout

\begin_layout Plain Layout

Par <- Param1
\end_layout

\begin_layout Plain Layout

a <- Par$a
\end_layout

\begin_layout Plain Layout

tau1 <- Par$tau1
\end_layout

\begin_layout Plain Layout

tau2 <- Par$tau2
\end_layout

\begin_layout Plain Layout

df <- Rate / N
\end_layout

\begin_layout Plain Layout

frq <- c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
\end_layout

\begin_layout Plain Layout

zeta <- -atan(2*pi*frq*tau2)
\end_layout

\begin_layout Plain Layout

b <- cos(zeta)
\end_layout

\begin_layout Plain Layout

## Use the Laplace-transform solution
\end_layout

\begin_layout Plain Layout

C1 <- 1 / (1 + 4 * pi^2 * frq^2 * tau1^2) * 
\end_layout

\begin_layout Plain Layout

        (-(a + (1 - a) * b * cos(zeta)) * 2 * pi * frq * tau1 +
\end_layout

\begin_layout Plain Layout

           (1 - a) * b * sin(zeta)) 
\end_layout

\begin_layout Plain Layout

C2 <- 1 / (1 + 4 * pi^2 * frq^2 * tau1^2) * 
\end_layout

\begin_layout Plain Layout

        ((a + (1 - a) * b * cos(zeta)) + 
\end_layout

\begin_layout Plain Layout

           (1 - a) * b * sin(zeta) * 2 * pi * frq * tau1)
\end_layout

\begin_layout Plain Layout

cTC <- sqrt(C1^2 + C2^2)
\end_layout

\begin_layout Plain Layout

phiTC <- atan2(C1, C2)
\end_layout

\begin_layout Plain Layout

H <- complex(modulus=cTC, argument=phiTC)
\end_layout

\begin_layout Plain Layout

DTC <- data.frame()
\end_layout

\begin_layout Plain Layout

for (DTY in list(DT1, DT2, DT3, DT4, DT5, DT6)) {
\end_layout

\begin_layout Plain Layout

  N1 <- (N - nrow(DTY)) %/% 2
\end_layout

\begin_layout Plain Layout

  N2 <- N - nrow(DTY) - N1
\end_layout

\begin_layout Plain Layout

  TTRR <- c(rep(0, N1), detrend(DTY[, c('Time', 'TTRR')]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  WIC <- c(rep(0, N1), detrend(DTY[, c('Time', 'WIC')]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  Q <- c(rep(0, N1),detrend(DTY[, c('Time', 'Q')]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  ftq <- fft(Q)
\end_layout

\begin_layout Plain Layout

  ft1 <- fft(TTRR)
\end_layout

\begin_layout Plain Layout

  ft2 <- fft(WIC)
\end_layout

\begin_layout Plain Layout

  ## Estimate original recovery T and apply corrected dynamic heating:
\end_layout

\begin_layout Plain Layout

  alphaR <- mean(DTY$alphaR, na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

  ATC <- Re(fft(ft1 / H, inverse = TRUE) / length(ft1)) # -
\end_layout

\begin_layout Plain Layout

  #           alphaR * Re(fft(H * ftq, inverse = TRUE) / length(ftq))
\end_layout

\begin_layout Plain Layout

  DTY$ATC <- ATC[(N1+1):(N-N2)] - alphaR * DTY$QF
\end_layout

\begin_layout Plain Layout

  DTC <- rbind(DTC, DTY)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

Cp <- 1005    # mean(SpecificHeats(DDR$EWX/DDR$PSXC)[,1], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

Rho <-
\end_layout

\begin_layout Plain Layout

  mean (100 * DTC$PSXC / ((DTC$ATX + 273.15) * 287.05), na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

sBins <- 100
\end_layout

\begin_layout Plain Layout

DHC <- DTC$alphaR * DTC$TASX^2 / 2010
\end_layout

\begin_layout Plain Layout

DTC$WIC <- ShiftInTime(DTC$WIC, .rate=25, .shift=-40)
\end_layout

\begin_layout Plain Layout

X <-
\end_layout

\begin_layout Plain Layout

  flux(
\end_layout

\begin_layout Plain Layout

    DTC,
\end_layout

\begin_layout Plain Layout

    'ATC',
\end_layout

\begin_layout Plain Layout

    Units = bquote("W" ~ m ^ -2),
\end_layout

\begin_layout Plain Layout

    spans = 149,
\end_layout

\begin_layout Plain Layout

    scaleFactor = (Rho * Cp),
\end_layout

\begin_layout Plain Layout

    smoothBins = sBins,
\end_layout

\begin_layout Plain Layout

    wavelengthLimit = 3000,
\end_layout

\begin_layout Plain Layout

    xlim = c(0.01, 15),
\end_layout

\begin_layout Plain Layout

    ylim = c(1.e-3, 10)
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Extra
inverted 0
status open

\begin_layout Standard
Although the value measured for the sensible-heat flux is small, the plot
 indicates that there are positive contributions to the flux up to the highest
 frequencies measured.
 The adjustment in dynamic heating has only a minor (ca.
\begin_inset space ~
\end_inset


\begin_inset Formula $+10$
\end_inset

%) effect on the measured flux, but it is not negligible.
 It is an encouraging sign that there seems to be some consistent contribution
 to the flux even from the high-frequency range.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<correctedCospec, include=TRUE, fig.pos='t', fig.cap='The cospectrum for
 temperature and updraft, multiplied by the air density and specific heat
 to convert to a cospectrum for the sensible-heat flux, for six 10-min boundary-
layer flight segments from the VOCALS project.
 The measurements used in the preceding plot have been corrected for the
 time response of the temperature sensor, and the dynamic-heating correction
 has been filtered to compensate for the expected response of the temperature
 sensor.
 Further description of the plot is included in the caption for the preceding
 figure.
 An added line is the dashed brown line; it duplicates the exceedance plot
 from the uncorrected calculation of the cospectrum as shown in the previous
 figure.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

D <- DVOCALS
\end_layout

\begin_layout Plain Layout

DT1 <- D %>% selectTime(65000, 70000)
\end_layout

\begin_layout Plain Layout

DT2 <- D %>% selectTime(73300, 74300)
\end_layout

\begin_layout Plain Layout

DT3 <- D %>% selectTime(104600, 105600)
\end_layout

\begin_layout Plain Layout

DT4 <- D %>% selectTime(114200, 115200)  ## 113900, 115200
\end_layout

\begin_layout Plain Layout

DT5 <- D %>% selectTime(124300, 125300)
\end_layout

\begin_layout Plain Layout

DT6 <- D %>% selectTime(133000, 134000)
\end_layout

\begin_layout Plain Layout

CoSp <- rep(0, N)
\end_layout

\begin_layout Plain Layout

for (.data in list(DT1, DT2, DT3, DT4, DT5, DT6)) {
\end_layout

\begin_layout Plain Layout

  N1 <- (N - nrow(.data)) %/% 2
\end_layout

\begin_layout Plain Layout

  N2 <- N - nrow(.data) - N1
\end_layout

\begin_layout Plain Layout

  WP <- c(rep(0, N1), detrend(.data[, c('Time', 'WIC')]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  TP <- c(rep(0, N1), detrend(.data[, c('Time', .A)]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  RT <- c(rep(0, N1), detrend(.data[, c('Time', .B)]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  Q  <- c(rep(0, N1), detrend(.data[, c('Time', 'Q')]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  ff1 <- fft(TP)
\end_layout

\begin_layout Plain Layout

  ff2 <- fft(WP)
\end_layout

\begin_layout Plain Layout

  ffq <- fft(Q)
\end_layout

\begin_layout Plain Layout

  ffr <- fft(RT)
\end_layout

\begin_layout Plain Layout

  # cs <- 2 * Re(ff1 * Conj(ff2)) / (Rate * N)
\end_layout

\begin_layout Plain Layout

  ## Estimate original recovery T and apply corrected dynamic heating:
\end_layout

\begin_layout Plain Layout

  alphaR <- mean(.data$alphaR, na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

  cs <- 2 * Re((ffr / H - alphaR * ffq) * Conj(ff2)) / (Rate * N)
\end_layout

\begin_layout Plain Layout

  CoSp <- CoSp + cs
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

CoSp <- CoSp * scaleFactor / 6
\end_layout

\begin_layout Plain Layout

Nby2 <- N %/% 2
\end_layout

\begin_layout Plain Layout

CS <- data.frame(freq = frq[2:(Nby2+1)], cospec = CoSp[2:(Nby2+1)])
\end_layout

\begin_layout Plain Layout

CS.corrected <- plotCS(CS, Units, spans, fL, wavelengthLimit, smoothBins,
 
\end_layout

\begin_layout Plain Layout

                   xlim, ylim, printTitle, CSprevious = CS.orig) 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The result after corrections for the time response of the sensor is shown
 in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:correctedCospec}
\end_layout

\end_inset

.
 The exceedance distributions for the original and corrected measurements
 of sensible-heat flux are both shown in this figure, the former as the
 dashed brown line.
 For this plot, the combination of the correction methods described in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Outline-correction"
plural "false"
caps "false"
noprefix "false"

\end_inset

 was used by correcting the measured temperature for dynamic heating using
 the digital filter but then using Fourier transforms to find the corrected
 flux as specified by the transfer function.
 Only minor differences arose when the other combinations of the methods
 were used.
 The estimated flux of sensible heat is increased by about 60%, from 1.93
 to 3.09
\begin_inset space ~
\end_inset

W
\begin_inset space \thinspace{}
\end_inset

m
\begin_inset Formula $^{-2}$
\end_inset

 for the contribution to the flux from wavelengths smaller than 3
\begin_inset space ~
\end_inset

km, and the flux attributable to frequencies above 1
\begin_inset space ~
\end_inset

Hz increased by 100%.
\end_layout

\begin_layout Standard
The VOCALS data led to very small sensible-heat flux.
 (For comparison, solar insolation provides a top-of-the-atmosphere flux
 of more than 1000
\begin_inset space ~
\end_inset

W
\begin_inset space \thinspace{}
\end_inset

m
\begin_inset Formula $^{-2}$
\end_inset

.
 The measured flux of sensible heat in this case is insignificant, although
 the measurement itself appears valid.) Therefore it is useful to extend
 these measurements to cases with more flux of sensible heat.
\end_layout

\end_inset


\begin_inset Branch Extra
inverted 0
status open

\begin_layout Standard
SOCRATES example
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<SOCrf15, include=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

load(file='AR.Rdata')  ## get ARG, etc.
\end_layout

\begin_layout Plain Layout

DS <-
\end_layout

\begin_layout Plain Layout

  getNetCDF('/Data/SOCRATES/SOCRATESrf15h.nc',
\end_layout

\begin_layout Plain Layout

            standardVariables(c('ATF1')),
\end_layout

\begin_layout Plain Layout

            55500,
\end_layout

\begin_layout Plain Layout

            62000)
\end_layout

\begin_layout Plain Layout

Rate <- attr(DS, 'Rate')
\end_layout

\begin_layout Plain Layout

rhozero <- 1013.25 * 100 / (287.05 * 288.15)
\end_layout

\begin_layout Plain Layout

MRHO <- DS$MACHX * DS$PSXC * 100 / 
\end_layout

\begin_layout Plain Layout

        (287.05 * (273.15 + DS$ATX)) / rhozero
\end_layout

\begin_layout Plain Layout

ParamFS1 <- ParamSF
\end_layout

\begin_layout Plain Layout

ParamFS1$tau1 <- ParamFS1$tau1 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ -0.6
\end_layout

\begin_layout Plain Layout

ParamFS1$tau2 <- ParamFS1$tau2 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ -0.6
\end_layout

\begin_layout Plain Layout

DS$TASX <- SmoothInterp(DS$TASX, .Length = 0)
\end_layout

\begin_layout Plain Layout

DS$Q <- DS$TASX ^ 2 / 2010
\end_layout

\begin_layout Plain Layout

DS$ATX <- DS$ATF1
\end_layout

\begin_layout Plain Layout

# DS$AT <- reviseDH(DS, ParamFS1, rf)  # rf was calculated in an earlier
 code chunk
\end_layout

\begin_layout Plain Layout

## Replace this by the filtered result:
\end_layout

\begin_layout Plain Layout

## Recalculate AT using the dynamic-heating filter:
\end_layout

\begin_layout Plain Layout

DS$ATX <- SmoothInterp(DS$ATX, .Length=0)
\end_layout

\begin_layout Plain Layout

DS$PSXC <- SmoothInterp(DS$PSXC, .Length=0)
\end_layout

\begin_layout Plain Layout

DS$QCXC <- SmoothInterp(DS$QCXC, .Length=0)
\end_layout

\begin_layout Plain Layout

DS$MACH <- SmoothInterp(MachNumber(DS$PSXC, DS$QCXC), .Length=0)
\end_layout

\begin_layout Plain Layout

DS$alphaR <- RecoveryFactor(DS$MACH, 'UNHEATED') 
\end_layout

\begin_layout Plain Layout

DS$Q <- DS$TASX^2 / (2 * SpecificHeats()[1])
\end_layout

\begin_layout Plain Layout

DS$QF <- as.vector(signal::filter(ARG, DS$Q))
\end_layout

\begin_layout Plain Layout

DS$QF <- ShiftInTime(DS$QF, .shift=-Lshift * 40, .rate=25)
\end_layout

\begin_layout Plain Layout

DS$AT <- DS$ATX + DS$alphaR * (DS$Q - DS$QF)
\end_layout

\begin_layout Plain Layout

DS$AT <- SmoothInterp(DS$AT, .Length = 0)
\end_layout

\begin_layout Plain Layout

DS$RTF1 <-
\end_layout

\begin_layout Plain Layout

  DS$ATF1 + DS$alphaR * DS$Q  ## This variable isn't in the available file
\end_layout

\begin_layout Plain Layout

DS$RTF1 <- SmoothInterp(DS$RTF1, .Length = 0)
\end_layout

\begin_layout Plain Layout

## Estimate the corrected recovery temperature:
\end_layout

\begin_layout Plain Layout

aV <- ParamFS1$a
\end_layout

\begin_layout Plain Layout

tau1V <- ParamFS1$tau1
\end_layout

\begin_layout Plain Layout

tau2V <- ParamFS1$tau2
\end_layout

\begin_layout Plain Layout

DS$DTMDT <- c(0, diff(DS$RTF1, 2), 0) * Rate / 2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

fSS <- function(y, i) {  # Eq.
 Ts3
\end_layout

\begin_layout Plain Layout

    ((1/aV) * (tau1V * DS$DTMDT[i] + DS$RTF1[i] - (1-aV) * y) - y) / (Rate
 * tau2V)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DS$Ts <- rk4.integrate (fSS, DS$RTF1[1], 1:nrow(DS))
\end_layout

\begin_layout Plain Layout

DS$RTC <- (1/aV) * (tau1V * DS$DTMDT + DS$RTF1 - (1-aV) * DS$Ts)
\end_layout

\begin_layout Plain Layout

DS$ATC <- DS$RTC - DS$alphaR * DS$QF
\end_layout

\begin_layout Plain Layout

## Small time adjustment seems useful?
\end_layout

\begin_layout Plain Layout

# DS$Q <- ShiftInTime(DS$Q, .shift = -25, .rate = 25)
\end_layout

\begin_layout Plain Layout

DS$RHOCP <- 100 * DS$PSXC / (287.05 * 278) * 1005
\end_layout

\begin_layout Plain Layout

DS$RHOCP <- SmoothInterp(DS$RHOCP, .Length = 0)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Two examples of measured cospectra illustrate the effect of the correction.
 The first example is from the SOCRATES project, flight of 24 January 2018,
 6:00:00 to 6:15:00 UTC, and the second is from the CSET project, flight
 of 1 August 2015, from various segments from 16:00:00 to 19:15:00 UTC.
 The flight segments were all at low level (150
\begin_inset space ~
\end_inset

m) in the marine boundary layer over Pacific Ocean\SpecialChar endofsentence
 An unheated Rosemount
 102E4AL sensor was used to measure temperature on these flights.
 In each case, the cospectra from three flight segments of 5 min (SOCRATES)
 or 10 min (CSET) duration were averaged to produce the measured cospectra.
 The flux estimates were then compared without correction and corrected
 using the appropriate transfer function as determined in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:theTransferFn"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<SOCp1, include=TRUE, fig.height=3.5>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

LTphaseC <- function(f, P) {
\end_layout

\begin_layout Plain Layout

  ## f=frequency; P=Param
\end_layout

\begin_layout Plain Layout

  tau1 <- P$tau1
\end_layout

\begin_layout Plain Layout

  tau2 <- P$tau2
\end_layout

\begin_layout Plain Layout

  a <- P$a
\end_layout

\begin_layout Plain Layout

  b <- sqrt(1 / (1 + (2 * pi * f * tau2) ^ 2))
\end_layout

\begin_layout Plain Layout

  zeta <- -atan(2 * pi * f * tau2)
\end_layout

\begin_layout Plain Layout

  C1 <- 1 / (1 + 4 * pi ^ 2 * f ^ 2 * tau1 ^ 2) *
\end_layout

\begin_layout Plain Layout

    (-(a + (1 - a) * b * cos(zeta)) * 2 * pi * f * tau1 +
\end_layout

\begin_layout Plain Layout

       (1 - a) * b * sin(zeta))
\end_layout

\begin_layout Plain Layout

  C2 <- 1 / (1 + 4 * pi ^ 2 * f ^ 2 * tau1 ^ 2) *
\end_layout

\begin_layout Plain Layout

    ((a + (1 - a) * b * cos(zeta)) +
\end_layout

\begin_layout Plain Layout

       (1 - a) * b * sin(zeta) * 2 * pi * f * tau1)
\end_layout

\begin_layout Plain Layout

  cTF <- sqrt(C1 ^ 2 + C2 ^ 2)
\end_layout

\begin_layout Plain Layout

  phiTF <- atan2(C1, C2) 
\end_layout

\begin_layout Plain Layout

  return(complex(modulus = cTF, argument = phiTF))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

N <- 2^13   ## 8192 covers the 5-min (7500-pt) segment
\end_layout

\begin_layout Plain Layout

# Get the transfer function:
\end_layout

\begin_layout Plain Layout

Par <- Param1
\end_layout

\begin_layout Plain Layout

a <- ParamFS1$a
\end_layout

\begin_layout Plain Layout

tau1 <- ParamFS1$tau1
\end_layout

\begin_layout Plain Layout

tau2 <- ParamFS1$tau2
\end_layout

\begin_layout Plain Layout

df <- Rate / N
\end_layout

\begin_layout Plain Layout

frq <- c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
\end_layout

\begin_layout Plain Layout

H <- LTphaseC(frq, ParamFS1) # complex(modulus=cTC, argument=phiTC)
\end_layout

\begin_layout Plain Layout

ir <- setRange(DS, 60000, 61500)
\end_layout

\begin_layout Plain Layout

Tasm <- mean(DS$TASX[ir], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

D <- DS
\end_layout

\begin_layout Plain Layout

RHO <- D$PSXC * 100 / (SpecificHeats()[3] * (D$ATX + 273.15))
\end_layout

\begin_layout Plain Layout

scaleFactor <- mean(RHO[ir], na.rm=TRUE) * SpecificHeats()[1]
\end_layout

\begin_layout Plain Layout

D$RTF1 <- ShiftInTime(D$RTF1, .rate=25, .shift=40)
\end_layout

\begin_layout Plain Layout

# D$ATC <- ShiftInTime(D$ATC, .rate=25, .shift=0)
\end_layout

\begin_layout Plain Layout

# D$WIC <- ShiftInTime(D$WIC, .rate=25, .shift=-40)
\end_layout

\begin_layout Plain Layout

DS1 <- D %>% selectTime(60000, 60500)
\end_layout

\begin_layout Plain Layout

DS2 <- D %>% selectTime(60500, 61000)
\end_layout

\begin_layout Plain Layout

DS3 <- D %>% selectTime(61000, 61500)
\end_layout

\begin_layout Plain Layout

CoSp <- rep(0, N)
\end_layout

\begin_layout Plain Layout

CoSpUC <- rep(0, N)
\end_layout

\begin_layout Plain Layout

.A <- 'RTF1'
\end_layout

\begin_layout Plain Layout

.B <- 'ATC'
\end_layout

\begin_layout Plain Layout

.C <- 'AT'
\end_layout

\begin_layout Plain Layout

.D <- 'ATF1'
\end_layout

\begin_layout Plain Layout

for (.data in list(DS1, DS2, DS3)) {
\end_layout

\begin_layout Plain Layout

  N1 <- (N - nrow(.data)) %/% 2
\end_layout

\begin_layout Plain Layout

  N2 <- N - nrow(.data) - N1
\end_layout

\begin_layout Plain Layout

  WP <- c(rep(0, N1), detrend(.data[, c('Time', 'WIC')]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  TP <- c(rep(0, N1), detrend(.data[, c('Time', .A)]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  TPB <- c(rep(0, N1), detrend(.data[, c('Time', .B)]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  TPuc <- c(rep(0, N1), detrend(.data[, c('Time', .C)]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  TPO <- c(rep(0, N1), detrend(.data[, c('Time', .D)]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  Q  <- c(rep(0, N1), detrend(.data[, c('Time', 'Q')]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  ff1 <- fft(TP)
\end_layout

\begin_layout Plain Layout

  ff1uc <- fft(TPuc)
\end_layout

\begin_layout Plain Layout

  ffb <- fft(TPB)
\end_layout

\begin_layout Plain Layout

  ffo <- fft(TPO)
\end_layout

\begin_layout Plain Layout

  ff2 <- fft(WP)
\end_layout

\begin_layout Plain Layout

  ffq <- fft(Q)
\end_layout

\begin_layout Plain Layout

  cs.orig <- 2 * Re(ff1uc * Conj(ff2)) / (Rate * nrow(.data))
\end_layout

\begin_layout Plain Layout

  # cs <- 2 * Re(ff1 * Conj(ff2)) / (Rate * N)
\end_layout

\begin_layout Plain Layout

  ## Estimate original recovery T and apply corrected dynamic heating:
\end_layout

\begin_layout Plain Layout

  alphaR <- mean(.data$alphaR, na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

  cs <- 2 * Re((ff1 / H - alphaR * H * ffq) * Conj(ff2)) / (Rate * nrow(.data))
\end_layout

\begin_layout Plain Layout

  ## supercede with direct use of ATC:
\end_layout

\begin_layout Plain Layout

  cs <- 2 * Re((ff1uc / H) * Conj(ff2)) / (Rate * nrow(.data))
\end_layout

\begin_layout Plain Layout

  cs <- 1/(Mod(H)*cos(Arg(H))) * 2 * Re((ff1uc) * Conj(ff2)) / (Rate * nrow(.data
))
\end_layout

\begin_layout Plain Layout

  CoSp <- CoSp + cs
\end_layout

\begin_layout Plain Layout

  CoSpUC <- CoSpUC + cs.orig
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

CoSp <- CoSp * scaleFactor / 3
\end_layout

\begin_layout Plain Layout

CoSpUC <- CoSpUC * scaleFactor / 3
\end_layout

\begin_layout Plain Layout

Nby2 <- N %/% 2
\end_layout

\begin_layout Plain Layout

CS <- data.frame(freq = frq[2:(Nby2+1)], cospec = CoSp[2:(Nby2+1)])
\end_layout

\begin_layout Plain Layout

CS.orig <- data.frame(freq = frq[2:(Nby2+1)], cospec = CoSpUC[2:(Nby2+1)])
\end_layout

\begin_layout Plain Layout

CSogiveUC <- cumsum(CoSpUC[2:(Nby2+1)]) * CS$freq[1]
\end_layout

\begin_layout Plain Layout

CSogiveUC <- CSogiveUC[length(CSogiveUC)]-CSogiveUC
\end_layout

\begin_layout Plain Layout

CS.orig$ogive <- CSogiveUC
\end_layout

\begin_layout Plain Layout

wavelengthLimit <- 2000
\end_layout

\begin_layout Plain Layout

fL <- Tasm / wavelengthLimit
\end_layout

\begin_layout Plain Layout

ylim <- c(1.e-2, 120)
\end_layout

\begin_layout Plain Layout

Units = bquote("W" ~ m ^ -2)
\end_layout

\begin_layout Plain Layout

spans = 49
\end_layout

\begin_layout Plain Layout

sBins <- 100
\end_layout

\begin_layout Plain Layout

CS.corrected <- plotCS(CS, Units, spans, fL, 
\end_layout

\begin_layout Plain Layout

                   wavelengthLimit, smoothBins=sBins, 
\end_layout

\begin_layout Plain Layout

                   xlim, ylim, CSprevious = CS.orig, project = 'SOCRATES')
 
\end_layout

\begin_layout Plain Layout

CS.orig$cospec <- SmoothInterp(CS.orig$cospec, .Length=0)  # treat NAs
\end_layout

\begin_layout Plain Layout

  s25 <- spans %/% 25; s10 <- spans %/% 10; s3 <- spans %/% 3
\end_layout

\begin_layout Plain Layout

  s25 <- s25 + (s25 + 1) %% 2
\end_layout

\begin_layout Plain Layout

  s10 <- s10 + (s10 + 1) %% 2
\end_layout

\begin_layout Plain Layout

  s3 <- s3 + (s3 + 1) %% 2
\end_layout

\begin_layout Plain Layout

  CS.orig$cospec <- zoo::rollapply(CS.orig$cospec, FUN = mean, fill='extend',
 width = s25)
\end_layout

\begin_layout Plain Layout

  CS.orig$cospec[CS.orig$freq > 0.01] <- zoo::rollapply(CS.orig$cospec, FUN
 = mean, fill='extend', width = s10)[CS.orig$freq > 0.01]
\end_layout

\begin_layout Plain Layout

  CS.orig$cospec[CS.orig$freq > 0.1] <- zoo::rollapply(CS.orig$cospec, FUN =
 mean, fill='extend', width = s3)[CS.orig$freq > 0.1]
\end_layout

\begin_layout Plain Layout

  CS.orig$cospec[CS.orig$freq > 1] <- zoo::rollapply(CS.orig$cospec, FUN =
 mean, fill='extend', width = spans)[CS.orig$freq > 1]
\end_layout

\begin_layout Plain Layout

# g + geom_path(data=CS.orig, aes(x=freq, y=cospec*freq), col='forestgreen',
 size=1.3)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

XS <-
\end_layout

\begin_layout Plain Layout

  flux(
\end_layout

\begin_layout Plain Layout

    DS[setRange(DS, 60000, 61500), ],
\end_layout

\begin_layout Plain Layout

    'AT',
\end_layout

\begin_layout Plain Layout

    Units = bquote("W"~m^-2),
\end_layout

\begin_layout Plain Layout

    smoothBins = 50,
\end_layout

\begin_layout Plain Layout

    scaleFactor = scaleFactor,
\end_layout

\begin_layout Plain Layout

    wavelengthLimit = 2000,
\end_layout

\begin_layout Plain Layout

    .plot = FALSE,
\end_layout

\begin_layout Plain Layout

    Par = ParamFS1
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

DCX <- getNetCDF(file.path(DataDirectory(), 'CSET/rf12h.nc'),
\end_layout

\begin_layout Plain Layout

                 standardVariables(c('ATF1', 'ATH1', 'ATH2')), 153000, 193000)
\end_layout

\begin_layout Plain Layout

Rate <- attr(DCX, 'Rate')
\end_layout

\begin_layout Plain Layout

MRHO <- DCX$MACHX * DCX$PSXC * 100 / 
\end_layout

\begin_layout Plain Layout

        (287.05 * (273.15 + DCX$ATX)) / rhozero
\end_layout

\begin_layout Plain Layout

ParamFS1 <- ParamSF
\end_layout

\begin_layout Plain Layout

ParamFS1$tau1 <- ParamFS1$tau1 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ -0.6
\end_layout

\begin_layout Plain Layout

ParamFS1$tau2 <- ParamFS1$tau2 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ -0.6
\end_layout

\begin_layout Plain Layout

DCX$TASX <- SmoothInterp(DCX$TASX, .Length = 0)
\end_layout

\begin_layout Plain Layout

DCX$Q <- DCX$TASX ^ 2 / 2010
\end_layout

\begin_layout Plain Layout

DCX$ATX <- DCX$ATF1
\end_layout

\begin_layout Plain Layout

# DCX$AT <- reviseDH(DCX, ParamFS1, rf)  # rf was calculated in an earlier
 code chunk
\end_layout

\begin_layout Plain Layout

## Replace this by the filtered result:
\end_layout

\begin_layout Plain Layout

## Recalculate AT using the dynamic-heating filter:
\end_layout

\begin_layout Plain Layout

DCX$ATX <- SmoothInterp(DCX$ATX, .Length=0)
\end_layout

\begin_layout Plain Layout

DCX$PSXC <- SmoothInterp(DCX$PSXC, .Length=0)
\end_layout

\begin_layout Plain Layout

DCX$QCXC <- SmoothInterp(DCX$QCXC, .Length=0)
\end_layout

\begin_layout Plain Layout

DCX$MACH <- SmoothInterp(MachNumber(DCX$PSXC, DCX$QCXC), .Length=0)
\end_layout

\begin_layout Plain Layout

DCX$alphaR <- RecoveryFactor(DCX$MACH, 'UNHEATED') 
\end_layout

\begin_layout Plain Layout

DCX$Q <- DCX$TASX^2 / (2 * SpecificHeats()[1])
\end_layout

\begin_layout Plain Layout

DCX$QF <- as.vector(signal::filter(ARG, DCX$Q))
\end_layout

\begin_layout Plain Layout

DCX$QF <- ShiftInTime(DCX$QF, .shift=-Lshift * 40, .rate=25)
\end_layout

\begin_layout Plain Layout

DCX$AT <- DCX$ATX + DCX$alphaR * (DCX$Q - DCX$QF)
\end_layout

\begin_layout Plain Layout

DCX$AT <- SmoothInterp(DCX$AT, .Length = 0)
\end_layout

\begin_layout Plain Layout

DCX$RTF1 <-
\end_layout

\begin_layout Plain Layout

  DCX$ATF1 + DCX$alphaR * DCX$Q  ## This variable isn't in the available
 file
\end_layout

\begin_layout Plain Layout

DCX$RTF1 <- SmoothInterp(DCX$RTF1, .Length = 0)
\end_layout

\begin_layout Plain Layout

## Estimate the corrected recovery temperature:
\end_layout

\begin_layout Plain Layout

aV <- ParamFS1$a
\end_layout

\begin_layout Plain Layout

tau1V <- ParamFS1$tau1
\end_layout

\begin_layout Plain Layout

tau2V <- ParamFS1$tau2
\end_layout

\begin_layout Plain Layout

DCX$DTMDT <- c(0, diff(DCX$RTF1, 2), 0) * Rate / 2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

fSS <- function(y, i) {  # Eq.
 Ts3
\end_layout

\begin_layout Plain Layout

    ((1/aV) * (tau1V * DCX$DTMDT[i] + DCX$RTF1[i] - (1-aV) * y) - y) / (Rate
 * tau2V)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DCX$Ts <- rk4.integrate (fSS, DCX$RTF1[1], 1:nrow(DCX))
\end_layout

\begin_layout Plain Layout

DCX$RTC <- (1/aV) * (tau1V * DCX$DTMDT + DCX$RTF1 - (1-aV) * DCX$Ts)
\end_layout

\begin_layout Plain Layout

DCX$ATC <- DCX$RTC - DCX$alphaR * DCX$QF
\end_layout

\begin_layout Plain Layout

## Small time adjustment seems useful?
\end_layout

\begin_layout Plain Layout

# DCX$Q <- ShiftInTime(DCX$Q, .shift = -25, .rate = 25)
\end_layout

\begin_layout Plain Layout

DCX$RHOCP <- 100 * DCX$PSXC / (287.05 * 278) * 1005
\end_layout

\begin_layout Plain Layout

DCX$RHOCP <- SmoothInterp(DCX$RHOCP, .Length = 0)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

N <- 2^14   ## 16384 covers the 10-min (15000-pt) segments
\end_layout

\begin_layout Plain Layout

# Get the transfer function:
\end_layout

\begin_layout Plain Layout

a <- ParamFS1$a
\end_layout

\begin_layout Plain Layout

tau1 <- ParamFS1$tau1
\end_layout

\begin_layout Plain Layout

tau2 <- ParamFS1$tau2
\end_layout

\begin_layout Plain Layout

df <- Rate / N
\end_layout

\begin_layout Plain Layout

frq <- c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
\end_layout

\begin_layout Plain Layout

H <- LTphaseC(frq, ParamFS1)
\end_layout

\begin_layout Plain Layout

D <- DCX
\end_layout

\begin_layout Plain Layout

D$RTF1 <- ShiftInTime(D$RTF1, .rate=25, .shift=40)
\end_layout

\begin_layout Plain Layout

# D$ATC <- ShiftInTime(D$ATC, .rate=25, .shift=0)
\end_layout

\begin_layout Plain Layout

# D$WIC <- ShiftInTime(D$WIC, .rate=25, .shift=-40)
\end_layout

\begin_layout Plain Layout

DC1 <- D %>% selectTime(160452, 161452)
\end_layout

\begin_layout Plain Layout

DC2 <- D %>% selectTime(182635, 183625)
\end_layout

\begin_layout Plain Layout

DC3 <- D %>% selectTime(191435, 192435)
\end_layout

\begin_layout Plain Layout

CoSp <- rep(0, N)
\end_layout

\begin_layout Plain Layout

CoSpUC <- rep(0, N)
\end_layout

\begin_layout Plain Layout

.A <- 'RTF1'
\end_layout

\begin_layout Plain Layout

.B <- 'ATC'
\end_layout

\begin_layout Plain Layout

.C <- 'AT'
\end_layout

\begin_layout Plain Layout

.D <- 'ATF1'
\end_layout

\begin_layout Plain Layout

DCF <- data.frame()
\end_layout

\begin_layout Plain Layout

for (.data in list(DC1, DC2, DC3)) {
\end_layout

\begin_layout Plain Layout

  N1 <- (N - nrow(.data)) %/% 2
\end_layout

\begin_layout Plain Layout

  N2 <- N - nrow(.data) - N1
\end_layout

\begin_layout Plain Layout

  WP <- c(rep(0, N1), detrend(.data[, c('Time', 'WIC')]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  TP <- c(rep(0, N1), detrend(.data[, c('Time', .A)]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  TPB <- c(rep(0, N1), detrend(.data[, c('Time', .B)]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  TPuc <- c(rep(0, N1), detrend(.data[, c('Time', .C)]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  TPO <- c(rep(0, N1), detrend(.data[, c('Time', .D)]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  Q  <- c(rep(0, N1), detrend(.data[, c('Time', 'Q')]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  ff1 <- fft(TP)
\end_layout

\begin_layout Plain Layout

  ff1uc <- fft(TPuc)
\end_layout

\begin_layout Plain Layout

  ffb <- fft(TPB)
\end_layout

\begin_layout Plain Layout

  ffo <- fft(TPO)
\end_layout

\begin_layout Plain Layout

  ff2 <- fft(WP)
\end_layout

\begin_layout Plain Layout

  ffq <- fft(Q)
\end_layout

\begin_layout Plain Layout

  cs.orig <- 2 * Re(ff1uc * Conj(ff2)) / (Rate * nrow(.data))
\end_layout

\begin_layout Plain Layout

  # cs <- 2 * Re(ff1 * Conj(ff2)) / (Rate * N)
\end_layout

\begin_layout Plain Layout

  ## Estimate original recovery T and apply corrected dynamic heating:
\end_layout

\begin_layout Plain Layout

  alphaR <- mean(.data$alphaR, na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

  cs <- 2 * Re((ff1 / H - alphaR * H * ffq) * Conj(ff2)) / (Rate * nrow(.data))
\end_layout

\begin_layout Plain Layout

  ## supercede with direct use of ATC:
\end_layout

\begin_layout Plain Layout

  cs <- 2 * Re((ff1uc / H) * Conj(ff2)) / (Rate * nrow(.data))
\end_layout

\begin_layout Plain Layout

  cs <- 1/(Mod(H)*cos(Arg(H))) * 2 * Re((ff1uc) * Conj(ff2)) / (Rate * nrow(.data
))
\end_layout

\begin_layout Plain Layout

  CoSp <- CoSp + cs
\end_layout

\begin_layout Plain Layout

  CoSpUC <- CoSpUC + cs.orig
\end_layout

\begin_layout Plain Layout

  DCF <- rbind(DCF, .data)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

Tasm <- mean(DCF$TASX, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

CoSp <- CoSp * scaleFactor / 3
\end_layout

\begin_layout Plain Layout

CoSpUC <- CoSpUC * scaleFactor / 3
\end_layout

\begin_layout Plain Layout

Nby2 <- N %/% 2
\end_layout

\begin_layout Plain Layout

CS <- data.frame(freq = frq[2:(Nby2+1)], cospec = CoSp[2:(Nby2+1)])
\end_layout

\begin_layout Plain Layout

CS.orig <- data.frame(freq = frq[2:(Nby2+1)], cospec = CoSpUC[2:(Nby2+1)])
\end_layout

\begin_layout Plain Layout

CSogiveUC <- cumsum(CoSpUC[2:(Nby2+1)]) * CS$freq[1]
\end_layout

\begin_layout Plain Layout

CSogiveUC <- CSogiveUC[length(CSogiveUC)]-CSogiveUC
\end_layout

\begin_layout Plain Layout

CS.orig$ogive <- CSogiveUC
\end_layout

\begin_layout Plain Layout

wavelengthLimit <- 2000
\end_layout

\begin_layout Plain Layout

fL <- Tasm / wavelengthLimit
\end_layout

\begin_layout Plain Layout

ylim <- c(1.e-2, 50)
\end_layout

\begin_layout Plain Layout

CS.corrected <- plotCS(CS, Units, spans, fL, wavelengthLimit, 
\end_layout

\begin_layout Plain Layout

                   smoothBins=sBins, 
\end_layout

\begin_layout Plain Layout

                   xlim, ylim, CSprevious = CS.orig, project = 'CSET') 
\end_layout

\begin_layout Plain Layout

CS.orig$cospec <- SmoothInterp(CS.orig$cospec, .Length=0)  # treat NAs
\end_layout

\begin_layout Plain Layout

  s25 <- spans %/% 25; s10 <- spans %/% 10; s3 <- spans %/% 3
\end_layout

\begin_layout Plain Layout

  s25 <- s25 + (s25 + 1) %% 2
\end_layout

\begin_layout Plain Layout

  s10 <- s10 + (s10 + 1) %% 2
\end_layout

\begin_layout Plain Layout

  s3 <- s3 + (s3 + 1) %% 2
\end_layout

\begin_layout Plain Layout

  CS.orig$cospec <- zoo::rollapply(CS.orig$cospec, FUN = mean, fill='extend',
 width = s25)
\end_layout

\begin_layout Plain Layout

  CS.orig$cospec[CS.orig$freq > 0.01] <- zoo::rollapply(CS.orig$cospec, FUN
 = mean, fill='extend', width = s10)[CS.orig$freq > 0.01]
\end_layout

\begin_layout Plain Layout

  CS.orig$cospec[CS.orig$freq > 0.1] <- zoo::rollapply(CS.orig$cospec, FUN =
 mean, fill='extend', width = s3)[CS.orig$freq > 0.1]
\end_layout

\begin_layout Plain Layout

  CS.orig$cospec[CS.orig$freq > 1] <- zoo::rollapply(CS.orig$cospec, FUN =
 mean, fill='extend', width = spans)[CS.orig$freq > 1]
\end_layout

\begin_layout Plain Layout

# g + geom_path(data=CS.orig, aes(x=freq, y=cospec*freq), col='forestgreen',
 size=1.3)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
The corrected flux of sensible heat for low-level flight segments over the
 Pacific Ocean.
 
\end_layout

\end_inset

The corrected flux of sensible heat, weighted by the frequency 
\begin_inset Formula $\nu$
\end_inset

, for low-level flight segments over the Pacific Ocean.
 The 
\begin_inset Quotes eld
\end_inset

exceedance
\begin_inset Quotes erd
\end_inset

 is the complement of the cumulative distribution function (i.e., the sum
 of contributions from frequencies above the plotted value), and the dashed
 brown exceedance line is that without transfer-function correction but
 with adjustment of the dynamic-heating term to incorporate the estimated
 response of the temperature sensor.
 The dashed black line shows the frequency limit that corresponds to a wavelengt
h of 2
\begin_inset space ~
\end_inset

km.
\begin_inset CommandInset label
LatexCommand label
name "fig:SOCp1"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The results are shown in Figs.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:SOCp1}
\end_layout

\end_inset

, where the measured fluxes of sensible heat are listed in the plot titles.
 This plot format is unconventional so some explanation is provided below
 because this plot will be used throughout the paper as the primary display
 of the cospectrum.
 The cospectrum can be positive or negative, so it is usually plotted using
 a linear scale for the abscissa.
 However, as the figure shows, the range of ordinate values is displayed
 better with a logarithmic scale, even after weighting the cospectrum by
 frequency.
 The compromise made in this plot is to use a logarithmic scale but plot
 negative values with sign reversed and with a different color, here red
 instead of blue.
 The values plotted in red therefore should be regarded as negative values
 of the plotted magnitude.
 There is then a dead-band at the bottom of the plot where spectral values
 with very small absolute value lie, here absolute values smaller than 
\begin_inset Formula $10^{-2}\thinspace\mathrm{W\,m^{-2}}$
\end_inset

.
 Weighting by frequency is used as is appropriate for a logarithmic abscissa.
 Other features of this plot and computation conventions include the following:
\end_layout

\begin_layout Enumerate
The cospectrum (blue line) has been smoothed using Daniell smoothing, with
 consecutive smoothing using width-3 for frequencies above 0.01
\begin_inset space ~
\end_inset

Hz, then width-5 for frequencies above 0.1
\begin_inset space ~
\end_inset

Hz, then width-17 for frequencies above 1
\begin_inset space ~
\end_inset

Hz.
 For these 5-min flight legs and for 25
\begin_inset space ~
\end_inset

Hz measurements, the maximum smoothing interval corresponds to a smoother
 spanning about 0.05
\begin_inset space ~
\end_inset

Hz, so most spectral features are retained even with this strong smoothing.
 Additional smoothing results from averaging three cospectra to obtain the
 plotted values.
\end_layout

\begin_layout Enumerate
Further smoothing is included by binning the results into 100 logarithmically
 spaced intervals in frequency and averaging in those bins.
 That results in the blue dots (or dark red dots for negative points).
\end_layout

\begin_layout Enumerate
The total flux indicated in the title is that arising from the part of the
 flux with frequency above 0.01
\begin_inset space ~
\end_inset

Hz.
 This corresponds to a wavelength of more than 10
\begin_inset space ~
\end_inset

km\SpecialChar endofsentence
 In addition, there is another estimate of the contribution to the flux
 from wavelengths below a selected limit, here 2
\begin_inset space ~
\end_inset

km.
 That or a still smaller wavelength limit is often a reasonable estimate
 of the part of the flux contributed by turbulent air motions in the boundary
 layer, so that will be regarded as the primary measurement of sensible-heat
 flux.
\end_layout

\begin_layout Enumerate
One additional line is plotted brown and labeled 
\begin_inset Quotes eld
\end_inset

exceedance.
\begin_inset Quotes erd
\end_inset

 That is a cumulative distribution function for the cospectrum, called 
\begin_inset Quotes eld
\end_inset

exceedance
\begin_inset Quotes erd
\end_inset

 because it is the contribution from all frequencies 
\emph on
higher
\emph default
 than the indicated value.
 At high frequency on a logarithmic scale, where some of the most interesting
 variation is located, that is more informative that the conventional cumulative
 distribution.
 The units for exceedance are 
\begin_inset Formula $\mathrm{W\,m}^{-2}$
\end_inset

, not 
\begin_inset Formula $\mathrm{W\,m}^{-2}$
\end_inset

 per logarithmic interval as is the case for the weighted cospectrum.
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The cumulative distribution termed 
\begin_inset Quotes eld
\end_inset

exceedance
\begin_inset Quotes erd
\end_inset

 here is sometimes called the ogive.
\begin_inset Note Note
status open

\begin_layout Plain Layout

\lang english
oh-jive
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The exceedance distributions before correction, shown as the dashed brown
 lines, were calculated using a dynamic-heating correction that was filtered
 to match the response of the sensor, but otherwise were not corrected.
 Without correction for the response as represented by the transfer function,
 about 33% of the flux contributed by wavelengths smaller than 2
\begin_inset space ~
\end_inset

km would be missed.
 The underestimation is particularly serious at higher frequencies: In both
 cases the measured contribution from frequencies above 1
\begin_inset space ~
\end_inset

Hz is more than twice as large after correction as it is without correction.
 
\begin_inset CommandInset citation
LatexCommand citet
key "LawsonRodi1992"
literal "false"

\end_inset

 estimated that, in comparison to their fast thermocouple sensor, the unheated
 Rosemount sensor underestimated the flux by about 21% in their measurements.
 The magnitude of the correction applied here is larger than that estimated
 error, but the flight speed of the aircraft was about 30% higher in this
 case so a larger error would be expected.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
It is unexpected that there is so little difference between the corrected
 and uncorrected flux at high frequency, because the transfer function would
 suggest a significantly larger difference.
 For example, at 5
\begin_inset space ~
\end_inset

Hz the gain and phase of the transfer function are respectively 0.51 and
 
\begin_inset Formula $-40^{\circ},$
\end_inset

which would imply a correction of more than 2.5.
 Instead the ratio of the two cospectra at this frequency is only XXX.
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
The two variables leading to the solid and dashed exceedance variables in
 Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:SOCp1}
\end_layout

\end_inset

 were calculated as follows:
\end_layout

\begin_layout Enumerate
The solid line represents the results obtained by correcting the recovery-temper
ature measurement (RTF1) for its time response and then subtracting the
 estimated effect of dynamic heating as it affects that measurement.This
 was calculated in two ways, with almost equivalent results except at highest
 frequencies.
 First, the air temperature was calculated following the correction procedure
 of Sect.
\begin_inset space ~
\end_inset

4.1 of Part 1, by integration of the equation for the supporting structure,
 solving the remaining equation for the corrected recovery temperature,
 and then applying the filtered dynamic-heating term as in Part 2.
 The second used Fourier transforms to calculate the cospectrum.
 The formula for the cospectrum, in terms of the original measurement 
\begin_inset Formula $T_{m}(t)$
\end_inset

, the updraft 
\begin_inset Formula $w(t)$
\end_inset

 and the dynamic heating 
\begin_inset Formula $Q(t)$
\end_inset

 is:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
C(\nu)=\mathrm{Re}\left((\hat{T}_{m}(\nu)/\mathcal{H}(\nu)-\mathcal{H}(\nu)\hat{Q}(\nu))H(\nu)\hat{w}^{*}(\nu)\right)
\]

\end_inset

where 
\begin_inset Quotes eld
\end_inset

Re
\begin_inset Quotes erd
\end_inset

 denotes the real part, 
\begin_inset Formula $\mathcal{H}(\nu)$
\end_inset

 is the transfer function as a function of frequency 
\begin_inset Formula $\nu$
\end_inset

, the circumflex or 
\begin_inset Quotes eld
\end_inset

hat
\begin_inset Quotes erd
\end_inset

 denotes the Fourier transform of the original function of time and the
 asterisk denotes a complex conjugate.
 The inverse Fourier transform of 
\begin_inset Formula $(\hat{T_{m}}(\nu)/\mathcal{H}(\nu)-\mathcal{H}(\nu)\hat{Q}(\nu))$
\end_inset

 gives the air temperature 
\begin_inset Formula $T_{a}(t)$
\end_inset

 after correction for the time response of the sensor and for the (filtered)
 effect of dynamic heating.
 Both produced overlapping results when added to Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:SOCp1}
\end_layout

\end_inset

 except at frequencies above about 5
\begin_inset space ~
\end_inset

Hz, where the Fourier-transform method appeared to produce excess variance.
 FoBy obtaining a realistic measurement of the cospectrum at high frequency,
 it is possible to estimate how much of the otherwise unknown contribution
 above 1
\begin_inset space ~
\end_inset

Hz has been missed and therefore to judge if the frequency coverage is adequate.
 In this case, the exceedance curve is less than 2% at 10
\begin_inset space ~
\end_inset

Hz and falls rapidly above that frequency, so it appears likely that additional
 contributions from higher frequencies can go unmeasured without introducing
 serious errors into the measurement of flux.r this reason, the first method
 was used.
\end_layout

\begin_layout Enumerate
The dashed line shows the result with correction only for dynamic heating,
 with appropriate filtering of the dynamic-heating term to correct for the
 response of the sensor.
 The transfer function was not otherwise used to correct the estimated air
 temperature.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
By obtaining a realistic measurement of the cospectrum at high frequency,
 it is possible to estimate how much of the otherwise unknown contribution
 above 1
\begin_inset space ~
\end_inset

Hz has been missed and therefore to judge if the frequency coverage is adequate.
 In this case, the exceedance curve is less than 2% at 10
\begin_inset space ~
\end_inset

Hz and falls rapidly above that frequency, even after correction, so it
 appears likely that additional contributions from higher frequencies can
 go unmeasured without introducing serious errors into the measurement of
 flux.
\end_layout

\begin_layout Subsection
Evidence from Simulated Measurements
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<reinitialization,echo=FALSE,include=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Directory <- DataDirectory ()
\end_layout

\begin_layout Plain Layout

Flight <- 1 				
\end_layout

\begin_layout Plain Layout

Project = "SOCRATES"			
\end_layout

\begin_layout Plain Layout

ProjectDir <- "SOCRATES"
\end_layout

\begin_layout Plain Layout

fname = sprintf("%s%s/%srf%02d.nc", Directory, ProjectDir, Project, Flight)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This section uses simulated measurements with the analysis methods described
 in the preceding section to demonstrate that those correction schemes can
 recover the assumed simulated conditions.
 The study uses generated time series representing isotropic wind measurements
 that have a specified relationship to the eddy dissipation rate and the
 expected 
\begin_inset Formula $-5/3$
\end_inset

 slope of spectral variance vs.
\begin_inset space ~
\end_inset

frequency that is expected for an inertial sub-range.
 The procedure was to generate a Gaussian-noise spectrum, find the Fourier
 components, weight them to obtain a 
\begin_inset Formula $-5/3$
\end_inset

 slope, and then use an inverse Fourier transform to reconstruct the simulated
 measurement series.
 The variance spectrum was generated to have the following form as expected
 for an inertial sub-range:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
P(\nu)=C\left(\frac{2\pi}{V}\right)^{-2/3}\epsilon^{2/3}\nu^{-5/3}\label{eq:expectedSpectrum}
\end{equation}

\end_inset

where 
\begin_inset Formula $\nu$
\end_inset

 is the frequency, 
\begin_inset Formula $V$
\end_inset

 the airspeed, 
\begin_inset Formula $\epsilon$
\end_inset

 the eddy dissipation rate, and 
\begin_inset Formula $C=0.5$
\end_inset

 for the longitudinal component of the wind and 2/3 for a lateral component.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout

\lang english
for a lateral wind component is shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:varSpecISR}
\end_layout

\end_inset

.
\end_layout

\end_inset

Thirty-minute sequences were generated at 50
\begin_inset space ~
\end_inset

Hz for the three components of the wind, for an eddy dissipation rate of
 
\begin_inset Formula $10^{-3}\mathrm{m}^{2}\mathrm{s}^{-3}$
\end_inset

, and then 
\begin_inset Note Note
status open

\begin_layout Plain Layout
is shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:generate}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
This time series can then be written to a netCDF file (preferably with the
 Time variable converted to RAF convention) to use as input to studies of
 how missing values and other problems will affect the resulting variance
 spectrum.
 Because the amplitude of the variations is proportional to 
\begin_inset Formula $\epsilon^{1/3}$
\end_inset

, a time series for a different eddy dissipation rate can be obtained by
 scaling these by (
\begin_inset Formula $\epsilon^{\prime}/\epsilon^{*})^{1/3}$
\end_inset

 where 
\begin_inset Formula $\epsilon^{\prime}$
\end_inset

 is the desired eddy dissipation rate and 
\begin_inset Formula $\epsilon^{*}$
\end_inset

 is 
\begin_inset Formula $10^{-5}\,\mathrm{m}^{2}\mathrm{s}^{-3}$
\end_inset

.
\end_layout

\end_inset

long-wavelength components with frequency below 0.05
\begin_inset space ~
\end_inset

Hz were attenuated by multiplying the Fourier components by 
\begin_inset Formula $\exp(-5*0.05/|\nu|)$
\end_inset

 where 
\begin_inset Formula $\nu$
\end_inset

 is the frequency.
 This not only produced a more realistic spectrum but also improved the
 accuracy of the high-frequency simulation, which otherwise exhibited some
 variability for different random sequences.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<varSpecISR, include=FALSE, echo=FALSE, fig.cap=
\begin_inset Quotes erd
\end_inset

Assumed spectral variance at periodogram points.
\begin_inset Quotes erd
\end_inset

>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

epsilon <- 1.e-3  ## mks
\end_layout

\begin_layout Plain Layout

e23 <- epsilon ^ (2 / 3)
\end_layout

\begin_layout Plain Layout

V <- 200   ## assumed flight speed, m/s
\end_layout

\begin_layout Plain Layout

duration <- 1800
\end_layout

\begin_layout Plain Layout

Rate <- 50
\end_layout

\begin_layout Plain Layout

Nyq <- Rate / 2
\end_layout

\begin_layout Plain Layout

C <- (2 / 3) * (2 * pi / V) ^ (-2 / 3)
\end_layout

\begin_layout Plain Layout

# freq <- seq(1/duration, Nyq, by=1/duration)  ## unaliased
\end_layout

\begin_layout Plain Layout

freq <- seq(1 / duration, Nyq * 5, by = 1 / duration)  ## aliased version
\end_layout

\begin_layout Plain Layout

p <-
\end_layout

\begin_layout Plain Layout

  C * e23 * freq ^ (-5 / 3)  ## This is variance per frequency interval,
\end_layout

\begin_layout Plain Layout

## normalized to be positive frequencies
\end_layout

\begin_layout Plain Layout

r <- freq > 0 & freq <= Nyq
\end_layout

\begin_layout Plain Layout

plotWAC(
\end_layout

\begin_layout Plain Layout

  data.frame (freq[r], p[r]),
\end_layout

\begin_layout Plain Layout

  log = 'xy',
\end_layout

\begin_layout Plain Layout

  xlab = 'frequency [Hz]',
\end_layout

\begin_layout Plain Layout

  ylab = bquote('P(frequency) [m' ^ 2 ~ 's' ^ -2 ~ 'Hz' ^ -1 ~ ']'),
\end_layout

\begin_layout Plain Layout

  col = 'blue',
\end_layout

\begin_layout Plain Layout

  lwd = 2
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Extra
inverted 0
status open

\begin_layout Standard

\lang english
\begin_inset ERT
status open

\begin_layout Plain Layout

<<originalGenerate, include = FALSE, eval = FALSE, fig.cap = ''>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## This is the first try, replaced by the method in the next chumk
\end_layout

\begin_layout Plain Layout

if (file.exists('./DF.Rdata')) {
\end_layout

\begin_layout Plain Layout

  load(file = './DF.Rdata') # load data.frame DF
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  Time <- seq(0, duration * Rate - 1) / Rate
\end_layout

\begin_layout Plain Layout

  u <- v <- w <- rep(0, length(Time))
\end_layout

\begin_layout Plain Layout

  nf <- length(freq)
\end_layout

\begin_layout Plain Layout

  rnu <- runif(nf)
\end_layout

\begin_layout Plain Layout

  rnv <- runif(nf)
\end_layout

\begin_layout Plain Layout

  rnw <- runif(nf)
\end_layout

\begin_layout Plain Layout

  a <- sqrt(2 * p / duration)   ## 2 for normalization convention
\end_layout

\begin_layout Plain Layout

  for (i in 1:nf) {
\end_layout

\begin_layout Plain Layout

    fT <- freq[i] * Time
\end_layout

\begin_layout Plain Layout

    u <-
\end_layout

\begin_layout Plain Layout

      u + sqrt(3 / 4) * a[i] * sin(2 * pi * (fT + rnu[i]))  ## random phase
\end_layout

\begin_layout Plain Layout

    v <- v + a[i] * sin(2 * pi * (fT + rnv[i]))
\end_layout

\begin_layout Plain Layout

    w <- w + a[i] * sin(2 * pi * (fT + rnw[i]))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  DF <-
\end_layout

\begin_layout Plain Layout

    data.frame(
\end_layout

\begin_layout Plain Layout

      Time = Time,
\end_layout

\begin_layout Plain Layout

      TASX = rep(V, length(Time)),
\end_layout

\begin_layout Plain Layout

      u = u,
\end_layout

\begin_layout Plain Layout

      v = v,
\end_layout

\begin_layout Plain Layout

      w = w
\end_layout

\begin_layout Plain Layout

    )
\end_layout

\begin_layout Plain Layout

  attr(DF, 'Rate') <- Rate
\end_layout

\begin_layout Plain Layout

  save(DF, file = './DF.Rdata')
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

g <- VSpec(DF, 'w', xlim = c(0.01, 30))
\end_layout

\begin_layout Plain Layout

g <- VSpec(DF, 'v', ADD = g)
\end_layout

\begin_layout Plain Layout

VSpec(DF, 'u', ADD = g) + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

DF$w <- DF$w * 100^0.33333
\end_layout

\begin_layout Plain Layout

DF$v <- DF$v * 100^0.33333
\end_layout

\begin_layout Plain Layout

DF$u <- DF$u * 100^0.33333
\end_layout

\begin_layout Plain Layout

g <- VSpec(DF, 'w', xlim = c(0.01, 30), type = 'MEM')
\end_layout

\begin_layout Plain Layout

if (file.exists('./EDR.Rdata')) {
\end_layout

\begin_layout Plain Layout

  # loads data.frame DF2
\end_layout

\begin_layout Plain Layout

  load(file = './EDR.Rdata')
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  ## now filter and reduce rate to Rate2
\end_layout

\begin_layout Plain Layout

  Rate2 <- 25
\end_layout

\begin_layout Plain Layout

  Time2 <- seq(0, duration * Rate2 - 1) / Rate2
\end_layout

\begin_layout Plain Layout

  wf <- signal::decimate(DF$w, Rate / Rate2, n = 25, ftype = 'fir')
\end_layout

\begin_layout Plain Layout

  uf <- signal::decimate(DF$u, Rate / Rate2, n = 25, ftype = 'fir')
\end_layout

\begin_layout Plain Layout

  vf <- signal::decimate(DF$v, Rate / Rate2, n = 25, ftype = 'fir')
\end_layout

\begin_layout Plain Layout

  DF2 <-
\end_layout

\begin_layout Plain Layout

    data.frame(
\end_layout

\begin_layout Plain Layout

      Time = Time2,
\end_layout

\begin_layout Plain Layout

      TASX = rep(V, length(Time2)) + uf,
\end_layout

\begin_layout Plain Layout

      u = uf,
\end_layout

\begin_layout Plain Layout

      v = vf,
\end_layout

\begin_layout Plain Layout

      w = wf
\end_layout

\begin_layout Plain Layout

    )
\end_layout

\begin_layout Plain Layout

  attr(DF2, 'Rate') <- Rate2
\end_layout

\begin_layout Plain Layout

  save(DF2, file = './EDR.Rdata')
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

load('../SocratesQA/Time_units.Rdata')
\end_layout

\begin_layout Plain Layout

attr(DF2$Time, 'units') <- Time_units$value
\end_layout

\begin_layout Plain Layout

tref <- sub ('seconds since ', '', attr (DF2$Time, 'units'))
\end_layout

\begin_layout Plain Layout

DF2$Time <- as.POSIXct(DF2$Time, tz = 'UTC', origin = tref)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<generate, include=FALSE, echo=FALSE, fig.cap='The variance spectrum of
 the generated time series.
 Three wind components are shown: $u$ longitudinal; $v$ side lateral; $w$
 upward.
 The simulated eddy dissipation rate was $10^{-3}$ m$^2s^{-3}$.
 The generated longitudinal spectral density (u) is 3/4 the lateral spectral
 densities (v and w), as expected in an inertial subrange.
 The dashed orange lines indicated the expected slope ($-2/3$ for this distribut
ion because it is weighted by frequency), with the large-dot line representing
 $10^{-4}$ m$^2s^{-3}$ and other lines representing eddy dissipation rates
  factors of 10 higher or lower.
 The spectral variance has been attenuated at low frequency to simulate
 the shapes that are often observed.
 The displayed wavelength scale was determined from the average flight speed.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if (file.exists('DF2.Rdata')) {  ## This is to avoid having this change every
 run
\end_layout

\begin_layout Plain Layout

  load(file = 'DF2.Rdata')
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  Rate <- 25
\end_layout

\begin_layout Plain Layout

  duration <- 2^16 / Rate
\end_layout

\begin_layout Plain Layout

  epsilon <- 1.e-3  ## Specify the eddy dissipation rate, mks units
\end_layout

\begin_layout Plain Layout

  V <- 200   ## assumed flight speed, m/s
\end_layout

\begin_layout Plain Layout

  ## Spectral variance amplitude, lateral component
\end_layout

\begin_layout Plain Layout

  C <- (2 / 3) * (2 * pi / V) ^ (-2 / 3) * epsilon ^ (2 / 3) 
\end_layout

\begin_layout Plain Layout

  Time <- seq(0, duration * Rate - 1) / Rate
\end_layout

\begin_layout Plain Layout

  N <- length(Time)
\end_layout

\begin_layout Plain Layout

  A <- sqrt(C * Rate / 2)
\end_layout

\begin_layout Plain Layout

  u <- rnorm(N, 0, A) * sqrt(3/4)  ## sqrt(3/4) to get 3:4 ratio, spectra
\end_layout

\begin_layout Plain Layout

  v <- rnorm(N, 0, A)
\end_layout

\begin_layout Plain Layout

  w <- rnorm(N, 0, A)
\end_layout

\begin_layout Plain Layout

  DF2 <- data.frame(Time = Time, TASX = V + u, u = u, v = v, w = w)
\end_layout

\begin_layout Plain Layout

  attr(DF2, 'Rate') <- Rate
\end_layout

\begin_layout Plain Layout

  f1 <- fft(DF2$u)
\end_layout

\begin_layout Plain Layout

  f2 <- fft(DF2$v)
\end_layout

\begin_layout Plain Layout

  f3 <- fft(DF2$w)
\end_layout

\begin_layout Plain Layout

  df <- Rate / N
\end_layout

\begin_layout Plain Layout

  frq <- c(seq(0, Rate/2, by = df), seq(-Rate/2+df, -df, by = df))
\end_layout

\begin_layout Plain Layout

  f1[2:N] <- f1[2:N] * abs(frq[2:N]) ^ (-5/6)  ## Force -5/3 slope
\end_layout

\begin_layout Plain Layout

  f2[2:N] <- f2[2:N] * abs(frq[2:N]) ^ (-5/6)
\end_layout

\begin_layout Plain Layout

  f3[2:N] <- f3[2:N] * abs(frq[2:N]) ^ (-5/6)
\end_layout

\begin_layout Plain Layout

  f_atten <- 0.05
\end_layout

\begin_layout Plain Layout

  rf <- (abs(frq) < f_atten)
\end_layout

\begin_layout Plain Layout

  rf[1] <- TRUE
\end_layout

\begin_layout Plain Layout

  f1[rf] <- f1[rf] * exp(-5 * f_atten / abs(frq[rf]))  ## Truncate low-frequency
\end_layout

\begin_layout Plain Layout

                                          ## (improves high-f accuracy)
\end_layout

\begin_layout Plain Layout

  f2[rf] <- f2[rf] * exp(-5 * f_atten / abs(frq[rf]))
\end_layout

\begin_layout Plain Layout

  f3[rf] <- f3[rf] * exp(-5 * f_atten / abs(frq[rf]))
\end_layout

\begin_layout Plain Layout

  DF2$u <- Re(fft(f1, inverse = TRUE) / N)
\end_layout

\begin_layout Plain Layout

  DF2$v <- Re(fft(f2, inverse = TRUE) / N)
\end_layout

\begin_layout Plain Layout

  DF2$w <- Re(fft(f3, inverse = TRUE) / N)
\end_layout

\begin_layout Plain Layout

  ## Modify time to get a POSIXct value as expected by Ranadu:
\end_layout

\begin_layout Plain Layout

  load('chunks/Time_units.Rdata')  ## Saved from a conventional file
\end_layout

\begin_layout Plain Layout

  attr(DF2$Time, 'units') <- Time_units$value
\end_layout

\begin_layout Plain Layout

  tref <- sub ('seconds since ', '', attr (DF2$Time, 'units'))
\end_layout

\begin_layout Plain Layout

  DF2$Time <- as.POSIXct(DF2$Time, tz = 'UTC', origin = tref)
\end_layout

\begin_layout Plain Layout

  DF2 <- DF2 %>% selectTime(500, 3500)  # Select subset to avoid end effects
\end_layout

\begin_layout Plain Layout

  save(DF2, file='DF2.Rdata')
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

DF2 %>% select(Time, TASX, u, v, w) %>% 
\end_layout

\begin_layout Plain Layout

        VSpec(xlim=c(0.01,15), ylim=c(1.e-3, 10), method = 'MEM', poles=100)
 +          
\end_layout

\begin_layout Plain Layout

        theme_WAC(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plotCS2, include=TRUE, echo=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## plotCS is redefined here to get the form desired for a unified
\end_layout

\begin_layout Plain Layout

## plot of the simulation results without distorting earlier plots.
\end_layout

\begin_layout Plain Layout

plotCS <- function(CS, Units, spans=149, fL, wavelengthLimit=2000, 
\end_layout

\begin_layout Plain Layout

                   smoothBins=100, 
\end_layout

\begin_layout Plain Layout

                   xlim=c(0.01,15), ylim=c(0.001,80), 
\end_layout

\begin_layout Plain Layout

                   printTitle=TRUE, CSprevious = NA,
\end_layout

\begin_layout Plain Layout

                   plotFigure = TRUE, plotRibbon=TRUE, 
\end_layout

\begin_layout Plain Layout

                   showNegative = TRUE, ADD = FALSE) {
\end_layout

\begin_layout Plain Layout

  if(ADD) {
\end_layout

\begin_layout Plain Layout

    ## Add to an existing plot definition that is saved in a previous call
\end_layout

\begin_layout Plain Layout

    if(exists('g.CS')) g <- g.CS  ## Saved from a previous call
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  ylab <- bquote(nu * " x flux cospectrum ["*.(Units)*"]")    
\end_layout

\begin_layout Plain Layout

  CSogive <- cumsum(CS$cospec) * CS$freq[1]
\end_layout

\begin_layout Plain Layout

  CSogive <- CSogive[length(CSogive)]-CSogive
\end_layout

\begin_layout Plain Layout

  CS$ogive <- CSogive
\end_layout

\begin_layout Plain Layout

  CS$cospec <- SmoothInterp(CS$cospec, .Length=0)  # treat NAs
\end_layout

\begin_layout Plain Layout

  s25 <- spans %/% 25; s10 <- spans %/% 10; s3 <- spans %/% 3
\end_layout

\begin_layout Plain Layout

  s25 <- s25 + (s25 + 1) %% 2
\end_layout

\begin_layout Plain Layout

  s10 <- s10 + (s10 + 1) %% 2
\end_layout

\begin_layout Plain Layout

  s3 <- s3 + (s3 + 1) %% 2
\end_layout

\begin_layout Plain Layout

  CS$cospec <- zoo::rollapply(CS$cospec, FUN = mean, fill='extend', width
 = s25)
\end_layout

\begin_layout Plain Layout

  CS$cospec[CS$freq > 0.01] <- zoo::rollapply(CS$cospec, FUN = mean, fill='extend
', width = s10)[CS$freq > 0.01]
\end_layout

\begin_layout Plain Layout

  CS$cospec[CS$freq > 0.1] <- zoo::rollapply(CS$cospec, FUN = mean, fill='extend'
, width = s3)[CS$freq > 0.1]
\end_layout

\begin_layout Plain Layout

  CS$cospec[CS$freq > 1] <- zoo::rollapply(CS$cospec, FUN = mean, fill='extend',
 width = spans)[CS$freq > 1]
\end_layout

\begin_layout Plain Layout

  FluxL <- CSogive[which(CS$freq > fL)[1]]
\end_layout

\begin_layout Plain Layout

  Flux <- CSogive[which(CS$freq > 0.01)[1]]
\end_layout

\begin_layout Plain Layout

  attr(CS, 'Flux') <- Flux
\end_layout

\begin_layout Plain Layout

  attr(CS, 'FluxL') <- FluxL
\end_layout

\begin_layout Plain Layout

  attr(CS, 'wavelengthLimit') <- wavelengthLimit
\end_layout

\begin_layout Plain Layout

  ## Construct the plot:
\end_layout

\begin_layout Plain Layout

  CS$ncospec <- -1 * CS$cospec
\end_layout

\begin_layout Plain Layout

  ## Weight by frequency for log-abscissa plot:
\end_layout

\begin_layout Plain Layout

  CS$cospec <- CS$cospec * CS$freq
\end_layout

\begin_layout Plain Layout

  CS$ncospec <- CS$ncospec * CS$freq
\end_layout

\begin_layout Plain Layout

  # plotWAC(CS, xlab='frequency [Hz]', ylab=ylab, log='xy',
\end_layout

\begin_layout Plain Layout

  #     col = c('skyblue', 'forestgreen', 'red'), lwd = c(2, 2, 2), 
\end_layout

\begin_layout Plain Layout

  #     lty = c(1, 2, 1),
\end_layout

\begin_layout Plain Layout

  #     xlim=c(0.05, 15), ylim=c(0.01,250), legend.position=NA)
\end_layout

\begin_layout Plain Layout

  if (smoothBins > 5) {
\end_layout

\begin_layout Plain Layout

    BS <- binStats(data.frame(CS$cospec, log(CS$freq)), bins = smoothBins)
\end_layout

\begin_layout Plain Layout

    # lines(exp(BS$xc), BS$ybar, lwd=2, col='brown')
\end_layout

\begin_layout Plain Layout

    BS$nybar <- -1 * BS$ybar
\end_layout

\begin_layout Plain Layout

    BS$ybar[BS$ybar < 0] <- NA
\end_layout

\begin_layout Plain Layout

    BS$nybar[BS$nybar < 0] <- NA
\end_layout

\begin_layout Plain Layout

    BS$xc <- exp(BS$xc)
\end_layout

\begin_layout Plain Layout

    # lines(exp(BS$xc), BS$nybar, lwd=2, col='magenta')
\end_layout

\begin_layout Plain Layout

    attr(CS, 'smoothed data.frame') <- BS
\end_layout

\begin_layout Plain Layout

    bse <- data.frame(x = BS$xc, ymin = BS$ybar - BS$sigma, ymax = BS$ybar
 + BS$sigma,
\end_layout

\begin_layout Plain Layout

                      yminN = BS$nybar - BS$sigma, ymaxN = BS$nybar + BS$sigma)
\end_layout

\begin_layout Plain Layout

    # lines(exp(BS$xc), BS$nybar, lwd=2, col='magenta')
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  if (smoothBins > 5) {
\end_layout

\begin_layout Plain Layout

    bse$ymin[bse$ymin < ylim[1]] <- ylim[1]
\end_layout

\begin_layout Plain Layout

    bse$yminN[bse$yminN < ylim[1]] <- ylim[1]
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  if(ADD) {
\end_layout

\begin_layout Plain Layout

    g <- g + geom_path(data = CS, aes(y = cospec, colour='measured',
\end_layout

\begin_layout Plain Layout

                       linetype='measured'))
\end_layout

\begin_layout Plain Layout

    if (showNegative) {
\end_layout

\begin_layout Plain Layout

      g <- g + geom_path(aes(y = ncospec, colour='-cosp2', 
\end_layout

\begin_layout Plain Layout

         linetype='-cosp2'))
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    g <- g + geom_path(data = CS, aes(y = ogive, colour='exc-msrd', 
\end_layout

\begin_layout Plain Layout

                       linetype='exc-msrd'), lwd=1.2)
\end_layout

\begin_layout Plain Layout

    # g <- g + geom_point(data = CS, aes(y = ogive, colour = 'exc-msrd',
\end_layout

\begin_layout Plain Layout

    #                    shape = 'exc-msrd'))
\end_layout

\begin_layout Plain Layout

  } else { 
\end_layout

\begin_layout Plain Layout

    g <- ggplot(data = CS, aes(x=freq))
\end_layout

\begin_layout Plain Layout

    g <- g + geom_path(data = CS, aes(y = cospec, colour='generated', 
\end_layout

\begin_layout Plain Layout

                       linetype='generated'))
\end_layout

\begin_layout Plain Layout

    if (showNegative) {
\end_layout

\begin_layout Plain Layout

      g <- g + geom_path(aes(y = ncospec, colour='-cosp', linetype='-cosp'))
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    g <- g + geom_path(aes(y = ogive, colour='exceedance',
\end_layout

\begin_layout Plain Layout

                           linetype = 'exceedance'), lwd=1.2)
\end_layout

\begin_layout Plain Layout

    # g <- g + geom_point(aes(y = ogive, colour = 'exceedance',
\end_layout

\begin_layout Plain Layout

    #                         shape = 'exceedance'))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  if (is.data.frame(CSprevious)) {
\end_layout

\begin_layout Plain Layout

    g <- g + geom_path(data=CSprevious, aes(x = freq, y = ogive,
\end_layout

\begin_layout Plain Layout

                       colour='exc-corr', linetype='exc-corr'),
\end_layout

\begin_layout Plain Layout

                       lwd=1.2)
\end_layout

\begin_layout Plain Layout

    # g <- g + geom_point(data = CSprevious, aes(x = freq, y = ogive,
\end_layout

\begin_layout Plain Layout

    #                    colour = 'exc-corr', shape = 'exc-corr'))
\end_layout

\begin_layout Plain Layout

    if ('ogive2' %in% names(CSprevious)) {
\end_layout

\begin_layout Plain Layout

      g <- g + geom_path(data=CSprevious, aes(x = freq, y = ogive2,
\end_layout

\begin_layout Plain Layout

                          colour='generated', linetype='generated'),
\end_layout

\begin_layout Plain Layout

                          lwd=1.3)
\end_layout

\begin_layout Plain Layout

      # g <- g + geom_point(data = CSprevious, aes(x = freq, y = ogive2,
\end_layout

\begin_layout Plain Layout

      #                     colour = 'generated', shape = 'generated'))
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  if (smoothBins > 5) {
\end_layout

\begin_layout Plain Layout

    pclr <- ifelse(ADD, 'measured', 'generated')
\end_layout

\begin_layout Plain Layout

    pclr <- ifelse(ADD, 'forestgreen', 'blue')
\end_layout

\begin_layout Plain Layout

    # g <- g + geom_path(data = BS, aes(x=xc, y=ybar, colour=pclr), lwd=1.2)
\end_layout

\begin_layout Plain Layout

    # g <- g + geom_path(data = BS, aes(x=xc, y=nybar), colour='deeppink3',
 lwd=1.2)
\end_layout

\begin_layout Plain Layout

    if (ADD) {
\end_layout

\begin_layout Plain Layout

      g <- g + geom_point(data = BS, aes(x=xc, y=ybar, colour='measured'),
 pch=19)
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      g <- g + geom_point(data = BS, aes(x=xc, y=ybar, colour='generated'),
 pch=19)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if (showNegative) {
\end_layout

\begin_layout Plain Layout

      g <- g + geom_point(data = BS, aes(x=xc, y=nybar), colour='darkred',
 pch=19)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if (plotRibbon) {
\end_layout

\begin_layout Plain Layout

      # GeomRibbon$handle_na <- function(data, params) {  data }
\end_layout

\begin_layout Plain Layout

      g <- g + geom_ribbon(data=bse, aes(x=x, ymin=ymin, ymax=ymax),
\end_layout

\begin_layout Plain Layout

        fill=pclr, alpha=0.2, show.legend=FALSE, inherit.aes=FALSE, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

      if (showNegative) {
\end_layout

\begin_layout Plain Layout

        g <- g + geom_ribbon(data=bse, aes(x=x, ymin=yminN, ymax=ymaxN),
\end_layout

\begin_layout Plain Layout

                fill='red', alpha=0.2, show.legend=FALSE, 
\end_layout

\begin_layout Plain Layout

                inherit.aes=FALSE, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      # g <- g + geom_path(data=bse, aes(x=x, y=ymin), lty=1, lwd=0.5, col='magen
ta') +
\end_layout

\begin_layout Plain Layout

      #          geom_path(data=bse, aes(x=x, y=ymax), lty=1, lwd=0.5, col='magen
ta')
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  if (!ADD) {
\end_layout

\begin_layout Plain Layout

  g <- g + geom_path(data=data.frame(x=rep(fL, 2), y=ylim), aes(x=x, y=y),
 linetype=2)
\end_layout

\begin_layout Plain Layout

  g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=2), #limits = xlim, 
\end_layout

\begin_layout Plain Layout

    labels = trans_format("log10", math_format(10^.x))) +
\end_layout

\begin_layout Plain Layout

    scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x, n=4),
 #limits = ylim,             
\end_layout

\begin_layout Plain Layout

      labels = trans_format("log10", math_format(10^.x))) +
\end_layout

\begin_layout Plain Layout

    annotation_logticks(sides='trbl') +
\end_layout

\begin_layout Plain Layout

    coord_cartesian(xlim=xlim, ylim=ylim)
\end_layout

\begin_layout Plain Layout

  g <- g + xlab('frequency [Hz]') + ylab(ylab)
\end_layout

\begin_layout Plain Layout

  ttl <- bquote('Total flux '~.(format(Flux, digits=3))~.(Units)*'; partial
 <'*.(format((wavelengthLimit/1000), digits=2))~'km:'~.(format(FluxL, digits=3))~.(
Units))
\end_layout

\begin_layout Plain Layout

  if (printTitle) {
\end_layout

\begin_layout Plain Layout

    g <- g + labs(title=ttl)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  g <- g + theme_WAC(1) + theme(plot.title = element_text(size=12)) +
\end_layout

\begin_layout Plain Layout

                             theme(legend.position=c(0.5, 0.91))
\end_layout

\begin_layout Plain Layout

  } else {  ## this is for ADD == TRUE
\end_layout

\begin_layout Plain Layout

   if (showNegative) {
\end_layout

\begin_layout Plain Layout

     g <- suppressWarnings(g + scale_colour_manual (name='', 
\end_layout

\begin_layout Plain Layout

          values=c('cosp'='blue', '-cosp'='red', 'exceedance'='brown',
\end_layout

\begin_layout Plain Layout

             'generated' = 'forestgreen', 'measured'='forestgreen',
\end_layout

\begin_layout Plain Layout

             '-cosp2'='darkorange', 'exceedance2'='black')))
\end_layout

\begin_layout Plain Layout

    g <- g + scale_linetype_manual (name='', values=c('cosp'=1, 
\end_layout

\begin_layout Plain Layout

             '-cosp'=1, 'exceedance'=1, 'generated' = 4, 'measured'=1, 
\end_layout

\begin_layout Plain Layout

             '-cosp2'=1, 'exceedance2'=2))
\end_layout

\begin_layout Plain Layout

    # g <- g + guides(col=guide_legend(reverse = TRUE), 
\end_layout

\begin_layout Plain Layout

    #               linetype=guide_legend(reverse = TRUE))
\end_layout

\begin_layout Plain Layout

  } else {
\end_layout

\begin_layout Plain Layout

    g <- g + scale_linetype_manual (name = '', values=c('generated'=1, 
\end_layout

\begin_layout Plain Layout

             'exceedance' = 1, 'exc-msrd' = 2, 'measured' = 1, 
\end_layout

\begin_layout Plain Layout

             'exc-corr' = 2))
\end_layout

\begin_layout Plain Layout

    g <- g + scale_shape_manual(name = '', values = c('generated' = 19,
\end_layout

\begin_layout Plain Layout

             'exceedance' = NA, 'exc-msrd' = NA, 'measured' = 19, 
\end_layout

\begin_layout Plain Layout

             'exc-corr' = NA))
\end_layout

\begin_layout Plain Layout

#     g <- g + scale_shape_manual(name = '', guide = guide_legend(
\end_layout

\begin_layout Plain Layout

#                override.aes = list(19, NA, NA, 19, NA)))
\end_layout

\begin_layout Plain Layout

    g <- g + scale_colour_manual (name='', 
\end_layout

\begin_layout Plain Layout

          values=c('generated'='blue', 'exceedance'='brown',
\end_layout

\begin_layout Plain Layout

             'exc-msrd' = 'brown', 'measured'='forestgreen',
\end_layout

\begin_layout Plain Layout

             'exc-corr'='black'),
\end_layout

\begin_layout Plain Layout

              guide = guide_legend(
\end_layout

\begin_layout Plain Layout

              override.aes = list(shape = c('generated' = 19, 
\end_layout

\begin_layout Plain Layout

                'measured' = 19))))
\end_layout

\begin_layout Plain Layout

    g <- g + guides(colour = guide_legend(reverse = TRUE),  
\end_layout

\begin_layout Plain Layout

                    linetype=guide_legend(reverse = TRUE),
\end_layout

\begin_layout Plain Layout

                    shape = guide_legend(reverse = TRUE)) 
\end_layout

\begin_layout Plain Layout

    g <- g + guides(shape = guide_legend(override.aes = list(shape=c(19,
 NA, NA, 19, NA))))
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  if (plotFigure) suppressWarnings(print(g))
\end_layout

\begin_layout Plain Layout

  g.CS <<- g  ## Save for adding additional lines...
\end_layout

\begin_layout Plain Layout

  # par(bg = 'gray95')
\end_layout

\begin_layout Plain Layout

  # plotWAC(data.frame(exp(BSF1$xc), BSF1$ybar, BSF1$nybar), 
\end_layout

\begin_layout Plain Layout

  #   col = c('blue', 'red'), ylab = ylab,
\end_layout

\begin_layout Plain Layout

  #   xlab='frequency [Hz]', log='xy', xlim=c(0.05,15),
\end_layout

\begin_layout Plain Layout

  #   ylim=c(0.01,250), legend.position=NA)
\end_layout

\begin_layout Plain Layout

  # lines(CSF1, col='gray50')
\end_layout

\begin_layout Plain Layout

  # lines(exp(BSF1$xc), BSF1$ybar, col='blue', lwd=2)
\end_layout

\begin_layout Plain Layout

  # lines(exp(BSF1$xc), BSF1$ybar+BSF1$sigma, col='blue', lwd=1)
\end_layout

\begin_layout Plain Layout

  # lines(exp(BSF1$xc), BSF1$ybar-BSF1$sigma, col='blue', lwd=1)
\end_layout

\begin_layout Plain Layout

  return(CS)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To introduce sensible-heat flux a correlation was introduced between the
 simulated temperature and updraft, as follows:
\end_layout

\begin_layout Enumerate
In addition to the three-component time series for the wind, another independent
 time series with the same slope was generated for the 
\emph on
air temperature 
\emph default

\begin_inset Formula $T_{a}$
\end_inset

 with fluctuations 
\begin_inset Formula $T_{a}^{\prime}$
\end_inset

 scaled smaller by a factor of 
\begin_inset Formula $S=1^{\circ}\mathrm{C}/(5\thinspace\mathrm{m/s)}$
\end_inset

 in comparison to the magnitude of the wind fluctuations.
 
\end_layout

\begin_layout Enumerate
Correlation between the two time series was then introduced by defining
 a new temperature time series with the fluctuations 
\begin_inset Formula $T_{c}^{\prime}=(1-r)T^{\prime}+rw^{\prime}S$
\end_inset

 where 
\begin_inset Formula $r=0.3$
\end_inset

.
 The result will be 
\begin_inset Formula $<w^{\prime}T_{c}^{\prime}>=r\sqrt{\sigma_{w}\sigma_{T_{c}}}$
\end_inset

, which will lead to a flux of sensible heat specified as
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
F_{s}=\rho_{a}C_{p}r\sqrt{\sigma_{w}\sigma_{T_{c}}}
\]

\end_inset


\end_layout

\begin_layout Enumerate
Finally, the measured recovery temperature was simulated by adding the dynamic-h
eating correction to the simulated air temperature and then filtering the
 result to represent how the sensor would respond.
\end_layout

\begin_layout Standard
In this simulation, the correlation is the same at all frequencies so the
 contribution to the measured flux also extends over all frequencies.
 About 15% of the 
\begin_inset Formula $<2.5\,\mathrm{km}$
\end_inset

 flux is contributed by frequencies above 1
\begin_inset space ~
\end_inset

Hz, where the sensor may respond incompletely to the fluctuations and underestim
ate the flux.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<genF, include=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

rc <- 0.3
\end_layout

\begin_layout Plain Layout

DF2$T <- DF2$v / 5
\end_layout

\begin_layout Plain Layout

DF2$T <- (1 - rc) * DF2$T + rc * DF2$w / 5 + 10
\end_layout

\begin_layout Plain Layout

DF2$WIC <- DF2$w
\end_layout

\begin_layout Plain Layout

DF2$Q <- 0.985 * DF2$TASX ^ 2 / 2010
\end_layout

\begin_layout Plain Layout

## The true recovery temperature that is the measurand
\end_layout

\begin_layout Plain Layout

DF2$RT <- DF2$T + DF2$Q  
\end_layout

\begin_layout Plain Layout

a <- Param1$a
\end_layout

\begin_layout Plain Layout

tau1 <- Param1$tau1
\end_layout

\begin_layout Plain Layout

tau2 <- Param1$tau2
\end_layout

\begin_layout Plain Layout

DF2$TsQ <- DF2$RT
\end_layout

\begin_layout Plain Layout

DF2$Qp <- DF2$Q
\end_layout

\begin_layout Plain Layout

Rate <- attr (DF2, 'Rate')
\end_layout

\begin_layout Plain Layout

fS <- function(y, i) {
\end_layout

\begin_layout Plain Layout

  (DF2$Q[i] - y) / (Rate * tau2)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

fM <- function (y, i) {
\end_layout

\begin_layout Plain Layout

  (a * DF2$Q[i] + (1 - a) * DF2$TsQ[i] - y) / (Rate * tau1)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

# DF2$TsQ <- rk4.integrate (fS, DF2$Q[1], 1:nrow(DF2))
\end_layout

\begin_layout Plain Layout

# DF2$Qp <- rk4.integrate (fM, DF2$Q[1], 1:nrow(DF2))
\end_layout

\begin_layout Plain Layout

DF2$QF <- as.vector(signal::filter(AR, DF2$Q))
\end_layout

\begin_layout Plain Layout

DF2$QF <- ShiftInTime(DF2$QF, .shift=-Lshift * 40, .rate=25)
\end_layout

\begin_layout Plain Layout

## Find the measured recovery temperature Tm responding to RT
\end_layout

\begin_layout Plain Layout

fS <- function(y, i) {
\end_layout

\begin_layout Plain Layout

  (DF2$RT[i] - y) / (Rate * tau2)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

fM <- function (y, i) {
\end_layout

\begin_layout Plain Layout

  (a * DF2$RT[i] + (1 - a) * DF2$Ts[i] - y) / (Rate * tau1)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

# DF2$Ts <- rk4.integrate (fS, DF2$RT[1], 1:nrow(DF2))
\end_layout

\begin_layout Plain Layout

# DF2$Tm <- rk4.integrate (fM, DF2$RT[1], tv = 1:nrow(DF2))
\end_layout

\begin_layout Plain Layout

# DF2$Tm <- rk4.integrate (fM, DF2$RT[1], 1:nrow(DF2))
\end_layout

\begin_layout Plain Layout

DF2$TF <- as.vector(signal::filter(AR, DF2$RT))
\end_layout

\begin_layout Plain Layout

## TF is the filtered measurement of the recovery temperature, 
\end_layout

\begin_layout Plain Layout

## so this is what would be measured.
\end_layout

\begin_layout Plain Layout

DF2$TF <- ShiftInTime(DF2$TF, .shift=-Lshift * 40, .rate=25) 
\end_layout

\begin_layout Plain Layout

## The erroneous conventionally measured ambient temperature
\end_layout

\begin_layout Plain Layout

DF2$ATm <- DF2$TF - DF2$Q 
\end_layout

\begin_layout Plain Layout

# It would be better to use the filtered dynamic-heating
\end_layout

\begin_layout Plain Layout

DF2$ATM <- DF2$TF - DF2$QF  
\end_layout

\begin_layout Plain Layout

SF <- 100 * 850 / (287 * 283) * 1005
\end_layout

\begin_layout Plain Layout

A <- flux(    ## This is the 
\begin_inset Quotes eld
\end_inset

true
\begin_inset Quotes erd
\end_inset

 flux
\end_layout

\begin_layout Plain Layout

  DF2,
\end_layout

\begin_layout Plain Layout

  'T',
\end_layout

\begin_layout Plain Layout

  Units = bquote("W" ~ m ^ -2),
\end_layout

\begin_layout Plain Layout

  smoothBins = 100,
\end_layout

\begin_layout Plain Layout

  scaleFactor = mean(SF, na.rm=TRUE),
\end_layout

\begin_layout Plain Layout

  wavelengthLimit = 2500,
\end_layout

\begin_layout Plain Layout

  .plot = FALSE
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<simF, include=TRUE, fig.height=4, fig.scap = 'The cospectrum for the flux
 of sensible heat, weighted by frequency, for a simulated data set.', fig.cap='The
 cospectrum for the flux of sensible heat (blue line), weighted by frequency
 $
\backslash

\backslash
nu$, for the simulated data generated as described in the text.
 Three 10-min segments of simulated 25 Hz data were averaged.
 The measured cospectrum was obtained by filtering the simulated recovery
 temperature and subtracting the correction for dynamic heating.
 For the generated and measured cospectrum, filled circles indicate the
 average values calculated in 50 logarithmically space intervals, and for
 the measured cospectrum shading indicates the standard deviation in those
 intervals.
 The exceedance lines show the contribution to flux from frequencies higher
 than the plotted frequency.
 The corrected cospectrum is not shown but is consistent with the generated
 cospectrum, as demonstrated by the agreement between the generated exceedance
 and the corrected exceedance.
 The units for the exceedance distributions are W m$^{-2}$, while the units
 for the weighted flux cospectra are W m$^{-2}$ per unit logarithmic increment.'>
>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# A <- flux(
\end_layout

\begin_layout Plain Layout

#   DF2,
\end_layout

\begin_layout Plain Layout

#   'ATF',
\end_layout

\begin_layout Plain Layout

#   Units = bquote("W" ~ m ^ -2),
\end_layout

\begin_layout Plain Layout

#   smoothBins = 100,
\end_layout

\begin_layout Plain Layout

#   scaleFactor = mean(SF, na.rm=TRUE),
\end_layout

\begin_layout Plain Layout

#   wavelengthLimit = 2500
\end_layout

\begin_layout Plain Layout

# )
\end_layout

\begin_layout Plain Layout

AF <- flux(
\end_layout

\begin_layout Plain Layout

  DF2,
\end_layout

\begin_layout Plain Layout

  'ATm',
\end_layout

\begin_layout Plain Layout

  Units = bquote("W" ~ m ^ -2),
\end_layout

\begin_layout Plain Layout

  smoothBins = 100,
\end_layout

\begin_layout Plain Layout

  scaleFactor = mean(SF, na.rm=TRUE),
\end_layout

\begin_layout Plain Layout

  Par = Param1,
\end_layout

\begin_layout Plain Layout

  .plot = FALSE,
\end_layout

\begin_layout Plain Layout

  wavelengthLimit = 2500
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

N <- 2^14   ## 16384 covers the 10-min (15000-pt) segments
\end_layout

\begin_layout Plain Layout

# Get the transfer function:
\end_layout

\begin_layout Plain Layout

a <- Param1$a
\end_layout

\begin_layout Plain Layout

tau1 <- Param1$tau1
\end_layout

\begin_layout Plain Layout

tau2 <- Param1$tau2
\end_layout

\begin_layout Plain Layout

df <- Rate / N
\end_layout

\begin_layout Plain Layout

frq <- c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
\end_layout

\begin_layout Plain Layout

H <- LTphaseC(frq, Param1)
\end_layout

\begin_layout Plain Layout

D <- DF2
\end_layout

\begin_layout Plain Layout

# D$RTF1 <- ShiftInTime(D$RTF1, .rate=25, .shift=40)
\end_layout

\begin_layout Plain Layout

# D$ATC <- ShiftInTime(D$ATC, .rate=25, .shift=0)
\end_layout

\begin_layout Plain Layout

# D$WIC <- ShiftInTime(D$WIC, .rate=25, .shift=-40)
\end_layout

\begin_layout Plain Layout

DX1 <- D %>% selectTime(500, 1500)
\end_layout

\begin_layout Plain Layout

DX2 <- D %>% selectTime(1500, 2500)
\end_layout

\begin_layout Plain Layout

DX3 <- D %>% selectTime(2500, 3500)
\end_layout

\begin_layout Plain Layout

CoSp <- rep(0, N)
\end_layout

\begin_layout Plain Layout

CoSpG <- rep(0, N)  ## cospectrum of generated T
\end_layout

\begin_layout Plain Layout

CoSpUC <- rep(0, N)
\end_layout

\begin_layout Plain Layout

.A <- 'ATm' # the simulated measurement of air temperature 
\end_layout

\begin_layout Plain Layout

.B <- 'TF'  # the measured recovery temperature
\end_layout

\begin_layout Plain Layout

.C <- 'ATM' # improved measurement using filtered Q
\end_layout

\begin_layout Plain Layout

.D <- 'T'   # the generated air temperature
\end_layout

\begin_layout Plain Layout

DCF <- data.frame()
\end_layout

\begin_layout Plain Layout

for (.data in list(DX1, DX2, DX3)) {
\end_layout

\begin_layout Plain Layout

  N1 <- (N - nrow(.data)) %/% 2
\end_layout

\begin_layout Plain Layout

  N2 <- N - nrow(.data) - N1
\end_layout

\begin_layout Plain Layout

  WP <- c(rep(0, N1), detrend(.data[, c('Time', 'WIC')]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  TPuc <- c(rep(0, N1), detrend(.data[, c('Time', .A)]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  TPB <- c(rep(0, N1), detrend(.data[, c('Time', .B)]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  TP <- c(rep(0, N1), detrend(.data[, c('Time', .C)]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  TPO <- c(rep(0, N1), detrend(.data[, c('Time', .D)]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  Q  <- c(rep(0, N1), detrend(.data[, c('Time', 'Q')]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  ff1 <- fft(TP)
\end_layout

\begin_layout Plain Layout

  ff1uc <- fft(TPuc)
\end_layout

\begin_layout Plain Layout

  ffb <- fft(TPB)
\end_layout

\begin_layout Plain Layout

  ffo <- fft(TPO)
\end_layout

\begin_layout Plain Layout

  ff2 <- fft(WP)
\end_layout

\begin_layout Plain Layout

  ffq <- fft(Q)
\end_layout

\begin_layout Plain Layout

  ## The original as generated
\end_layout

\begin_layout Plain Layout

  cs.G <- 2 * Re(ffo * Conj(ff2)) / (Rate * nrow(.data))
\end_layout

\begin_layout Plain Layout

  ## The predicted measurement before correction
\end_layout

\begin_layout Plain Layout

  cs.orig <- 2 * Re(ff1uc * Conj(ff2)) / (Rate * nrow(.data))
\end_layout

\begin_layout Plain Layout

  ## The predicted measurement with adjusted dynamic heating
\end_layout

\begin_layout Plain Layout

  cs.orig <- 2 * Re(ff1 * Conj(ff2)) / (Rate * nrow(.data))
\end_layout

\begin_layout Plain Layout

  # cs <- 2 * Re(ff1 * Conj(ff2)) / (Rate * N)
\end_layout

\begin_layout Plain Layout

  ## The corrected cospectrum:
\end_layout

\begin_layout Plain Layout

  cs <- 2 * Re((ffb / H - ffq) * Conj(ff2)) / (Rate * nrow(.data))
\end_layout

\begin_layout Plain Layout

  CoSp <- CoSp + cs
\end_layout

\begin_layout Plain Layout

  CoSpG <- CoSpG + cs.G
\end_layout

\begin_layout Plain Layout

  CoSpUC <- CoSpUC + cs.orig
\end_layout

\begin_layout Plain Layout

  DCF <- rbind(DCF, .data)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

Tasm <- mean(DCF$TASX, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

CoSp <- CoSp * scaleFactor / 3
\end_layout

\begin_layout Plain Layout

CoSpG <- CoSpG * scaleFactor / 3
\end_layout

\begin_layout Plain Layout

CoSpUC <- CoSpUC * scaleFactor / 3
\end_layout

\begin_layout Plain Layout

Nby2 <- N %/% 2
\end_layout

\begin_layout Plain Layout

CS <- data.frame(freq = frq[2:(Nby2+1)], cospec = CoSp[2:(Nby2+1)])
\end_layout

\begin_layout Plain Layout

CS.G <- data.frame(freq = frq[2:(Nby2+1)], cospec = CoSpG[2:(Nby2+1)])
\end_layout

\begin_layout Plain Layout

CS.orig <- data.frame(freq = frq[2:(Nby2+1)], cospec = CoSpUC[2:(Nby2+1)])
\end_layout

\begin_layout Plain Layout

CSogiveUC <- cumsum(CoSpUC[2:(Nby2+1)]) * CS$freq[1]
\end_layout

\begin_layout Plain Layout

CSogiveUC <- CSogiveUC[length(CSogiveUC)]-CSogiveUC
\end_layout

\begin_layout Plain Layout

CS.orig$ogive <- CSogiveUC
\end_layout

\begin_layout Plain Layout

wavelengthLimit <- 2500
\end_layout

\begin_layout Plain Layout

fL <- Tasm / wavelengthLimit
\end_layout

\begin_layout Plain Layout

ylim <- c(1.e-3, 100)
\end_layout

\begin_layout Plain Layout

sBins <- 50
\end_layout

\begin_layout Plain Layout

xlim <- c(0.08,15)
\end_layout

\begin_layout Plain Layout

## This is just to get the corrected ogive
\end_layout

\begin_layout Plain Layout

CS.corrected <- plotCS(CS, Units, spans=121, fL, wavelengthLimit, 
\end_layout

\begin_layout Plain Layout

                   smoothBins=sBins, 
\end_layout

\begin_layout Plain Layout

                   xlim=xlim, ylim=ylim, 
\end_layout

\begin_layout Plain Layout

                   plotFigure = FALSE) 
\end_layout

\begin_layout Plain Layout

CS.G <- plotCS(CS.G, Units, spans=121, fL, wavelengthLimit, 
\end_layout

\begin_layout Plain Layout

                   smoothBins=sBins,
\end_layout

\begin_layout Plain Layout

                   xlim, ylim, CSprevious = CS.corrected, 
\end_layout

\begin_layout Plain Layout

                   plotFigure = FALSE,
\end_layout

\begin_layout Plain Layout

                   showNegative = FALSE)
\end_layout

\begin_layout Plain Layout

CS.X <- plotCS(CS.orig, Units, spans=151, fL, wavelengthLimit, 
\end_layout

\begin_layout Plain Layout

                   smoothBins=sBins, 
\end_layout

\begin_layout Plain Layout

                   xlim=xlim, ylim=ylim, 
\end_layout

\begin_layout Plain Layout

                   showNegative = FALSE,
\end_layout

\begin_layout Plain Layout

                   plotFigure = FALSE,
\end_layout

\begin_layout Plain Layout

                   ADD = TRUE) 
\end_layout

\begin_layout Plain Layout

CS <- CS.G
\end_layout

\begin_layout Plain Layout

CS$cospecM <- CS.X$cospec
\end_layout

\begin_layout Plain Layout

CS$ogiveM <- CS.X$ogive
\end_layout

\begin_layout Plain Layout

CS$xcM <- CS.X$xc
\end_layout

\begin_layout Plain Layout

CS$ybarM <- CS.X$ybar
\end_layout

\begin_layout Plain Layout

CS$sigmaM <- CS.X$sigma
\end_layout

\begin_layout Plain Layout

CS$nbM <- CS.X$nb
\end_layout

\begin_layout Plain Layout

CS$cospecC <- CS.corrected$cospec
\end_layout

\begin_layout Plain Layout

CS$ogiveC <- CS.corrected$ogive
\end_layout

\begin_layout Plain Layout

CS$xcC <- CS.corrected$xc
\end_layout

\begin_layout Plain Layout

CS$ybarC <- CS.corrected$ybar
\end_layout

\begin_layout Plain Layout

CS$sigmaC <- CS.corrected$sigma
\end_layout

\begin_layout Plain Layout

CS$nbC <- CS.corrected$nb
\end_layout

\begin_layout Plain Layout

lLbl <- c('generated cospectrum', 'measured cospectrum',
\end_layout

\begin_layout Plain Layout

                  'exceedance - generated', 'exceedance-measured',
\end_layout

\begin_layout Plain Layout

                  'exceedance - corrected')
\end_layout

\begin_layout Plain Layout

g <- ggplot(data = CS, aes(x=freq))
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(aes(y = cospec, colour = lLbl[1], 
\end_layout

\begin_layout Plain Layout

            linetype = lLbl[1]), size = 1.2)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(aes(y = cospecM, colour = lLbl[2],
\end_layout

\begin_layout Plain Layout

            linetype = lLbl[2]), size = 1.2)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(aes(y = ogive, colour = lLbl[3],
\end_layout

\begin_layout Plain Layout

            linetype = lLbl[3]), size = 1.5)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(aes(y = ogiveC, colour = lLbl[5],
\end_layout

\begin_layout Plain Layout

            linetype = lLbl[5]), size = 1)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(aes(y = ogiveM, colour = lLbl[4],
\end_layout

\begin_layout Plain Layout

            linetype = lLbl[4]), size = 1.5)
\end_layout

\begin_layout Plain Layout

g <- g + geom_point(aes(y = ogive, colour = lLbl[3],
\end_layout

\begin_layout Plain Layout

            shape = lLbl[3]))
\end_layout

\begin_layout Plain Layout

g <- g + geom_point(aes(y = ogiveC, colour = lLbl[5],
\end_layout

\begin_layout Plain Layout

            shape = lLbl[5]))
\end_layout

\begin_layout Plain Layout

g <- g + geom_point(aes(y = ogiveM, colour = lLbl[4],
\end_layout

\begin_layout Plain Layout

            shape = lLbl[4]))
\end_layout

\begin_layout Plain Layout

g <- g + geom_point(data = attr(CS.G, 'smoothed data.frame'),
\end_layout

\begin_layout Plain Layout

           aes(x = xc, y = ybar, colour = lLbl[1],
\end_layout

\begin_layout Plain Layout

               shape = lLbl[1]), cex = 2.5)
\end_layout

\begin_layout Plain Layout

g <- g + geom_point(data = attr(CS.X, 'smoothed data.frame'),
\end_layout

\begin_layout Plain Layout

           aes(x = xc, y = ybar, colour = lLbl[2],
\end_layout

\begin_layout Plain Layout

               shape = lLbl[2]), cex = 2.5)
\end_layout

\begin_layout Plain Layout

g <- g + geom_ribbon(data = attr(CS.X, 'smoothed data.frame'), 
\end_layout

\begin_layout Plain Layout

           aes(x = xc, ymin = ybar - sigma, ymax = ybar + sigma),
\end_layout

\begin_layout Plain Layout

           fill = 'darkgreen', alpha = 0.3, show.legend = FALSE,  
\end_layout

\begin_layout Plain Layout

           inherit.aes = FALSE, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=data.frame(x=rep(fL, 2), y=ylim), aes(x=x, y=y),
 linetype=2, lwd = 1.3)
\end_layout

\begin_layout Plain Layout

g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=2), #limits = xlim, 
\end_layout

\begin_layout Plain Layout

                           labels = trans_format("log10", math_format(10^.x)))
 +
\end_layout

\begin_layout Plain Layout

      scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x, n=4),
 #limits = ylim,             
\end_layout

\begin_layout Plain Layout

                    labels = trans_format("log10", math_format(10^.x))) +
\end_layout

\begin_layout Plain Layout

      annotation_logticks(sides='trbl') +
\end_layout

\begin_layout Plain Layout

      coord_cartesian(xlim=xlim, ylim=ylim)
\end_layout

\begin_layout Plain Layout

    vllt <- c(1,1,1,4,4)
\end_layout

\begin_layout Plain Layout

    vlsh <- c(19, 19, NA, NA, NA)
\end_layout

\begin_layout Plain Layout

    vlcl <- c('blue', 'forestgreen', 'brown', 'brown', 'black')
\end_layout

\begin_layout Plain Layout

    vlsz <- c(0.7, 0.7, 1.5, 2, 1.2)
\end_layout

\begin_layout Plain Layout

    names(vllt) <- lLbl
\end_layout

\begin_layout Plain Layout

    names(vlsh) <- lLbl
\end_layout

\begin_layout Plain Layout

    names(vlcl) <- lLbl
\end_layout

\begin_layout Plain Layout

    names(vlsz) <- lLbl
\end_layout

\begin_layout Plain Layout

    g <- g + scale_linetype_manual (name = '  legend:', values = vllt)
\end_layout

\begin_layout Plain Layout

    g <- g + scale_shape_manual(name = '  legend:', values = vlsh)
\end_layout

\begin_layout Plain Layout

#     g <- g + scale_shape_manual(name = '  legend:', guide = guide_legend(
\end_layout

\begin_layout Plain Layout

#                override.aes = list(19, NA, NA, 19, NA)))
\end_layout

\begin_layout Plain Layout

    g <- g + scale_colour_manual (name='  legend:', values = vlcl)
\end_layout

\begin_layout Plain Layout

    g <- g + scale_size_manual(name = '  legend:', values = vlsz)
\end_layout

\begin_layout Plain Layout

    g <- g + guides(colour = guide_legend(reverse = TRUE),  
\end_layout

\begin_layout Plain Layout

                    linetype=guide_legend(reverse = TRUE),
\end_layout

\begin_layout Plain Layout

                    shape = guide_legend(reverse = TRUE)) 
\end_layout

\begin_layout Plain Layout

    g <- g + xlab('frequency [Hz]') + ylab(bquote(nu * " x flux cospectrum
 ["*.(Units)*"]"))
\end_layout

\begin_layout Plain Layout

    g <- g + theme_WAC()
\end_layout

\begin_layout Plain Layout

      g <- g + theme(legend.position=c(0.35, 0.3),
\end_layout

\begin_layout Plain Layout

      plot.margin=unit(c(0.3,0.3,1.1,1.3),"lines"),
\end_layout

\begin_layout Plain Layout

      legend.background=element_rect(colour='black', size=0.3, fill="ivory"),
\end_layout

\begin_layout Plain Layout

      legend.direction="vertical",
\end_layout

\begin_layout Plain Layout

      legend.key.width=unit(1.3,'lines'), legend.key.height=unit(0.7,'lines'),
\end_layout

\begin_layout Plain Layout

      legend.text=element_text(size=12))
\end_layout

\begin_layout Plain Layout

    suppressWarnings(print(g + theme(legend.key.size = unit(0.5, 
\begin_inset Quotes eld
\end_inset

in
\begin_inset Quotes erd
\end_inset

))))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:simF}
\end_layout

\end_inset

 shows (as the green line) how the simulated cospectrum would be measured
 by a sensor with response parameters {
\begin_inset Formula $a,\,\tau_{1},\,\tau_{2}$
\end_inset

} equal to {0.733, 0.0308, 0.447}, as is characteristic of a Rosemount 102E4AL
 sensor.
 The simulated measurement of air temperature was obtained by adding the
 dynamic-heating correction to the simulated air temperature and then applying
 the digital filter developed in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand eqref
reference "subsec:A-filter-for"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to estimate how the sensor would respond.
 Then the resulting value for measured recovery temperature was corrected
 for dynamic heating to obtain the value that would be measured for the
 air temperature, and that value was used with the simulated updraft to
 calculate the cospectrum.
 The resulting measured cospectrum is significantly smaller than the generated
 cospectrum for frequencies above about 1
\begin_inset space ~
\end_inset

Hz and is almost a factor of ten too low at 10
\begin_inset space ~
\end_inset

Hz.
 The measured exceedamce distribution (dashed brown line) emphasizes the
 extent of the missing flux at high frequency.
\end_layout

\begin_layout Standard
The cospectrum obtained using the correction procedure of Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Outline-correction"
plural "false"
caps "false"
noprefix "false"

\end_inset

 was consistent with the generated cospectrum, as illustrated by the corrected
 exceedance distribution in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:simF}
\end_layout

\end_inset

 (dashed black line).
 For wavelengths smaller than 2.5
\begin_inset space ~
\end_inset

km, the generated flux of sensible heat was 39.5
\begin_inset space ~
\end_inset

W
\begin_inset space \thinspace{}
\end_inset

m
\begin_inset Formula $^{-2}$
\end_inset

 and the measured values before and after correction were 33.2 and 38.5
\begin_inset space ~
\end_inset

W
\begin_inset space \thinspace{}
\end_inset

m
\begin_inset Formula $^{-2}.$
\end_inset

 The correction thus reduces the 15% measurement error to about 2.5%.
 The representation of the high-frequency contribution is improved significantly
 by the correction procedure: For the contribution to the flux from frequencies
 above 3
\begin_inset space ~
\end_inset

Hz, the respective values for the generated, measured, and corrected exceedance
 distributions are 15.3, 10.8, and 15.1
\begin_inset space ~
\end_inset

W
\begin_inset space \thinspace{}
\end_inset

m
\begin_inset Formula $^{-2}$
\end_inset

, so about 30% of the contribution in this frequency range would be missed
 without correction.
\end_layout

\begin_layout Standard
This test only confirms consistency between the prediction of the transfer
 function and the correction procedure based on that function.
 The former, when deployed in a digital filter, is dependent on the assumptions
 and weaknesses in that filter, while the latter may be influenced by end
 effects and window effects from calculating the Fourier transforms.
 The agreement between the simulated and corrected flux therefore provides
 some support for the filter developed in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:A-filter-for"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and for the correction procedure developed in this paper.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Section
Summary and Conclusions
\end_layout

\begin_layout Standard
The key findings are these:
\end_layout

\begin_layout Enumerate
The differential equations 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

, with appropriate parameters, provide an analytical representation of the
 transfer function for the recovery temperature measured by an unheated
 Rosemount 102E4AL sensor.
 That transfer function was shown to be consistent with measurements of
 the phase and amplitude ratio of the response to dynamic-heating fluctuations.
 This is evidence that the equations provide a valid representation of the
 time response for that sensor.
 The predictions of the equations are less satisfactory when applied to
 a heated HARCO sensor or a heated Rosemount sensor, possibly indicating
 that the heat transfer is not represented adequately by those equations.
\end_layout

\begin_layout Enumerate
For the Rosemount 102E4AL sensor, the three parameters in those equations
 (characterizing the two time constants and the fraction of heat transfer
 to the air vs.
\begin_inset space ~
\end_inset

that to the structure supporting the sensing wire) can be determined with
 small uncertainty by fitting the transfer function to observations of dynamic
 heating.
 These parameters are thus constrained well and can be relied upon to make
 corrections to the measurements and otherwise to characterize the effects
 of time response of that sensor.
\end_layout

\begin_layout Enumerate
Once the transfer function for the unheated Rosemount sensor has been determined
, it can be used to estimate the true recovery temperature, and then transfer
 functions for other sensors can be determined by comparison to that estimate
 of the measurand to which they are responding.
 This approach has been used here for the slower heated sensors and should
 provide a means of correcting other sensors slower than the unheated sensor.
 Appendix A uses these results with standard methods to correct the measurements
 from airborne temperature sensors for their time response.
\end_layout

\begin_layout Enumerate
Because temperature sensors often do not respond fast enough to measure
 high-frequency components of the dynamic-heating correction, erroneous
 corrections are introduced by conventional data processing.
 Instead, the corrections should be filtered to match the response of the
 temperature sensor to avoid introduction of these errors.
 A digital filter is proposed that can be used to correct standard processing
 schemes to eliminate the errors arising from the dynamic-heating term.
 The errors discussed here are prevalent in almost all existing data from
 research aircraft, so application of this proposed correction method will
 lead to significant improvement in those measurements.
\end_layout

\begin_layout Enumerate
A correction procedure was proposed that consists of using the transfer
 function to correct the measured cospectrum of sensible-heat flux.
 Two illustrative cases were presented in which there was significant correlatio
n between temperature and updraft at a range of frequencies including those
 above 1
\begin_inset space ~
\end_inset

Hz.
 The measured values of sensible-heat flux would be underestimated significantly
 (by about 33%) without correction.
\end_layout

\begin_layout Enumerate
The cospectrum with correction appears to be represented reasonably at frequenci
es up to about 10
\begin_inset space ~
\end_inset

Hz, so the decrease in the cospectrum with frequency near that value suggests
 that it is not necessary to measure contributions from still higher frequencies.
 This conclusion is tentative and needs reconsideration when applied to
 new cases.
\end_layout

\begin_layout Enumerate
Results of a simulation support the consistency between the response as
 represented by the digital filter and the application of the transfer function
 to correct the measurement of the flux of sensible heat.
\end_layout

\begin_layout Section
\start_of_appendix
Correcting the Temperature
\begin_inset CommandInset label
LatexCommand label
name "sec:Correcting-the-Temperature"

\end_inset


\end_layout

\begin_layout Standard
The true recovery temperature 
\begin_inset Formula $T_{r}$
\end_inset

 can be retrieved from the measured temperature 
\begin_inset Formula $T_{m}$
\end_inset

 in two ways, either from the differential equations or by Fourier transformatio
n.
 Only a cursory discussion of these techniques is included here because
 the procedures are standard and follow earlier work, notably that of 
\begin_inset CommandInset citation
LatexCommand citet
key "InverarityJTech2000"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
The differential equations 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 involve two unknowns, the actual recovery temperature 
\begin_inset Formula $T_{r}(t)$
\end_inset

, and the temperature of the supporting structure 
\begin_inset Formula $T_{s}(t)$
\end_inset

.
 The second equation can be used to eliminate 
\begin_inset Formula $T_{r}$
\end_inset

 from the first:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\frac{dT_{s}(t)}{dt}=\frac{\frac{1}{a}\left\{ \tau_{1}\frac{dT_{m}(t)}{dt}+T_{m}(t)-(1-a)T_{s}(t)\right\} -T_{s}(t)}{\tau_{2}}\label{eq:Ts3}
\end{equation}

\end_inset

Because the measured temperature 
\begin_inset Formula $T_{m}(t)$
\end_inset

 is known, this can be integrated from an assumed initial value 
\begin_inset Formula $T_{s}(0)$
\end_inset

 to find the temperature of the support, 
\begin_inset Formula $T_{s}(t)$
\end_inset

.
 Then 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 can be solved to give the true recovery temperature 
\begin_inset Formula $T_{r}(t)$
\end_inset

 without further integration.
 The only choices needed are the numerical method used to find the derivative
 
\begin_inset Formula $dT_{m}/dt$
\end_inset

 (here centered fourth-order) and the integration method applied to 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts3"
plural "false"
caps "false"
noprefix "false"

\end_inset

, here fourth-order Runge-Kutta integration with Cash-Karp (
\begin_inset CommandInset citation
LatexCommand citet
key "cash1990variable"
literal "false"

\end_inset

) adjustment of the step size.
 If a centered second-order finite-difference expression is used for 
\begin_inset Formula $dT_{m}(t)/dt$
\end_inset

 and an Euler integration is used to integrate 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts3"
plural "false"
caps "false"
noprefix "false"

\end_inset

, this correction can be shown to be equivalent to that developed by 
\begin_inset CommandInset citation
LatexCommand citet
key "InverarityJTech2000"
literal "false"

\end_inset

; cf.
\begin_inset space ~
\end_inset

his Eqn.
\begin_inset space ~
\end_inset

(12).
 However, this correction should be applied to the 
\emph on
recovery 
\emph default
temperature, not the 
\emph on
air 
\emph default
temperature.
 The sensor responds to the recovery temperature that includes the increase
 caused by dynamic heating, so applying the correction to the recovery temperatu
re properly corrects for the response to dynamic heating also.
 Then the usual dynamic-heating correction can be subtracted to obtain an
 estimate of the air temperature.
 
\end_layout

\begin_layout Standard
The correction procedure must be modified for the HARCO sensor because,
 with the best-fit value 
\begin_inset Formula $a=0$
\end_inset

, 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 can't be solved for 
\begin_inset Formula $T_{r}(t)$
\end_inset

.
 However, for 
\begin_inset Formula $a=0$
\end_inset

 the differential equations can be combined to give
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
T_{r}(t)=(\tau_{1}+\tau_{2})\frac{dT_{m}(t)}{dt}+T_{m}(t)+\tau_{2}\tau_{1}\frac{d^{2}T_{m}(t)}{dt^{2}}\label{eq:HARCOsoln}
\end{equation}

\end_inset

This gives 
\begin_inset Formula $T_{r}(t)$
\end_inset

 without integration because finite-difference expressions can be used for
 the derivatives of the measurement (
\begin_inset Formula $T_{m}(t)$
\end_inset

).
 Because finite-difference estimates introduce high-frequency noise, the
 result was smoothed using a low-pass filter with 2
\begin_inset space ~
\end_inset

Hz cutoff frequency.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
If the correction is applied instead to the air temperature, as has been
 done for example by 
\begin_inset CommandInset citation
LatexCommand citet
key "mccarthy1973method"
literal "false"

\end_inset

 and 
\begin_inset CommandInset citation
LatexCommand citet
key "InverarityJTech2000"
literal "false"

\end_inset

, the correction for the incomplete response of the sensor to dynamic-heating
 fluctuations.
 The result is the introduction of extraneous noise into the temperature
 measurement.
 This is discussed further in an appendix to Part 2.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Extra
inverted 0
status open

\begin_layout Standard
The heated Rosemount sensor presents a special case because the best-fit
 parameters included 
\begin_inset Formula $a=0$
\end_inset

 so it isn't possible to substitute 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 into 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 as for the other sensors.
 Instead, 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 can be solved to find the support temperature 
\begin_inset Formula $T_{s}(t)$
\end_inset

:
\begin_inset Formula 
\begin{equation}
T_{s}(t)=\tau_{1}\frac{dT_{m}(t)}{dt}+T_{m}(t)\label{eq:Ts4}
\end{equation}

\end_inset

which can be solved for 
\begin_inset Formula $T_{s}(t)$
\end_inset

 because both 
\begin_inset Formula $T_{m}(t)$
\end_inset

 and 
\begin_inset Formula $dT_{m}(t)/dt$
\end_inset

 are measured.
 With this solution and the resulting derivative 
\begin_inset Formula $dT_{s}(t)/dt$
\end_inset

 of this solution, 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 leads to 
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
T_{r}(t)=T_{s}(t)+\tau_{2}\frac{dT_{s}(t)}{dt}\label{eq:Tm4}
\end{equation}

\end_inset

which gives the solution directly (without integration) because all terms
 on the right side are known.
 The result could also be written by combining 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm4"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts4"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to give
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
T_{r}(t)=(\tau_{1}+\tau_{2})\frac{dT_{m}(t)}{dt}+T_{m}(t)+\tau_{2}\tau_{1}\frac{d^{2}T_{m}(t)}{dt^{2}}\label{eq:Tm5}
\end{equation}

\end_inset

which, without the second-derivative term, would represent a first-order
 response with time constant 
\begin_inset Formula $\tau=\tau_{1}+\tau_{2}$
\end_inset

.
 The transfer function for the HARCO (Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:rfHARCO}
\end_layout

\end_inset

 shows that, contrary to first-order response, the phase lag can be negative
 for some frequencies, so the second-derivative term plays an important
 role.
 The second derivative in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:HARCOsoln"
plural "false"
caps "false"
noprefix "false"

\end_inset

 can be represented, for example, by
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\frac{d^{2}T_{m}(t)}{dt^{2}}=\frac{T_{m}(t-\delta t)-2T_{m}(t)+T_{m}(t+\delta t)}{(\delta t)^{2}}\label{eq:deriv2nd}
\end{equation}

\end_inset

where all quantities on the right side are known from the measurement sequence.
 Equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm5"
plural "false"
caps "false"
noprefix "false"

\end_inset

 thus provides the corrected recovery temperature 
\begin_inset Formula $T_{r}(t)$
\end_inset

 without any need to calculate the temperature of the support.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<method1, include=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

a <- Param1$a
\end_layout

\begin_layout Plain Layout

tau1 <- Param1$tau1
\end_layout

\begin_layout Plain Layout

tau2 <- Param1$tau2
\end_layout

\begin_layout Plain Layout

## RT is the working solution; Ts is the support temperature
\end_layout

\begin_layout Plain Layout

DT$Ts <- DT$RT
\end_layout

\begin_layout Plain Layout

Rate <- attr (DT, 'Rate')
\end_layout

\begin_layout Plain Layout

DT$DTMDT <- c(0, diff(DT$TTRR, 2), 0) * Rate / 2
\end_layout

\begin_layout Plain Layout

DT$DTMDT <-  (c(0, 8*diff(DT$TTRR, 2), 0) - 
\end_layout

\begin_layout Plain Layout

              c(0, 0, diff(DT$TTRR, 4), 0, 0)) * Rate / 12
\end_layout

\begin_layout Plain Layout

# DT$DTMDT <- (DT$DTMDT + c(0, DT$DTMDT[1:(nrow(DT)-1)])) / 2
\end_layout

\begin_layout Plain Layout

# DT$DTMDT <- as.vector (signal::filter(signal::sgolay(1, 3, m=1), DT$TTRR))
 * Rate
\end_layout

\begin_layout Plain Layout

fS <- function(y, i) {
\end_layout

\begin_layout Plain Layout

  # Eq.
 Ts3
\end_layout

\begin_layout Plain Layout

  ((tau1 * DT$DTMDT[i] + DT$TTRR[i] - (1 - a) * y)/a - y) / (Rate * tau2)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DT$Ts <- rk4.integrate (fS, DT$Ts[1], 1:nrow(DT))
\end_layout

\begin_layout Plain Layout

DT$RT <- (1 / a) * (tau1 * DT$DTMDT + DT$TTRR - (1 - a) * DT$Ts)
\end_layout

\begin_layout Plain Layout

DT %>% select(Time, TTRR, RT, Ts) %>% 
\end_layout

\begin_layout Plain Layout

  selectTime(114500, 114505) %>% 
\end_layout

\begin_layout Plain Layout

  plotWAC()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<meth1Example, include=FALSE, fig.height=4, fig.cap=c('Examples of the changes
 produced by the correction procedures.
 The original measurement of recovery temperature is Tm and the revised
 value using is RT.
 The estimated temperature of the support (Ts) is also shown.
 The plotted time is seconds after 11:45:00 UTC for VOCALS flight 3.', 'Variance
 spectra for the original measurement of recovery temperature (TTRR) and
 for the corrected value (RT).')>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DT %>% select(Time, TTRR, RT, Ts) %>% 
\end_layout

\begin_layout Plain Layout

  selectTime(114500, 114505) %>% 
\end_layout

\begin_layout Plain Layout

  plotWAC(legend.position = 'topright')
\end_layout

\begin_layout Plain Layout

g <- VSpec(DT, 'TTRR', ylim = c(1.e-5, 0.1))
\end_layout

\begin_layout Plain Layout

VSpec(DT, 'RT', add = g) + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
An alternate approach is to use Fourier transforms:
\end_layout

\begin_layout Enumerate
Calculate the Fourier transform of the measured time series: 
\begin_inset Formula $\hat{T}_{m}(\omega)=\mathcal{F}\left(T_{m}(t)\right)$
\end_inset

 where 
\begin_inset Formula $\omega$
\end_inset

 is angular frequency and 
\begin_inset Formula $\mathcal{F}$
\end_inset

 denotes the Fourier transform.
\end_layout

\begin_layout Enumerate
Divide the result by the complex representation of the transfer function:
 
\begin_inset Formula $\hat{T}_{r}(\omega)=\hat{T}_{m}(\omega)/H(\omega)$
\end_inset

.
\end_layout

\begin_layout Enumerate
Use the inverse Fourier transform to find a retrieved estimate of the true
 recovery temperature: 
\begin_inset Formula $T_{r}(t)=\mathrm{Re}\left(\mathcal{F}^{-1}\left(\hat{T}_{r}(\omega)\right)\right)$
\end_inset

 where Re denotes the real part of the complex result.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<setUpFFT, include=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

N <- length(DT$TTRR)
\end_layout

\begin_layout Plain Layout

if (N %% 2 == 1) {
\end_layout

\begin_layout Plain Layout

  N <- N - 1
\end_layout

\begin_layout Plain Layout

  DT  <- DT[-nrow(DT), ]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

f <- fft (DT$TTRR)
\end_layout

\begin_layout Plain Layout

N <- length(f)
\end_layout

\begin_layout Plain Layout

df <- Rate / N
\end_layout

\begin_layout Plain Layout

frq <- c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
\end_layout

\begin_layout Plain Layout

N2 <- N %/% 2
\end_layout

\begin_layout Plain Layout

fmax <- 2
\end_layout

\begin_layout Plain Layout

nlim <- which(frq > fmax)[1]
\end_layout

\begin_layout Plain Layout

# f[nlim:N2] <- f[nlim:N2] * (fmax / frq[nlim:(N2-1)])
\end_layout

\begin_layout Plain Layout

# f[(N2+1):(N-nlim)] <- Conj(rev(f[nlim:N2]))
\end_layout

\begin_layout Plain Layout

## Modify the spectrum by the inverse of the response function:
\end_layout

\begin_layout Plain Layout

AFFT <- LTphase(frq, Param1)
\end_layout

\begin_layout Plain Layout

AFFT$frq <- frq
\end_layout

\begin_layout Plain Layout

AFFT$Phase <- AFFT$Phase * pi / 180
\end_layout

\begin_layout Plain Layout

H <- complex (modulus = AFFT$Amp, argument = AFFT$Phase)
\end_layout

\begin_layout Plain Layout

xn <- Re(fft(f / H, inverse = TRUE)) / N
\end_layout

\begin_layout Plain Layout

DT$FFT <- xn
\end_layout

\begin_layout Plain Layout

# g <- VSpec(DT, 'TTRR', ylim=c(1.e-5, 0.1))
\end_layout

\begin_layout Plain Layout

# g <- VSpec(DT, 'FFT', add=g)
\end_layout

\begin_layout Plain Layout

# VSpec(DT, 'RT', add=g) + theme_WAC()
\end_layout

\begin_layout Plain Layout

# DT %>% select(Time, TTRR, FFT) %>% selectTime(114500, 114505) %>% plotWAC()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Examples of the corrections produced by these procedures are shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:sampleFFT}
\end_layout

\end_inset

.
 The agreement between the two correction methods is very good, and both
 show evidence of faster and higher-amplitude response to fluctuations.
 In comparison to the original measurement, the corrected values for the
 HARCO sensor are improved significantly by this correction procedure and
 are even a reasonable match to the corrected measurement from the unheated
 Rosemount.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<sampleFFT, include=TRUE, fig.height=4.1, fig.width=4.1, out.width='0.48
\backslash

\backslash
linewidth', fig.show='hold', messages = FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DT$measured_uncorrected <- DT$TTRR
\end_layout

\begin_layout Plain Layout

DT$corrected_FFT <- DT$FFT
\end_layout

\begin_layout Plain Layout

DT$corrected_DE <- DT$RT
\end_layout

\begin_layout Plain Layout

DT$support <- DT$Ts
\end_layout

\begin_layout Plain Layout

DT %>% select(Time, corrected_FFT, corrected_DE, support, 
\end_layout

\begin_layout Plain Layout

              measured_uncorrected) %>% 
\end_layout

\begin_layout Plain Layout

  selectTime(114500, 114502) %>% 
\end_layout

\begin_layout Plain Layout

  ggplotWAC(col=c('black', 'darkorange', 'forestgreen', 'blue'), 
\end_layout

\begin_layout Plain Layout

          ylab=bquote('recovery temperature [' ~ degree * 'C]'),
\end_layout

\begin_layout Plain Layout

          lty=c(1,2,4,1), lwd=c(1.5,1,1.5,1)) + 
\end_layout

\begin_layout Plain Layout

    xlab('time [s]') + theme_WAC(1) +
\end_layout

\begin_layout Plain Layout

    annotate('text', x = DT$Time[getIndex(DT, 114500)] + 1.5, y=20.97, label='(unh
eated)', size=5) +
\end_layout

\begin_layout Plain Layout

    theme(legend.key.width=unit(1.3,'lines'),  
\end_layout

\begin_layout Plain Layout

          legend.key.height=unit(0.5,'lines'),
\end_layout

\begin_layout Plain Layout

          legend.text=element_text(size=10)) + 
\end_layout

\begin_layout Plain Layout

      guides(colour = guide_legend(reverse = TRUE, '  legend:')) +
\end_layout

\begin_layout Plain Layout

      guides(linetype = guide_legend(reverse = TRUE, '  legend:')) +
\end_layout

\begin_layout Plain Layout

      guides(size = guide_legend(reverse = TRUE, '  legend:')) +
\end_layout

\begin_layout Plain Layout

          theme(legend.direction = 'vertical', 
\end_layout

\begin_layout Plain Layout

                legend.position = c(0.65, 0.20))
\end_layout

\begin_layout Plain Layout

# g <- VSpec(DT, 'TTRR', ylim = c(1.e-5, 0.1))
\end_layout

\begin_layout Plain Layout

# VSpec(DT, 'FFT', add = g) + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

# DT %>% select(Time, TASX, Tm, RT, FFT) %>% 
\end_layout

\begin_layout Plain Layout

#        VSpec(method='MEM', ylim=c(1.e-5, 0.1)) +
\end_layout

\begin_layout Plain Layout

#        theme_WAC(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

a <- Param1$a
\end_layout

\begin_layout Plain Layout

tau1 <- Param1$tau1
\end_layout

\begin_layout Plain Layout

tau2 <- Param1$tau2
\end_layout

\begin_layout Plain Layout

## RT is the working solution; Ts is the support temperature
\end_layout

\begin_layout Plain Layout

DSX$Ts <- DSX$RTF1
\end_layout

\begin_layout Plain Layout

Rate <- attr (DSX, 'Rate')
\end_layout

\begin_layout Plain Layout

DSX$DTMDT <- c(0, diff(DSX$RTF1, 2), 0) * Rate / 2
\end_layout

\begin_layout Plain Layout

DSX$DTMDT <-  (c(0, 8*diff(DSX$RTF1, 2), 0) - 
\end_layout

\begin_layout Plain Layout

              c(0, 0, diff(DSX$RTF1, 4), 0, 0)) * Rate / 12
\end_layout

\begin_layout Plain Layout

# DT$DTMDT <- (DT$DTMDT + c(0, DT$DTMDT[1:(nrow(DT)-1)])) / 2
\end_layout

\begin_layout Plain Layout

# DT$DTMDT <- as.vector (signal::filter(signal::sgolay(1, 3, m=1),
\end_layout

\begin_layout Plain Layout

#             DT$TTRR)) * Rate
\end_layout

\begin_layout Plain Layout

fS <- function(y, i) {  # Eq.
 Ts3
\end_layout

\begin_layout Plain Layout

  ((1/a) * (tau1 * DSX$DTMDT[i] + DSX$RTF1[i] - (1-a) * y) - y) / (Rate
 * tau2)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DSX$Ts <- rk4.integrate (fS, DSX$Ts[1], 1:nrow(DSX))
\end_layout

\begin_layout Plain Layout

DSX$RT <- (1/a) * (tau1 * DSX$DTMDT + DSX$RTF1 - (1-a) * DSX$Ts)
\end_layout

\begin_layout Plain Layout

MRHO <- MachNumber(DSX$PSXC, DSX$QCXC) * DSX$PSXC * 100 /
\end_layout

\begin_layout Plain Layout

                  (287.05 * (273.15 + DSX$ATX)) / rhozero
\end_layout

\begin_layout Plain Layout

a <- bestSH[1]
\end_layout

\begin_layout Plain Layout

tau1 <- bestSH[2] * (MRHO / 0.3) ^ 0.6  ## Note that these are variable
\end_layout

\begin_layout Plain Layout

tau2 <- bestSH[3] * (MRHO / 0.3) ^ 0.6
\end_layout

\begin_layout Plain Layout

Rate <- attr (DSX, 'Rate')
\end_layout

\begin_layout Plain Layout

DSX$DTMDT <- c(0, diff(DSX$RTH1, 2), 0) * Rate / 2
\end_layout

\begin_layout Plain Layout

DSX$DTM2DT2 <- (c(diff(DSX$RTH1), 0) - c(0, diff(DSX$RTH1))) * Rate^2
\end_layout

\begin_layout Plain Layout

DSX$RTHC <- (tau1 + tau2) * DSX$DTMDT + DSX$RTH1 + tau1 * tau2 * DSX$DTM2DT2
\end_layout

\begin_layout Plain Layout

DSX$RTHC <- zoo::na.approx (as.vector(DSX$RTHC), maxgap=1000*Rate,
\end_layout

\begin_layout Plain Layout

      na.rm = FALSE, rule = 2)
\end_layout

\begin_layout Plain Layout

CutoffPeriod <- 12.5  ## 2 Hz
\end_layout

\begin_layout Plain Layout

DSX$RTHC <- signal::filtfilt (signal::butter (3,
\end_layout

\begin_layout Plain Layout

      2/CutoffPeriod), DSX$RTHC)
\end_layout

\begin_layout Plain Layout

# DSX$RTHC <- SmoothInterp(DSX$RTHC, .Length=25)
\end_layout

\begin_layout Plain Layout

DSAP <- DSX
\end_layout

\begin_layout Plain Layout

DSAP$RTH1 <- DSAP$RTH1 - mean(DSAP$RTH1[setRange(DSAP, 55700, 60000)], na.rm=TRUE
)
\end_layout

\begin_layout Plain Layout

DSAP$RTF1P <- DSAP$RTF1 - mean(DSAP$RTF1[setRange(DSAP, 55700, 60000)],
 na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

DSAP$RTHC <- DSAP$RTHC - mean(DSAP$RTHC[setRange(DSAP, 55700, 60000)], na.rm=TRUE
)
\end_layout

\begin_layout Plain Layout

DSAP$RT <- DSAP$RT - mean(DSAP$RT[setRange(DSAP, 55700, 60000)], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

# DSAP %>% selectTime(55920, 55950) %>% 
\end_layout

\begin_layout Plain Layout

#          select(Time, RT, RTH1, RTHC) %>% 
\end_layout

\begin_layout Plain Layout

#         ggplotWAC(col=c('blue', 'forestgreen', 'black'), lty=c(1,4,1),
\end_layout

\begin_layout Plain Layout

#                   ylab=bquote('recovery temperature [' ~ degree * 'C]'),
 
\end_layout

\begin_layout Plain Layout

#                   lwd=c(0.8,1,1)) + xlab('time [s]') +
\end_layout

\begin_layout Plain Layout

#         theme_WAC(1) + theme(legend.position=c(0.75, 0.9))
\end_layout

\begin_layout Plain Layout

DSAX <- DSX %>% selectTime(55700, 60300)
\end_layout

\begin_layout Plain Layout

DSAX <- DSAX[1:2^13, ]
\end_layout

\begin_layout Plain Layout

ft <- fft(DSAX$RTH1)
\end_layout

\begin_layout Plain Layout

N <- length(ft)
\end_layout

\begin_layout Plain Layout

Rate <- attr(DSX, 'Rate')
\end_layout

\begin_layout Plain Layout

df <- Rate / N
\end_layout

\begin_layout Plain Layout

frq <- c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
\end_layout

\begin_layout Plain Layout

fr <- log(abs(frq))
\end_layout

\begin_layout Plain Layout

Gain  <- cfrHARCO[1] + fr * (cfrHARCO[2] + fr * fr * (cfrHARCO[3] + 
\end_layout

\begin_layout Plain Layout

         fr * (cfrHARCO[4] + fr * cfrHARCO[5])))
\end_layout

\begin_layout Plain Layout

Gain[abs(frq) < 0.024] <- 1
\end_layout

\begin_layout Plain Layout

Phase <- cfHARCO[1] + cfHARCO[2] * fr + cfHARCO[3] * fr^2 +
\end_layout

\begin_layout Plain Layout

         cfHARCO[4] * atan(frq)
\end_layout

\begin_layout Plain Layout

Phase[frq < 0] <- -Phase[frq < 0]
\end_layout

\begin_layout Plain Layout

Phase[1] <- 0
\end_layout

\begin_layout Plain Layout

Phase <- Phase * pi / 180
\end_layout

\begin_layout Plain Layout

TF <- complex(modulus=Gain, argument=Phase)
\end_layout

\begin_layout Plain Layout

tlmt <- 1.8
\end_layout

\begin_layout Plain Layout

TF[abs(frq) > tlmt] <- TF[abs(frq) > tlmt] * exp(5*abs(frq[abs(frq) > tlmt])
 / tlmt)
\end_layout

\begin_layout Plain Layout

ftx <- ft / TF
\end_layout

\begin_layout Plain Layout

DSAX$RTFFT <- Re(fft(ftx, inverse = TRUE) / N)
\end_layout

\begin_layout Plain Layout

N <- 2^13 
\end_layout

\begin_layout Plain Layout

Nby2 <- N / 2
\end_layout

\begin_layout Plain Layout

RTH1 <- DSAX$RTH1
\end_layout

\begin_layout Plain Layout

ff1 <- fft(RTH1)
\end_layout

\begin_layout Plain Layout

RTH <- Re(fft(ff1, inverse=TRUE)) / N
\end_layout

\begin_layout Plain Layout

df <- Rate / N
\end_layout

\begin_layout Plain Layout

frq <- c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
\end_layout

\begin_layout Plain Layout

fr <- log(frq[1:(Nby2+1)])
\end_layout

\begin_layout Plain Layout

## Get the transfer function from the fitted parameterized form:
\end_layout

\begin_layout Plain Layout

Ph <- cfHARCO[1] + cfHARCO[2] * fr + 
\end_layout

\begin_layout Plain Layout

           cfHARCO[3] * fr^2 + cfHARCO[4] * atan(frq[1:(Nby2+1)])
\end_layout

\begin_layout Plain Layout

Ph[1] <- 0
\end_layout

\begin_layout Plain Layout

G <- cfrHARCO[1] + fr * (cfrHARCO[2] + fr * fr * (cfrHARCO[3] + 
\end_layout

\begin_layout Plain Layout

           fr * (cfrHARCO[4] + fr * cfrHARCO[5])))
\end_layout

\begin_layout Plain Layout

G[frq[1:length(fr)] < 0.024] <- 1
\end_layout

\begin_layout Plain Layout

G[frq[1:length(fr)] > 2] <- G[which.min(abs(frq-2))]
\end_layout

\begin_layout Plain Layout

H <- rep(complex(modulus=0), N)
\end_layout

\begin_layout Plain Layout

H[1:(Nby2+1)] <- complex(modulus=G, argument=Ph * pi / 180)
\end_layout

\begin_layout Plain Layout

H[(Nby2+2):N] <- rev(Conj(H[2:Nby2]))
\end_layout

\begin_layout Plain Layout

RTC <- Re(fft(ff1 / H, inverse = TRUE)) / N
\end_layout

\begin_layout Plain Layout

DSAX$RTC <- RTC
\end_layout

\begin_layout Plain Layout

dfTF <- data.frame(
\end_layout

\begin_layout Plain Layout

  'Time' = frq,
\end_layout

\begin_layout Plain Layout

  'Amp' = Gain,
\end_layout

\begin_layout Plain Layout

  'Phase' = Phase
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  ggplotWAC(
\end_layout

\begin_layout Plain Layout

    dfTF,
\end_layout

\begin_layout Plain Layout

    panels = 2,
\end_layout

\begin_layout Plain Layout

    labelP = c('    Amplitude', 'Phase [degrees]')
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab(bquote('transfer function H(' * nu
 ~ ')'))
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  g + scale_x_log10(
\end_layout

\begin_layout Plain Layout

    breaks = trans_breaks("log10", function(x)
\end_layout

\begin_layout Plain Layout

      10 ^ x, n = 4),
\end_layout

\begin_layout Plain Layout

    labels = trans_format("log10", math_format(expr = 10 ^ .x))
\end_layout

\begin_layout Plain Layout

  ) + xlab('frequency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = 'tb')
\end_layout

\begin_layout Plain Layout

# g + theme_WAC(1) + theme(legend.position = c(0.3, 0.65))
\end_layout

\begin_layout Plain Layout

DSAP <- DSAX
\end_layout

\begin_layout Plain Layout

DSAP$RTH1 <- DSAP$RTH1 - mean(DSAP$RTH1[setRange(DSAP, 55700, 60000)], na.rm=TRUE
)
\end_layout

\begin_layout Plain Layout

DSAP$RTF1P <- DSAP$RTF1 - mean(DSAP$RTF1[setRange(DSAP, 55700, 60000)],
 na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

DSAP$RTH <- DSAP$RTHC - mean(DSAP$RTHC[setRange(DSAP, 55700, 60000)], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

DSAP$RT <- DSAP$RT - mean(DSAP$RT[setRange(DSAP, 55700, 60000)], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

DSAP$FFT <- DSAP$RTFFT - mean(DSAP$RTFFT[setRange(DSAP, 55700, 60000)],
\end_layout

\begin_layout Plain Layout

                                na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

DSAP$measured_uncorrected <- DSAP$RTH1
\end_layout

\begin_layout Plain Layout

DSAP$corrected_DE <- DSAP$RTH
\end_layout

\begin_layout Plain Layout

DSAP$corrected_FFT <- DSAP$FFT
\end_layout

\begin_layout Plain Layout

DSAP$reference_unheated <- DSAP$RT
\end_layout

\begin_layout Plain Layout

DSAP %>% selectTime(55920, 55940) %>% 
\end_layout

\begin_layout Plain Layout

         select(Time, reference_unheated, corrected_FFT, corrected_DE,
\end_layout

\begin_layout Plain Layout

                measured_uncorrected) %>% 
\end_layout

\begin_layout Plain Layout

         ggplotWAC(c('forestgreen', 'black', 'darkorange', 'blue'),
\end_layout

\begin_layout Plain Layout

                   ylab=bquote('recovery temperature [' ~ degree * 'C]'),
\end_layout

\begin_layout Plain Layout

                   lty=c(1,1,1,1), lwd=c(0.5, 1.2, 0.8, 1.2)) + xlab('time [s]')
 +
\end_layout

\begin_layout Plain Layout

         theme_WAC(1) + 
\end_layout

\begin_layout Plain Layout

         annotate('text', x = DSAP$Time[getIndex(DSAP, 55923)] + 1.5, y=0.15,
 label='(heated)', size=5) +
\end_layout

\begin_layout Plain Layout

         theme(axis.title.y = element_blank(),
\end_layout

\begin_layout Plain Layout

               plot.margin=unit(c(0.3,0.3,1.1,0.3),"lines"),
\end_layout

\begin_layout Plain Layout

               legend.direction = 'vertical',
\end_layout

\begin_layout Plain Layout

               legend.text=element_text(size=10),
\end_layout

\begin_layout Plain Layout

               legend.key.width=unit(1.3,'lines'),  
\end_layout

\begin_layout Plain Layout

               legend.key.height=unit(0.5,'lines'),
\end_layout

\begin_layout Plain Layout

               # legend.box.margin = margin(50, 6, 6, 6),
\end_layout

\begin_layout Plain Layout

               legend.position=c(0.28, 0.83)) +
\end_layout

\begin_layout Plain Layout

         guides(colour = guide_legend(reverse = TRUE, '  legend:')) +
\end_layout

\begin_layout Plain Layout

         guides(linetype = guide_legend(reverse = TRUE, '  legend:')) +
\end_layout

\begin_layout Plain Layout

         guides(size = guide_legend(reverse = TRUE, '  legend:'))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Examples of corrected recovery temperatures compared to the original uncorrected
 measurements, for two different correction methods.
 
\end_layout

\end_inset

Examples of the corrected recovery temperatures compared to the original
 uncorrected measurements.
 In each case, the correction based on the differential equations is shown
 as 
\begin_inset Quotes eld
\end_inset

corrected_DE
\begin_inset Quotes erd
\end_inset

 and that based on Fourier transforms is labeled 
\begin_inset Quotes eld
\end_inset

corrected_FFT
\begin_inset Quotes erd
\end_inset

.
 The dashed green line in the left plot shows the calculated temperature
 of the support that contacts the sensing wire.
 The solid green line in the right plot shows the corrected measurement
 from the unheated sensor for comparison.
\begin_inset Newline newline
\end_inset

(left): An unheated Rosemount 102E4AL sensor.
 Measurements from VOCALS flight 3.
\begin_inset Newline newline
\end_inset

(right): A heated HARCO sensor.
 In this case the 
\begin_inset Quotes eld
\end_inset

corrected_DE
\begin_inset Quotes erd
\end_inset

 result is based on 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:HARCOsoln"
plural "false"
caps "false"
noprefix "false"

\end_inset

 while 
\begin_inset Quotes eld
\end_inset

corrected_FFT
\begin_inset Quotes erd
\end_inset

 uses the fit provided by 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:lfitH"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The time is seconds after 2018-02-24 5:59:00 UTC, SOCRATES flight 15.
 Mean values have been subtracted to facilitate comparison.
\begin_inset CommandInset label
LatexCommand label
name "fig:sampleFFT"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The resulting variance spectrum for the Fourier-transform method (Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:sampleFFT2}
\end_layout

\end_inset

) has high variance above about 5
\begin_inset space ~
\end_inset

Hz that is above the variance for the corrected variable obtained from 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm2"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The increasing variance for the Fourier-transform method is is likely the
 fault of the measurement itself: The spectral variance for the original
 measurement (Tm) does not decrease at high frequency as expected from the
 transfer function, and the correction procedure amplifies this excess noise.
 The lower variance for the variable obtained from 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 at high frequency arises from the finite-difference representation of the
 term 
\begin_inset Formula $dT_{m}(t)/dt$
\end_inset

, which results in some smoothing.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Taking the Fourier transform of an entire 25-Hz measurement for a flight
 of several hours becomes impractical.
 However, it is possible to segment the time series, calculate Fourier transform
s for the segments, and then combine the results to represent the entire
 flight.
 Tests have shown that, for example, dividing into 
\begin_inset Formula $2^{16}$
\end_inset

-sample overlapping segments, using fast Fourier transforms, and combining
 the middle halves of each segment is feasible with many-hour flights and
 25-Hz data.
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:HARCOcorrection}
\end_layout

\end_inset

 shows the result (as 
\begin_inset Quotes eld
\end_inset

RTH
\begin_inset Quotes erd
\end_inset

) after a Butterworth low-pass filter with cutoff frequency of 2
\begin_inset space ~
\end_inset

Hz smoothed the corrected measurements.
 This filtering is reasonable because the variance spectrum for this sensor
 shows very little real signal at frequencies above 2
\begin_inset space ~
\end_inset

Hz.
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
This is not as good a representation of the transfer function as is possible
 with the fitted representation shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:GVHARCO}
\end_layout

\end_inset

 and given by 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:lfitH"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 That fit can be used with the Fourier-transform approach to correction.
 The result is shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:HARCOcorrection1}
\end_layout

\end_inset

 as the black line labeled 
\begin_inset Quotes eld
\end_inset

FFT
\begin_inset Quotes erd
\end_inset

.
 This is also a significant improvement over the original and reproduces
 many of the features of the best measurement (
\begin_inset Quotes eld
\end_inset

RT
\begin_inset Quotes erd
\end_inset

).
 To obtain this result, it was necessary to attenuate frequencies above
 1.8
\begin_inset space ~
\end_inset

Hz in the Fourier transform solution because there is a zero in the transfer
 function as represented by 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:lfitH"
plural "false"
caps "false"
noprefix "false"

\end_inset

 that otherwise invalidates the inversion.
 This attenuation was accomplished by multiplying the transfer function
 by 
\begin_inset Formula $e^{5\nu}$
\end_inset

above 1.8
\begin_inset space ~
\end_inset

Hz.
 This arbitrarily chosen attenuation gave reasonable results, although it
 is likely that better choices could be made with further exploration.
 One more general measure of the improvement, beyond the anecdotal evidence
 in the preceding figures, is that either correction procedure reduced the
 standard deviation of the difference between the measured value (Tm) and
 the estimated best value (RT) from 
\begin_inset Formula $0.06^{\circ}$
\end_inset

C before correction to 
\begin_inset Formula $0.03^{\circ}$
\end_inset

C after correction.
\end_layout

\begin_layout Plain Layout
The plot of variance spectra (Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:HARCOcorrection2}
\end_layout

\end_inset

) shows that the original spectrum (blue line labeled 
\begin_inset Quotes eld
\end_inset

Tm
\begin_inset Quotes erd
\end_inset

) is seriously attenuated at high frequencies relative to the reference
 measurement (
\begin_inset Quotes eld
\end_inset

RT
\begin_inset Quotes erd
\end_inset

) and that both correction procedures restore significant parts of the missing
 spectral variance.
 Despite its inferior representation of the transfer function, it appears
 that application of 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:HARCOsoln"
plural "false"
caps "false"
noprefix "false"

\end_inset

 provides a better match to the reference measurements.
 It does not appear possible to restore the missing high-frequency fluctuations
 (above about 1 or 2
\begin_inset space ~
\end_inset

Hz) because the original measurement is so severely attenuated at these
 frequencies.
 This sensor and the similar heated Rosemount sensor are therefore unable
 to detect contributions to sensible-heat flux from this frequency range,
 even after corrections.
 It nevertheless appears useful to apply one of these correction approaches
 routinely to improve the quality of this measurement.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<HARCOcorrection, include=FALSE, fig.height=3.5, fig.cap=c('Corrected recovery
 temperature as measured by a heated HARCO sensor (
\begin_inset Quotes eld
\end_inset

RTH
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

FFT
\begin_inset Quotes erd
\end_inset

), the uncorrected measurement (
\begin_inset Quotes eld
\end_inset

Tm
\begin_inset Quotes erd
\end_inset

), and the best estimate of the true recovery temperature (
\begin_inset Quotes eld
\end_inset

RT
\begin_inset Quotes erd
\end_inset

) based on an unheated Rosemount sensor after correction.
 The time is seconds after 2018-02-24 5:59:00 UTC, SOCRATES flight 15.
 
\begin_inset Quotes eld
\end_inset

RTH
\begin_inset Quotes erd
\end_inset

 is based on the approximate formula (20), while 
\begin_inset Quotes eld
\end_inset

FFT
\begin_inset Quotes erd
\end_inset

 results from Fourier transformation after correction using the transfer
 function determined from (13).
 Mean values have been subtracted from all to facilitate comparisons.', 'Variance
 spectra for some measurements of recovery temperature: 
\begin_inset Quotes eld
\end_inset

RT
\begin_inset Quotes erd
\end_inset

 (the best estimate resulting from correction of the measurements from the
 unheated Rosemount 102E4AL); 
\begin_inset Quotes eld
\end_inset

Tm
\begin_inset Quotes erd
\end_inset

 (the uncorrected measurement from the heated HARCO); 
\begin_inset Quotes eld
\end_inset

FFT
\begin_inset Quotes erd
\end_inset

 (the corrected HARCO measurement based on Fourier transforms); and 
\begin_inset Quotes eld
\end_inset

RTH
\begin_inset Quotes erd
\end_inset

 (the corrected HARCO measurement based on the correction formula (17)).')>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

a <- Param1$a
\end_layout

\begin_layout Plain Layout

tau1 <- Param1$tau1
\end_layout

\begin_layout Plain Layout

tau2 <- Param1$tau2
\end_layout

\begin_layout Plain Layout

## RT is the working solution; Ts is the support temperature
\end_layout

\begin_layout Plain Layout

DSX$Ts <- DSX$RTF1
\end_layout

\begin_layout Plain Layout

Rate <- attr (DSX, 'Rate')
\end_layout

\begin_layout Plain Layout

DSX$DTMDT <- c(0, diff(DSX$RTF1, 2), 0) * Rate / 2
\end_layout

\begin_layout Plain Layout

DSX$DTMDT <-  (c(0, 8*diff(DSX$RTF1, 2), 0) - 
\end_layout

\begin_layout Plain Layout

              c(0, 0, diff(DSX$RTF1, 4), 0, 0)) * Rate / 12
\end_layout

\begin_layout Plain Layout

# DT$DTMDT <- (DT$DTMDT + c(0, DT$DTMDT[1:(nrow(DT)-1)])) / 2
\end_layout

\begin_layout Plain Layout

# DT$DTMDT <- as.vector (signal::filter(signal::sgolay(1, 3, m=1),
\end_layout

\begin_layout Plain Layout

#             DT$TTRR)) * Rate
\end_layout

\begin_layout Plain Layout

fS <- function(y, i) {  # Eq.
 Ts3
\end_layout

\begin_layout Plain Layout

  ((1/a) * (tau1 * DSX$DTMDT[i] + DSX$RTF1[i] - (1-a) * y) - y) / (Rate
 * tau2)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DSX$Ts <- rk4.integrate (fS, DSX$Ts[1], 1:nrow(DSX))
\end_layout

\begin_layout Plain Layout

DSX$RT <- (1/a) * (tau1 * DSX$DTMDT + DSX$RTF1 - (1-a) * DSX$Ts)
\end_layout

\begin_layout Plain Layout

MRHO <- MachNumber(DSX$PSXC, DSX$QCXC) * DSX$PSXC * 100 /
\end_layout

\begin_layout Plain Layout

                  (287.05 * (273.15 + DSX$ATX)) / rhozero
\end_layout

\begin_layout Plain Layout

a <- bestSH[1]
\end_layout

\begin_layout Plain Layout

tau1 <- bestSH[2] * (MRHO / 0.3) ^ 0.6  ## Note that these are variable
\end_layout

\begin_layout Plain Layout

tau2 <- bestSH[3] * (MRHO / 0.3) ^ 0.6
\end_layout

\begin_layout Plain Layout

Rate <- attr (DSX, 'Rate')
\end_layout

\begin_layout Plain Layout

DSX$DTMDT <- c(0, diff(DSX$RTH1, 2), 0) * Rate / 2
\end_layout

\begin_layout Plain Layout

DSX$DTM2DT2 <- (c(diff(DSX$RTH1), 0) - c(0, diff(DSX$RTH1))) * Rate^2
\end_layout

\begin_layout Plain Layout

DSX$RTHC <- (tau1 + tau2) * DSX$DTMDT + DSX$RTH1 + tau1 * tau2 * DSX$DTM2DT2
\end_layout

\begin_layout Plain Layout

DSX$RTHC <- zoo::na.approx (as.vector(DSX$RTHC), maxgap=1000*Rate,
\end_layout

\begin_layout Plain Layout

      na.rm = FALSE, rule = 2)
\end_layout

\begin_layout Plain Layout

CutoffPeriod <- 12.5
\end_layout

\begin_layout Plain Layout

DSX$RTHC <- signal::filtfilt (signal::butter (3,
\end_layout

\begin_layout Plain Layout

      2/CutoffPeriod), DSX$RTHC)
\end_layout

\begin_layout Plain Layout

# DSX$RTHC <- SmoothInterp(DSX$RTHC, .Length=25)
\end_layout

\begin_layout Plain Layout

DSAP <- DSX
\end_layout

\begin_layout Plain Layout

DSAP$RTH1 <- DSAP$RTH1 - mean(DSAP$RTH1[setRange(DSAP, 55700, 60000)], na.rm=TRUE
)
\end_layout

\begin_layout Plain Layout

DSAP$RTF1P <- DSAP$RTF1 - mean(DSAP$RTF1[setRange(DSAP, 55700, 60000)],
 na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

DSAP$RTHC <- DSAP$RTHC - mean(DSAP$RTHC[setRange(DSAP, 55700, 60000)], na.rm=TRUE
)
\end_layout

\begin_layout Plain Layout

DSAP$RT <- DSAP$RT - mean(DSAP$RT[setRange(DSAP, 55700, 60000)], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

# DSAP %>% selectTime(55920, 55950) %>% 
\end_layout

\begin_layout Plain Layout

#          select(Time, RT, RTH1, RTHC) %>% 
\end_layout

\begin_layout Plain Layout

#         ggplotWAC(col=c('blue', 'forestgreen', 'black'), lty=c(1,4,1),
\end_layout

\begin_layout Plain Layout

#                   ylab=bquote('recovery temperature [' ~ degree * 'C]'),
 
\end_layout

\begin_layout Plain Layout

#                   lwd=c(0.8,1,1)) + xlab('time [s]') +
\end_layout

\begin_layout Plain Layout

#         theme_WAC(1) + theme(legend.position=c(0.75, 0.9))
\end_layout

\begin_layout Plain Layout

DSAX <- DSX %>% selectTime(55700, 60300)
\end_layout

\begin_layout Plain Layout

DSAX <- DSAX[1:2^13, ]
\end_layout

\begin_layout Plain Layout

ft <- fft(DSAX$RTH1)
\end_layout

\begin_layout Plain Layout

N <- length(ft)
\end_layout

\begin_layout Plain Layout

Rate <- attr(DSX, 'Rate')
\end_layout

\begin_layout Plain Layout

df <- Rate / N
\end_layout

\begin_layout Plain Layout

frq <- c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
\end_layout

\begin_layout Plain Layout

fr <- log(abs(frq))
\end_layout

\begin_layout Plain Layout

Gain  <- cfrHARCO[1] + fr * (cfrHARCO[2] + fr * fr * (cfrHARCO[3] + 
\end_layout

\begin_layout Plain Layout

         fr * (cfrHARCO[4] + fr * cfrHARCO[5])))
\end_layout

\begin_layout Plain Layout

Gain[abs(frq) < 0.024] <- 1
\end_layout

\begin_layout Plain Layout

Phase <- cfHARCO[1] + cfHARCO[2] * fr + cfHARCO[3] * fr^2 +
\end_layout

\begin_layout Plain Layout

         cfHARCO[4] * atan(frq)
\end_layout

\begin_layout Plain Layout

Phase[frq < 0] <- -Phase[frq < 0]
\end_layout

\begin_layout Plain Layout

Phase[1] <- 0
\end_layout

\begin_layout Plain Layout

Phase <- Phase * pi / 180
\end_layout

\begin_layout Plain Layout

TF <- complex(modulus=Gain, argument=Phase)
\end_layout

\begin_layout Plain Layout

tlmt <- 1.8
\end_layout

\begin_layout Plain Layout

TF[abs(frq) > tlmt] <- TF[abs(frq) > tlmt] * exp(5*abs(frq[abs(frq) > tlmt])
 / tlmt)
\end_layout

\begin_layout Plain Layout

ftx <- ft / TF
\end_layout

\begin_layout Plain Layout

DSAX$RTFFT <- Re(fft(ftx, inverse = TRUE) / N)
\end_layout

\begin_layout Plain Layout

N <- 2^13 
\end_layout

\begin_layout Plain Layout

Nby2 <- N / 2
\end_layout

\begin_layout Plain Layout

RTH1 <- DSAX$RTH1
\end_layout

\begin_layout Plain Layout

ff1 <- fft(RTH1)
\end_layout

\begin_layout Plain Layout

RTH <- Re(fft(ff1, inverse=TRUE)) / N
\end_layout

\begin_layout Plain Layout

df <- Rate / N
\end_layout

\begin_layout Plain Layout

frq <- c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
\end_layout

\begin_layout Plain Layout

fr <- log(frq[1:(Nby2+1)])
\end_layout

\begin_layout Plain Layout

## Get the transfer function from the fitted parameterized form:
\end_layout

\begin_layout Plain Layout

Ph <- cfHARCO[1] + cfHARCO[2] * fr + 
\end_layout

\begin_layout Plain Layout

           cfHARCO[3] * fr^2 + cfHARCO[4] * atan(frq[1:(Nby2+1)])
\end_layout

\begin_layout Plain Layout

Ph[1] <- 0
\end_layout

\begin_layout Plain Layout

G <- cfrHARCO[1] + fr * (cfrHARCO[2] + fr * fr * (cfrHARCO[3] + 
\end_layout

\begin_layout Plain Layout

           fr * (cfrHARCO[4] + fr * cfrHARCO[5])))
\end_layout

\begin_layout Plain Layout

G[frq[1:length(fr)] < 0.024] <- 1
\end_layout

\begin_layout Plain Layout

G[frq[1:length(fr)] > 2] <- G[which.min(abs(frq-2))]
\end_layout

\begin_layout Plain Layout

H <- rep(complex(modulus=0), N)
\end_layout

\begin_layout Plain Layout

H[1:(Nby2+1)] <- complex(modulus=G, argument=Ph * pi / 180)
\end_layout

\begin_layout Plain Layout

H[(Nby2+2):N] <- rev(Conj(H[2:Nby2]))
\end_layout

\begin_layout Plain Layout

RTC <- Re(fft(ff1 / H, inverse = TRUE)) / N
\end_layout

\begin_layout Plain Layout

DSAX$RTC <- RTC
\end_layout

\begin_layout Plain Layout

dfTF <- data.frame(
\end_layout

\begin_layout Plain Layout

  'Time' = frq,
\end_layout

\begin_layout Plain Layout

  'Amp' = Gain,
\end_layout

\begin_layout Plain Layout

  'Phase' = Phase
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  ggplotWAC(
\end_layout

\begin_layout Plain Layout

    dfTF,
\end_layout

\begin_layout Plain Layout

    panels = 2,
\end_layout

\begin_layout Plain Layout

    labelP = c('    Amplitude', 'Phase [degrees]')
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab(bquote('transfer function H(' * nu
 ~ ')'))
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  g + scale_x_log10(
\end_layout

\begin_layout Plain Layout

    breaks = trans_breaks("log10", function(x)
\end_layout

\begin_layout Plain Layout

      10 ^ x, n = 4),
\end_layout

\begin_layout Plain Layout

    labels = trans_format("log10", math_format(expr = 10 ^ .x))
\end_layout

\begin_layout Plain Layout

  ) + xlab('frequency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = 'tb')
\end_layout

\begin_layout Plain Layout

# g + theme_WAC(1) + theme(legend.position = c(0.3, 0.65))
\end_layout

\begin_layout Plain Layout

DSAP <- DSAX
\end_layout

\begin_layout Plain Layout

DSAP$RTH1 <- DSAP$RTH1 - mean(DSAP$RTH1[setRange(DSAP, 55700, 60000)], na.rm=TRUE
)
\end_layout

\begin_layout Plain Layout

DSAP$RTF1P <- DSAP$RTF1 - mean(DSAP$RTF1[setRange(DSAP, 55700, 60000)],
 na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

DSAP$RTH <- DSAP$RTHC - mean(DSAP$RTHC[setRange(DSAP, 55700, 60000)], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

DSAP$RT <- DSAP$RT - mean(DSAP$RT[setRange(DSAP, 55700, 60000)], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

DSAP$FFT <- DSAP$RTFFT - mean(DSAP$RTFFT[setRange(DSAP, 55700, 60000)],
\end_layout

\begin_layout Plain Layout

                                na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

DSAP$Tm <- DSAP$RTH1
\end_layout

\begin_layout Plain Layout

DSAP %>% selectTime(55918, 55950) %>% 
\end_layout

\begin_layout Plain Layout

         select(Time, RT, Tm, FFT, RTH) %>% 
\end_layout

\begin_layout Plain Layout

         ggplotWAC(c('blue', 'forestgreen', 'black', 'darkorange'),
\end_layout

\begin_layout Plain Layout

                   ylab=bquote('recovery temperature [' ~ degree * 'C]'),
\end_layout

\begin_layout Plain Layout

                   lty=c(1,2,1,1), lwd=c(0.8,1.2,1,0.8)) + xlab('time [s]')
 +
\end_layout

\begin_layout Plain Layout

         theme_WAC(1) + 
\end_layout

\begin_layout Plain Layout

         theme(legend.position=c(0.715, 0.93))
\end_layout

\begin_layout Plain Layout

g <- DSAP %>% select(Time, TASX, Tm, RTH, RT) %>% 
\end_layout

\begin_layout Plain Layout

        VSpec(xlim=c(5.e-3, 15), ylim=c(2.e-6, 1.e-2), 
\end_layout

\begin_layout Plain Layout

        smoothBins = 100, method='MEM')
\end_layout

\begin_layout Plain Layout

VSpec(DSAP, 'FFT', add=g, type='MEM') + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\begin_inset Branch expanded
inverted 0
status open

\begin_layout Section
The Digital Filter for Dynamic Heating
\end_layout

\begin_layout Standard
As described in Sect
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand eqref
reference "subsec:A-filter-for"
plural "false"
caps "false"
noprefix "false"

\end_inset

, digital filters for dynamic heating were developed from the transfer functions
 for the probes studied in Part 1.
 The procedure was to use the inverse Fourier transforms of those transfer
 functions, which give the impulse response functions, and then design filters
 using coefficients determined from those impulse functions.
 This appendix describes in more detail how this was done and includes reference
s to the coefficients that might be used by others.
 The filters so obtained appear to function as desired, although this is
 an area where further work will be warranted.
\end_layout

\begin_layout Standard
The procedures was as follows:
\end_layout

\begin_layout Enumerate
Specify the transfer function for the sensor (e.g., for the unheated Rosemount
 102E4AL sensor or the heated HARCO sensor) as determined in Part 1.
\end_layout

\begin_layout Enumerate
For a large set of frequencies spanning the interval from 
\begin_inset Formula $-12.5$
\end_inset

 to 
\begin_inset Formula $12.5$
\end_inset


\begin_inset space ~
\end_inset

Hz, e.g., with resolution between assumed frequencies of (1/600)
\begin_inset space ~
\end_inset

Hz, evaluate the frequency-dependent transfer function.
 This solution is stored in a vector with frequencies in the order (0 to
 12.5
\begin_inset space ~
\end_inset

Hz, then 
\begin_inset Formula $(-12.5+1/600)$
\end_inset

 to 
\begin_inset Formula $-(1/600)$
\end_inset

 Hz, as is conventional for representations of the Fourier transform in
 R and also many other languages.
 It was necessary to calculate the negative-frequency components and, to
 obtain real-number results, to store them so that the values representing
 negative frequencies are complex conjugates of those for the corresponding
 positive frequencies.
\end_layout

\begin_layout Enumerate
The inverse Fourier transform then gave the impulse function at 15,000 delays,
 many of them representing negative delays.
 The values in the central part of this array were mostly very small.
\end_layout

\begin_layout Enumerate
To obtain a manageable number of moving-average coefficients, all values
 in the array representing the impulse function were set to zero for indices
 k with values 
\begin_inset Formula $M+2\leq k\leq N-M$
\end_inset

 where 
\begin_inset Formula $N$
\end_inset

 is the length of the calculated impulse function and 
\begin_inset Formula $M=100$
\end_inset

, which left 201 non-zero coefficients.
 These coefficients then spanned 8 s at 25
\begin_inset space ~
\end_inset

Hz, a time long compared to the expected impulse response of the sensor.
\end_layout

\begin_layout Enumerate
The upper-100 coefficients represent negative delays in the impulse response
 because of the cyclic nature of the Fourier transform, so the coefficients
 were re-arranged into a sequence with the last-100 coefficients first and
 the initial-101 coefficients moved to the end of the array.
 These coefficients were then moving-average coefficients that implement
 a filter matching the transfer function, except for the omitted terms outside
 the 200-coefficient range that are assumed negligible.
\end_layout

\begin_layout Enumerate
The resulting set of moving-average coefficients can then be applied to
 the measured dynamic-heating term 
\begin_inset Formula $Q$
\end_inset

 to produce a filtered version.
\end_layout

\begin_layout Enumerate
The filtered result then needs to be shifted in time by 4
\begin_inset space ~
\end_inset

s to correct for the offset in the filter.
\end_layout

\begin_layout Standard
Additional details, references to filter coefficients, and relevant R code
 are included in the 
\begin_inset Quotes eld
\end_inset

Workflow
\begin_inset Quotes erd
\end_inset

 document.
\end_layout

\end_inset


\begin_inset Branch expanded
inverted 0
status open

\begin_layout Section
Pressure-Line Resonance
\end_layout

\begin_layout Standard
\begin_inset CommandInset citation
LatexCommand citet
key "Cooper2016ncartn"
literal "false"

\end_inset

 showed evidence that the variance spectrum of the longitudinal component
 of the wind measured by the NSF/NCAR GV appears to have excess variance
 at frequencies above about 2
\begin_inset space ~
\end_inset

Hz.
 Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:Qproblem}
\end_layout

\end_inset

 shows the problem: Both the airspeed and the dynamic heating calculated
 from it have excess variance above the expected distribution for frequencies
 above about 2
\begin_inset space ~
\end_inset

Hz, although this is a turbulent region with characteristics otherwise consisten
t with an inertial subrange.
 The lateral components of the wind do not show this excess variance; it
 only appears in the longitudinal component.
 It is far above the noise expected from the precision of the sensor used
 to measure the dynamic pressure (estimated at about 0.1
\begin_inset space ~
\end_inset

hPa), so there must be another source of this contamination of the signal.
 A similar but less pronounced effect on a different aircraft was shown
 by 
\begin_inset CommandInset citation
LatexCommand citet
key "nicholls1978measurements"
literal "false"

\end_inset

 (in his Fig.
\begin_inset space ~
\end_inset

2) and was also discussed by 
\begin_inset CommandInset citation
LatexCommand citet
key "InverarityJTech2000"
literal "false"

\end_inset

.
 Both references used filtering of the final temperature measurement to
 give a reasonable variance spectrum, but it will be argued here that the
 effect should be removed from the dynamic-heating correction instead.
\end_layout

\begin_layout Standard
The suggested explanation (by D.
\begin_inset space ~
\end_inset

Lenschow, included in 
\begin_inset CommandInset citation
LatexCommand citet
key "Cooper2016ncartn"
literal "false"

\end_inset

, p.
\begin_inset space ~
\end_inset

140) is that there is resonance in the lines connecting the pressure ports
 to the pressure transducers and effects in those lines cause either amplificati
on or attenuation of the pressure signals, along with phase shifts, at various
 frequencies.
 On the NSF/NCAR GV dynamic pressure is measured by a differential pressure
 transducer that connects to a pitot-tube and, on the reference side, to
 the static-pressure ports.
 The connecting lines are about 8-m long to the static-pressure sources
 and a few meters long to the pitot tube.
 The extraneous variance in the pressure lines does not influence the temperatur
e sensor.
 Therefore, subtraction of the measured dynamic-heating term from the recovery
 temperature to obtain the ambient temperature introduces still more high-freque
ncy noise into the measurement of air temperature if the estimate of dynamic
 heating is contaminated by these line effects.
 When correcting for temperature-sensor time response, this additional source
 of false variation in the dynamic-heating term should be removed where
 possible.
 This appendix discusses a possible approach to that removal.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<Qproblem, include=TRUE, fig.scap = 'The variance spectrum for the dynamic-heati
ng correction in a region thought to have characteristics of an inertial
 subrange.', fig.cap='The variance spectrum for the dynamic-heating correction
 $Q$, from SOCRATES flight 15, 6:00:00 to 6:15:00 UTC, in a region thought
 to have characteristics of an inertial subrange.
 The variance spectrum for the airspeed measurement (TASX) is also shown.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DS15 <- getNetCDF(file.path(DataDirectory(), 'SOCRATES/SOCRATESrf15h.nc'),
 
\end_layout

\begin_layout Plain Layout

                  standardVariables(c('ATF1', 'PSF', 'QCF')), 55700, 61900)
\end_layout

\begin_layout Plain Layout

DS15$Q <- RecoveryFactor(DS15$MACHX, probe = 'UNHEATED') * DS15$TASX^2 /
 2010
\end_layout

\begin_layout Plain Layout

DS15$TAS <- DS15$TASX  ## needed to get TASX to plot in VSpec 
\end_layout

\begin_layout Plain Layout

DS15 %>% selectTime(60000, 61500) %>%
\end_layout

\begin_layout Plain Layout

         select(Time, TASX, Q, TAS) %>% 
\end_layout

\begin_layout Plain Layout

         VSpec(WACtheme = 1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The argument presented in 
\begin_inset CommandInset citation
LatexCommand citet
key "Cooper2016ncartn"
literal "false"

\end_inset

 was that line resonance in the static pressure line used as a lower-pressure
 reference for the dynamic-pressure measurement was responsible.
 It appears now that this was not the correct explanation.
 The reason is that fluctuations in static pressure normally make a negligible
 contribution to the measured fluctuations in dynamic pressure; instead,
 fluctuations in dynamic pressure are dominated by fluctua\SpecialChar softhyphen
tions in the total
 pressure delivered by the pitot tube to the differential sensor.
 Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:3Pplot}
\end_layout

\end_inset

 shows that the dominant contributions to variance in dynamic pressure,
 measured as the difference between the total and static pressure, comes
 from the variance in the total pressure present in the shorter inlet line.
 Resonances in both lines need to be evaluated, but the following analysis
 indicates that the fluctuations in the static-pressure line do not make
 any significant contribution to fluctuations in measured dynamic pressure.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout

\lang english
The correction analyzed there, however, uses the resonance predicted for
 a long line extending from the static-pressure source to one side of a
 differential pressure transducer.
 Previous evaluations, including that in 
\begin_inset CommandInset citation
LatexCommand citet
key "Cooper2016ncartn"
literal "false"

\end_inset

, emphasized the role of the long pressure line connecting the differential
 pressure sensor (for 
\begin_inset Quotes eld
\end_inset

QCF
\begin_inset Quotes erd
\end_inset

) to the static pressure source (measured as 
\begin_inset Quotes eld
\end_inset


\begin_inset Quotes erd
\end_inset

PSF
\begin_inset Quotes erd
\end_inset

).
 However, there are two possible resonance effects that influence the measuremen
t of dynamic pressure, that in the static-pressure line and that in the
 total-pressure line from the pitot tube to the differential pressure transducer.
 The fluctuations in static pressure are much smaller than those in total
 pressure, so it is not obvious that the static-pressure effects dominate.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<3Pplot, include=TRUE, fig.pos='t', fig.cap='Variance spectra for three pressure
 measurements: the ambient or static pressure (
\begin_inset Quotes eld
\end_inset

PS
\begin_inset Quotes erd
\end_inset

), the dynamic pressure (
\begin_inset Quotes eld
\end_inset

Q
\begin_inset Quotes erd
\end_inset

), and their sum (
\begin_inset Quotes eld
\end_inset

PT
\begin_inset Quotes erd
\end_inset

), the total pressure.
 The plots for dynamic and total pressure mostly overlap and are indistiguishabl
e in this plot.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DS15$PTOT <- DS15$PSF + DS15$QCF
\end_layout

\begin_layout Plain Layout

D4Here <- DS15
\end_layout

\begin_layout Plain Layout

D4Here$PS <- D4Here$PSF
\end_layout

\begin_layout Plain Layout

D4Here$Q <- D4Here$QCF
\end_layout

\begin_layout Plain Layout

D4Here$PT <- D4Here$PTOT
\end_layout

\begin_layout Plain Layout

D4Here %>% selectTime(60000, 61500) %>%
\end_layout

\begin_layout Plain Layout

         select(Time, TASX, PS, Q, PT) %>%
\end_layout

\begin_layout Plain Layout

         VSpec(ylim=c(1.e-4, 3)) + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Extra
inverted 0
status open

\begin_layout Standard

\lang english
See Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:showLineTF}
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<lineTF>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

library(Bessel)
\end_layout

\begin_layout Plain Layout

Rate <- 25
\end_layout

\begin_layout Plain Layout

N <- 2^14
\end_layout

\begin_layout Plain Layout

df <- Rate / N
\end_layout

\begin_layout Plain Layout

frq <- seq(df, Rate / 2, by = df)
\end_layout

\begin_layout Plain Layout

# AFFT <- LTphase(frq, ParamSF)
\end_layout

\begin_layout Plain Layout

## Lenschow/Iberall calc:
\end_layout

\begin_layout Plain Layout

LineTF <- function(frq, pinp = 1013.25, Tinp = 15, Dinp = 3.1e-3, Linp = 8,
 Vinp = 1.e-6) {
\end_layout

\begin_layout Plain Layout

  izero  <- which(frq == 0)
\end_layout

\begin_layout Plain Layout

  if (!is.null(izero)) {
\end_layout

\begin_layout Plain Layout

    frq[izero] <- 1  ## placeholder
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  omega <- 2 * pi * frq
\end_layout

\begin_layout Plain Layout

  visc <- (1.718+0.0049*Tinp)*1.e-5    # viscosity, kg/(m s)
\end_layout

\begin_layout Plain Layout

  dens <- 100 * pinp / (StandardConstant('Rd') * (Tinp+273.15))  # air density
 mks
\end_layout

\begin_layout Plain Layout

  kvisc <- visc / dens
\end_layout

\begin_layout Plain Layout

  gIberall <- sqrt(abs(omega) / (2 * kvisc)) * Dinp / 2
\end_layout

\begin_layout Plain Layout

  gIberall <- gIberall * complex(1, 1, -sign(omega)) 
\end_layout

\begin_layout Plain Layout

  FIberall <- (1/1.4) * 
\end_layout

\begin_layout Plain Layout

    (1 + (2 * 0.4 * BesselI(gIberall, 1)) / (gIberall  * BesselI(gIberall,
 0))) *
\end_layout

\begin_layout Plain Layout

    (gIberall^2/8) / (2*BesselI(gIberall, 1) / (gIberall * BesselI(gIberall,
 0)) - 1)
\end_layout

\begin_layout Plain Layout

  F2Iberall <- 1.4 / (1 + 0.4 * 2 * BesselI(gIberall, 1) /
\end_layout

\begin_layout Plain Layout

    (gIberall * BesselI(gIberall, 0)))
\end_layout

\begin_layout Plain Layout

  xIberall <- 32 * visc * omega / (100 * pinp) * (Linp / Dinp)^2 * FIberall
\end_layout

\begin_layout Plain Layout

  psiIberall <- sqrt(complex(1, 0, 1) * xIberall)
\end_layout

\begin_layout Plain Layout

  xIIberall <- Vinp / (1.4 * pi * (Dinp/2)^2 * Linp) * xIberall * F2Iberall
\end_layout

\begin_layout Plain Layout

  psiIIberall <- complex(1, 0, 1) * xIIberall
\end_layout

\begin_layout Plain Layout

  HIberall <- 1 / cosh(psiIberall)
\end_layout

\begin_layout Plain Layout

  ## Enhancement for the instrument volume:
\end_layout

\begin_layout Plain Layout

  HIberall <- 1 / (cosh(psiIberall) + psiIIberall / psiIberall * sinh(psiIberall
))
\end_layout

\begin_layout Plain Layout

  if (!is.null(izero)) {
\end_layout

\begin_layout Plain Layout

    HIberall[izero] <- complex(1,1,0)
\end_layout

\begin_layout Plain Layout

    frq[izero] <- 0
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  dIberall <- data.frame(freq = frq, Amp = Mod(HIberall), Phase = -Arg(HIberall)
 * 180 / pi)
\end_layout

\begin_layout Plain Layout

  return(dIberall)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Extra
inverted 0
status open

\begin_layout Standard

\lang english
\begin_inset ERT
status open

\begin_layout Plain Layout

<<showLineTF, include=TRUE, fig.cap='Pressure line response function, for
 1013.25 Hpa and 15C and for 700 hPa and 0C.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

pI <- c(1013.25, 700)
\end_layout

\begin_layout Plain Layout

dIberall <- LineTF(frq, p=pI[1])
\end_layout

\begin_layout Plain Layout

nm <- names(dIberall)
\end_layout

\begin_layout Plain Layout

nm[which(nm == 'freq')] <- 'Time'
\end_layout

\begin_layout Plain Layout

names(dIberall) <- nm
\end_layout

\begin_layout Plain Layout

dI2 <- LineTF(frq, p=pI[2])
\end_layout

\begin_layout Plain Layout

dIberall$Amp2 <- dI2$Amp
\end_layout

\begin_layout Plain Layout

dIberall$Phase2 <- dI2$Phase
\end_layout

\begin_layout Plain Layout

ltitle <- c(sprintf('%.0f hPa', pI[1]), sprintf('%.0f hPa', pI[2]))
\end_layout

\begin_layout Plain Layout

ggplotWAC(dIberall[, c(1,2,4,3,5)], panels = 2, 
\end_layout

\begin_layout Plain Layout

  labelP = c('      Amplitude', '   Phase [degrees]'), 
\end_layout

\begin_layout Plain Layout

  labelL=ltitle, legend.position=c(0.25, 0.93),
\end_layout

\begin_layout Plain Layout

  ylab='Response Function', theme.version=1) + xlab('Frequency [Hz]')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Lenschow's analysis (based on theoretical predictions of 
\begin_inset CommandInset citation
LatexCommand citet
key "Iberall1950"
literal "false"

\end_inset

) leads to a transfer function representing the effect of the line resonance
 on the measurement.
 This transfer function was plotted in Fig.
\begin_inset space ~
\end_inset

52 of 
\begin_inset CommandInset citation
LatexCommand citet
key "Cooper2016ncartn"
literal "false"

\end_inset

 and has been recalculated from the equations in 
\begin_inset CommandInset citation
LatexCommand citet
key "Iberall1950"
literal "false"

\end_inset

, specifically Eqs.
\begin_inset space ~
\end_inset

(105) and (106) with (99) and (95) from that reference and with the volume
 within the pressure sensor at the end of the line assumed to be 300
\begin_inset space ~
\end_inset

mm
\begin_inset Formula $^{3}$
\end_inset

 as used by D\SpecialChar endofsentence
 Lenschow, for use in the present work.
 That transfer function then can be used in the same way as the time-response
 transfer function to correct the measured dynamic-heating term by applying
 the correction to both lines connected to the dynamic-pressure sensor.
 The result should be a better estimate of the dynamic heating at the temperatur
e sensor because the fluctuations occurring only in the lines and not affecting
 the temperature sensor will be removed.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<correctQresonance, include=TRUE, fig.cap='The variance spectrum that results
 from correcting the measured static pressure (
\begin_inset Quotes eld
\end_inset

PS
\begin_inset Quotes erd
\end_inset

) for the theoretical effect of line resonance.
 The corrected pressure is represented here as 
\begin_inset Quotes eld
\end_inset

PSC
\begin_inset Quotes erd
\end_inset

.
 To reduce suspected noise, additional attenuation is applied above 8 Hz
 to obtain 
\begin_inset Quotes eld
\end_inset

PSCF
\begin_inset Quotes erd
\end_inset

.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Rate <- attr(DS15, 'Rate')
\end_layout

\begin_layout Plain Layout

## Correct TASX for the line-resonance effect:
\end_layout

\begin_layout Plain Layout

DS15$TASX <- SmoothInterp(DS15$TASX, .Length = 0)
\end_layout

\begin_layout Plain Layout

DS15$PTOT <- DS15$PSF + DS15$QCF
\end_layout

\begin_layout Plain Layout

DS15$PTOT <- SmoothInterp(DS15$PTOT, .Length = 0)
\end_layout

\begin_layout Plain Layout

DS15$PSF <- SmoothInterp(DS15$PSF, .Length = 0)
\end_layout

\begin_layout Plain Layout

DS15$QCF <- SmoothInterp(DS15$QCF, .Length = 0)
\end_layout

\begin_layout Plain Layout

DS15 <- DS15[1:2^15, ]
\end_layout

\begin_layout Plain Layout

f <- fft (DS15$TASX) 
\end_layout

\begin_layout Plain Layout

fp <- fft(DS15$PSF)
\end_layout

\begin_layout Plain Layout

N <- length(f)
\end_layout

\begin_layout Plain Layout

df <- Rate / N
\end_layout

\begin_layout Plain Layout

frq <- c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
\end_layout

\begin_layout Plain Layout

N2 <- N %/% 2
\end_layout

\begin_layout Plain Layout

## Attenuate above 8 Hz:
\end_layout

\begin_layout Plain Layout

fAtten <- 8
\end_layout

\begin_layout Plain Layout

iatt <- which.min(abs(frq - fAtten))
\end_layout

\begin_layout Plain Layout

fpf <- fp
\end_layout

\begin_layout Plain Layout

irg <- iatt : (N - iatt)
\end_layout

\begin_layout Plain Layout

fpf[irg] <- fpf[irg] * (fAtten / abs(frq[irg]))^10  ## 3.5 looks good!
\end_layout

\begin_layout Plain Layout

## Modify the spectrum by the inverse of the response function:
\end_layout

\begin_layout Plain Layout

AFFT <- LineTF(frq, mean(DS15$PSF, na.rm=TRUE), mean(DS15$ATX, na.rm=TRUE),
\end_layout

\begin_layout Plain Layout

               Dinp = 4e-3, Linp = 9, Vinp = 0.3e-6)
\end_layout

\begin_layout Plain Layout

# AFFT <- rbind(data.frame(Time=0, Amp=1, Phase=0), AFFT, rev(AFFT[2:N2,
 ]))
\end_layout

\begin_layout Plain Layout

# AFFT$Phase[(N2+2):N] <- -AFFT$Phase[(N2+2):N]
\end_layout

\begin_layout Plain Layout

AFFT$frq <- frq
\end_layout

\begin_layout Plain Layout

AFFT$Phase <- AFFT$Phase * pi / 180
\end_layout

\begin_layout Plain Layout

HI <- complex (modulus = AFFT$Amp, argument = AFFT$Phase)
\end_layout

\begin_layout Plain Layout

f <- f / HI
\end_layout

\begin_layout Plain Layout

fp <- fp / HI
\end_layout

\begin_layout Plain Layout

fpf <- fpf / HI
\end_layout

\begin_layout Plain Layout

AFFTT <- LineTF(frq, mean(DS15$PTOT, na.rm=TRUE), 
\end_layout

\begin_layout Plain Layout

                mean(DS15$ATX + DS15$TASX^2 / 2010, na.rm=TRUE),
\end_layout

\begin_layout Plain Layout

                Dinp = 3.1e-3, Linp = 4, Vinp = 1.e-5)
\end_layout

\begin_layout Plain Layout

HT <- complex (modulus = AFFTT$Amp, argument = AFFTT$Phase)
\end_layout

\begin_layout Plain Layout

xn <- Re(fft(f, inverse = TRUE)) / N
\end_layout

\begin_layout Plain Layout

xnp <- Re(fft(fp, inverse = TRUE)) / N
\end_layout

\begin_layout Plain Layout

xnpf <- Re(fft(fpf, inverse = TRUE)) / N  ## Best estimate of the static
 pressure
\end_layout

\begin_layout Plain Layout

DS15$TASQ <- xn
\end_layout

\begin_layout Plain Layout

DS15$PSC <- xnp
\end_layout

\begin_layout Plain Layout

DS15$PSCF <- xnpf
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

fq <- fft(DS15$QCF + DS15$PSF)  ## Best estimate of total pressure in the
 line
\end_layout

\begin_layout Plain Layout

fq <- fq / HT
\end_layout

\begin_layout Plain Layout

xnq <- Re(fft(fq, inverse = TRUE)) / N
\end_layout

\begin_layout Plain Layout

DS15$PTOTR <- xnq               ## Best estimate of the true total pressure
\end_layout

\begin_layout Plain Layout

DS15$QCFR <- xnq - xnpf         ## Best estimate of the true dynamic pressure
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DS15$Q <- DS15$TASX^2 / 2010
\end_layout

\begin_layout Plain Layout

DS15$QQ <- DS15$TASQ^2 / 2010
\end_layout

\begin_layout Plain Layout

DS15$SIM <- rnorm(nrow(DS15), 0, 0.34)
\end_layout

\begin_layout Plain Layout

DS15$PS <- DS15$PSF
\end_layout

\begin_layout Plain Layout

DS15 %>% selectTime(60000, 61500) %>% 
\end_layout

\begin_layout Plain Layout

         select(Time, TASX, PS, PSC, PSCF) %>% 
\end_layout

\begin_layout Plain Layout

         VSpec(spans = 99, ylim=c(1.e-5, 1.e-1)) + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# DS15 %>% selectTime(60000, 61500) %>% 
\end_layout

\begin_layout Plain Layout

#          select(Time, TASX, Q, QQ) %>% 
\end_layout

\begin_layout Plain Layout

#          VSpec(ylim=c(1.e-5, 1.e-1), WACtheme=1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Consider first the effect on static pressure.
 The predicted transfer function is based on a theoretical analysis, so
 it is useful to determine from observations if the correction based on
 that transfer function is reasonable.
 In a region thought to represent an inertial subrange, the slope of the
 variance spectrum of the longitudinal wind (and therefore of airspeed fluctuati
ons and also the dynamic-heating term) is expected to exhibit a 
\begin_inset Formula $-5/3$
\end_inset

 slope with frequency or a 
\begin_inset Formula $-2/3$
\end_inset

 slope in the frequency-weighted spectral-variance plots used here.
 Measurements of static pressure from the same region shown in Figs.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:Qproblem}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:3Pplot}
\end_layout

\end_inset

 were processed by calculating the Fourier transform of the pressure, dividing
 by the transfer function, and using an inverse Fourier transform to recover
 the corrected pressure.
 The result is shown as 
\begin_inset Quotes eld
\end_inset

PSC
\begin_inset Quotes erd
\end_inset

 in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:correctQresonance}
\end_layout

\end_inset

, as the green line (mostly overlapped at low frequency by the black line).
 The result seems reasonable for frequencies below about 8
\begin_inset space ~
\end_inset

Hz, but there is a sharp increase above that point.
 Two possible causes are: (i) The sensor resolution, thought to be 0.1
\begin_inset space ~
\end_inset

hPa from the manufacturer's specified uncertainty limit, would cause a noise
 spectrum of about this magnitude, although with a smaller slope; and (ii)
 aliasing of higher-frequency fluctuations may contribute.
 The digital filters applied to the measurements don't remove this aliasing
 because the fluctuations are real fluctuations in pressure in the pressure
 lines and so will still be sampled as aliased.
 For these reasons, additional filtering was applied to the Fourier components
 before inverse transformation to reduce frequencies above 8
\begin_inset space ~
\end_inset

Hz.
 The result, shown as 
\begin_inset Quotes eld
\end_inset

PSFR
\begin_inset Quotes erd
\end_inset

 in the figure, is a reasonable adjustment to the original variance spectrum
 to account for line resonance for frequencies below 8
\begin_inset space ~
\end_inset

Hz, and evidently excess variance at higher frequency has been removed
\end_layout

\begin_layout Standard
This approximate agreement between predictions for the measured static pressure
 and the expected shape of the variance spectrum after correction, for frequency
 below 8
\begin_inset space ~
\end_inset

Hz, provides some support for the theoretical analysis by greatly improving
 the appearance of the variance spectrum for pressure, although the shape
 is still not ideal.
 The spectrum would appear better if the gain of the transfer function around
 4
\begin_inset space ~
\end_inset

Hz were approximately 40% larger so that the variance there would be reduced
 by about a factor of 2.
 Although the distance from the static source to the pressure transducer
 is only about 3
\begin_inset space ~
\end_inset

m, it appears that resonance in the branch of this line that continues forward
 to the differential transducer affects the signal also at this location.
\end_layout

\begin_layout Standard
Analysis of the effect of line resonance on the measurement of dynamic pressure
 is more complicated because resonance can occur in both lines, the line
 delivering total pressure from the pitot tube and the line delivering static
 pressure from the static sources.
 The measured quantity at the differential pressure transducer is the difference
 between the total-pressure-line resonating pressure and the ambient-pressure-li
ne resonating pressure, so (using primes to denote quantities in the resonating
 lines) 
\begin_inset Formula $p_{t}^{\prime}=q^{\prime}+p_{s}^{\prime}$
\end_inset

 is the true total pressure in the line from the pitot tube.
 This can be corrected using the theoretical transfer function for that
 line
\begin_inset Foot
status open

\begin_layout Plain Layout
Assumed parameters are length 4 m, diameter 3.1 mm, sensor volume 
\begin_inset Formula $10^{4}\thinspace\mathrm{mm}^{3}$
\end_inset

.
 These need confirmation and possible adjustment.
 They were selected primarily to produce the appropriately corrected variance
 spectrum for dynamic heating.
 The sensor volume in particular is probably too high.
\end_layout

\end_inset

 to obtain the true total pressure at the inlet to the pitot tube, 
\begin_inset Formula $p_{t}$
\end_inset

.
 Then the best estimate of the true dynamic pressure 
\begin_inset Formula $q$
\end_inset

 is 
\begin_inset Formula $q=p_{t}-p_{s}$
\end_inset

 where corrected quantities are used for both 
\begin_inset Formula $p_{t}$
\end_inset

 and 
\begin_inset Formula $p_{s}$
\end_inset

, the latter as estimated from 
\begin_inset Quotes eld
\end_inset

PSCF
\begin_inset Quotes erd
\end_inset

 in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:correctQresonance}
\end_layout

\end_inset

.
 The corrected measurement of dynamic pressure, shown as 
\begin_inset Quotes eld
\end_inset

QC
\begin_inset Quotes erd
\end_inset

 in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:QCcorr}
\end_layout

\end_inset

, now exhibits a variance spectrum with the expected high-frequency slope.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout

\lang english
and primes denote quantities in the resonating lines, the measured quantity
 
\begin_inset Formula $q_{m}$
\end_inset

 is
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
q_{m}=p_{tot}^{\prime}-p_{s}^{\prime}=p_{tot}-(p_{tot}-p_{tot}^{\prime})-p_{s}+(p_{s}-p_{s}^{\prime})=q-(p_{tot}-p_{tot}^{\prime})+(p_{s}-p_{s}^{\prime})\label{eq:qmEq}
\end{equation}

\end_inset

where 
\begin_inset Formula $q^{\prime}=p_{tot}-p_{s}$
\end_inset

 is the true dynamic pressure.
 In the last term 
\begin_inset Formula $p_{s}$
\end_inset

 is obtained by applying the correction predicted by the transfer function
 
\begin_inset Formula $H_{s}(\omega)$
\end_inset

 for the static-pressure line to the measured value 
\begin_inset Formula $p_{s}^{\prime}$
\end_inset

, as displayed in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:correctQresonance}
\end_layout

\end_inset

: 
\begin_inset Formula $p_{s}=\mathcal{F}^{-1}(\mathcal{F}(p_{s}^{\prime})/H_{s}(\omega))$
\end_inset

 where 
\begin_inset Formula $\mathcal{F}$
\end_inset

 denotes the Fourier transform and 
\begin_inset Formula $\mathcal{F}^{-1}$
\end_inset

 its inverse transform.
 Subtracting the known last term, 
\begin_inset Formula $\delta p_{s}=(p_{s}-p_{s}^{\prime})$
\end_inset

 from the measured dynamic pressure gives, from the middle equality in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:qmEq"
plural "false"
caps "false"
noprefix "false"

\end_inset

,
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
p_{tot}^{\prime}=q_{m}+p_{s}^{\prime}\label{eq:ptotPrime}
\end{equation}

\end_inset

so the true pressure in the resonating total-pressure line (
\begin_inset Formula $p_{tot}^{\prime}$
\end_inset

) is 
\begin_inset Formula $q_{m}+p_{s}$
\end_inset

, the sum of the measured differential pressure and the corrected estimate
 of the static pressure.
 The transfer function for that total-pressure line 
\begin_inset Formula $H_{t}(\omega)$
\end_inset

 then leads to the corrected total pressure: 
\begin_inset Formula $p_{tot}=\mathcal{F}^{-1}(\mathcal{F}(p_{tot}^{\prime})/H_{t}(\omega))$
\end_inset

.
 The best estimate of the dynamic pressure is then 
\begin_inset Formula $q=p_{tot}-p_{s}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<QCcorr, include=TRUE, fig.cap='Variance spectra for the best estimate for
 dynamic heating, 
\begin_inset Quotes eld
\end_inset

QC
\begin_inset Quotes erd
\end_inset

, after correction for resonance in both lines connected to the differential
 pressure sensor that produces the original measurement 
\begin_inset Quotes eld
\end_inset

Q
\begin_inset Quotes erd
\end_inset

.
 The corresponding spectrum for the measured pressure in the line connected
 to the static sources (
\begin_inset Quotes eld
\end_inset

PS
\begin_inset Quotes erd
\end_inset

) is also shown.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DS15 %>% selectTime(60000, 61500) %>%
\end_layout

\begin_layout Plain Layout

         Rmutate(Q = QCF, QC = QCFR, PS = PSF) %>%
\end_layout

\begin_layout Plain Layout

         select(Time, TASX, Q, QC, PS) %>%
\end_layout

\begin_layout Plain Layout

         VSpec() + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout

\lang english
For illustration, 
\begin_inset Formula $H_{t}(\omega)$
\end_inset

 is calculated here for a 4-m line having diameter 3.1
\begin_inset space ~
\end_inset

mm and a sensor volume of 
\begin_inset Formula $10^{-5}\mathrm{m}^{3}$
\end_inset

.
 This is a higher volume than estimated for the sensor, but a volume of
 this magnitude or a longer line length is required to obtain the expected
 variance spectrum for dynamic pressure after correction (QCFR).
 The variance spectrum for the directly measured dynamic pressure, shown
 as 
\begin_inset Quotes eld
\end_inset

QCF
\begin_inset Quotes erd
\end_inset

 in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:QCcorr}
\end_layout

\end_inset

, has apparent noise above about 5
\begin_inset space ~
\end_inset

Hz, with standard deviation of 0.35
\begin_inset space ~
\end_inset

hPa, which is larger than expected for the precision of this sensor (0.1
\begin_inset space ~
\end_inset

hPa).
 The apparent noise in the high-frequency spectrum can also be removed by
 filtering as was done for the static pressure.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
It is notable that the variance spectrum for the measured static pressure,
 
\begin_inset Quotes eld
\end_inset

PS
\begin_inset Quotes erd
\end_inset

, is far below that for the corrected dynamic pressure (
\begin_inset Quotes eld
\end_inset

QC
\begin_inset Quotes erd
\end_inset

) or for the original measurement (
\begin_inset Quotes eld
\end_inset

Q
\begin_inset Quotes erd
\end_inset

), except near 12
\begin_inset space ~
\end_inset

Hz.
 That confirms that resonance in the long line supplying static pressure
 to the differential pressure sensor has little effect on the measurement
 of dynamic pressure and hence on the measurement of the longitudinal component
 of the wind.
 The important contribution appears to be from resonance in the total-pressure
 line.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This correction greatly improves the variance spectrum for dynamic pressure
 by giving a slope consistent with expectations for an inertial subrange.
 During this flight segment, other measurements (notably the vertical wind)
 indicate 
\begin_inset Formula $-5/3$
\end_inset

 slope, while the uncorrected measurement departs from that slope significantly
 for frequencies above about 4
\begin_inset space ~
\end_inset

Hz.
 Using this corrected dynamic pressure produces a longitudinal component
 of the wind having a spectrum consistent with the lateral components.
 The excess variance present at these frequencies therefore should also
 be removed from estimates of dynamic heating based on dynamic pressure,
 before the filtering to account for temperature-sensor response (Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand eqref
reference "subsec:A-filter-for"
plural "false"
caps "false"
noprefix "false"

\end_inset

) is applied, because the temperature sensor in a separate housing is not
 affected by the fluctuations that are removed.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
For routine processing, it would be useful to find an inverse filter that
 removes the effects of the two transfer functions.
 That appears to be beyond the appropriate scope of this paper.
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
As for dynamic heating, the appropriate correction also can be produced
 by a digital filter.
 This provides a particularly convenient approach to correction.
 There are two transfer functions involved, 
\begin_inset Formula $H_{t}(\nu)$
\end_inset

 describing the effect of resonance on the total pressure in the line from
 the pitot tube and 
\begin_inset Formula $H_{s}(\nu)$
\end_inset

 describing the corresponding effect on static pressure.
 The uncorrected dynamic pressure 
\begin_inset Formula $Q^{\dagger}$
\end_inset

 is related to the measured pressures (
\begin_inset Formula $p_{t}^{\dagger}$
\end_inset

 and 
\begin_inset Formula $p_{s}^{\dagger}$
\end_inset

) and to the true values (
\begin_inset Formula $p_{t}$
\end_inset

 and 
\begin_inset Formula $p_{s}$
\end_inset

) according to:
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\[
Q^{\dagger}=p_{t}^{\dagger}-p_{s}^{\dagger}=H_{t}p_{t}-H_{s}p_{s}
\]

\end_inset

or, if 
\begin_inset Formula $Q^{\prime}=p_{t}-p_{s}$
\end_inset

 is the corrected dynamic pressure, in terms of the frequency-domain transfer
 functions and Fourier transforms of the measurements,
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\hat{Q}^{\prime}(\nu)=\hat{p}_{t}(\nu)/H_{t}(\nu)-\hat{p}_{s}(\nu)/H_{s}(\nu)
\]

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Section
Reproducibility
\end_layout

\begin_layout Standard
\begin_inset Index idx
status open

\begin_layout Plain Layout
reproducibility
\end_layout

\end_inset

This document is constructed in ways that support duplication of the study.
 The code that generates the plots and implements the correction procedure
 is incorporated into the same 
\begin_inset Index idx
status open

\begin_layout Plain Layout
program!file
\end_layout

\end_inset

file that generated this document via 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
LaTeX
\end_layout

\end_inset

, using principles and techniques described by 
\begin_inset CommandInset citation
LatexCommand citet
key "Xie2014a"
literal "true"

\end_inset

 as implemented in the R 
\begin_inset Index idx
status open

\begin_layout Plain Layout
R language!package!knitr
\end_layout

\end_inset

package
\begin_inset Index idx
status open

\begin_layout Plain Layout
knitr
\end_layout

\end_inset

 'knitr' (
\begin_inset CommandInset citation
LatexCommand citet
key "Xie2014b"
literal "true"

\end_inset

).
 The program, 'SensibleHeatFluxPaper.Rnw', is archived on 'GitHub' 
\begin_inset Index idx
status open

\begin_layout Plain Layout
GitHub repository
\end_layout

\end_inset

in the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
repository!github
\end_layout

\end_inset

directory
\begin_inset Index idx
status open

\begin_layout Plain Layout
archive!for this document
\end_layout

\end_inset

 at 
\begin_inset CommandInset href
LatexCommand href
name "this URL"
target "https://github.com/WilliamCooper/KalmanFilter.git"
literal "false"

\end_inset

.
 There is some 
\begin_inset Index idx
status open

\begin_layout Plain Layout
supplemental material
\end_layout

\end_inset

supplemental material in that directory, including a workflow document
\begin_inset Index idx
status open

\begin_layout Plain Layout
workflow document
\end_layout

\end_inset

 for all the papers, the bibliography and some code segments saved in the
 
\begin_inset Quotes eld
\end_inset

chunks
\begin_inset Quotes erd
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
R language!program chunks
\end_layout

\end_inset

 subdirectory, so the full directory should be downloaded in order to run
 the program.
 The calculations use the programming 
\begin_inset Index idx
status open

\begin_layout Plain Layout
R language
\end_layout

\end_inset

language 
\begin_inset Index idx
status open

\begin_layout Plain Layout
R language!program
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
RStudio
\end_layout

\end_inset

R (
\begin_inset CommandInset citation
LatexCommand citet
key "Rlanguage"
literal "true"

\end_inset

) and were run within 
\begin_inset Index idx
status open

\begin_layout Plain Layout
RStudio
\end_layout

\end_inset

RStudio (
\begin_inset CommandInset citation
LatexCommand citet
key "RStudio2012"
literal "true"

\end_inset

), so this is the most straightforward way to replicate the calculations
 and the generation of this 
\begin_inset Index idx
status open

\begin_layout Plain Layout
program!generating this document
\end_layout

\end_inset

document.
\end_layout

\begin_layout Standard
A 
\begin_inset Index idx
status open

\begin_layout Plain Layout
R language!package!Ranadu
\end_layout

\end_inset

package named Ranadu,
\begin_inset Index idx
status open

\begin_layout Plain Layout
R language!package!Ranadu
\end_layout

\end_inset

 containing auxillary 
\begin_inset Index idx
status open

\begin_layout Plain Layout
function!Ranadu
\end_layout

\end_inset

functions, is used extensively in the R code.
 It is available on GitHub
\begin_inset Index idx
status open

\begin_layout Plain Layout
GitHub repository
\end_layout

\end_inset

 as 
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/WilliamCooper/Ranadu.git"
literal "false"

\end_inset

.
 The version used for calculations in this technical note is included in
 the 'zip' archive listed below.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The 
\begin_inset Index idx
status open

\begin_layout Plain Layout
file!data
\end_layout

\end_inset

data files used are also preserved in the NCAR/EOL Data Archives and can
 be obtained via a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
data!requesting
\end_layout

\end_inset

request to 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

mailto:raf-dm@eol.ucar.edu
\end_layout

\end_inset

 or via the 
\begin_inset Quotes eld
\end_inset

Data Access
\begin_inset Quotes erd
\end_inset

 links at 
\begin_inset CommandInset href
LatexCommand href
name "this web site"
target "https://www.eol.ucar.edu/all-field-projects-and-deployments"
literal "false"

\end_inset

.
 The original files containing the data as produced by the NCAR Earth Observing
 Laboratory, Research Aviation Facility, were in 
\begin_inset Index idx
status open

\begin_layout Plain Layout
netCDF format
\end_layout

\end_inset

netCDF format (cf.
\begin_inset space ~
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "this URL"
target "http://www.unidata.ucar.edu/software/netcdf/"
literal "false"

\end_inset

), but in many cases data archives were reprocessed and the files may change
 after reprocessing so a separate archive
\begin_inset Index idx
status open

\begin_layout Plain Layout
archive!for this document!data
\end_layout

\end_inset

 is maintained for this document.
 The data files
\begin_inset Index idx
status open

\begin_layout Plain Layout
file!data!archive
\end_layout

\end_inset

 in this archive contain 
\begin_inset Index idx
status open

\begin_layout Plain Layout
R language!data.frames
\end_layout

\end_inset

R data.frames and are preserved as binary-format 'Rdata' files via R 'save'
 commands.
 The code in the GitHub archive has appropriate 'load' commands to read
 these data files from a subdirectory named 'Data' (/Data or ~/Data or /home/Dat
a) but this is not part of the GitHub repository because it is too large
 to be appropriate there.
 To reproduce this research, those data files have to be transferred separately
 from {??where??}
\end_layout

\begin_layout Plain Layout
Extensive use has been made of 
\begin_inset Index idx
status open

\begin_layout Plain Layout
attributes!data.frame
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
attributes!variable
\end_layout

\end_inset

attributes assigned to the data.frames and the variables in those data.frames.
 All the attributes from the original netCDF 
\begin_inset Index idx
status open

\begin_layout Plain Layout
file!netCDF
\end_layout

\end_inset

files have been transferred to the data.frames, so there is a record of how
 the original data were processed, for example with 
\begin_inset Index idx
status open

\begin_layout Plain Layout
calibration!coefficients!used in processing
\end_layout

\end_inset

calibration coefficients and processing dependence for the variables.
 Key information like the processing date, the program version that produced
 the archive, and the selection of primary variables for various measurements
 thus is preserved.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
(See the related list of project components on the next page that are preserved
 to enhance reproducibility.)
\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Project:
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SensibleHeatFlux
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Archive package:
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "SensibleHeatFluxPaper.zip"
target "https://github.com/WilliamCooper/SensibleHeatFlux/blob/master/SensibleHeatFluxPaper.zip"
literal "false"

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Contains:
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
attachment list below
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Program:
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "SensibleHeatFluxPaper.Rnw"
target "https://github.com/WilliamCooper/SensibleHeatFlux/blob/master/SensibleHeatFluxPaper.Rnw"
literal "false"

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Original Data:
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset CommandInset citation
LatexCommand citet
key "VOCALS2011"
literal "false"

\end_inset

, 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset CommandInset citation
LatexCommand citet
key "CSET2017"
literal "false"

\end_inset

,
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
,
\begin_inset CommandInset citation
LatexCommand citet
key "SOCRATES2019"
literal "false"

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Special Data Files:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SensibleHeatFluxTechNote.Rdata, SensibleHeatFluxTechNote2.Rdata
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Workflow Document:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "WorkflowSensibleHeatFlux.pdf"
target "https://github.com/WilliamCooper/SensibleHeatFlux/blob/master/WorkflowSensibleHeatFlux.pdf"
literal "false"

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Git:
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Index idx
status open

\begin_layout Plain Layout
GitHub repository
\end_layout

\end_inset


\begin_inset CommandInset href
LatexCommand href
name "https://github.com/WilliamCooper/SensibleHeatFlux.git"
target "https://github.com/WilliamCooper/SensibleHeatFlux.git"
literal "false"

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
attachm{
\end_layout

\end_inset

SensibleHeatFluxPaper.Rnw
\begin_inset Newline newline
\end_inset

SensibleHeatFluxPaper.pdf
\begin_inset Newline newline
\end_inset

WorkflowSensibleHeatFlux.pdf
\begin_inset Newline newline
\end_inset

WAC.bib
\begin_inset Newline newline
\end_inset

chunks/*
\begin_inset Newline newline
\end_inset

*.Rdata
\begin_inset Newline newline
\end_inset

SessionInfo
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\begin_layout Plain Layout


\backslash
phantomsection 
\backslash
addcontentsline{toc}{section}{List of Symbols}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset index_print
LatexCommand printindex
type "lis"
name "List of Symbols"
literal "true"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\begin_layout Plain Layout


\backslash
phantomsection 
\backslash
addcontentsline{toc}{section}{Variable Names and Acronyms}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset index_print
LatexCommand printindex
type "var"
name "Variable Names and Acronyms"
literal "true"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Variable Names
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\begin_layout Plain Layout


\backslash
phantomsection 
\backslash
addcontentsline{toc}{section}{Index}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
** indicates that many similar entries are omitted.
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset index_print
LatexCommand printindex
type "idx"
name "Index"
literal "true"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\begin_layout Plain Layout

%
\backslash
phantomsection 
\backslash
addcontentsline{toc}{section}{References}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:bibliography"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "WAC"
options "bibtotoc,plainnat"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% 
\backslash
centerline{-- Blank Page, End of this Technical Report --}
\end_layout

\begin_layout Plain Layout

% 
\backslash
vfill
\backslash
eject
\end_layout

\begin_layout Plain Layout

% 
\backslash
clearpage
\end_layout

\begin_layout Plain Layout

%
\backslash
addcontentsline{toc}{section}{End}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<make-zip-archive, INCLUDE=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

system (sprintf("zip KalmanFilterTechNote.zip KalmanFilterTechNote.Rnw KalmanFilte
rTechNote.pdf WorkflowKalmanFilter.pdf WAC.bib ./chunks/* SessionInfo"))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@ 
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
