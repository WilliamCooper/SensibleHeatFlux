%% LyX 2.3.3 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[11pt,twoside,english,american,12pt,twoside,american]{article}
\renewcommand{\familydefault}{\rmdefault}
\usepackage[T1]{fontenc}
\usepackage[letterpaper]{geometry}
\geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1.2in,rmargin=1in}
\usepackage{fancyhdr}
\pagestyle{fancy}
\setcounter{tocdepth}{2}
\setlength{\parskip}{\medskipamount}
\setlength{\parindent}{0pt}
\usepackage{color}
\definecolor{page_backgroundcolor}{rgb}{1, 1, 1}
\pagecolor{page_backgroundcolor}
\usepackage{babel}
\usepackage{url}
\usepackage{amsmath}
\usepackage{esint}
\usepackage[authoryear]{natbib}
\usepackage[unicode=true,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=true,pdfborder={0 0 0},pdfborderstyle={},backref=section,colorlinks=true]
 {hyperref}
\hypersetup{pdftitle={Technical Note: Measuring Sensible-Heat Flux},
 pdfauthor={William A. Cooper},
 pdfsubject={Assessment of Measurements of Sensible-Heat Flux},
 pdfkeywords={sensible heat flux, temperature, time response of sensors, NCAR Research Aviation Facility, research aircraft, NCAR/EOL/RAF},
  linkcolor=blue, citecolor={blue}}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
%% Because html converters don't know tabularnewline
\providecommand{\tabularnewline}{\\}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
\newenvironment{lyxcode}
	{\par\begin{list}{}{
		\setlength{\rightmargin}{\leftmargin}
		\setlength{\listparindent}{0pt}% needed for AMS classes
		\raggedright
		\setlength{\itemsep}{0pt}
		\setlength{\parsep}{0pt}
		\normalfont\ttfamily}%
	 \item[]}
	{\end{list}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\definecolor{fgcolor}{rgb}{0.345, 0.345, 0.345}\definecolor{messagecolor}{rgb}{0, 0, 0}\definecolor{warningcolor}{rgb}{1, 0, 1}\definecolor{errorcolor}{rgb}{1, 0, 0}\setlength{\headheight}{14.5pt}\usepackage{babel}


\definecolor{fgcolor}{rgb}{0.345, 0.345, 0.345}\definecolor{messagecolor}{rgb}{0, 0, 0}\definecolor{warningcolor}{rgb}{1, 0, 1}\definecolor{errorcolor}{rgb}{1, 0, 0}\usepackage{babel}
% macro for italic page numbers in the index
\newcommand{\IndexDef}[1]{\textit{#1}}
\newcommand{\IndexPrimary}[1]{\textbf{#1}}
% force a page break at the start of sections
\let\stdsection\section
\renewcommand{\section}{\newpage\stdsection}


% workaround for a makeindex bug,
% see sec. "Index Entry Order"
% only uncomment this when you are using makindex
%\let\OrgIndex\index 
%\renewcommand*{\index}[1]{\OrgIndex{#1}}
%\usepackage{splitidx}

% workaround for a makeindex bug,
% see sec. "Index Entry Order"
% only uncomment this when you are using makindex
\let\OrgIndex\index 
\renewcommand*{\index}[1]{\OrgIndex{#1}}
\usepackage{splitidx}
%\indexsetup{noclearpage}
\AtBeginDocument{
  \def\labelitemii{\(\circ\)}
  \def\labelitemiii{\(\triangleright\)}
}
\usepackage[font={normal,sl}]{caption}% set captions slanted

\IfFileExists{upquote.sty}{\usepackage{upquote}}{}

\newenvironment{lylist}[1]{\begin{list}{}
{\settowidth{\labelwidth}{#1}
\setlength{\leftmargin}{\labelwidth}
\addtolength{\leftmargin}{\labelsep}
\renewcommand{\makelabel}[1]{##1\hfil}}}{\end{list}}
\newcommand{\datetoday}{\number\day\space
     \ifcase\month\or January\or February\or March\or April\or May\or
     June\or July\or August\or September\or October\or November\or
     December\fi
     \space\number\year}
\newcommand{\EOLmemo}{\null \vskip-1.5truein
{\raggedright \textsf{\textsc{\large \textcolor{blue}{Earth Observing Laboratory}}}}\par
{\raggedright \textsf{\textsl{\textcolor{blue}{Memorandum:}}}} \par \vskip6pt
{\color{blue}{\hrule}}\par
\vskip0.3truein \leftline{\hskip \longindent \datetoday} \vskip0.2truein
\thispagestyle{empty}}
\newcommand{\attachm}[1]{\begin{lylist}{Attachments:00}
\item [Attachments:] {#1}
\end{lylist}}
\newcommand{\cc}[1]{\begin{lylist}{Attachments:00}
\item [cc:] {#1}
\end{lylist}}
\newcommand{\attach}[1]{\begin{lylist}{Attachments:00}
\item [Attachment:] {#1}
\end{lylist}}

\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\pagenumbering{gobble}

\makeatother

\begin{document}
\title{The Delayed Response of Airborne Thermometers:\\
Part 2: Correcting for Dynamic Heating }
\author{William A. Cooper and others...}
\date{\textcolor{red}{DRAFT} March 2020}

\maketitle
National Center for Atmospheric Research\\
Earth Observing Laboratory\\
Research Aviation Facility

\vfill{}
\cleardoublepage{} \pagenumbering{roman}

\renewcommand{\contentsname}{Table of Contents} \tableofcontents{}
\vfill{}
\eject

%% LyX 2.2.2 created this file.  For more info, see http://www.lyx.org/.

%\phantomsection \addcontentsline{toc}{section}{List of Figures}

\listoffigures

\clearpage %\phantomsection \addcontentsline{toc}{section}{List of Tables}

\listoftables

\clearpage{}

\renewcommand{\abstractname}{Preface and Abstract}\thispagestyle{plain}\begin{abstract}

In Part 1, the time response of some standard airborne thermometers
was determined by observing the response to turbulent dynamic heating.
For some standard airborne thermometers, the transfer function characterizing
this time response was parameterized in terms of assumed differential
equations or more generally via fitted expressions. In this paper,
the consequences for how dynamic heating is treated are discussed.
The standard processing approach used with most airborne measurement
platforms is to determine the ambient or air temperature by subtracting
a dynamic-heating correction from the measured recovery temperature.
When the sensor cannot respond to fluctuations in dynamic heating,
this procedure introduces errors and excess noise into the resulting
air temperature. A modified correction procedure is proposed here
that instead corrects for dynamic heating only after filtering to
match the response of the temperature sensors. The filter used for
this processing step is obtained from the transfer functions determined
in Part 1. This has a beneficial effect on the variance spectra of
temperature measurements.

\end{abstract}

\clearpage{}

\section*{Acknowledgments}

\label{sec:acknowledgements}

This material is based upon work supported by the National Center
for Atmospheric Research, which is a major facility sponsored by the
National Science Foundation under Cooperative Agreement No. 1852977.
Any opinions, findings and conclusions or recom-mendations expressed
in this publication are those of the author(s) and do not necessarily
reflect the views of the National Science Foundation. The data used
in the examples presented are from the VOCALS (VAMOS Ocean-Cloud-Atmosphere-Land
Study), SOCRATES (Southern Ocean Clouds, Radiation, Aerosol Transport
Experimental Study) and the CSET (Cloud Systems Evolution in the Trades)
experiment, each described at \href{https://www.eol.ucar.edu/field_projects/}{this URL}.
Citations for the data sets are included in the references. Measurements
(\citet{VOCALS2011}, \citet{SOCRATES2019}, \citet{WECAN2018}) were
collected by the project experiment teams, and flight operations and
data acquisition and processing were performed by the Research Aviation
Facility, Earth Observing Laboratory, National Center for Atmospheric
Research (NCAR). The analyses reported here were mostly performed
using R (\citet{Rlanguage}), with \index{RStudio}RStudio (\citet{RStudio2012})
and \index{knitr}knitr (\citet{Xie2014a,Xie2014b}). Data files in
netCDF format have been read and written using the R \index{R language!package!ncdf4}package
``ncdf4''; cf.~\citet{ncdf4}. Substantial use also was made of
the \index{ggplot2}\index{R language!package!ggplot2}``ggplot2''
package (\citet{wickham2009}) for R, and some fits relied on the
``nleqslv'' package for R \citet{hasselman-nleqslv}. Extensive
use was made of the ``stats'' package, part of Core R\@. Some of
the numerical integrations used the Runge-Kutta function from the
``rmutil'' package (\citet{runge.kutta}).

\thispagestyle{plain}\clearpage{}

\thispagestyle{empty}

\cleardoublepage{}

\pagenumbering{arabic}

\section{Introduction}

\subsection{Overview}

This series of papers was introduced in Part 1, where it was indicated
that the overarching goal of these papers is to improve capabilities
to measure sensible-heat flux from research aircraft. Toward that
goal, Part 1 characterized the measured quantity, the ``recovery
temperature,'' using a parameterized transfer function. That paper
did not discuss the implications for the final measurement of ambient
or air temperature, which requires a correction for the dynamic heating
of the sensor. This second paper in the series treats that correction.
It might seem that this is minor and could be incorporated into other
parts, but the claim here is that this correction as applied by essentially
all operators of research aircraft introduces errors and noise into
the measurement that should be eliminated. Making this point therefore
seems worth a separate discussion. Part 1 and this paper will establish
the foundation for Part 3, where measuring the flux of sensible heat
is discussed and the corrections developed in the first two parts
are applied.

<<initialization, echo=FALSE,include=FALSE>>=
## This chunk loads some needed R packages and defines a function
## used for the Laplace-transform solution of the governing
## differential equations.

library(knitr)
opts_chunk$set(echo = FALSE,
               include = FALSE,
               fig.lp = "fig:")
# note that fig.pos="center" gave errors, changed to fig.align
opts_chunk$set(
  fig.width = 6,
  fig.height = 3.5,
  fig.align = "center",
  digits = 4
)
thisFileName <- "SensibleHeatFluxTechNote"
library(Ranadu, quietly = TRUE, warn.conflicts = FALSE)
library(scales)
require(numDeriv)    ## is this used?
library(signal)      ## used for filtering
library(reshape2)    ## used with ggplot facet plots
library(grid)
library(magrittr)    ## used for pipes (%>%)
library(dplyr)
library(nleqslv)
library(rmutil)      ## provides the runge-kutta integration function
options(stringsAsFactors = FALSE)

CACHE <- FALSE
setwd ('~/RStudio/SensibleHeatFlux') 
Directory <- DataDirectory ()
## standard values:
frq <- seq(0.01, 25, by = 0.01)
Phi <- rep(0, length(frq))
H <- rep(0, length(frq))
a <- 0.733 # 0.713
tau1 <- 0.0308  # 0.0335
tau2 <- 0.447
# The Laplace-transform solution:
LTphase <- function(f, P) {
  ## f=frequency; P=Param
  tau1 <- P$tau1
  tau2 <- P$tau2
  a <- P$a
  b <- sqrt(1 / (1 + (2 * pi * f * tau2) ^ 2))
  zeta <- -atan(2 * pi * f * tau2)
  C1 <- 1 / (1 + 4 * pi ^ 2 * f ^ 2 * tau1 ^ 2) *
    (-(a + (1 - a) * b * cos(zeta)) * 2 * pi * f * tau1 +
       (1 - a) * b * sin(zeta))
  C2 <- 1 / (1 + 4 * pi ^ 2 * f ^ 2 * tau1 ^ 2) *
    ((a + (1 - a) * b * cos(zeta)) +
       (1 - a) * b * sin(zeta) * 2 * pi * f * tau1)
  cTF <- sqrt(C1 ^ 2 + C2 ^ 2)
  phiTF <- atan2(C1, C2) * 180 / pi
  return(list('Amp' = cTF, 'Phase' = phiTF))
}
reviseDH <-
  function (.data, P, alphaR) {
    # P is Param1, e.g.; alphaR is recovery factor
    .data$Q <- .data$TASX ^ 2 / 2010
    aV <- P$a
    tau1V <- P$tau1
    tau2V <- P$tau2
    Rate <- attr (.data, 'Rate')
    fS <- function(y, i) {
      (.data$Q[i] - y) / (tau2V * Rate)
    }
    fM <- function (y, i) {
      (aV * .data$Q[i] + (1 - aV) * TsQ[i] - y) / (Rate * tau1V)
    }
    TsQ <- rk4.integrate (fS, .data$Q[1], 1:nrow(.data))
    Qp <- rk4.integrate (fM, .data$Q[1], 1:nrow(.data))
    return (.data$ATX + alphaR * (.data$Q - Qp))
  }
## This is a special version with features not in the standard Ranadu version
CohP <-
  function (.data,
            .Var1,
            .Var2,
            col = 'blue',
            spans = 25,
            smoothBins = 50,
            plotType = 'ggplot',
            showErrors = 0,
            returnCospectrum = FALSE) {
    if (is.data.frame(.data)) {
      if (.Var1 %in% names(.data)) {
        Z <-
          capture.output (Vr <-
                            SmoothInterp(detrend (.data[, c('Time', .Var1)]), .Length = 0))
      } else {
        print(sprintf(
          'CohPhase ERROR: Variable %s is not in the supplied data.frame',
          .Var1
        ))
        return (NA)
      }
      if (.Var2 %in% names(.data)) {
        Z <-
          capture.output (VrC <-
                            SmoothInterp(detrend (.data[, c('Time', .Var2)]), .Length = 0))
      } else {
        print(sprintf(
          'CohPhase ERROR: Variable %s is not in the supplied data.frame',
          .Var2
        ))
        return (NA)
      }
    } else {
      print('CohPhase ERROR: first argument is not a data.frame.')
      return (NA)
    }
    if (is.null(attr(.data, 'Rate'))) {
      print ('CohPhase warning: Rate attribute missing from data.frame, so using Rate=1')
      Rate <- 1
    } else {
      Rate <- attr(.data, 'Rate')
    }
    vcv <- cbind(ts(Vr, frequency = Rate), ts(VrC, frequency = Rate))
    P <-
      spec.pgram(
        vcv,
        detrend = FALSE,
        fast = TRUE,
        plot = FALSE,
        spans = spans
      )
    df1 <- data.frame(P$coh, log(P$freq))
    df2 <- data.frame (P$phase, log(P$freq))
    df3 <- data.frame (P$spec[, 1], log(P$freq))
    df4 <- data.frame (P$spec[, 2], log(P$freq))
    pf1 <- binStats (df1, bins = smoothBins)
    pf2 <- binStats (df2, bins = smoothBins)
    pf3 <- binStats (df3, bins = smoothBins)
    pf4 <- binStats (df4, bins = smoothBins)
    pf1 <- pf1[!is.na (pf1$ybar),]
    pf2 <- pf2[!is.na (pf2$ybar),]
    pf3 <- pf3[!is.na (pf3$ybar),]
    pf4 <- pf4[!is.na (pf4$ybar),]
    # pf1$sigma[pf1$nb > 1] <- pf1$sigma[pf1$nb > 1] / sqrt(pf1$nb[pf1$nb > 2])
    pf1$sigma[pf1$nb <= 1] <- NA # pf1$ybar[pf1$nb <= 1] * 0.5
    # pf2$sigma[pf2$nb > 1] <- pf2$sigma[pf2$nb > 1] / sqrt(pf2$nb[pf2$nb > 2])
    pf2$sigma[pf2$nb <= 1] <- NA # pf2$ybar[pf2$nb <= 1] * 0.5is
    if (plotType != 'ggplot') {
      pf1 <- binStats (df1, bins = smoothBins, addBin = TRUE)
      pf2 <- binStats (df2, bins = smoothBins, addBin = TRUE)
      pf3 <- binStats (df3, bins = smoothBins, addBin = TRUE)
      pf4 <- binStats (df4, bins = smoothBins, addBin = TRUE)
      return(cbind(pf1, pf2, pf3, pf4)[, c(2, 1, 3, 4, 6, 7, 10)])
    } else {
      d2 <-
        data.frame(
          Time = exp(pf1$xc),
          coherence = pf1$ybar,
          phase = pf2$ybar * 180 / pi,
          clo = (pf1$ybar - showErrors * pf1$sigma),
          chi = pf1$ybar + showErrors * pf1$sigma,
          plo = (pf2$ybar - showErrors * pf2$sigma) * 180 / pi,
          phi = (pf2$ybar + showErrors * pf2$sigma) * 180 / pi
        )
      d2$clo[!is.na(d2$clo) & (d2$clo < 0)] <- 0
      labelP <- c('coherence', 'phase [degrees]')
      g <- ggplotWAC(
        d2[, c(1, 2, 3)],
        panels = 2,
        labelP = labelP,
        col = col,
        lwd = c(1.0),
        lty = c(1),
        xlab = 'freq'
      )
      g <-
        g + xlab('frequency [Hz]') + ylab (sprintf ('%s x %s', .Var1, .Var2))
      g <-
        g + scale_x_log10(
          breaks = trans_breaks("log10", function(x)
            10 ^ x, n = 4),
          labels = trans_format("log10", math_format(expr = 10 ^ .x))
        ) + xlab('frequency [Hz]')
      if (showErrors > 0 && smoothBins > 5) {
        da <- data.frame(d2[, c(1, 4, 5)])
        db <- data.frame(d2[, c(1, 6, 7)])
        names(da) <- c('Time', 'ymin', 'ymax')
        names(db) <- c('Time', 'ymin', 'ymax')
        da$PanelGroup <- labelP[1]
        db$PanelGroup <- labelP[2]
        d <- rbind(db, da)
        g <-
          g + geom_ribbon(
            data = d,
            aes(
              x = Time,
              ymin = ymin,
              ymax = ymax
            ),
            colour = 'grey',
            alpha = 0.15,
            inherit.aes = FALSE
          )
      }
      g <- g + theme_WAC(1) + theme(legend.position = 'none')
      if (returnCospectrum) {
        CS <-
          sqrt(P$coh[, 1] * P$spec[, 1] * P$spec[, 2] / (1 + tan(P$phase[, 1]) ^
                                                           2))
        v1 <- SmoothInterp(.data[, .Var1], .Length = 0)
        v2 <- SmoothInterp(.data[, .Var2], .Length = 0)
        v1 <- detrend(data.frame(Time = .data$Time, v1))
        v2 <- detrend(data.frame(Time = .data$Time, v2))
        ff1 <- fft(v1)
        ff2 <- fft(v2)
        G <- Re(ff1 * Conj(ff2)) / nrow(.data)
        GQ <- Im(ff1 * Conj(ff2)) / nrow(.data)
        N <- nrow(.data) %/% 2
        S1 <- Re(ff1 * Conj(ff1) / nrow(.data))
        S2 <- Re(ff2 * Conj(ff2) / nrow(.data))
        G <- G[2:(N + 1)]
        GQ <- GQ[2:(N + 1)]
        S1 <- S1[2:(N + 1)]
        S2 <- S2[2:(N + 1)]
        frq <- c(1:N) * Rate / nrow(.data)
        spec1 <- 2 * S1 / Rate
        spec2 <- 2 * S2 / Rate
        cospec <- 2 * G / Rate
        quad <- 2 * GQ / Rate
        # cospectrum - i * quadrature = (gain spectrum) * exp(i*(phase spectrum))
        # sqrt(cospectrum^2 + quadrature^2) is the amplitude or gain spectrum
        return(data.frame(
          freq = frq,
          cospec = cospec,
          quad = quad,
          spec1 = spec1,
          spec2 = spec2
        ))
      } else {
        return(g)
      }
    }
  }
a <- 0.733 # 0.713
tau1 <- 0.0308  # 0.0335
tau2 <- 0.447
Param <- list(
  a = a,
  tau1 = tau1,
  tau2 = tau2
)
Param1 <- Param
ParamSH <- Param
ParamSH$a <- 0
ParamSH$tau1 <- 0.05681167 
ParamSH$tau2 <- 1.25078040
ParamSF <- Param
ParamSF$a <- 0.652
ParamSF$tau1 <- 0.0295
ParamSF$tau2 <- 1.04
source('./chunks/rk4.integrate.R')

@

\section{The Dynamic-Heating Correction\label{sec:Revised-Treatment-of}}

The dynamic-heating term is discussed for example by \citet{BangeEtAl2013.ch2}
(cf.~their Eq.~2.23) and also in the working document describing
processing algorithms in use at the Research Aviation Facility, NCAR:
``\href{https://github.com/NCAR/aircraft_ProcessingAlgorithms/blob/master/ProcessingAlgorithms.pdf}{RAF Technical Report: Processing Algorithms}''.
These sources express the dynamic-heating term $Q$ as\\
\begin{equation}
Q=\alpha_{r}\frac{V^{2}}{2C_{p}}=T_{r}\left(\frac{\alpha_{r}M^{2}R_{a}/(2C_{v})}{1+\alpha_{r}M^{2}R_{a}/(2C_{v})}\right)\label{eq:DHterm-1}
\end{equation}
where $\alpha_{r}$ is the ``recovery factor'' characterizing the
extent to which the air is brought to rest relative to the sensor,
$V$ is the airspeed, $C_{p}$ and $C_{v}$ are respectively the specific
heat of air at constant pressure and constant volume, $T_{r}$ is
the (true) recovery temperature expressed in absolute units, $M$
the Mach number, and $R_{a}$ the gas constant for air. The recovery
factor is close to unity for the sensors discussed in this report.
The dynamic-heating term can exceed $20^{\circ}\mathrm{C}$ at NCAR/NSF
GV flight speeds, so the correction is large and fluctuations in this
term are often the dominant source of variability in the recovery
temperature. The recovery temperature is related to the air or ambient
temperature $T_{a}$ via\\
\begin{equation}
T_{r}=T_{a}+Q\label{eq:recoveryTemperature-1}
\end{equation}


\subsection{Errors conventionally introduced}

Normal data processing subtracts the dynamic-heating term $Q$ from
the measured recovery temperature to estimate the actual air temperature.
However, the dynamic-heating term often varies rapidly in a turbulent
wind field and produces rapid changes in the true recovery temperature
to which the temperature sensor may not respond. In that case, applying
the standard dynamic-heating correction introduces erroneous fluctuations
in the estimated ambient temperature.

\selectlanguage{english}%
<<S15, include=TRUE, fig.cap='The variance spectrum for the recovery temperature (RTF1, blue line) measured by a Rosemount 102E4AL sensor during a flight segment from the SOCRATES project, flight 15, 6:00:00 -- 6:15:00 UTC. The variance spectra for the dynamic-heating term (Q) and for the calculated air temperature after this correction is applied (ATF1) are also shown.'>>=

DS <-
  getNetCDF('/Data/SOCRATES/SOCRATESrf15h.nc',
            standardVariables(c('ATF1', 'UXC')),
            60000,
            61500)
rf.txt <- attr(DS$ATF1, 'RecoveryFactor')
rf <- gsub('mach', 'MACHX', rf.txt)
rf <- gsub(' log', ' * log', rf)
rf <- gsub(' \\(', ' * \\(', rf)
rf <- with(DS, eval(parse(text=rf)))
rf <- SmoothInterp(rf, .Length = 0)
## RTF1 is not in the netCDF file so recalculate it:
DS$RTF1 <- DS$ATF1 + rf * DS$TASX^2 / 2010
DS$TASX <- SmoothInterp(DS$TASX, .Length = 0)
DS$Q <- rf * DS$TASX ^ 2 / 2010
DS$ATX <- DS$ATF1  ## Replace ATX, based on ATH1 in netCDF file
DS$AT <- reviseDH(DS, Param1, rf)
DS$AT <- SmoothInterp(DS$AT, .Length = 0)
g <-
  VSpec(
    DS,
    'RTF1',
    spans = 99,
    xlim = c(0.01, 15),
    ylim = c(1.e-5, 1.e-1)
  )
g <- VSpec(DS, 'ATF1', spans = 99, add = g)
VSpec(DS, 'Q', spans = 99, add = g) + theme_WAC(1)

@

\selectlanguage{american}%
Figure~\ref{fig:S15} illustrates the problem. The measurements are
from a region reasonably consistent with an inertial sub-range, where
the slope of the temperature variance spectrum would be expected to
be -5/3 (or -2/3 in this plot where the spectrum is weighted by the
frequency). The measured spectrum (RTF1) has a steeper slope than
this but that would be expected if the time response attenuates the
signal at higher frequencies. However, the variance spectrum for the
estimated ambient temperature (ATF1) appears to have a substantial
amount of high-frequency contamination. This matches well the spectrum
for dynamic heating, but if the sensor worked correctly the recovery-temperature
spectrum should exceed that of the ambient temperature, as is the
case around 0.1 to 0.5~Hz, so that the subtraction of dynamic heating
would produce smaller variance in the measured ambient temperature. 

Data processing should instead remove an estimate of how dynamic heating
affects the sensor. The approach followed in this paper is therefore
to use the transfer function determined in Part 1 (e.g., Fig.~1 in
that paper) to characterize the response to dynamic heating so that
only that response can be subtracted from the measurement. This is
made possible by the assumed linearity in response of the sensor,
which is required if this part of the response is to be separated
from the more general response to the combination of dynamic heating
and true fluctuations in temperature. 

The revised dynamic-heating adjustment will be labeled $Q^{\prime}$
to distinguish it from the standard adjustment $Q$, and the ambient
temperature $T_{a}$ should be estimated from this equation:\\
\begin{equation}
T_{a}(t)=T_{m}(t)-Q^{\prime}(t)\label{eq:QprimeCorr}
\end{equation}
instead of \eqref{eq:recoveryTemperature-1}. The equation depends
on the actual measured (recovery) temperature $T_{m}(t)$, rather
than the true recovery temperature $T_{r}(t)$ in \eqref{eq:recoveryTemperature-1},
to emphasize that the measurement is affected by the time-response
of the sensor and therefore differs from the true recovery temperature.

This revised adjustment can be obtained by using a numerical solution
to the differential equations in Part 1, using only $Q(t)$ as the
input term. However, for the high-frequency components numerical integration
must be done with considerable attention to accuracy, especially for
the unheated Rosemount sensor because its characteristic time constant
for the wire response ($\tau_{1}$) is smaller than the time interval
between typically used 25-Hz samples. For this reason, it is preferable
to develop an appropriate digital filter having response that matches
the transfer function. This also leads to much faster processing. 

\subsection{A filter for dynamic heating\label{subsec:A-filter-for}}

With the transfer function $H(\omega)$ as determined in Part 1, the
impulse response of the sensor can be found from the inverse Fourier
transform of that transfer function. Once that is determined, appropriate
moving-average coefficients can be found from the impulse response,
and those coefficients define a digital filter that represents the
sensor response. The procedure used here is somewhat arbitrary, and
no claim is made that this is the best filter, but it functions reasonably
for 25~Hz measurements. Details including the filter coefficients
are provided in Appendix A, and the development of the filter is described
in detail in the ``Workflow'' document (cf.~Appendix B) that accompanies
this paper.

<<designFilter, include=FALSE>>=

P <- Param1
NP <- 15000  ## Assume 10-min segment
df <- 25 / NP
df1 <- 1 / NP
frq <- c(seq(0, 12.5, by=df), seq(-12.5+df, -df, by=df))
frq1 <- c(seq(0, 0.5, by = df1), seq(-0.5+df1, -df1, by = df1))
NP <- length(frq)
NP1 <- length(frq1)
E <- LTphase(frq, P)
EH <- LTphase(frq, ParamSH)
EHB <- LTphase(frq, ParamSH)
EG <- LTphase(frq, ParamSF)
E1 <- LTphase(frq1, P)
EH1 <- LTphase(frq1, ParamSH)
EHB1 <- LTphase(frq1, ParamSH)
EG1 <- LTphase(frq1, ParamSF)
## --------------------------
G <- complex(modulus=E$Amp, argument=E$Phase * pi / 180)
NG <- length(G)
GT <- fft(G, inverse=TRUE) / NG  # get the impulse function
## Limit to 200 coefficients (8 s at 25 Hz)
Lshift <- 100
GT[(Lshift + 2):(NP - Lshift)] <- complex(modulus=0)
GTT <- GT[GT != complex(modulus=0)]
## Reorder:
GTT <- c(GTT[(Lshift + 2):length(GTT)], GTT[1:(Lshift + 1)])
AR <- Arma(Re(GTT) / sum(Re(GTT)), 1) # Normalize to avoid <1% bias
## --------------------------
GG <- complex(modulus=EG$Amp, argument=EG$Phase * pi / 180)
GTG <- fft(GG, inverse=TRUE) / NG  # get the impulse function
GTG[(Lshift + 2):(NP - Lshift)] <- complex(modulus=0)
GTTG <- GTG[GTG != complex(modulus=0)]
## Reorder:
GTTG <- c(GTTG[(Lshift + 2):length(GTTG)], GTTG[1:(Lshift + 1)])
ARG <- Arma(Re(GTTG) / sum(Re(GTTG)), 1) # Normalize to avoid <1% bias
## --------------------------
GH <- complex(modulus=EH$Amp, argument=EH$Phase * pi / 180)
NG <- length(GH)
GTH <- fft(GH, inverse=TRUE) / NG  # get the impulse function
## Limit to 300 coefficients (12 s at 25 Hz)
LshiftH <- 150
GTH[(LshiftH + 2):(NP - LshiftH)] <- complex(modulus=0)
GTTH <- GTH[GTH != complex(modulus=0)]
## Reorder:
GTTH <- c(GTTH[(LshiftH + 2):length(GTTH)], GTTH[1:(LshiftH + 1)])
ARH <- Arma(Re(GTTH) / sum(Re(GTTH)), 1)
## --------------------------
GHB <- complex(modulus=EHB$Amp, argument=EHB$Phase * pi / 180)
NG <- length(GHB)
GTHB <- fft(GHB, inverse=TRUE) / NG  # get the impulse function
## Limit to 300 coefficients (12 s at 25 Hz)
LshiftH <- 150
GTHB[(LshiftH + 2):(NP - LshiftH)] <- complex(modulus=0)
GTTHB <- GTHB[GTHB != complex(modulus=0)]
## Reorder:
GTTHB <- c(GTTHB[(LshiftH + 2):length(GTTHB)], GTTHB[1:(LshiftH + 1)])
ARHB <- Arma(Re(GTTHB) / sum(Re(GTTHB)), 1)
## --------------------------
G1 <- complex(modulus=E1$Amp, argument=E1$Phase * pi / 180)
NG1 <- length(G1)
GT1 <- fft(G1, inverse=TRUE) / NG1  # get the impulse function
## Limit to 20 coefficients (20 s at 1 Hz)
Lshift1 <- 10
GT1[(Lshift1 + 2):(NP1 - Lshift1)] <- complex(modulus=0)
GTT1 <- GT1[GT1 != complex(modulus=0)]
## Reorder:
GTT1 <- c(GTT1[(Lshift1 + 2):length(GTT1)], GTT1[1:(Lshift1 + 1)])
AR1 <- Arma(Re(GTT1) / sum(Re(GTT1)), 1)
## --------------------------
GH1 <- complex(modulus=EH1$Amp, argument=EH1$Phase * pi / 180)
NG1 <- length(GH1)
GTH1 <- fft(GH1, inverse=TRUE) / NG1  # get the impulse function
LshiftH1 <- 10
GTH1[(LshiftH1 + 2):(NP1 - LshiftH1)] <- complex(modulus=0)
GTTH1 <- GTH1[GTH1 != complex(modulus=0)]
GTTH1 <- c(GTTH1[(LshiftH1 + 2):length(GTTH1)], GTTH1[1:(LshiftH1 + 1)])
ARH1 <- Arma(Re(GTTH1) / sum(Re(GTTH1)), 1)
## --------------------------
GHB1 <- complex(modulus=EHB1$Amp, argument=EHB1$Phase * pi / 180)
NG1 <- length(GHB1)
GTHB1 <- fft(GHB1, inverse=TRUE) / NG1  # get the impulse function
LshiftH1 <- 10
GTHB1[(LshiftH1 + 2):(NP1 - LshiftH1)] <- complex(modulus=0)
GTTHB1 <- GTHB1[GTHB1 != complex(modulus=0)]
GTTHB1 <- c(GTTHB1[(LshiftH1 + 2):length(GTTHB1)], GTTHB1[1:(LshiftH1 + 1)])
ARHB1 <- Arma(Re(GTTHB1) / sum(Re(GTTHB1)), 1)
## --------------------------
GG1 <- complex(modulus=EG1$Amp, argument=EG1$Phase * pi / 180)
NG1 <- length(GG1)
GTG1 <- fft(GG1, inverse=TRUE) / NG1  # get the impulse function
LshiftH1 <- 10
GTG1[(LshiftH1 + 2):(NP1 - LshiftH1)] <- complex(modulus=0)
GTTG1 <- GTG1[GTG1 != complex(modulus=0)]
GTTG1 <- c(GTTG1[(LshiftH1 + 2):length(GTTG1)], GTTG1[1:(LshiftH1 + 1)])
ARG1 <- Arma(Re(GTTG1) / sum(Re(GTTG1)), 1)
save(AR, ARH, ARHB, ARG, AR1, ARH1, ARHB1, ARG1, Lshift, LshiftH, Lshift1, LshiftH1,
     file='AR.Rdata')
## --------------------------
# DF2$QF <- as.vector(signal::filter(AR, DF2$Q))
# DF2$QF <- ShiftInTime(DF2$QF, .shift=(-(Lshift + 1) * 40), .rate = 25)

@

<<plotImpulse, include=TRUE, fig.height=4.5, fig.cap=c('(a) The impulse response function found from the inverse Fourier transform of the transfer function for the unheated Rosemount 102E4AL sensor (Rosemount) and for the heated HARCO sensor (HARCO), using the response parameters from Table 2 of Part 1. The impulse response for the HARCO sensor is multiplied by 10. (b) A filter function (moving-average coefficients spanning 8 s) obtained from the impulse response function. The filtered result must be shifted forward in time by 4 s to compensate for the delay introduced by the filter. The coefficients are multiplied by 10 for the HARCO sensor.')>>=

layout(matrix(1:2, ncol=1), widths=c(8,8), heights=c(6.5,8))
op <- par (mar=c(2,4,1,1)+0.1, oma=c(1.1,0,0,0))
dP1 <- data.frame(Time = (1 : 100) * 0.04, R = Re(GT[1:100]), 
                 H = 10*Re(GTH[1:100]))
plotWAC(dP1, xlab='Time [s]', ylab='impulse response', lwd = c(2, 2), 
        lty = c(1, 2), legend.position = NA)
legend(2, 0.3, legend=c('Rosemount', 'HARCO x 10'), 
       col=c('blue', 'forestgreen'), lwd=c(2,2), lty=c(1,2))
abline(h=0, lty=2) 
text(4, 0.3, labels='(a)', cex=1.5)
op <- par (mar=c(5,4,1,1)+0.1)
dP2 <- data.frame(Time = (0 : 200) * 0.04, R = Re(GTT), 
                 H = 10 * Re(GTTH[51 :251]))
plotWAC(dP2, xlab='Time [s]', ylab='filter coef.', lwd = c(2, 2), 
        lty = c(1, 2), legend.position = NA)
legend(0.5, 0.3, legend=c('Rosemount', 'HARCO x 10'), 
       col=c('blue', 'forestgreen'), lwd=c(2,2), lty=c(1,2))
abline(h=0, lty=2)
text(8, 0.3, labels='(b)', cex=1.5)
layout(matrix(1:1, ncol=1), widths=c(8), heights=c(5.5))

@

Figure \ref{fig:plotImpulse}a shows the impulse function for the
unheated Rosemount and heated HARCO sensors, and Fig.~\ref{fig:plotImpulse}b
shows corresponding moving-average coefficients for a filter obtained
from this impulse function. There is significant ringing in the filter
for the Rosemount sensor because the shorter time constant for the
sensor, 0.03~s, is smaller than the time between 25-Hz samples. The
impulse response for the slower HARCO sensor leads to a much broader
impulse response function. Both sets of moving-average coefficients
sum to more than 0.99 as calculated but were then normalized to sum
to 1.0.

\subsection{Integration, Fourier transformation, and filtering}

<<Integration, include=TRUE, echo=FALSE, fig.pos='t', fig.cap='Variance spectra for the dynamic-heating term (Q) and for the filtered term obtained by integrating the differential equations for the derivatives (Qp), by Fourier transformation with application of the transfer function (Qft), or applying the digital filter (QF). The result for the latter is so close to Qft that it is obscured in this plot. Data from SOCRATES flight 15, 6:02:00 to 6:13:00 UTC.'>>=

# DS is the data.frame, which includes Q
a <- ParamSF$a
tau1 <- ParamSF$tau1
tau2 <- ParamSF$tau2
DS$RT <- DS$RTF1
DS$TsQ <- DS$RT
DS$Qp <- DS$Q
Rate <- attr (DS, 'Rate')
fS <- function(y, i) {
  (DS$Q[i] - y) / (Rate * tau2)
}
fM <- function (y, i) {
  (a * DS$Q[i] + (1 - a) * DS$TsQ[i] - y) / (Rate * tau1)
}
DS$TsQ <- rk4.integrate (fS, DS$Q[1], 1:nrow(DS))
DS$Qp <- rk4.integrate (fM, DS$Q[1], 1:nrow(DS))
DS$QF <- as.vector(signal::filter(ARG, DS$Q))
DS$QF <- ShiftInTime(DS$QF, .shift=-Lshift * 40, .rate=25)
ft <- fft(DS$Q[1:(nrow(DS)-1)])
df <- 25 / length(ft)
frq <- c(0, seq(df, 12.5, by = df), seq(-12.5 + df, -df, by = df))
ATF <- LTphase(frq, ParamSF)
H <- complex(modulus = ATF$Amp, argument = ATF$Phase * pi / 180)
ftq <- ft * H
DS$Qft <- c(Re(fft(ftq, inverse=TRUE) / length(ft)), 0)
DS$Qft[nrow(DS)] <- mean(DS$Qft, na.rm=TRUE)
g <- DS %>% selectTime(60200, 61300) %>% 
            select(Time, TASX, Qp, QF, Qft) %>% 
            VSpec(ylim = c(1.e-6, 1.))
VSpec(DS, 'Q', add = g) + theme_WAC(1)
# g <- VSpec(DS, 'Q', ylim = c(1.e-6, 0.1))
# g <- VSpec(DS, 'QF', add = g)
# VSpec(DS, 'Qp', add = g) + theme_WAC(1)

@

<<revisedT, include=TRUE, echo=FALSE, fig.cap='Variance spectra for the measurement of recovery temperature (RT) from the unheated Rosemount 102E4AL sensor and the resulting corrected measurement of ambient temperature (AT) with the filtered dynamic-heating term (QF). The original variable for ambient temperature based on standard processing (ATF1) is also shown. Data from SOCRATES flight 15, 6:00:00 to 6:15:00 UTC.'>>=

DS$AT <- DS$RT - DS$QF
g <- VSpec(DS, 'AT', ylim = c(1.e-6, 0.1))
# g <- VSpec(DS, 'QF', add = g)
g <- VSpec(DS, 'RT', add = g)
VSpec(DS, 'ATF1', add = g) + theme_WAC(1)

@

The response of the sensor to the dynamic-heating signal $Q$ can
be found in three ways: integration of the differential equations,
Fourier transformation with application of the transfer function,
or application of the digital filter developed in thepreceding subsection.
Those three approaches are explored in this subsection.

With specified differential equations like Part 1 Eqns.~(3) and (4),
numerical integration can provide estimates of the response of the
temperature sensor to the dynamic-heating fluctuations. Applied to
dynamic heating, those equations become\\
\begin{equation}
\frac{dQ_{qs}(t)}{dt}=\frac{Q(t)-Q_{qs}(t)}{\tau_{2}}\label{eq:Ts}
\end{equation}
\begin{equation}
\frac{dQ^{\prime}(t)}{dt}=\frac{a(Q(t)-Q^{\prime}(t))+(1-a)(Q_{qs}(t)-Q^{\prime}(t))}{\tau_{1}}=\frac{\left\{ aQ(t)+(1-a)Q_{qs}(t)\right\} -Q^{\prime}(t)}{\tau_{1}}\label{eq:Tm}
\end{equation}
where the first equation describes the variation of $Q_{qs}$, the
partial response of the support structure to dynamic heating, and
the second describes the response of the sensing wire to the combined
partial effects of the support temperature as influenced by dynamic
heating and the dynamic-heating term. This separation relies on the
linearity of the underlying equations, which makes it possible to
represent the effect of dynamic heating in isolation from real fluctuations
in temperatrure. Euler integration of these differential equations
led to erroneous results at high frequency arising from inadequate
resolution in the integration, so a fourth-order Runge-Kutta integration\footnote{The integration method was fourth-order Runge-Kutta with adjustment
of the time step to control the estimated tolerance during the integration.
The method was based on \citet{cash1990variable}. The integration
was also tested with the R routine ``rmutil::runge.kutta'' \citet{runge.kutta}.
See the Workflow document for additional details.} was used instead. 

The response of the sensor is specified by the transfer function,
so the filtered response can also be found by first calculating the
Fourier transform of the dynamic-heating signal (here denoted $Q^{\dagger}(\nu)=\mathcal{F}(Q(t))$
where $\mathcal{F}$ denotes the Fourier transform) and then using
the inverse Fourier transform ($\mathcal{F}^{-1}$) to estimate the
sensor response:\\
\[
Q^{\prime}=\mathcal{F}^{-1}(Q^{\dagger}(\nu)H(\nu))
\]

The third option is to apply the digital filter as developed in Sect.~\ref{subsec:A-filter-for}.
Appendix A provides more detail.

Figure~\ref{fig:Integration} shows the variance spectra that result
from all three methods, applied to measurements from an unheated Rosemount
102E4AL sensor. These results use the same data used in Fig.~\ref{fig:S15}.
The modified variance spectrum obtained by integration of the underlying
differential equations is shown as the black line (``Qp'') in Fig.~\ref{fig:Integration}.
The dynamic-heating correction is appropriately attenuated at high
frequency after this integration. The results obtained after filtering
as described in the Sect.~\ref{subsec:A-filter-for}, shown as ``QF'',
or after Fourier transformation, shown as ``Qft'', are overlapping
so as to be indistinguishable in this plot. These corrected estimates
of the dynamic heating are attenuated even more than the result from
numerical integration and are in better agreement with the predicted
effect of the transfer function, which for example predicts attenuation
of the variance spectrum by a factor of 0.096 for the component with
frequency  10~Hz. The numerical integration was closer to the results
of the filter if the measurements are interpolated to 125~Hz with
25-Hz smoothing, integrated, and then resampled to obtain 25~Hz measurements.
This illustrated that the discrepancy in results is attributable to
accumulating numerical errors in the integration, but the integration
became awkwardly slow when performed at 125-Hz resolution. The equivalence
of the results from the digital filter and from Fourier transformation
with application of the transfer function supports the validity of
these results and suggests that these are preferable and equivalent
methods for filtering dynamic heating to match the response of the
temperature sensor. 

With the corrected dynamic-heating term $Q^{\prime}$, a new estimate
of the ambient air temperature was calculated using \eqref{eq:QprimeCorr}.
The spectral variance for air temperature, shown in Fig.~\ref{fig:revisedT}
as ``AT,'' is improved considerably vs.~that using the standard
correction (``ATF1''). The new estimate of air temperature is an
improved measurement to use in estimates of sensible-heat flux and
other studies where the high-rate components of the temperature are
important.

\selectlanguage{english}%
<<WECANX, include=TRUE, echo=FALSE>>=

DWECAN <- getNetCDF('/Data/WECAN/WECANrf17h.nc', standardVariables(c('RTH1',
                    'ATH1', 'RTF1', 'ATF1')), 180400, 183500)   # 182600,182900)
DWECAN$Q <- DWECAN$TASX^2 / 2010
SB <- 50
Z <- capture.output (Vr <- SmoothInterp(detrend (DWECAN[, c('Time', 'RTH1')]), .Length=0))
Z <- capture.output (VrC <- SmoothInterp(detrend (DWECAN[, c('Time', 'Q')]), .Length=0))
Rate <- attr(DWECAN, 'Rate')
vcv <- cbind(ts(Vr, frequency=Rate), ts(VrC, frequency=Rate))
P <- spec.pgram(vcv, detrend=FALSE, fast=TRUE, plot=FALSE, spans=25)
dfH <- data.frame(P$coh, log(P$freq))
pfH <- binStats (dfH, bins=SB)
RXH <- CohP(DWECAN, 'RTH1', 'Q', plotType='Ranadu', smoothBins=SB)
phaseH <- rep(0, SB)
nphaseH <- rep(0, SB)
phase2H <- rep(0, SB)
arH <- rep(0, SB)
ar2H <- rep(0, SB)
narH <- rep(0, SB)
RXH$P.spec...1.[RXH$P.spec...1. < 0] <- 0
for (i in 2:nrow(RXH)) {
  phaseH[RXH$BIN.1[i]] <- phaseH[RXH$BIN.1[i]]+RXH$P.phase[i]
  nphaseH[RXH$BIN.1[i]] <- nphaseH[RXH$BIN.1[i]] + 1
  phase2H[RXH$BIN.1[i]] <- phase2H[RXH$BIN.1[i]]+RXH$P.phase[i]^2 
  arH[RXH$BIN.1[i]] <- arH[RXH$BIN.1[i]] + 
             sqrt(RXH$P.spec...1.[i] / RXH$P.spec...2.[i])
  ar2H[RXH$BIN.1[i]] <- ar2H[RXH$BIN.1[i]] + 
             (RXH$P.spec...1.[i] / RXH$P.spec...2.[i])
  narH[RXH$BIN.1[i]] <- narH[RXH$BIN.1[i]] + 1
}
narH[narH <= 0] <- 1
nphaseH[nphaseH == 0] <- 1
mphaseH <- phaseH/nphaseH
mphase2H <- phase2H/nphaseH
sdpH <- sqrt(mphase2H - mphaseH^2)
mphaseH <- mphaseH * 180 / pi
sdpH <- sdpH * 180 / pi
sdpH <- sdpH * 2 / sqrt(nphaseH)
arH <- arH / narH
ar2H <- ar2H / narH
sdrH <- sqrt(ar2H - arH^2)
sdrH <- sdrH * 2 / sqrt(narH)

@

\selectlanguage{american}%
<<HarcoQ, include=TRUE, echo=FALSE, fig.cap=c('Variance spectra for the unmodified dynamic-heating term and the filtered terms, for measurements from a heated HARCO sensor on the GV research aircraft.', 'The variance spectra for the original measured temperature and the temperature as modified by filtering the dynamic-heating term for a sample of measurements from a heated HARCO sensor on the GV research aircraft. The plotted spectra are for the measured recovery temperature (RTH1), the conventional calculated air temperature (ATH1), and the revised air temperature (AT) obtained by using the filtered version of the dynamic-heating term (QF).')>>=

a <- 0.733
tau1 <- 0.299
tau2 <- 0.433
DWECAN$RT <- SmoothInterp(DWECAN$RTH1, .Length = 0)
DWECAN$TsQ <- DWECAN$RT
DWECAN$Q <- SmoothInterp(DWECAN$Q, .Length = 0)  ## avoid missing values
Rate <- attr (DWECAN, 'Rate')
rhozero <- 1013.25 * 100 / (287.05 * 288.15)
MRHO <- MachNumber(DWECAN$PSXC, DWECAN$QCXC) * DWECAN$PSXC * 100 /
                  (287.05 * (273.15 + DWECAN$ATX)) / rhozero
MRHO <- SmoothInterp(MRHO, .Length=0)
a <- ParamSH$a
tau1 <- ParamSH$tau1 * (MRHO / 0.3) ^ 0.6  ## Note that these are variable
tau2 <- ParamSH$tau2 * (MRHO / 0.3) ^ 0.6
Rate <- attr (DWECAN, 'Rate')
DWECAN$TsQ <- DWECAN$Q
DWECAN$Qp <- DWECAN$Q
fS <- function(y, i) {
  (DWECAN$Q[i] - y) / (Rate * tau2[i])
}
fM <- function (y, i) {
  (a * DWECAN$Q[i] + (1 - a) * DWECAN$TsQ[i] - y) / (Rate * tau1[i])
}
DWECAN$TsQ <- rk4.integrate (fS, DWECAN$Q[1], 1:nrow(DWECAN))
DWECAN$Qp <- rk4.integrate (fM, DWECAN$Q[1], 1:nrow(DWECAN))
DWECAN$QF <- as.vector(signal::filter(ARH, DWECAN$Q))
DWECAN$QF <- ShiftInTime(DWECAN$QF, .shift=-LshiftH * 40, .rate=25)
DWECAN %>% select(Time, TASX, Q, QF, Qp) %>% VSpec(ylim=c(1.e-6,1), WACtheme=1)
DWECAN$AT <- DWECAN$RT - DWECAN$QF
g <- VSpec(DWECAN, 'AT', ylim = c(1.e-6, 0.1))
g <- VSpec(DWECAN, 'ATH1', add = g)
# g <- VSpec(DWECAN, 'RTH1', add = g)
suppressWarnings(print (VSpec (DWECAN, 'RTH1', add = g) + theme_WAC(1) + theme(legend.position = c(0.75, 0.93))))

@

In the case of the heated sensors, the revision is still more significant
because they respond more slowly. Figure~\ref{fig:HarcoQ1} shows
the result of filtering the dynamic-heating term with the time constants
determined for this sensor. In this case, the result of integration
(Qp) and the digital filter (QF) are almost identical so there is
no evidence of the integration problems that were encountered with
the unheated Rosemount sensor. The effect is quite dramatic even at
1~Hz, and the errors are significant for all frequencies about about
0.1~Hz. Because the variance spectra denoted ``QF'' or ``Qp''
represent how the temperature sensor responds to the actual fluctuations,
subtracting the actual fluctuations in dynamic heating instead of
the filtered fluctuations introduces erroneous variability into the
calculated air temperature.

Figure~\ref{fig:HarcoQ2} shows how this affects the spectral variance
of the measured air temperature from the heated HARCO sensor. The
slow response of this sensor causes the measured recovery temperature
(RTH1) to have very low spectral variance when the frequency is above
1~Hz, so the variance in the original air-temperature measurement
(ATH1) in this frequency range is almost entirely caused by erroneous
adjustment for fluctuations in dynamic heating to which the sensor
does not respond. The correction procedure leading to $Q^{\prime}$
removes this excess spectral variance and produces a signal where
the variance for frequencies above about 0.1~Hz arises primarily
from variance in the measured recovery temperature. The variance spectrum
for the conventionally processed temperature looks approximately as
might be expected in an inertial subrange, but the variance above
about 0.5~Hz is a false signal that does not arise from real variance
in temperature. It therefore becomes very important to use this revised
processing scheme to avoid erroneous measurements even for changes
occurring over 5~s or more.

<<ATATF, include=TRUE, echo=FALSE, fig.pos='t', fig.cap='The original measured temperature from an unheated Rosemount 102E4AL sensor (ATRR) and the same temperature after revising the dynamic-heating correction as described in the text (AT). The time is seconds after 8:01:00 UTC for VOCALS flight 3.'>>=

if (file.exists ('./DVOCALS.Rdata')) {
  load (file = './DVOCALS.Rdata')
  DVOCALS <- D
  DVOCALS %>% select(Time, ATRR, AT) %>% 
    selectTime(80100, 80104) %>% 
    ggplotWAC(legend.position = c(0.7, 0.93))
}

@

For the unheated Rosemount 102E4AL sensor, Fig.~\ref{fig:ATATF}
illustrates the removal of erroneous structure by filtering, and Fig.~\ref{fig:ATATH1}
shows a similar example for the heated HARCO sensor. These plots illustrate
that the erroneous fluctuations in the uncorrected measurements can
be important in many potential uses of these measurements and should
be removed as part of standard processing. The effect is particularly
significant for the HARCO sensor, for which there are large fluctuations
in Fig.~\ref{fig:ATATH1} that are caused by fluctuations in dynamic
heating to which the sensor does not respond, as demonstrated by the
corrected measurement of air temperature shown as the green line.
Appendix B provides an algorithm and suggested code to implement this
correction.\footnote{For the NSF/NCAR GV, the dynamic-heating term is complicated further
by resonance in the pressure lines connecting the transducers to the
pressure sources. This is discussed in detail in Appendix B. That
resonance is an additional source of spurious air-temperature noise
because the resonance occurs only in the pressure lines and so does
not affect the temperature sensor. When they are present, those resonance
effects also need to be removed from the dynamic-heating term applied
to the recovery temperature.}

<<ATATH1, include=TRUE, echo=FALSE, fig.pos='t', fig.cap='The original measured temperature from a heated HARCO sensor (ATH1) and the same temperature after revising the dynamic-heating correction (AT). The time is seconds after 18:13:00 UTC, for WECAN flight 17.'>>=

DWECAN$MACHX <- SmoothInterp (DWECAN$MACHX, .Length = 0)
DWECAN$ATH1 <- SmoothInterp (DWECAN$ATH1, .Length = 0)
alphaR2 <-
  0.988 + 0.053 * log10(DWECAN$MACHX) +
  0.090 * (log10(DWECAN$MACHX)) ^ 2 +
  0.091 * (log10(DWECAN$MACHX)) ^ 3
DWECAN$AT <- DWECAN$ATH1 + alphaR2 * (DWECAN$Q - DWECAN$Qp)
DWECAN %>% select(Time, ATH1, AT) %>%
  selectTime(181300, 181320) %>%
  ggplotWAC() + ylab(bquote('temperature (ATH1) [' * degree ~ 'C]'))

@


\section{Summary and Conclusions}

The primary conclusions of this investigation is that, because standard
data processing corrects the measured recovery temperature using an
estimate of dynamic heating based on the measured airspeed, such processing
often over-corrects and introduces errors because the temperature
sensors are not able to respond to the high-frequency fluctuations
in measured airspeed. This introduces a significant level of noise
into the high-frequency fluctuations in the resulting temperature.
A revised treatment of dynamic heating is proposed and shown to lead
to improved measurements. A digital filter is presented that can be
used to correct standard processing schemes to eliminate the errors
arising from the dynamic-heating term.

This Part 2 paper has focused on the dynamic-heating correction needed
to obtain the measurement of air temperature from the directly measured
recovery temperature. Because the errors discussed here are so prevalent
in almost all existing data from research aircraft, it is essential
to be able to remove these errors, and this paper develops one way
of correcting these errors. Part III will then turn to the implications
for measuring the flux of sensible heat.

\appendix

\section{The Digital Filter for Dynamic Heating}

As described in Sect~\eqref{subsec:A-filter-for}, digital filters
for dynamic heating were developed from the transfer functions for
the probes studied in Part 1. The procedure was to use the inverse
Fourier transforms of those transfer functions, which give the impulse
response functions, and then design filters using coefficients determined
from those impulse functions. This appendix describes in more detail
how this was done and includes references to the coefficients that
might be used by others. The filters so obtained appear to function
as desired, although this is an area where further work will be warranted.

The procedures was as follows:
\begin{enumerate}
\item Use the response parameters for the sensor (e.g., for the unheated
Rosemount 102E4AL sensor or the heated HARCO sensor) and a large set
of frequencies spanning the interval from $-12.5$ to $12.5$~Hz,
e.g., with resolution between assumed frequencies of (1/600)~Hz,
in the solution specified by Part 1 Eqs.~(7) and (8) to specify the
transfer function. This solution is stored in a vector with frequencies
in the order (0 to 12.5~Hz, then $(-12.5+1/600)$ to $-(1/600)$
Hz, as is conventional for representations of the Fourier transform
in R and also many other languages. It was essential to calculate
the negative-frequency components and, to obtain real-number results,
to store then is that the values representing negative frequencies
are the complex conjugates of those for the corresponding positive
frequencies.
\item The inverse Fourier transform then gave the impulse function at 15,000
delays, many of them representing negative delays. The values in the
central part of this array were mostly very small.
\item To obtain a manageable number of moving-average coefficients, all
values in the array representing the impulse function were set to
zero for indices k with values $M+2\leq k\leq N-M$ where $N$ is
the length of the calculated impulse function and $M=100$ to leave
201 non-zero coefficients. This gave coefficients spanning about 8
s at 25~Hz, or a time long compared to the expected impulse response
of the sensor.
\item The upper-100 coefficients represent negative delays in the impulse
response because of the cyclic nature of the Fourier transform, so
the coefficients were re-arranged into a sequence with the last-100
coefficients first and the initial-101 coefficients moved to the end
of the array. These coefficients were then moving-average coefficients
that implement a filter matching the transfer function, except for
some omitted terms outside the 200-coefficient range that are assumed
negligible.
\item The resulting set of moving-average coefficients can then be applied
to the measured dynamic-heating term $Q$ to produce a filtered version.
\item The filtered result then needs to be shifted in time by 4~s to correct
for the offset in the filter.
\end{enumerate}
As an illustration, R code to define filter coefficients for use with
25-Hz samples is listed here for the unheated Rosemount 102E4AL sensor:
\begin{lyxcode}
NP~<-~15000~~\#\#~Assume~10-min~segment

df~<-~25~/~NP

frq~<-~c(seq(0,~12.5,~by=df),~seq(-12.5+df,~-df,~by=df))

E~<-~LTphase(frq,~P)~~\#\#~This~function~returns~the~gain~and~phase~in~deg.

G~<-~complex(modulus=E\$Amp,~argument=E\$Phase~{*}~pi~/~180)~\#~the~transfer~fn

NG~<-~length(G)

GT~<-~fft(G,~inverse=TRUE)~/~NG~~\#~get~the~impulse~function

\#\#~Limit~to~200~coefficients~(8~s~at~25~Hz)

Lshift~<-~100~~\#\#~below,~will~need~to~shift~by~100~40-ms~samples

GT{[}(Lshift~+~2):(NP~-~Lshift){]}~<-~complex(modulus=0)

GTT~<-~GT{[}GT~!=~complex(modulus=0){]}

\#\#~Reorder:

GTT~<-~c(GTT{[}(Lshift~+~2):length(GTT){]},~GTT{[}1:(Lshift~+~1){]})

AR~<-~Arma(Re(GTT)~/~sum(Re(GTT)),~1)~\#~Normalize~to~avoid~<1\%~bias

\#\#~Result~is~appropriate~coefficients~to~use~for~filtering;~

\#\#~e.g.,~if~DF~is~data.frame~with~Q~measured~dynamic~heating:

DF\$QF~<-~as.vector(signal::filter(AR,~DF\$Q))~\#\#~standard~R

\#\#~the~following~is~a~function~to~shift~in~time:

DF\$QF~<-~ShiftInTime(DF\$QF,~.shift=-Lshift~{*}~40,~.rate=25)
\end{lyxcode}
The 201 coefficients in ``AR'' are archived in the zip file included
in the GitHub repository for this project, as described in Appendix
C. Other autoregressive moving-average (ARMA) coefficients included
there, which can be used as in the last three code lines above, are
listed in the following table:
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline 
\textbf{sensor} & \textbf{aircraft} & \textbf{data rate {[}Hz{]}} & \textbf{ARMA} & \textbf{time shift {[}s{]}}\tabularnewline
\hline 
unheated Rosemount 102E4AL & C-130 & 25 & AR & 4\tabularnewline
\hline 
`` & `` & 1 & AR1 & 10\tabularnewline
\hline 
`` & GV & 25 & ARG & 4\tabularnewline
\hline 
`` & `` & 1 & ARG1 & 10\tabularnewline
\hline 
heated HARCO & both & 25 & AH & 6\tabularnewline
\hline 
`` & `` & 1 & AH1 & 10\tabularnewline
\hline 
\end{tabular}
\par\end{center}

\section{Pressure-Line Resonance}

\citet{Cooper2016ncartn} showed evidence that the variance spectrum
of the longitudinal component of the wind appears to have excess variance
at frequencies above about 2~Hz. Figure~\ref{fig:Qproblem} shows
the problem: Both the airspeed and the dynamic heating calculated
from it have excess variance above the expected distribution for frequencies
above about 2~Hz, although this is a turbulent region with characteristics
otherwise consistent with an inertial subrange. The lateral components
of the wind do not show this excess variance; it only appears in the
longitudinal component. It is far above the noise expected from the
precision of the sensor used to measure the dynamic pressure (estimated
at about 0.1~hPa), so there must be another source of this contamination
of the signal. The suggested explanation (by D.~Lenschow, included
in that same reference, p.~140) is that there is resonance in the
long lines connecting the pressure ports to the pressure transducers
and that causes either amplification or attenuation of the pressure
signals, along with phase shifts, at various frequencies. If this
extraneous variance arises in the pressure lines, it does not influence
the temperature sensor so subtraction of the measured dynamic-heating
term from the recovery temperature to obtain the ambient temperature
introduces still more high-frequency noise into the measurement of
air temperature. When correcting for temperature-sensor time response,
this additional source of false variation in the dynamic-heating term
should be removed where possible. This appendix discusses a possible
approach to that removal.

<<Qproblem, include=TRUE, fig.cap='The variance spectrum for the dynamic-heating correction $Q$, from SOCRATES flight 15, 6:00:00 to 6:15:00 UTC, in a region thought to have characteristics of an inertial subrange. The variance spectrum for the airspeed measurement (TASX) is also shown.'>>=


DS15 <- getNetCDF(file.path(DataDirectory(), 'SOCRATES/SOCRATESrf15h.nc'), 
                  standardVariables(c('ATF1', 'PSF', 'QCF')), 55700, 61900)
DS15$Q <- RecoveryFactor(DS15$MACHX, probe = 'UNHEATED') * DS15$TASX^2 / 2010
DS15$TAS <- DS15$TASX  ## needed to get TASX to plot in VSpec 
DS15 %>% selectTime(60000, 61500) %>%
         select(Time, TASX, Q, TAS) %>% 
         VSpec(WACtheme = 1)

@

The argument presented in \citet{Cooper2016ncartn} was that line
resonance in the static pressure line used as a lower-pressure reference
for the dynamic-pressure measurement was responsible. It appears now
that this was not the correct explanation. The reason is that fluctuations
in static pressure normally make a negligible contribution to the
measured fluctuations in dynamic pressure; instead, fluctuations in
dynamic pressure are dominated by fluctua\-tions in the total pressure
delivered by the pitot tube to the differential sensor. Figure~\ref{fig:3Pplot}
shows that the dominant contributions to variance in dynamic pressure,
measured as the difference between the total and static pressure,
comes from the variance in the total pressure present in the shorter
inlet line. Resonances in both lines need to be evaluated, but the
following argument indicates that the fluctuations in the static-pressure
line do not make any significant contribution to fluctuations in measured
dynamic pressure.

<<3Pplot, include=TRUE, fig.pos='t', fig.cap='Variance spectra for three pressure measurements: the ambient or static pressure (PSF), the dynamic pressure (QCF), and their sum (PTOT).'>>=

DS15$PTOT <- DS15$PSF + DS15$QCF
DS15 %>% selectTime(60000, 61500) %>%
         select(Time, TASX, PSF, QCF, PTOT) %>%
         VSpec() + theme_WAC(1)

@

<<lineTF>>=

library(Bessel)
Rate <- 25
N <- 2^14
df <- Rate / N
frq <- seq(df, Rate / 2, by = df)
# AFFT <- LTphase(frq, ParamSF)
## Lenschow/Iberall calc:
LineTF <- function(frq, pinp = 1013.25, Tinp = 15, Dinp = 3.1e-3, Linp = 8, Vinp = 1.e-6) {
  izero  <- which(frq == 0)
  if (!is.null(izero)) {
    frq[izero] <- 1  ## placeholder
  }
  omega <- 2 * pi * frq
  visc <- (1.718+0.0049*Tinp)*1.e-5    # viscosity, kg/(m s)
  dens <- 100 * pinp / (StandardConstant('Rd') * (Tinp+273.15))  # air density mks
  kvisc <- visc / dens
  gIberall <- sqrt(abs(omega) / (2 * kvisc)) * Dinp / 2
  gIberall <- gIberall * complex(1, 1, -sign(omega)) 
  FIberall <- (1/1.4) * 
    (1 + (2 * 0.4 * BesselI(gIberall, 1)) / (gIberall  * BesselI(gIberall, 0))) *
    (gIberall^2/8) / (2*BesselI(gIberall, 1) / (gIberall * BesselI(gIberall, 0)) - 1)
  F2Iberall <- 1.4 / (1 + 0.4 * 2 * BesselI(gIberall, 1) /
    (gIberall * BesselI(gIberall, 0)))
  xIberall <- 32 * visc * omega / (100 * pinp) * (Linp / Dinp)^2 * FIberall
  psiIberall <- sqrt(complex(1, 0, 1) * xIberall)
  xIIberall <- Vinp / (1.4 * pi * (Dinp/2)^2 * Linp) * xIberall * F2Iberall
  psiIIberall <- complex(1, 0, 1) * xIIberall
  HIberall <- 1 / cosh(psiIberall)
  ## Enhancement for the instrument volume:
  HIberall <- 1 / (cosh(psiIberall) + psiIIberall / psiIberall * sinh(psiIberall))
  if (!is.null(izero)) {
    HIberall[izero] <- complex(1,1,0)
    frq[izero] <- 0
  }
  dIberall <- data.frame(freq = frq, Amp = Mod(HIberall), Phase = -Arg(HIberall) * 180 / pi)
  return(dIberall)
}

@

Lenschow's analysis (based on theoretical predictions of \citet{Iberall1950})
leads to a transfer function representing the effect of the line resonance
on the measurement. This transfer function was plotted in Fig.~52
of \citet{Cooper2016ncartn} and has been recalculated from the equations
in \citet{Iberall1950}, specifically Eqs.~(105) and (106) with (99)
and (95) and with the volume within the pressure sensor at the end
of the line assumed to be 300~mm$^{3}$ as used by D\@. Lenschow,
for use in the present work. That transfer function then can be used
in the same way as the time-response transfer function to correct
the measured dynamic-heating term by applying the correction to both
lines connected to the dynamic-pressure sensor. The result should
be a better estimate of the dynamic heating at the temperature sensor
because the fluctuations occurring only in the lines and not affecting
the temperature sensor will be removed.

<<correctQresonance, include=TRUE, fig.cap='The variance spectrum that results from correcting the measured static pressure ("PSF") for the theoretical effect of line resonance, represented here as "PSR". To reduce suspected noise, additional attenuation is applied above 8 Hz to obtain "PSFR".'>>=

Rate <- attr(DS15, 'Rate')
## Correct TASX for the line-resonance effect:
DS15$TASX <- SmoothInterp(DS15$TASX, .Length = 0)
DS15$PTOT <- DS15$PSF + DS15$QCF
DS15$PTOT <- SmoothInterp(DS15$PTOT, .Length = 0)
DS15$PSF <- SmoothInterp(DS15$PSF, .Length = 0)
DS15$QCF <- SmoothInterp(DS15$QCF, .Length = 0)
DS15 <- DS15[1:2^15, ]
f <- fft (DS15$TASX) 
fp <- fft(DS15$PSF)
N <- length(f)
df <- Rate / N
frq <- c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
N2 <- N %/% 2
## Attenuate above 8 Hz:
fAtten <- 8
iatt <- which.min(abs(frq - fAtten))
fpf <- fp
irg <- iatt : (N - iatt)
fpf[irg] <- fpf[irg] * (fAtten / abs(frq[irg]))^10  ## 3.5 looks good!
## Modify the spectrum by the inverse of the response function:
AFFT <- LineTF(frq, mean(DS15$PSF, na.rm=TRUE), mean(DS15$ATX, na.rm=TRUE),
               Dinp = 4e-3, Linp = 9, Vinp = 0.3e-6)
# AFFT <- rbind(data.frame(Time=0, Amp=1, Phase=0), AFFT, rev(AFFT[2:N2, ]))
# AFFT$Phase[(N2+2):N] <- -AFFT$Phase[(N2+2):N]
AFFT$frq <- frq
AFFT$Phase <- AFFT$Phase * pi / 180
HI <- complex (modulus = AFFT$Amp, argument = AFFT$Phase)
f <- f / HI
fp <- fp / HI
fpf <- fpf / HI
AFFTT <- LineTF(frq, mean(DS15$PTOT, na.rm=TRUE), 
                mean(DS15$ATX + DS15$TASX^2 / 2010, na.rm=TRUE),
                Dinp = 3.1e-3, Linp = 4, Vinp = 1.e-5)
HT <- complex (modulus = AFFTT$Amp, argument = AFFTT$Phase)
xn <- Re(fft(f, inverse = TRUE)) / N
xnp <- Re(fft(fp, inverse = TRUE)) / N
xnpf <- Re(fft(fpf, inverse = TRUE)) / N  ## Best estimate of the static pressure
DS15$TASQ <- xn
DS15$PSR <- xnp
DS15$PSFR <- xnpf

fq <- fft(DS15$QCF + DS15$PSF)  ## Best estimate of total pressure in the line
fq <- fq / HT
xnq <- Re(fft(fq, inverse = TRUE)) / N
DS15$PTOTR <- xnq               ## Best estimate of the true total pressure
DS15$QCFR <- xnq - xnpf         ## Best estimate of the true dynamic pressure

DS15$Q <- DS15$TASX^2 / 2010
DS15$QQ <- DS15$TASQ^2 / 2010
DS15$SIM <- rnorm(nrow(DS15), 0, 0.34)
DS15 %>% selectTime(60000, 61500) %>% 
         select(Time, TASX, PSF, PSR, PSFR) %>% 
         VSpec(spans = 99, ylim=c(1.e-5, 1.e-1)) + theme_WAC(1)

# DS15 %>% selectTime(60000, 61500) %>% 
#          select(Time, TASX, Q, QQ) %>% 
#          VSpec(ylim=c(1.e-5, 1.e-1), WACtheme=1)

@

Consider first the effect on static pressure. The predicted transfer
function is based on a theoretical analysis, so it is useful to determine
if the correction based on that transfer function is reasonable. In
a region thought to represent an inertial subrange, the slope of the
variance spectrum of the longitudinal wind (and therefore of airspeed
fluctuations at high frequency and also the dynamic-heating term)
is expected to exhibit a $-5/3$ slope with frequency or a $-2/3$
slope in the frequency-weighted spectral-variance plots used here.
Measurements of static pressure from the same region shown in Figs.~\ref{fig:Qproblem}
and \ref{fig:3Pplot} were processed by calculating the Fourier transform
of the pressure, dividing by the transfer function, and using an inverse
Fourier transform to recover the corrected pressure. The result is
shown as ``PSR'' in Fig.~\ref{fig:correctQresonance}, as the green
line (mostly overlapped at low frequency by the black line). The result
seems reasonable for frequencies below about 8~Hz, but there is a
sharp increase above that point. Two possible causes are: (i) The
sensor resolution, thought to be 0.1~hPa from the manufacturer's
specified uncertainty limit, would cause a noise spectrum of about
this magnitude, although with a smaller slope; and (ii) aliasing of
higher-frequency fluctuations may contribute. The digital filters
applied to the measurements don't remove this aliasing because the
fluctuations are real fluctuations in pressure in the pressure lines
and so will still be sampled as aliased. For these reasons, additional
filtering was applied to the Fourier components before inverse transformation
to reduce frequencies above 8~Hz. The result, shown as ``PSFR''
in the figure, is a reasonable adjustment to the original variance
spectrum to account for line resonance for frequencies below 8~Hz,
and evidently excess variance at higher frequency has been removed 

This approximate agreement between predictions for the measured static
pressure and the expected shape of the variance spectrum after correction,
for frequency below 8~Hz, provides some support for the theoretical
analysis by greatly improving the appearance of the variance spectrum
for pressure, although the shape is still not ideal. The spectrum
would appear better if the gain of the transfer function around 4~Hz
were approximately 40\% larger so that the variance there would be
reduced by about a factor of 2. Although the distance from the static
source to the pressure transducer is only about 3~m, it appears that
resonance in the branch of this line that continues forward to the
differential transducer affects the signal also at this location. 

Analysis of the effect of line resonance on the measurement of dynamic
pressure is more complicated because resonance can occur in both lines,
the line delivering total pressure from the pitot tube and the line
delivering static pressure from the static sources. The measured quantity
at the differential pressure transducer is the difference between
the total-pressure-line resonating pressure and the ambient-pressure-line
resonating pressure, so (using primes to denote quantities in the
resonating lines) $p_{t}^{\prime}=q^{\prime}+p_{s}^{\prime}$ is the
true total pressure in the line from the pitot tube. This can be corrected
using the theoretical transfer function for that line\footnote{Assumed parameters are length 4 m, diameter 3.1 mm, sensor volume
$10^{4}\thinspace\mathrm{mm}^{3}$. These need confirmation and possible
adjustment. They were selected primarily to produce the appropriately
corrected variance spectrum for dynamic heating. The sensor volume
in particular is probably too high.} to obtain the true total pressure at the inlet to the pitot tube,
$p_{t}$, and then the best estimate of the true dynamic pressure
$q$ is $q=p_{t}-p_{s}$ where corrected quantities are used for both
$p_{t}$ and $p_{s}$, the latter as estimated from ``PSFR'' in
Fig.~\ref{fig:correctQresonance}.

<<QCcorr, include=TRUE, fig.cap='Variance spectra for the best estimate for dynamic heating, "QCFR", after correction for resonance in both lines connected to the differential pressure sensor that produces the original measurement "QCF". The corresponding spectrum for the measured pressure in the line connected to the static sources ("PSF") is also shown.'>>=

DS15 %>% selectTime(60000, 61500) %>%
         select(Time, TASX, PSF, QCF, QCFR) %>%
         VSpec() + theme_WAC(1)

@

It is notable that the variance spectrum for the measured static pressure,
``PSF'', is far below that for the corrected dynamic pressure (``QCFR'')
or for the original measurement (``QCF''), except near 12~Hz. That
confirms that resonance in the long line supplying static pressure
to the differential pressure sensor has little effect on the measurement
of dynamic pressure and hence on the measurement of the longitudinal
component of the wind. The important contribution appears to be from
resonance in the total-pressure line.

This correction greatly improves the variance spectrum for dynamic
pressure by giving a slope consistent with expectations for an inertial
subrange. During this flight segment, other measurements (notably
the vertical wind) indicate $-5/3$ slope, while the uncorrected measurement
(QCF) departs from that slope significantly for frequencies above
about 4~Hz. The excess variance present at these frequencies therefore
should also be removed from estimates of dynamic heating based on
dynamic pressure, before the filtering to account for temperature-sensor
response (Sect.~\eqref{subsec:A-filter-for}) is applied. 

\section{Reproducibility}

\index{reproducibility}This document is constructed in ways that
support duplication of the study. The code that generates the plots
and implements the correction procedure is incorporated into the same
\index{program!file}file that generated this document via \LaTeX,
using principles and techniques described by \citet{Xie2014a} as
implemented in the R \index{R language!package!knitr}package\index{knitr}
'knitr' (\citet{Xie2014b}). The program, 'SensibleHeatFluxPaper1.Rnw',
is archived on 'GitHub' \index{GitHub repository}in the \index{repository!github}directory\index{archive!for this document}
at \href{https://github.com/WilliamCooper/KalmanFilter.git}{this URL}.
There is some \index{supplemental material}supplemental material
in that directory, including the workflow document\index{workflow document},
the bibliography and some code segments saved in the ``chunks''\index{R language!program chunks}
subdirectory, so the full directory should be downloaded in order
to run the program. The calculations use the programming \index{R language}language
\index{R language!program}\index{RStudio}R (\citet{Rlanguage})
and were run within \index{RStudio}RStudio (\citet{RStudio2012}),
so this is the most straightforward way to replicate the calculations
and the generation of this \index{program!generating this document}document.

A \index{R language!package!Ranadu}package named Ranadu,\index{R language!package!Ranadu}
containing auxillary \index{function!Ranadu}functions, is used extensively
in the R code. It is available on GitHub\index{GitHub repository}
as \href{https://github.com/WilliamCooper/Ranadu.git}{https://github.com/WilliamCooper/Ranadu.git}.
The version used for calculations in this technical note is included
in the 'zip' archive listed below.

The \index{file!data}data files used are also preserved in the NCAR/EOL
Data Archives and can be obtained via a \index{data!requesting}request
to \url{mailto:raf-dm@eol.ucar.edu} or via the ``Data Access''
links at \href{https://www.eol.ucar.edu/all-field-projects-and-deployments}{this web site}.
The original files containing the data as produced by the NCAR Earth
Observing Laboratory, Research Aviation Facility, were in \index{netCDF format}netCDF
format (cf.~\href{http://www.unidata.ucar.edu/software/netcdf/}{this URL}),
but in many cases data archives were reprocessed and the files may
change after reprocessing so a separate archive\index{archive!for this document!data}
is maintained for this document. The data files\index{file!data!archive}
in this archive contain \index{R language!data.frames}R data.frames
and are preserved as binary-format 'Rdata' files via R 'save' commands.
The code in the GitHub archive has appropriate 'load' commands to
read these data files from a subdirectory named 'Data' (/Data or \textasciitilde /Data
or /home/Data) but this is not part of the GitHub repository because
it is too large to be appropriate there. To reproduce this research,
those data files have to be transferred separately from \{??where??\}

Extensive use has been made of \index{attributes!data.frame}\index{attributes!variable}attributes
assigned to the data.frames and the variables in those data.frames.
All the attributes from the original netCDF \index{file!netCDF}files
have been transferred, so there is a record of how the original data
were processed, for example recording \index{calibration!coefficients!used in processing}calibration
coefficients and processing chains for the variables. Once the data.frames
are loaded into R, these attributes can be viewed and provide additional
documentation of what data were used. Key information like the processing
date, the program version that produced the archive, and the selection
of primary variables for various measurements thus is preserved.

(See the related list of project components on the next page that
are preserved to enhance reproducibility.)

\clearpage{}

\begin{tabular}{ll}
\textsf{\textsc{\textcolor{blue}{Project:}}}  & SensibleHeatFlux\tabularnewline
\textsf{\textsc{\textcolor{blue}{Archive package:}}}  & \href{https://github.com/WilliamCooper/SensibleHeatFlux/blob/master/SensibleHeatFluxPaper2.zip}{SensibleHeatFluxPaper2.zip}\tabularnewline
\textsf{\textsc{\textcolor{blue}{Contains:}}}  & attachment list below\tabularnewline
\textsf{\textsc{\textcolor{blue}{Program:}}}  & \href{https://github.com/WilliamCooper/SensibleHeatFlux/blob/master/SensibleHeatFluxPaper2.Rnw}{SensibleHeatFluxPaper2.Rnw}\tabularnewline
\textsf{\textsc{\textcolor{blue}{Original Data:}}}  & \citet{VOCALS2011}, \tabularnewline
 & \citet{SOCRATES2019},\tabularnewline
 & \citet{CSET2017} \tabularnewline
\textsf{\textsc{\textcolor{blue}{Special Data Files:}}}  & SensibleHeatFlux.Rdata, SensibleHeatFluxPaper2.Rdata, AR.Rdata\tabularnewline
\textsf{\textsc{\textcolor{blue}{Workflow Document:}}}  & \href{https://github.com/WilliamCooper/SensibleHeatFlux/blob/master/WorkflowSensibleHeatFluxPaper2.pdf}{WorkflowSensibleHeatFluxPaper2.pdf}\tabularnewline
\textsf{\textsc{\textcolor{blue}{Git:}}}  & \index{GitHub repository}\href{https://github.com/WilliamCooper/SensibleHeatFlux.git}{https://github.com/WilliamCooper/SensibleHeatFlux.git}\tabularnewline
\end{tabular}

\attachm{SensibleHeatFluxPaper2.Rnw\\
SensibleHeatFluxPaper2.pdf\\
WorkflowSensibleHeatFluxPaper2.pdf\\
WAC.bib\\
chunks/{*}\\
SessionInfo}

\label{sec:bibliography} 

\bibliographystyle{plainnat}
\phantomsection\addcontentsline{toc}{section}{\refname}\bibliography{/home/cooperw/RStudio/WAC}

\clearpage{}

% \centerline{-- Blank Page, End of this Technical Report --}
% \vfill\eject
% \clearpage
%\addcontentsline{toc}{section}{End}


\end{document}
