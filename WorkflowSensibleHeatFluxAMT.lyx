#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\input colordvi
\usepackage{color}
\fancyhead{}
\fancyfoot[CE,CO]{}
\newtoks{\addressee} \global\addressee={}
\newdimen\longindent \longindent=3.5truein
\fancyhead[L]{Memo to: \the\addressee \\ \datetoday \\ Page \thepage \hfill}
\renewcommand{\headrulewidth}{0.0pt}
\newenvironment{lyxlist}[1]
{\begin{list}{}
{\settowidth{\labelwidth}{#1}
\setlength{\leftmargin}{\labelwidth}
\addtolength{\leftmargin}{\labelsep}
\renewcommand{\makelabel}[1]{##1\hfil}}}
{\end{list}}
\newcommand{\datetoday}{\number\day\space
     \ifcase\month\or January\or February\or March\or April\or May\or
     June\or July\or August\or September\or October\or November\or
     December\fi
     \space\number\year}
\newcommand{\EOLmemo}{\null \vskip-1.5truein
{\raggedright \textsf{\textsc{\large \textcolor{blue}{Earth Observing Laboratory}}}}\par
{\raggedright \textsf{\textsl{\textcolor{blue}{Memorandum:}}}} \par \vskip6pt
{\color{blue}{\hrule}}\par
\vskip0.3truein \leftline{\hskip \longindent \datetoday} \vskip0.2truein
\thispagestyle{empty}}
\newcommand{\attachm}[1]{\begin{lyxlist}{Attachments:00}
\item [Attachments:] {#1}
\end{lyxlist}}
\newcommand{\cc}[1]{\begin{lyxlist}{Attachments:00}
\item [cc:] {#1}
\end{lyxlist}}
\newcommand{\attach}[1]{\begin{lyxlist}{Attachments:00}
\item [Attachment:] {#1}
\end{lyxlist}}
%usage: \encl{A\\B\\C} or \cc{ma,e1\\name2\\name3}
\end_preamble
\use_default_options false
\begin_modules
knitr
hanging
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding default
\fontencoding global
\font_roman "times" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize letterpaper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 0
\use_package mathdots 0
\use_package mathtools 1
\use_package mhchem 0
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type authoryear
\biblio_style plainnat
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2.54cm
\topmargin 3.54cm
\rightmargin 2.54cm
\bottommargin 2.54cm
\headheight 1cm
\headsep 2cm
\footskip 0.5cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
EOLmemo 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
global
\backslash
addressee={SensibleHeatFlux Archive: workflow document}% change "File" to
 the "To:" name
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
To:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
the
\backslash
addressee
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
From:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Al Cooper
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
 
\family sans
\shape smallcaps
\color blue
Subject:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Workflow comments for the AMT paper re sensible-heat flux
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
bigskip
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<initialization,echo=FALSE,include=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

library(knitr)
\end_layout

\begin_layout Plain Layout

opts_chunk$set(echo=FALSE, include=FALSE, fig.lp="fig:")
\end_layout

\begin_layout Plain Layout

opts_chunk$set(fig.width=6, fig.height=5, fig.align="center", digits=4)
\end_layout

\begin_layout Plain Layout

thisFileName <- "WorkflowSensibleHeatFlux"
\end_layout

\begin_layout Plain Layout

require(Ranadu, quietly = TRUE, warn.conflicts=FALSE)
\end_layout

\begin_layout Plain Layout

library(ggplot2)
\end_layout

\begin_layout Plain Layout

library(grid)
\end_layout

\begin_layout Plain Layout

library(ggthemes)
\end_layout

\begin_layout Plain Layout

library(nleqslv)
\end_layout

\begin_layout Plain Layout

library(magrittr)
\end_layout

\begin_layout Plain Layout

library(dplyr)
\end_layout

\begin_layout Plain Layout

Directory <- DataDirectory ()
\end_layout

\begin_layout Plain Layout

a <- 0.733 # 0.713
\end_layout

\begin_layout Plain Layout

tau1 <- 0.0308  # 0.0335
\end_layout

\begin_layout Plain Layout

tau2 <- 0.447
\end_layout

\begin_layout Plain Layout

Param <- list(
\end_layout

\begin_layout Plain Layout

  a = a,
\end_layout

\begin_layout Plain Layout

  tau1 = tau1,
\end_layout

\begin_layout Plain Layout

  tau2 = tau2
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

LTphase <- function(f, P) {
\end_layout

\begin_layout Plain Layout

  ## f=frequency; P=Param
\end_layout

\begin_layout Plain Layout

  tau1 <- P$tau1
\end_layout

\begin_layout Plain Layout

  tau2 <- P$tau2
\end_layout

\begin_layout Plain Layout

  a <- P$a
\end_layout

\begin_layout Plain Layout

  b <- sqrt(1 / (1 + (2 * pi * f * tau2) ^ 2))
\end_layout

\begin_layout Plain Layout

  zeta <- -atan(2 * pi * f * tau2)
\end_layout

\begin_layout Plain Layout

  C1 <- 1 / (1 + 4 * pi ^ 2 * f ^ 2 * tau1 ^ 2) *
\end_layout

\begin_layout Plain Layout

    (-(a + (1 - a) * b * cos(zeta)) * 2 * pi * f * tau1 +
\end_layout

\begin_layout Plain Layout

       (1 - a) * b * sin(zeta))
\end_layout

\begin_layout Plain Layout

  C2 <- 1 / (1 + 4 * pi ^ 2 * f ^ 2 * tau1 ^ 2) *
\end_layout

\begin_layout Plain Layout

    ((a + (1 - a) * b * cos(zeta)) +
\end_layout

\begin_layout Plain Layout

       (1 - a) * b * sin(zeta) * 2 * pi * f * tau1)
\end_layout

\begin_layout Plain Layout

  cTF <- sqrt(C1 ^ 2 + C2 ^ 2)
\end_layout

\begin_layout Plain Layout

  phiTF <- atan2(C1, C2) * 180 / pi
\end_layout

\begin_layout Plain Layout

  return(list('Amp' = cTF, 'Phase' = phiTF))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Section
Purpose
\end_layout

\begin_layout Standard
This workflow description provides additional details leading to the submitted
 paper titled, 
\begin_inset Quotes eld
\end_inset

On Measuring Sensible-Heat Flux with Airborne Thermometers.
\begin_inset Quotes erd
\end_inset

 The intent is to support replication of the analyses and figures presented
 in the papers, to facilitate changes based on new data or new analysis
 approaches, and to make it practical to apply the proposed algorithms to
 additional data collected by research aircraft used in atmospheric studies.
 The associated 
\begin_inset Quotes eld
\end_inset

.Rmd
\begin_inset Quotes erd
\end_inset

 file contains both text (in \SpecialChar LaTeX
 format) and R processing scripts for the analyses
 in the resulting paper and is the definitive reference for this work, but
 there are details here that are not evident in that script.
 Those details include a description of the process of collecting the observatio
ns and processing them to data files, the data archives used, the steps
 required to generate the plots and other results including the instances
 where manual intervention is required to identify appropriate subsets of
 the data, references to the relevant R code and \SpecialChar LaTeX
 documents, and all the
 steps leading to the generation of the text in the papers.
 This overview and these diagrams will help explain the workflow at a general
 level and so should substitute for reading the R and \SpecialChar LaTeX
 code in most cases.
 
\end_layout

\begin_layout Standard
For brevity the subject paper will be referenced as 
\begin_inset Quotes eld
\end_inset

the paper
\begin_inset Quotes erd
\end_inset

 here.
 It includes these sections:
\end_layout

\begin_layout Enumerate
Introduction
\end_layout

\begin_layout Enumerate
Determining the Transfer Function
\end_layout

\begin_layout Enumerate
Correcting for Dynamic Heating
\end_layout

\begin_layout Enumerate
The Flux Density of Sensible Heat
\end_layout

\begin_layout Enumerate
Conclusions
\end_layout

\begin_layout Standard
After some general comments that apply to all, there are separate discussions
 for each section.
\end_layout

\begin_layout Section
Acquisition of the primary data
\end_layout

\begin_layout Standard
The measurements used in these papers were collected using the NSF/NCAR
 research aircraft during various research projects that are described in
 included references.
 The onboard data-acquisition program 'aeros' recorded the data in digital
 format, and those data files were then processed by the program 'nimbus'
 to produce an archive in NetCDF format.
 The software management group of NCAR/EOL maintains a version-controlled
 archive of these programs, so if they are of interest they can be obtained
 by contacting the data-management group of EOL (
\begin_inset CommandInset href
LatexCommand href
name "at this "
target "raf-dm@eol.ucar.edu"
type "mailto:"
literal "false"

\end_inset

 or 
\begin_inset CommandInset href
LatexCommand href
name "this"
target "datahelp@eol.ucar.edu"
type "mailto:"
literal "false"

\end_inset

 address).
 The data files available from NCAR/EOL can be found at links on 
\begin_inset CommandInset href
LatexCommand href
name "this URL"
target "https://www.eol.ucar.edu/all-field-projects-and-deployments"
literal "false"

\end_inset

, where FTP access can be requested.
 The details of the processing algorithms including those for the calculation
 of wind are documented in this report on 
\begin_inset CommandInset href
LatexCommand href
name "Processing Algorithms"
target "https://github.com/NCAR/aircraft_ProcessingAlgorithms/blob/master/ProcessingAlgorithms.pdf"
literal "false"

\end_inset

 and in 
\begin_inset CommandInset citation
LatexCommand citet
key "Bulletin23"
literal "true"

\end_inset

.
 These procedures as they pertain to the measurement of wind are also documented
 in 
\begin_inset CommandInset citation
LatexCommand cite
key "Cooper2016ncartn"
literal "true"

\end_inset

.
 The resulting data files contain measurements in scientific units and brief
 descriptions of each measurement, included as netCDF attributes for the
 files and for each variable.
\end_layout

\begin_layout Section
The .Rmd files (RMarkdown)
\end_layout

\begin_layout Standard
The .Rmd file is basically \SpecialChar LaTeX
 text, generated for simplicity using \SpecialChar LyX
, exported
 to .Rnw format, converted to .Rmd using the 
\begin_inset Quotes eld
\end_inset

mdsr
\begin_inset Quotes erd
\end_inset

 package for R (
\begin_inset CommandInset citation
LatexCommand citet
key "mdsrBaumer2019"
literal "false"

\end_inset

), and then placed into the Copernicus template provided by Daniel N
\begin_inset Formula $\ddot{\mathrm{{u}}}$
\end_inset

st which uses the 
\begin_inset Quotes eld
\end_inset

rticles
\begin_inset Quotes erd
\end_inset

 package for R (
\begin_inset CommandInset citation
LatexCommand citet
key "rticles"
literal "false"

\end_inset

).
 After some necessary modifications to the output from 
\begin_inset Quotes eld
\end_inset

mdsr
\begin_inset Quotes erd
\end_inset

, this was processed to .pdf format using RStudio (
\begin_inset CommandInset citation
LatexCommand citet
key "RStudio2012"
literal "true"

\end_inset

).
 RMarkdown is described by 
\begin_inset CommandInset citation
LatexCommand citet
key "XieEtAl2018RMarkdown"
literal "false"

\end_inset

.
 Within the .Rmd file or within the .lyx file there are 
\begin_inset Quotes eld
\end_inset

chunks
\begin_inset Quotes erd
\end_inset

 of R code (
\begin_inset CommandInset citation
LatexCommand cite
key "Rlanguage"
literal "true"

\end_inset

), delineated by a header having this format:
\end_layout

\begin_layout LyX-Code
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout LyX-Code
```{title, option = setting, ...}
\end_layout

\begin_layout LyX-Code
...R code...
\end_layout

\begin_layout LyX-Code
```
\end_layout

\end_inset


\end_layout

\begin_layout Standard
These chunks generate plots and other results of analyses that are incorporated
 into the manuscript using 'knitr' (
\begin_inset CommandInset citation
LatexCommand citet
key "Xie2014a,Xie2014b"
literal "true"

\end_inset

).
 In RStudio, the chunks appear as gray sections in the file when it is edited.
 Where tasks involve execution of R code, the chunk containing the code
 is referenced in the discussion below.
 Any results from the processing can be incorporated into the \SpecialChar LaTeX
 text via
 
\begin_inset Quotes eld
\end_inset


\backslash
Sexpr{}
\begin_inset Quotes erd
\end_inset

 calls embedded in the \SpecialChar LaTeX
 portion of the file.
\end_layout

\begin_layout Standard
Two 
\begin_inset Quotes eld
\end_inset

switches
\begin_inset Quotes erd
\end_inset

 serve to speed execution of the code: (1) the 
\begin_inset Quotes eld
\end_inset

cache
\begin_inset Quotes erd
\end_inset

 option which uses previous results without recalculation, and (2) 
\begin_inset Quotes eld
\end_inset

generateFigures
\begin_inset Quotes erd
\end_inset

 which when TRUE causes the figures to be generated and placed into the
 text.
 When FALSE, previously generated figures saved in the subdirectory 
\begin_inset Quotes eld
\end_inset

figure/
\begin_inset Quotes erd
\end_inset

 are used instead.
 The first switch significantly speeds execution in cases where small changes
 are made.
 To ensure a clean run, set the 
\begin_inset Quotes eld
\end_inset

cache
\begin_inset Quotes erd
\end_inset

 option to FALSE and remove all entries from the 
\begin_inset Quotes eld
\end_inset

cache
\begin_inset Quotes erd
\end_inset

 subdirectory.
 In some cases, the figures generated from 
\begin_inset Quotes eld
\end_inset

generateFigures <- TRUE
\begin_inset Quotes erd
\end_inset

 were renamed in order to be supplied separately for the AMT submission;
 e.g., fig10.pdf is the reference used for the include_graphics argument but
 the code chunk generating that figure is 
\begin_inset Quotes eld
\end_inset

SOCp1
\begin_inset Quotes erd
\end_inset

 so the figure placed in the 
\begin_inset Quotes eld
\end_inset

figures
\begin_inset Quotes erd
\end_inset

 directory with that name has been changed to 
\begin_inset Quotes eld
\end_inset

fig10.pdf
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Section
Required R packages including Ranadu
\end_layout

\begin_layout Standard
The R code used for analysis reported in this paper relies heavily on a
 package of routines for R called 
\begin_inset Quotes eld
\end_inset

Ranadu.
\begin_inset Quotes erd
\end_inset

 This is a set of R functions for working with the NetCDF archive data files
 produced by NCAR/EOL/RAF, and it includes some convenience routines for
 generating plots and performing other data-analysis tasks with the archived
 data.
 The Ranadu package as used here is preserved at this reference: 
\begin_inset CommandInset citation
LatexCommand citet
key "Ranadu2.6"
literal "false"

\end_inset

.
 To run the R code referenced here, that version of the package should be
 included in the R installation.
 The .Rmd routine requires that package and also some others referenced in
 the file, including 
\begin_inset Quotes eld
\end_inset

knitr
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

ggplot2
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

grid
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

ggthemes
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

zoo
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

signal
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

magrittr
\begin_inset Quotes erd
\end_inset

.
 In addition, Ranadu requires 
\begin_inset Quotes eld
\end_inset

ncdf4
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

tcltk
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

stats
\begin_inset Quotes erd
\end_inset

.
 Some parts of 
\begin_inset Quotes eld
\end_inset

Ranadu
\begin_inset Quotes erd
\end_inset

 reference additional packages as needed, but they are not used in these
 papers so do not need to be available for this routine to run.
\end_layout

\begin_layout Standard
The data processing for this manuscript involved revising some parts of
 the Ranadu package, as listed below.
 The most significant change was the addition of 
\begin_inset Quotes eld
\end_inset

flux()
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

rk4.integrate()
\begin_inset Quotes erd
\end_inset

 functions to the package.
 The first function is used to generate and plot the cospectrum used to
 calculate the flux, and it can optionally apply the correction procedure
 developed in the paper.
 The second is used to integrate the differential equations in the paper.
\end_layout

\begin_layout Standard
It may be worthwhile to call attention to the 
\begin_inset Quotes eld
\end_inset

pipe
\begin_inset Quotes erd
\end_inset

 that is used frequently in the R code.
 This relies on the 
\begin_inset Quotes eld
\end_inset

magrittr
\begin_inset Quotes erd
\end_inset

 package for R.
 The general structure resembles the following:
\end_layout

\begin_layout LyX-Code
DataFrame %>% 
\end_layout

\begin_layout LyX-Code
  select(Time, ATH1, ATF1, Ts) %>% 
\end_layout

\begin_layout LyX-Code
  selectTime(114500, 115000) %>% 
\end_layout

\begin_layout LyX-Code
  plotWAC()
\end_layout

\begin_layout Standard
At each occurrence of %>% the output from the previous command is piped
 to the next command as the first argument.
 This provides clear documentation of the sequences used to construct various
 plots.
 When the plot is generated using the 
\begin_inset Quotes eld
\end_inset

ggplot2
\begin_inset Quotes erd
\end_inset

 package, this pipe is often followed by a sequence of ggplot2 functions
 linked by 
\begin_inset Quotes eld
\end_inset

+
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
The analysis uses R data.frames that are generated from the archived netCDF
 files by the function 
\begin_inset Quotes eld
\end_inset

Ranadu::getNetCDF()
\begin_inset Quotes erd
\end_inset

.
 Most of the plots are generated using 
\begin_inset Quotes eld
\end_inset

Ranadu::ggplotWAC()
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

Ranadu::plotWAC()
\begin_inset Quotes erd
\end_inset

, which are simple convenience routines that set various options preferred
 by the author before calling the R 
\begin_inset Quotes eld
\end_inset

ggplot()
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

plot()
\begin_inset Quotes erd
\end_inset

 routines.
\end_layout

\begin_layout Standard
There is a manual for the Ranadu package, included in the above package
 reference, that includes information on how to install it.
 See also 
\begin_inset CommandInset href
LatexCommand href
name "this URL"
target "https://github.com/NCAR/Ranadu/blob/master/inst/RanaduManual.pdf"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Subsection
Ranadu::flux ()
\end_layout

\begin_layout Standard
This function calculates the appropriate cospectrum, generates a plot of
 that cospectrum, calculates the total flux and the partial flux associated
 with fluctuations smaller than a specified wavelength, and returns a data.frame
 containing the frequency, the smoothed cospectrum (not weighted by frequency),
 and the exceedance values.
 The data.frame also has attributes "Flux" and "FluxL" representing the total
 flux and the flux from wavelengths smaller than the wavelength 
\begin_inset Quotes eld
\end_inset

wavelengthLimit
\begin_inset Quotes erd
\end_inset

.
 The 
\begin_inset Quotes eld
\end_inset

wavelengthLimit
\begin_inset Quotes erd
\end_inset

 is also included as an attribute of the returned data.frame.
 
\end_layout

\begin_layout Standard
An optional argument to this function is 
\begin_inset Quotes eld
\end_inset

Par
\begin_inset Quotes erd
\end_inset

 which can be set to appropriate response parameters for a temperature sensor.
 In that case, a response function is generated using those parameters and
 the cospectrum is corrected using that response function.
\end_layout

\begin_layout Standard
In the code used for this paper, this was replaced by 
\begin_inset Quotes eld
\end_inset

plotCS()
\begin_inset Quotes erd
\end_inset

, a function that incorporated much of the same code.
 This was done partly to facilitate placing the two panels of 
\begin_inset Quotes eld
\end_inset

fig10.pdf
\begin_inset Quotes erd
\end_inset

 into a single plot.
\end_layout

\begin_layout Subsection
Ranadu::CohPhase ()
\end_layout

\begin_layout Standard
Another Ranadu function used for the calculations in the paper is 
\begin_inset Quotes eld
\end_inset

Ranadu::CohPhase()
\begin_inset Quotes erd
\end_inset

, which calculates and plots the squared coherence and phase between two
 time series.
 That function was recently modified for the needs of the analysis leading
 to the paper\SpecialChar endofsentence
 Like all Ranadu functions, it can be obtained from the Zenodo
 reference cited above and its documentation can be checked using R help
 facilities once the package is installed.
 It was used to generate the cospectra used in the determination of the
 phase between the measured recovery temperature and the expected effect
 of dynamic heating.
\end_layout

\begin_layout Standard
A modified version of this routine is included in the .Rmd file, named CohP(
 ).
 It was modified to return binned values of the phase and amplitude ratio
 labeled with bin numbers so that multiple cross-spectra covering the same
 frequency interval could be averaged to obtain these values.
 This special version was used to find the averaged values entering, for
 example, Figs.
\begin_inset space ~
\end_inset

2 and 4.
 
\end_layout

\begin_layout Subsection
Ranadu::VSpec ()
\end_layout

\begin_layout Standard
Plots of variance spectra, as shown in Figs.
\begin_inset space ~
\end_inset

3 and 6, were generated using the Ranadu function 
\begin_inset Quotes eld
\end_inset

VSpec()
\begin_inset Quotes erd
\end_inset

.
 There is a brief discussion of this function in 
\begin_inset Quotes eld
\end_inset

RanaduManual.pdf
\begin_inset Quotes erd
\end_inset

 p.
\begin_inset space ~
\end_inset

39, available at 
\begin_inset CommandInset href
LatexCommand href
name "this URL"
target "https://github.com/NCAR/Ranadu/blob/master/inst/RanaduManual.pdf"
literal "false"

\end_inset

 or in the Zenodo reference.
 A tutorial Shiny-app is also available 
\begin_inset CommandInset href
LatexCommand href
name "here"
target "https://ncar-eol.shinyapps.io/VarSpec/"
literal "false"

\end_inset

 that discusses plotting spectral variance and describes some of the options
 available in 
\begin_inset Quotes eld
\end_inset

VSpec()
\begin_inset Quotes erd
\end_inset

.
 R help facilities also provide documentation once the 
\begin_inset Quotes eld
\end_inset

Ranadu
\begin_inset Quotes erd
\end_inset

 package is installed.
\end_layout

\begin_layout Subsection
Ranadu::SmoothInterp( )
\end_layout

\begin_layout Standard
Many functions including the standard spectral analysis functions and stats::fft
 will fail if there are missing values in the processed time series.
 To avoid this problem, 
\begin_inset Quotes eld
\end_inset

SmoothInterp( )
\begin_inset Quotes erd
\end_inset

 has been used extensively.
 It calls 
\begin_inset Quotes eld
\end_inset

zoo::na.approx( )
\begin_inset Quotes erd
\end_inset

 to substitute interpolated values for missing values, and it uses the 
\begin_inset Quotes eld
\end_inset

rule = 2
\begin_inset Quotes erd
\end_inset

 argument to that function to extend values to beginning and ending sequences
 with missing values.
 (
\begin_inset Quotes eld
\end_inset

zoo:na.spline( )
\begin_inset Quotes erd
\end_inset

 has been used in this function in other applications, but it tends to introduce
 extraneous variance.) By default, 
\begin_inset Quotes eld
\end_inset

SmoothInterp( )
\begin_inset Quotes erd
\end_inset

 also applies Savitzky-Golay smoothing, so this needs to be suppressed by
 the 
\begin_inset Quotes eld
\end_inset

.Length=0
\begin_inset Quotes erd
\end_inset

 argument to 
\begin_inset Quotes eld
\end_inset

SmoothInterp( )
\begin_inset Quotes erd
\end_inset

 when smoothing is not desired (which applies to all uses in these papers).
 
\begin_inset Quotes eld
\end_inset

SmoothInterp( )
\begin_inset Quotes erd
\end_inset

 is called internally from within some of the functions that deal with variance
 spectra, including 
\begin_inset Quotes eld
\end_inset

VSpec( )
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

CohPhase( )
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
The following construction can be used to remove all the missing values
 in a data.frame and substitute interpolated values:
\end_layout

\begin_layout LyX-Code
removeNA <- function (D) {D <- SmoothInterp(D, .Length=0)}
\end_layout

\begin_layout LyX-Code
DSW <- as.data.frame(lapply(DS11, removeNA))
\end_layout

\begin_layout LyX-Code
DSW <- transferAttributes(DS11, DSW)
\end_layout

\begin_layout Standard
The last line is needed because the 
\begin_inset Quotes eld
\end_inset

lapply( )
\begin_inset Quotes erd
\end_inset

 function doesn't carry forward the variable attributes so this transfers
 them from the original data.frame.
\end_layout

\begin_layout Subsection
rk4.integrate()
\begin_inset CommandInset label
LatexCommand label
name "subsec:rk4.integrate()"

\end_inset


\end_layout

\begin_layout Standard
For use in this study, a new function was defined that implements the Cash-Karp
 method of step adjustment (
\begin_inset CommandInset citation
LatexCommand citet
key "cash1990variable"
literal "false"

\end_inset

) for a fourth-order Runge-Kutta integration.
 This was done when it became apparent that the standard R function runge.kutta()
 in the 
\begin_inset Quotes eld
\end_inset

rmutil
\begin_inset Quotes erd
\end_inset

 package (
\begin_inset CommandInset citation
LatexCommand citet
key "runge.kutta"
literal "false"

\end_inset

) did not perform adequately for step sizes of 0.04
\begin_inset space ~
\end_inset

s (as required for processing 25-Hz files) because one time constant for
 the unheated Rosemount sensor is smaller than this step size.
 This new integration routine is based on the description of the method
 in 
\begin_inset CommandInset citation
LatexCommand citet
key "Press:1992:NRC:148286"
literal "false"

\end_inset

 but has been coded independently in R for use here.
 Unlike the standard method, it does not increase the step size above the
 time increment in the file, but if the error estimate for a particular
 step does not meet the specified tolerance then the step is divided into
 multiple smaller steps.
 If the tolerance is still not met, further subdivision occurs.
 
\end_layout

\begin_layout Standard
One aspect of how this routine is used makes it problematic for general
 use: The integration takes as an argument a function that provides the
 derivative to be integrated, but that function takes a single argument.
 As applied in this analysis, however, additional variables are needed to
 calculate the derivative.
 Here is an example of a function definition used to find the temperature
 of the support that contacts the wire:
\end_layout

\begin_layout LyX-Code
fS <- function(y, i) {  
\end_layout

\begin_layout LyX-Code
    ((1/a) * (tau1 * DS11$DTMDT[i] + DS11$RTF1[i] - (1-a) * y) - y) / (Rate
 * tau2)
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
This function only works by using quantities that are in the function environmen
t (here, DS11, a, tau1, Rate, tau2).
 A better structure would provide those as additional arguments to the function,
 but that will require restructuring the 
\begin_inset Quotes eld
\end_inset

rk4.integrate( )
\begin_inset Quotes erd
\end_inset

 function as well.
 The specific function that provides the derivative is defined each time
 an integration is performed, usually just before the integration, but the
 practice of referencing the calling environment might lead to problems
 for someone wanting to extend or revise the program embedded with this
 document in the 
\begin_inset Quotes eld
\end_inset

.Rmd
\begin_inset Quotes erd
\end_inset

 file.
\end_layout

\begin_layout Section
Comments on Section 1 (Introduction)
\end_layout

\begin_layout Standard
The short introductory section just provides some context.
 One matter to which the introduction only mentions briefly is that of terminolo
gy.
 
\begin_inset Quotes eld
\end_inset

Sensible heat flux
\begin_inset Quotes erd
\end_inset

 is the commonly used term, but it seems inappropriate to this author because
 
\begin_inset Quotes eld
\end_inset

heat
\begin_inset Quotes erd
\end_inset

 is not a property of the air but the flow of thermal energy as represented
 by the first law of thermodynamics.
 
\begin_inset Quotes eld
\end_inset

Heat flux
\begin_inset Quotes erd
\end_inset

 is therefore at best ambiguous because heat is necessarily energy in motion.
 The primary formula strictly represents the transfer of enthalpy for an
 ideal gas, but 
\begin_inset Quotes eld
\end_inset

enthalpy flux
\begin_inset Quotes erd
\end_inset

 would not exclude the reactive enthalpy embedded in the water vapor so
 that isn't a good substitute.
 
\begin_inset Quotes eld
\end_inset

Flux of thermal energy
\begin_inset Quotes erd
\end_inset

 also isn't appropriate because that would carry the connotation of the
 internal energy of a perfect gas; i.e., 
\begin_inset Formula $C_{v}\rho_{a}<w^{\prime}T^{\prime}>$
\end_inset

 with 
\begin_inset Formula $C_{v}$
\end_inset

 in place of 
\begin_inset Formula $C_{p}$
\end_inset

.
 A further problem is that what is conventionally referred to as the flux
 is really a flux density.
 Maybe the best compromise would be a term like 
\begin_inset Quotes eld
\end_inset

non-reactive enthalpy flux density
\begin_inset Quotes erd
\end_inset

 but to my knowledge that term has never been used or defined.
 In the end I decided to stay with 
\begin_inset Quotes eld
\end_inset

flux of sensible heat
\begin_inset Quotes erd
\end_inset

.
 (I have the same reservations about the term 
\begin_inset Quotes eld
\end_inset

flux of latent heat
\begin_inset Quotes erd
\end_inset

 for the same reasons: It is not the heat but the energy that is latent.)
\end_layout

\begin_layout Section
Comments on Section 2 (Determining the Transfer Function)
\end_layout

\begin_layout Standard
This section presents the steady-state solution to the differential equations
 (Eqns.
\begin_inset space ~
\end_inset

(4) and (6))
\begin_inset Foot
status open

\begin_layout Plain Layout
Equations in the submitted paper are denoted here using the notation 
\begin_inset Quotes eld
\end_inset

Eq.
\begin_inset space ~
\end_inset

(n)
\begin_inset Quotes erd
\end_inset

 as in that paper, while references to equations in this workflow document
 use the format 
\begin_inset Quotes eld
\end_inset

(n)
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset

 for a sinusoidal input, as Eqns.
\begin_inset space ~
\end_inset

(7)–(12), and determines the frequency-domain 
\begin_inset Quotes eld
\end_inset

transfer function
\begin_inset Quotes erd
\end_inset

 (ratio of output to input for sinusoidal input) from that solution.
 The solution was obtained using Laplace transforms, which may not be familiar
 to some potential users of this work, so extensive documentation of the
 approach is included in this section of the workflow document.
 Also included is a direct verification of the solution obtained by substituting
 into the governing differential equations and showing that those equations
 are satisfied.
 An additional derivation from the impulse function is included and shown
 to be equivalent.
 This detail did not seem appropriate to include in the paper but it may
 be of interest to someone wanting to replicate or extend this work.
 In particular, it may be useful if additional terms are needed to describe
 the time response.
\end_layout

\begin_layout Subsection
Re: Section 2.1
\end_layout

\begin_layout Standard
Here is exhaustive detail on the Laplace-transform solution.
 Someone expert in Laplace transforms could surely do this more elegantly
 and concisely.
 I went into this much detail to be convinced that the solution proposed
 was valid.
 This material is mostly superfluous because the solution has been verified
 several ways, so most readers can skip this subsection.
 This material will be unnecessary for those already expert in Laplace transform
s because they will be able to see the solution immediately from the differentia
l equations, as co-author Carnes has demonstrated.
 
\end_layout

\begin_layout Standard
Consider a sine-wave input 
\begin_inset Formula $T(t)=\sin\omega t$
\end_inset

 representing the normalized actual history of the air temperature.
 The temperature of the sensor and that of the support must both also be
 sine waves, possibly of different amplitudes and phases: 
\begin_inset Formula $T_{m}(t)=c\sin(\omega t+\phi)$
\end_inset

 and 
\begin_inset Formula $T_{s}(t)=b\sin(\omega t+\zeta)$
\end_inset

.
 
\end_layout

\begin_layout Standard
The equation for the support temperature
\begin_inset Formula $T_{s}(t)$
\end_inset

, given by TN Eq.
\begin_inset space ~
\end_inset

(4) and repeated here, is
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{dT_{s}(t)}{dt}=\frac{(T(t)-T_{s}(t)}{\tau_{2}}
\]

\end_inset

Taking Laplace transforms (denoted by 
\begin_inset Formula $\mathcal{L}$
\end_inset

) gives 
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
s\tau_{2}\mathcal{L}(T_{s})-\tau_{2}T_{s}(0)=\frac{\omega}{s^{2}+\omega^{2}}-\mathcal{L}(T_{s})\label{eq:LTsupport}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{align*}
\mathcal{L}(T_{s}) & =\frac{T_{s}(0)+\frac{1}{\tau_{2}}\frac{\omega}{s^{2}+\omega^{2}}}{\frac{1}{\tau_{2}}+s}\\
= & \frac{T_{s}(0)}{\frac{1}{\tau_{2}}+s}+\frac{\omega}{\tau_{2}}\frac{1}{\left(\frac{1}{\tau_{2}}+s\right)(s+i\omega)(s-i\omega)}
\end{align*}

\end_inset

Expanding the last term in partial fractions leads to:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\frac{T_{s}(0)}{\frac{1}{\tau_{2}}+s}+\frac{\omega}{\tau_{2}}\left(\frac{c_{1}}{\frac{1}{\tau_{2}}+s}+\frac{c_{2}}{s+i\omega}+\frac{c_{3}}{s-i\omega}\right)
\]

\end_inset

where, from 
\begin_inset CommandInset citation
LatexCommand citet
key "kreyszig1963advanced"
literal "false"

\end_inset

 p.
 219, and with 
\begin_inset Formula $\tau=\tau_{2}$
\end_inset

 so the equations can be reused later:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
c_{1}=\frac{1}{\omega^{2}+(1/\tau)^{2}}=\frac{\tau^{2}}{1+\omega^{2}\tau^{2}}\label{eq:c1Eq}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
c_{2}=-\frac{1}{2i\omega(1/\tau-i\omega)}=\frac{\tau(i-\omega\tau)}{2\omega(1+\omega^{2}\tau^{2})}\label{eq:c2Eq}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
c_{3}=\frac{\tau(-i-\omega\tau)}{2\omega(1+\omega^{2}\tau^{2})}\label{eq:c3Eq}
\end{equation}

\end_inset

The solution is then obtained by taking the inverse Laplace transform:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
T_{s}(t)=T_{s}(0)e^{-t/\tau_{2}}+\left(\frac{\omega\tau_{2}}{1+\omega^{2}\tau_{2}^{2}}e^{-t/\tau_{2}}+\frac{(i-\omega\tau_{2})}{2(1+\omega^{2}\tau_{2}^{2})}e^{-i\omega t}+\frac{(-i-\omega\tau_{2})}{2(1+\omega^{2}\tau_{2}^{2})}e^{i\omega t}\right)\label{eq:solnTs}
\end{equation}

\end_inset

After any initial transient response decays, the long-time solution is then
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
T_{s}(t)=\frac{1}{(1+\omega^{2}\tau_{2}^{2})}\left(-\omega\tau_{2}\cos\omega t+\sin\omega t\right)=b\sin(\omega t+\zeta)=b(\cos\zeta\sin\omega t+\sin\zeta\cos\omega t)\label{eq:TsLongTerm}
\end{equation}

\end_inset

which leads to the solution for 
\begin_inset Formula $b$
\end_inset

 and 
\begin_inset Formula $\zeta$
\end_inset

:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
b\cos\zeta=-\frac{1}{1+\omega^{2}\tau_{2}^{2}}
\]

\end_inset


\begin_inset Formula 
\[
b\sin\zeta=\frac{-\omega\tau_{2}}{1+\omega^{2}\tau_{2}^{2}}
\]

\end_inset


\begin_inset Formula 
\begin{equation}
\tan\zeta=-\omega\tau_{2}\label{eq:tanzeta}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
b=\frac{1}{1+\omega^{2}\tau_{2}^{2}}\sqrt{(1+\omega^{2}\tau_{2}^{2})}=\frac{1}{\sqrt{1+\omega^{2}\tau_{2}^{2}}}\label{eq:bFromLT}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
This illustrates the use of the Laplace-transform solution that will next
 be applied to Eq.
\begin_inset space ~
\end_inset

(6) from the paper.
 A specific input, 
\begin_inset Formula $T(t)=\sin\omega t$
\end_inset

, has been used, but a more general solution would replace the Laplace transform
 of this input (
\begin_inset Formula $\mathcal{L}(T)=\omega/(s^{2}+\omega^{2})$
\end_inset

) with the general form 
\begin_inset Formula $\mathcal{L}(T)$
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:LTsupport"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The transfer function in Laplace-transform notation then is the ratio of
 the Laplace transform of the output to that of the input, with initial-conditio
n-transients neglected; in this case the transfer function is 
\begin_inset Formula $G(s)=1/(1+s\tau_{2})$
\end_inset

.
 For a general input function, this leads to the Laplace transform of the
 response via 
\begin_inset Formula $\mathcal{L}(T_{s})=G(s)\mathcal{L}(T)$
\end_inset

, so the inverse transform of this equation will specify the solution for
 a general input.
 For example, for 
\begin_inset Formula $T=B\cos\omega t$
\end_inset

 with Laplace transform 
\begin_inset Formula $\mathcal{L}(T)=Bs/(s^{2}+\omega^{2})$
\end_inset

, 
\begin_inset Formula $\mathcal{L}(T_{s})=Bs/\left((1+s\tau_{2})(s+i\omega)(s-i\omega)\right)$
\end_inset

 or
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\frac{\tau_{2}}{B}\mathcal{L}(T_{s})=s\left(\frac{c_{1}}{s+1/\tau_{2}}+\frac{c_{2}}{s+i\omega}+\frac{c_{3}}{s-i\omega}\right)
\]

\end_inset

with coefficients 
\begin_inset Formula $c_{i}$
\end_inset

 as found above.
 Apart from an initial decaying exponential, the solution is obtained from
 the inverse Laplace transform: 
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{align*}
T_{s}(t) & =B\left(-\frac{i\omega(i-\omega\tau_{2})}{2\omega(1+\omega^{2}\tau_{2}^{2})}e^{-i\omega t}+\frac{i\omega(-i-\omega\tau_{2})}{2\omega(1+\omega^{2}\tau_{2}^{2})}e^{i\omega t}\right)=\left(\frac{B}{1+\omega^{2}\tau_{2}^{2}}\right)\left(\cos\omega t-\omega\tau_{2}\sin\omega t\right)\\
= & \frac{B}{1+\omega^{2}\tau_{2}^{2}}\cos(\omega t+\zeta)
\end{align*}

\end_inset

where the gain is 
\begin_inset Formula $1/(1+\omega^{2}\tau_{2}^{2})$
\end_inset

 and the phase shift is 
\begin_inset Formula $\tan\zeta=\omega t$
\end_inset

.
 
\end_layout

\begin_layout Standard
As a check, the solution can also be obtained as follows:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
b\omega\cos(\omega t+\zeta)=\frac{\sin\omega t-b\sin(\omega t+\zeta)}{\tau_{2}}
\]

\end_inset


\begin_inset Formula 
\[
b\omega\tau_{2}[\cos\omega t\cos\zeta-\sin\omega t\sin\zeta]=\sin\omega t-b[\sin\omega t\cos\zeta+\cos\omega t\sin\zeta]
\]

\end_inset

Rearranging:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
[1-b\cos\zeta+b\omega\tau_{2}\sin\zeta]\sin\omega t=b[\sin\zeta+\omega\tau_{2}\cos\zeta]\cos\omega t
\]

\end_inset

This can only be valid if each term in square brackets is zero.
 The right-side term leads to a simple result for the phase:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\tan\zeta=-\omega\tau_{2}\label{eq:tau1}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
The amplitude-ratio 
\begin_inset Formula $b$
\end_inset

 then follows from the left-side term:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
b=\frac{1}{(\tan\zeta\sin\zeta+\cos\zeta)}=\cos\zeta=1/\sqrt{1+\omega^{2}\tau_{2}^{2}}\label{eq:b-1}
\end{equation}

\end_inset

The support temperature also can be written as follows: 
\begin_inset Formula $T_{s}(t)=b(\cos\zeta\sin\omega t+\sin\zeta\cos\omega t).$
\end_inset


\end_layout

\begin_layout Standard
Once 
\begin_inset Formula $b$
\end_inset

 and 
\begin_inset Formula $\zeta$
\end_inset

 are known functions of frequency, they can be used in Eq.
\begin_inset space ~
\end_inset

(6) from the paper to represent the support temperature 
\begin_inset Formula $T_{s}(t)$
\end_inset

 to find the amplitude 
\begin_inset Formula $c$
\end_inset

 and phase 
\begin_inset Formula $\phi$
\end_inset

 of the response 
\begin_inset Formula $T_{m}(t)$
\end_inset

.
 
\end_layout

\begin_layout Standard
The same approach can then be applied to the equation for the sensor response
 
\begin_inset Formula $T_{m}(t)$
\end_inset

 in response to a real temperature 
\begin_inset Formula $T(t)=\sin\omega t.$
\end_inset

 The Laplace transform of Eq.
 (6) leads to
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\tau_{1}(s\mathcal{L}(T_{m})-T_{m}(0))=a\mathcal{L}(T)+(1-a)b(\cos\zeta\frac{\omega}{s^{2}+\omega^{2}}+\sin\zeta\frac{s}{s^{2}+\omega^{2}})-\mathcal{L}(T_{m})\label{eq:subsidiaryEq}
\end{equation}

\end_inset


\begin_inset Formula 
\[
\tau_{1}(s\mathcal{L}(T_{m})-T_{m}(0))=\mathcal{L}(T)\left(a+(1-a)\frac{\omega}{\tau_{2}}\frac{1}{\left(\frac{1}{\tau_{2}}+s\right)(s+i\omega)(s-i\omega)}\right)-\mathcal{L}(T_{m})
\]

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\mathcal{L}(T_{m})=\frac{T_{m}(0)+\left(a+(1-a)\frac{\omega}{\tau_{2}}\frac{1}{\left(\frac{1}{\tau_{2}}+s\right)(s+i\omega)(s-i\omega)}\right)\mathcal{L}(T)}{\tau_{1}(s+1/\tau_{1})}\label{eq:SEform2}
\end{equation}

\end_inset

The ratio of the output to input transform, if the constant term is dropped,
 is
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\mathcal{H}=\frac{a(s+\frac{1}{\tau_{2}})(s+i\omega)(s-i\omega)+(1-a)\omega/\tau_{2}}{\tau_{1}(s+1/\tau_{1})(s+1/\tau_{2})(s+i\omega)(s-i\omega)}=\frac{a}{\tau_{1}}\frac{1}{(s+\frac{1}{\tau_{1}})}+\frac{(1-a)\omega}{\tau_{1}\tau_{2}(s+1/\tau_{1})(s+1/\tau_{2})(s+i\omega)(s-i\omega)}
\]

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
XXX ?? how to use this or express it in terms of a rational fraction? Would
 like to get guidance regarding specifications for a filter to apply to
 both 
\begin_inset Formula $Q$
\end_inset

 and 
\begin_inset Formula $T$
\end_inset

.
 XXXXXXXXXXXXXXXXXXXXX
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The inverse Laplace transform then leads to the general solution for 
\begin_inset Formula $T_{m}(T)$
\end_inset

 for sine-wave input:
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Here the notation 
\begin_inset Formula $\mathcal{L}^{-1}()$
\end_inset

 denotes the inverse Laplace transform.
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{align}
T_{m}(t) & =\frac{T_{m}(0)}{\tau_{1}}e^{-t/\tau_{1}}\label{eq:LTsolution}\\
+ & \mathcal{L}^{-1}\left(\frac{a+(1-a)b\cos\zeta}{\tau_{1}}\frac{\omega}{(s+1/\tau_{1})(s^{2}+\omega^{2})}\right)\\
+ & \mathcal{L}^{-1}\left(\frac{(1-a)b\sin\zeta}{\tau_{1}}\frac{s}{(s+1/\tau_{1})(s^{2}+\omega^{2})}\right)
\end{align}

\end_inset

Use partial fractions to write, following 
\begin_inset CommandInset citation
LatexCommand citet
key "kreyszig1963advanced"
literal "false"

\end_inset

 p.
 219,
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{align}
\frac{1}{(s+1/\tau_{1})(s^{2}+\omega^{2})} & =\frac{c_{1}}{s+1/\tau_{1}}+\frac{c_{2}}{s+i\omega}+\frac{c_{3}}{s-i\omega}\label{eq:PartialFractions}
\end{align}

\end_inset

The coefficients 
\begin_inset Formula $c_{i}$
\end_inset

 are the same as found previously, 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:c1Eq"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:c3Eq"
plural "false"
caps "false"
noprefix "false"

\end_inset

, except now 
\begin_inset Formula $\tau=\tau_{1}$
\end_inset

.
 The Laplace-transform solutions for the three terms in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:PartialFractions"
plural "false"
caps "false"
noprefix "false"

\end_inset

, omitting the coefficients, are respectively 
\begin_inset Formula $e^{-t/\tau_{1}}$
\end_inset

, 
\begin_inset Formula $e^{-i\omega t}$
\end_inset

 and 
\begin_inset Formula $e^{i\omega t}$
\end_inset

.
 The three terms arising from representing the last term in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:LTsolution"
plural "false"
caps "false"
noprefix "false"

\end_inset

 by partial fractions are the same as the previous term but multiplied by
 
\begin_inset Formula $s$
\end_inset

 instead of 
\begin_inset Formula $\omega$
\end_inset

.
 Because multiplying the Laplace transform by 
\begin_inset Formula $s$
\end_inset

 corresponds to differentiation, differentiating the three terms gives 
\begin_inset Formula $-(1/\tau_{1})e^{-t/\tau_{1}}$
\end_inset

, 
\begin_inset Formula $-i\omega e^{-i\omega t}$
\end_inset

 and 
\begin_inset Formula $i\omega e^{i\omega t}$
\end_inset

, apart from delta functions at 
\begin_inset Formula $t=0$
\end_inset

 that integrate to constants.
 Then the solution, without the exponentially decaying terms, is
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{align}
T_{m}(t)= & \frac{a+(1-a)b\cos\zeta}{\tau_{1}}\omega\left(c_{2}e^{-i\omega t}+c_{3}e^{i\omega t}\right)+\frac{(1-a)b\sin\zeta}{\tau_{1}}\left(-c_{2}i\omega e^{-i\omega t}+c_{3}i\omega e^{i\omega t}\right)\label{eq:FullSoln}
\end{align}

\end_inset

This can be transformed to sine and cosine factors using the relationships
 
\begin_inset Formula $e^{i\omega t}=\cos\omega t+i\sin\omega t$
\end_inset

 and 
\begin_inset Formula $e^{-i\omega t}=\cos\omega t-i\sin\omega t$
\end_inset

:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
T_{m}(t)=\left(\frac{a+(1-a)b\cos\zeta}{1}\right)\left\{ \left(\frac{(i-\omega\tau)}{2(1+\omega^{2}\tau^{2})}\right)(\cos\omega t-i\sin\omega t)+\left(\frac{(-i-\omega\tau)}{2(1+\omega^{2}\tau^{2})}\right)(\cos\omega t+i\sin\omega t)\right\} 
\]

\end_inset


\begin_inset Formula 
\[
+\left(\frac{(1-a)b\sin\zeta}{1}\right)i\left\{ \left(\frac{-(i-\omega\tau)}{2(1+\omega^{2}\tau^{2})}\right)(\cos\omega t-i\sin\omega t)+\left(\frac{(-i-\omega\tau)}{2(1+\omega^{2}\tau^{2})}\right)(\cos\omega t+i\sin\omega t)\right\} 
\]

\end_inset


\begin_inset Formula 
\[
=C_{1}\cos\omega t+C_{2}\sin\omega t
\]

\end_inset

where
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
C_{1}=(a+(1-a)b\cos\zeta)\left(\frac{-\omega\tau}{1+\omega^{2}\tau^{2}}\right)+(1-a)b\sin\zeta\left(\frac{1}{1+\omega^{2}\tau^{2}}\right)
\]

\end_inset


\begin_inset Formula 
\[
C_{2}=(a+(1-a)b\cos\zeta)\left(\frac{1}{1+\omega^{2}\tau^{2}}\right)+(1-a)b\sin\zeta\left(\frac{\omega\tau}{1+\omega^{2}\tau^{2}}\right)
\]

\end_inset


\end_layout

\begin_layout Standard
In this equation, 
\begin_inset Formula $C_{1}$
\end_inset

, 
\begin_inset Formula $C_{2}$
\end_inset

, 
\begin_inset Formula $b$
\end_inset

 and 
\begin_inset Formula $\zeta$
\end_inset

 are all functions of frequency.
 It is useful to convert this solution into the form 
\begin_inset Formula $T_{m}(t)=c(\omega)\sin(\omega t+\phi(\omega))$
\end_inset

, so that the functions 
\begin_inset Formula $c(\omega)$
\end_inset

 and 
\begin_inset Formula $\phi(\omega)$
\end_inset

 represent the amplitude and phase of the response to an input of 
\begin_inset Formula $\sin\omega t$
\end_inset

.
 This then will characterize the transfer function.
 The result is that 
\begin_inset Formula $c(f)\sin(2\pi ft+\phi(f))=c(f)\left(\sin2\pi ft\cos\phi(f)+\cos2\pi ft\sin\phi(f)\right)$
\end_inset

 so 
\begin_inset Formula $C_{1}=c\sin\phi$
\end_inset

 and 
\begin_inset Formula $C_{2}=c\cos\phi$
\end_inset

.
 Thus, the amplitude and phase of the transfer function defining the response
 to sine waves of various frequencies are given by
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
c=\sqrt{C_{1}^{2}+C_{2}^{2}}\label{eq:amplitude}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
\phi=\arctan(C_{1}/C_{2})\label{eq:phase}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
The unheated Rosemount 102A2EL sensor can be represented by the parameters
 called 
\begin_inset Quotes eld
\end_inset

set 1
\begin_inset Quotes erd
\end_inset

 (
\begin_inset Formula $a=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(Param$a, 2)}
\end_layout

\end_inset

, 
\begin_inset Formula $\tau_{1}=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(Param$tau1, 2)}
\end_layout

\end_inset

, 
\begin_inset Formula $\tau_{2}=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(Param$tau2, 2)}
\end_layout

\end_inset

), as discussed in Section 2.4.1 of the paper.
 Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:AppxFig}
\end_layout

\end_inset

 shows the resulting frequency-dependent transfer function for sine-wave
 input.
\end_layout

\begin_layout Standard
There is a different route to the transfer function that starts with Eq.
\begin_inset space ~
\end_inset

(3) of the paper, which is an expression for the response to an inverse
 step function (i.e., a change from unity to zero).
 The corresponding response to a positive step is
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\Theta^{*}(t)=1-A_{1}e^{-t/\tau_{1}}-A_{2}e^{-t/\tau_{2}}\label{eq:StepFn}
\end{equation}

\end_inset

The derivative of that response is the impulse function 
\begin_inset Formula $I(t)$
\end_inset

, and the Fourier transform of that impulse function is the transfer function
 
\begin_inset Formula $H(\nu)$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
I(t)=(A_{1}/\tau_{1})e^{-t/\tau_{1}}+(A_{2}/\tau_{2})e^{-t/\tau_{2}}\,\,\,\mathrm{for}\,t\geq0\label{eq:ImpulseFn}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
H(\nu)=\int_{0}^{\infty}I(t)e^{-2\pi i\nu t}dt=\frac{A_{1}}{2\pi i\nu\tau_{1}+1}+\frac{A_{2}}{2\pi i\nu\tau_{2}+1}\label{eq:HfromIF}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
In terms of angular frequency 
\begin_inset Formula $\omega$
\end_inset

,
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
H(\omega)=\frac{A_{1}(1-i\omega\tau_{1})}{(1+\omega^{2}\tau_{1}^{2})}+\frac{A_{2}(1-i\omega\tau_{2})}{(1+\omega^{2}\tau_{2}^{2})}=\left(\frac{A_{1}}{1+\omega^{2}\tau_{1}^{2}}+\frac{A_{2}}{1+\omega^{2}\tau_{2}^{2}}\right)-i\omega\left(\frac{A_{1}\tau_{1}}{1+\omega^{2}\tau_{1}^{2}}+\frac{A_{2}\tau_{2}}{1+\omega^{2}\tau_{2}^{2}}\right)
\]

\end_inset


\begin_inset Formula 
\[
|H(\omega)|=\sqrt{C_{1}^{2}+C_{2}^{2}}\,\,\mathrm{and}\,\,\,\mathrm{Arg}(H(\omega))=-\arctan(C_{1}/C_{2})
\]

\end_inset

where
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
C_{1}=-\omega\left(\frac{A_{1}\tau_{1}}{1+\omega^{2}\tau_{1}^{2}}+\frac{A_{2}\tau_{2}}{1+\omega^{2}\tau_{2}^{2}}\right)\label{eq:C1IF}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
C_{2}=\left(\frac{A_{1}}{1+\omega^{2}\tau_{1}^{2}}+\frac{A_{2}}{1+\omega^{2}\tau_{2}^{2}}\right)\label{eq:C2IF}
\end{equation}

\end_inset

The asserted equivalence in coefficients is 
\begin_inset Formula $A_{2}=(1-a)\tau_{2}/(\tau_{2}-\tau_{1})$
\end_inset

 and 
\begin_inset Formula $A_{1}=1-A_{2}=(a\tau_{2}-\tau_{1})/(\tau_{2}-\tau_{1})$
\end_inset

, or 
\begin_inset Formula $a=A_{1}(1-\tau_{1}/\tau_{2})+\tau_{1}/\tau_{2}=A_{1}+(1-A_{1})(\tau_{1}/\tau_{2})=1-A_{2}(1-\tau_{1}/\tau_{2})$
\end_inset

.
 Those substitutions can be used to show the equivalence of 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:C1IF"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:C2IF"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to the corresponding expressions Eq.
\begin_inset space ~
\end_inset

(13) and Eq.
\begin_inset space ~
\end_inset

(14):
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{align*}
C_{1} & =-\omega\left(\frac{1}{(1+\omega^{2}\tau_{1}^{2})(1+\omega^{2}\tau_{2}^{2})}\right)\left(A_{2}\tau_{2}(1+\omega^{2}\tau_{1}^{2})+(1-A_{2})\tau_{1}(1+\omega^{2}\tau_{2}^{2})\right)\\
= & (")\left(\tau_{2}^{2}(1-a)(1+\omega^{2}\tau_{1}^{2})/(\tau_{2}-\tau_{1})+\tau_{1}(a\tau_{2}-\tau_{1})(1+\omega^{2}\tau_{2}^{2})/(\tau_{2}-\tau_{1})\right)\\
= & (")\left(\frac{a\left(\tau_{1}\tau_{2}(1+\omega^{2}\tau_{2}^{2})-\tau_{2}^{2}(1+\omega^{2}\tau_{1}^{2})\right)+\tau_{2}^{2}(1+\omega^{2}\tau_{1}^{2})-\tau_{1}^{2}(1+\omega^{2}\tau_{2}^{2})}{\tau_{2}-\tau_{2}}\right)\\
= & (")\left(\frac{a\left(\tau_{2}(\tau_{1}-\tau_{2})+\tau_{1}\tau_{2}^{2}\omega^{2}(\tau_{2}-\tau_{1})\right)+(\tau_{2}^{2}-\tau_{1}^{2})}{\tau_{2}-\tau_{1}}\right)\\
= & \left(\frac{-\omega}{(1+\omega^{2}\tau_{1}^{2})(1+\omega^{2}\tau_{2}^{2})}\right)\left(a\tau_{2}(-1+\tau_{1}\tau_{2}\omega^{2})+\tau_{2}+\tau_{1}\right)
\end{align*}

\end_inset


\begin_inset Formula 
\begin{align*}
C_{2} & =\left(\frac{1}{(1+\omega^{2}\tau_{1}^{2})(1+\omega^{2}\tau_{2}^{2})}\right)\left(A_{2}(1+\omega^{2}\tau_{1}^{2})+(1-A_{2})(1+\omega^{2}\tau_{2}^{2})\right)\\
= & \left(\frac{\tau_{2}}{(1+\omega^{2}\tau_{1}^{2})(1+\omega^{2}\tau_{2}^{2})}\right)\left(\frac{1-a}{\tau_{2}-\tau_{1}}(1+\omega^{2}\tau_{1}^{2})+\frac{a-\tau_{1}/\tau_{2}}{\tau_{2}-\tau_{1}}(1+\omega^{2}\tau_{2}^{2})\right)\\
= & \left(\frac{\tau_{2}}{(1+\omega^{2}\tau_{1}^{2})(1+\omega^{2}\tau_{2}^{2})}\right)\left(\frac{a(1+\omega^{2}\tau_{2}^{2}-1-\omega^{2}\tau_{1}^{2})+1+\omega^{2}\tau_{1}^{2}-(\tau_{1}/\tau_{2})(1+\omega^{2}\tau_{2}^{2})}{\tau_{2}-\tau_{1}}\right)\\
= & \left(\frac{\tau_{2}}{(1+\omega^{2}\tau_{1}^{2})(1+\omega^{2}\tau_{2}^{2})}\right)\left(\frac{a\omega^{2}(\tau_{2}^{2}-\tau_{1}^{2})}{\tau_{2}-\tau_{1}}+\frac{1-\tau_{1}/\tau_{2}+\omega^{2}\tau_{1}(\tau_{1}-\tau_{2})}{\tau_{2}-\tau_{1}}\right)\\
= & \left(\frac{1}{(1+\omega^{2}\tau_{1}^{2})(1+\omega^{2}\tau_{2}^{2})}\right)\left(a\omega^{2}\tau_{2}(\tau_{2}+\tau_{1})+1-\omega^{2}\tau_{1}\tau_{2}\right)
\end{align*}

\end_inset

which are the same as Eqs.
\begin_inset space ~
\end_inset

(13) and (14) in the paper, obtained from the differential equation using
 
\begin_inset Formula 
\[
\tan\zeta=-\omega\tau_{2}
\]

\end_inset


\begin_inset Formula 
\[
\cos\zeta=\frac{1}{\sqrt{\tan^{2}\zeta+1}}=\frac{1}{\sqrt{1+\omega^{2}\tau_{2}^{2}}}=b
\]

\end_inset


\begin_inset Formula 
\[
\sin\zeta=\sqrt{1-\cos^{2}\zeta}=\frac{-\omega\tau_{2}}{\sqrt{1+\omega^{2}\tau_{2}^{2}}}=-b\omega\tau_{2}
\]

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{align*}
C_{1}^{*} & =\frac{-\omega}{(1+\omega^{2}\tau_{1}^{2})}\left(\tau_{1}a+\frac{(1-a)(\tau_{1}+\tau_{2})}{(1+\omega^{2}\tau_{2}^{2})}\right)\\
= & \frac{-\omega}{(1+\omega^{2}\tau_{1}^{2})(1+\omega^{2}\tau_{2}^{2})}\left(a(\tau_{1}(1+\omega^{2}\tau_{2}^{2})-(\tau_{2}+\tau_{1}))+(\tau_{1}+\tau_{2})\right)\\
= & \frac{-\omega}{(1+\omega^{2}\tau_{1}^{2})(1+\omega^{2}\tau_{2}^{2})}\left(a\tau_{2}(-1+\tau_{1}\tau_{2}\omega^{2})+\tau_{1}+\tau_{2}\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
C_{2}^{*} & =\left(\frac{1}{1+\omega^{2}\tau_{1}^{2}}\right)\left(a+\frac{(1-a)(1-\omega^{2}\tau_{1}\tau_{2})}{(1+\omega^{2}\tau_{2}^{2})}\right)\\
= & \frac{1}{(1+\omega^{2}\tau_{1}^{2})(1+\omega^{2}\tau_{2}^{2})}\left(a\omega^{2}\tau_{2}(\tau_{2}+\tau_{1})+1-\omega^{2}\tau_{1}\tau_{2}\right)
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The code chunk 
\begin_inset Quotes eld
\end_inset

checkImpulseFnSoln
\begin_inset Quotes erd
\end_inset

 (in this project archive) was used to check that the expressions used for
 the transfer function were indeed equivalent.
 An example comparison is shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:checkImpulseFnSoln}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<checkImpulseFnSoln, include=TRUE, fig.cap='Example transfer function for
 $a$=0.5, $
\backslash

\backslash
tau_1$=0.05, $
\backslash

\backslash
tau_2$=0.5, for the Laplace-transform solution (
\begin_inset Quotes eld
\end_inset

std
\begin_inset Quotes erd
\end_inset

) and for the corresponding solution obtained from the impulse-response
 function (
\begin_inset Quotes eld
\end_inset

IF
\begin_inset Quotes erd
\end_inset

).
 The lines overlap in this plot and were verified to agree to  near machine-prec
ison limits.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

source('chunks/checkImpulseFnSoln.R')
\end_layout

\begin_layout Plain Layout

f <- seq(0.01,15,by=0.01)
\end_layout

\begin_layout Plain Layout

a <- 0.5
\end_layout

\begin_layout Plain Layout

tau1 <- 0.05
\end_layout

\begin_layout Plain Layout

tau2 <- 0.5
\end_layout

\begin_layout Plain Layout

print(CompareTF(f, a, tau1, tau2))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<AppxFig, include=TRUE, echo=FALSE, fig.cap='The amplitude and phase for
 the response of the Rosemount 102E4AL temperature sensor to a signal of
 the form $
\backslash

\backslash
sin(2
\backslash

\backslash
pi$$ft$) where $f$ is the frequency, for the Laplace-transform solution
 and for a numerical solution of simultaneous equations.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

a <- Param$a
\end_layout

\begin_layout Plain Layout

tau1 <- Param$tau1
\end_layout

\begin_layout Plain Layout

tau2 <- Param$tau2
\end_layout

\begin_layout Plain Layout

frq <- seq(0.01, 25, by = 0.01)
\end_layout

\begin_layout Plain Layout

zeta <- -atan(2 * pi * frq * tau2)
\end_layout

\begin_layout Plain Layout

b <- cos(zeta)
\end_layout

\begin_layout Plain Layout

Phi <- rep(0, length(frq))
\end_layout

\begin_layout Plain Layout

H <- rep(0, length(frq))
\end_layout

\begin_layout Plain Layout

f2solve <- function (x) {
\end_layout

\begin_layout Plain Layout

  # x[1]=phi, x[2]=cf
\end_layout

\begin_layout Plain Layout

  phi <- x[1]
\end_layout

\begin_layout Plain Layout

  cf <- x[2]
\end_layout

\begin_layout Plain Layout

  v <- x
\end_layout

\begin_layout Plain Layout

  v[1] <-
\end_layout

\begin_layout Plain Layout

    a + (1 - a) * bA * cos(zetaA) + cf * tau1 * 2 * pi * frqA * sin(phi)
 -
\end_layout

\begin_layout Plain Layout

    cf * cos(phi)
\end_layout

\begin_layout Plain Layout

  v[2] <- cf * (tau1 * 2 * pi * frqA * cos(phi) + sin(phi)) - (1 - a) *
\end_layout

\begin_layout Plain Layout

    bA * sin(zetaA)
\end_layout

\begin_layout Plain Layout

  return(v)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

for (i in 1:length(frq)) {
\end_layout

\begin_layout Plain Layout

  xg <- c(0.1, 0.5)
\end_layout

\begin_layout Plain Layout

  bA <- b[i]
\end_layout

\begin_layout Plain Layout

  zetaA <- zeta[i]
\end_layout

\begin_layout Plain Layout

  frqA <- frq[i]
\end_layout

\begin_layout Plain Layout

  r <- nleqslv(xg, f2solve)
\end_layout

\begin_layout Plain Layout

  Phi[i] <- r$x[1]
\end_layout

\begin_layout Plain Layout

  H[i] <- r$x[2]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

Phi <- Phi * 180 / pi
\end_layout

\begin_layout Plain Layout

dfAP <- data.frame('Time' = frq,
\end_layout

\begin_layout Plain Layout

                   'Amplitude' = H,
\end_layout

\begin_layout Plain Layout

                   'Phase' = Phi)
\end_layout

\begin_layout Plain Layout

## Use the Laplace-transform solution
\end_layout

\begin_layout Plain Layout

C1 <- 1 / (1 + 4 * pi ^ 2 * frq ^ 2 * tau1 ^ 2) *
\end_layout

\begin_layout Plain Layout

  (-(a + (1 - a) * b * cos(zeta)) * 2 * pi * frq * tau1 +
\end_layout

\begin_layout Plain Layout

     (1 - a) * b * sin(zeta))
\end_layout

\begin_layout Plain Layout

C2 <- 1 / (1 + 4 * pi ^ 2 * frq ^ 2 * tau1 ^ 2) *
\end_layout

\begin_layout Plain Layout

  ((a + (1 - a) * b * cos(zeta)) +
\end_layout

\begin_layout Plain Layout

     (1 - a) * b * sin(zeta) * 2 * pi * frq * tau1)
\end_layout

\begin_layout Plain Layout

cTF <- sqrt(C1 ^ 2 + C2 ^ 2)
\end_layout

\begin_layout Plain Layout

phiTF <- atan2(C1, C2) * 180 / pi
\end_layout

\begin_layout Plain Layout

dfAP <-
\end_layout

\begin_layout Plain Layout

  data.frame(
\end_layout

\begin_layout Plain Layout

    'Time' = frq,
\end_layout

\begin_layout Plain Layout

    'Amp1' = cTF,
\end_layout

\begin_layout Plain Layout

    'Amp2' = H,
\end_layout

\begin_layout Plain Layout

    'Phase1' = phiTF,
\end_layout

\begin_layout Plain Layout

    'Phase2' = Phi
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

t <- (0:(125 * 600)) / 125
\end_layout

\begin_layout Plain Layout

mx <- vector()
\end_layout

\begin_layout Plain Layout

for (f in c(1, 3, 10)) {
\end_layout

\begin_layout Plain Layout

  S <- sin(2 * pi * f * t)
\end_layout

\begin_layout Plain Layout

  TS <- rep(0, length(S))
\end_layout

\begin_layout Plain Layout

  for (i in 2:length(S)) {
\end_layout

\begin_layout Plain Layout

    TS[i] <- TS[i - 1] + (S[i] - TS[i - 1]) / (125 * tau2)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  TM <- TS
\end_layout

\begin_layout Plain Layout

  for (i in 2:length(S)) {
\end_layout

\begin_layout Plain Layout

    TM[i] <- TM[i - 1] + (a * S[i] + (1 - a) * TS[i] - TM[i - 1]) / (125
 * tau1)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  mx <- c(mx, max(TM[5001:6000]))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  ggplotWAC(
\end_layout

\begin_layout Plain Layout

    dfAP,
\end_layout

\begin_layout Plain Layout

    panels = 2,
\end_layout

\begin_layout Plain Layout

    labelP = c('       Amplitude', '    Phase [degrees]'),
\end_layout

\begin_layout Plain Layout

    labelL = c('Laplace Transform', 'numerical'),
\end_layout

\begin_layout Plain Layout

    lty = c(1, 2),
\end_layout

\begin_layout Plain Layout

    col = c('blue', 'darkorange')
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab('transfer function')
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  g + scale_x_log10(
\end_layout

\begin_layout Plain Layout

    breaks = trans_breaks("log10", function(x)
\end_layout

\begin_layout Plain Layout

      10 ^ x, n = 4),
\end_layout

\begin_layout Plain Layout

    labels = trans_format("log10", math_format(expr = 10 ^ .x))
\end_layout

\begin_layout Plain Layout

  ) + xlab('frequency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = 'tb')
\end_layout

\begin_layout Plain Layout

g + theme_WAC(1) + theme(legend.position = c(0.75, 0.92))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As still another check on the preceding derivations, an alternate solution
 was obtained as follows.
 Again isolate the factors multiplying 
\begin_inset Formula $\sin\omega t$
\end_inset

 and 
\begin_inset Formula $\cos\omega t:$
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{align*}
c\omega\tau_{1}[\cos\omega t\cos\phi-\sin\omega t\sin\phi]
\end{align*}

\end_inset


\begin_inset Formula 
\[
=a\sin\omega t+(1-a)b(\cos\zeta\sin\omega t+\sin\zeta\cos\omega t)-c[\cos\phi\sin\omega t+\sin\phi\cos\omega t]
\]

\end_inset


\begin_inset Newline newline
\end_inset

Gathering terms:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{align*}
[c\omega\tau_{1}\sin\phi+a+(1-a)b\cos\zeta-c\cos\phi]\sin\omega t
\end{align*}

\end_inset


\begin_inset Formula 
\[
=[c\omega\tau_{1}\cos\phi-(1-a)b\sin\zeta+c\sin\phi]\cos\omega t
\]

\end_inset

The simultaneous equations to be solved are then obtained by setting the
 factors in square brackets to zero:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
[c\omega\tau_{1}\sin\phi+a+(1-a)b\cos\zeta-c\cos\phi]=0\label{eq:seq1-1}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
[c\omega\tau_{1}\cos\phi-(1-a)b\sin\zeta+c\sin\phi]=0\label{eq:seq2-1}
\end{equation}

\end_inset

Because it is assumed that 
\begin_inset Formula $a$
\end_inset

 is known and because 
\begin_inset Formula $b$
\end_inset

 and 
\begin_inset Formula $\zeta$
\end_inset

 are known from the solution above, the two unknowns for which 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:seq1-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:seq2-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

 must be solved are 
\begin_inset Formula $c$
\end_inset

 and 
\begin_inset Formula $\phi$
\end_inset

, giving the amplitude and phase of the response to the input.
 They must be solved independently at each frequency because all the parameters
 {
\begin_inset Formula $b,\,\zeta,\,c,\,\phi$
\end_inset

} are functions of frequency.
 R code for this solution using the R package 
\begin_inset Quotes eld
\end_inset

nleqslv
\begin_inset Quotes erd
\end_inset

 is included in the 
\begin_inset Quotes eld
\end_inset

Rnw
\begin_inset Quotes erd
\end_inset

-format file used to generate this workflow memo.
 The results of the two methods of solution are the same to nearly the numerical
 precision of the software.
\end_layout

\begin_layout Standard
One final check was to simulate sine waves of various frequencies and then
 use a numerical solution of Eq.
\begin_inset space ~
\end_inset

(6) to calculate the expected measurement.
 The results were consistent with Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:AppxFig}
\end_layout

\end_inset

; for example, the 1
\begin_inset space ~
\end_inset

Hz simulation agreed in amplitude to within 1% and in phase within 
\begin_inset Formula $1^{\circ}$
\end_inset

 even for a simple Euler-method integration.
\end_layout

\begin_layout Standard
The following is a final verification of the solution by substituting into
 the differential equations.
 For (3), 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
b\omega\tau_{2}\cos(\omega t+\zeta)\stackrel{?}{=}\sin(\omega t)-b\sin(\omega t+\zeta)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
b\omega\tau_{2}(\cos\omega t\cos\zeta-\sin\omega t\sin\zeta)\stackrel{?}{=}\sin(\omega t)-b(\sin\omega t\cos\zeta+\sin\zeta\cos\omega t)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\cos\omega t(b\omega\tau_{2}\cos\zeta+b\sin\zeta)\stackrel{?}{=}\sin(\omega t)(b\omega\tau_{2}\sin\zeta+1-b\cos\zeta)
\]

\end_inset


\end_layout

\begin_layout Standard
The asserted solution gives zero for the coefficient multiplying 
\begin_inset Formula $\cos\omega t$
\end_inset

 on the left side.
 On the right side, the coefficient multiplying 
\begin_inset Formula $\sin\omega t$
\end_inset

 is 
\begin_inset Formula $1-b\cos\zeta(\omega^{2}\tau_{2}^{2}+1)$
\end_inset

 or, using 
\begin_inset Formula $\cos\zeta=1/\sqrt{1+\tan^{2}\zeta}=1/\sqrt{1+\omega^{2}\tau_{2}^{2}}$
\end_inset

, 
\begin_inset Formula $1-b\sqrt{1+\omega^{2}\tau_{2}^{2}}=0$
\end_inset

 so the equality is satisfied.
\end_layout

\begin_layout Standard
For (4), the approach is similar:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
-C_{1}\omega\tau_{1}\sin\omega t+C_{2}\omega\tau_{1}\cos\omega t
\]

\end_inset


\begin_inset Formula 
\[
\stackrel{?}{=}\left\{ a\sin\omega t+(1-a)b(\sin\omega t\cos\zeta+\cos\omega t\sin\zeta)\right\} -C_{1}\cos\omega t-C_{2}\sin\omega t
\]

\end_inset


\end_layout

\begin_layout Standard
Again gathering coefficients multiplying 
\begin_inset Formula $\sin\omega t$
\end_inset

 and 
\begin_inset Formula $\cos\omega t$
\end_inset

 separately:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\cos\omega t\left(C_{2}\omega\tau_{1}+C_{1}-(1-a)b\sin\zeta\right)\stackrel{?}{=}\sin\omega t\left(a+(1-a)b\cos\zeta+C_{1}\omega\tau_{1}-C_{2}\right)
\]

\end_inset

Substituting the solutions for 
\begin_inset Formula $C_{1}$
\end_inset

, 
\begin_inset Formula $C_{2}$
\end_inset

, 
\begin_inset Formula $b$
\end_inset

 and 
\begin_inset Formula $\zeta$
\end_inset

 gives, for the left side coefficient, after dividing by 
\begin_inset Formula $b\cos\zeta$
\end_inset

,
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\left((\frac{a\sqrt{1+\omega^{2}\tau_{2}^{2}}}{\cos\zeta}+(1-a))\left(\frac{1}{1+\omega^{2}\tau_{1}^{2}}\right)-(1-a)\omega\tau_{2}\left(\frac{\omega\tau_{1}}{1+\omega^{2}\tau_{1}^{2}}\right)\right)\omega\tau_{1}
\]

\end_inset


\begin_inset Formula 
\[
+\left((\frac{a\sqrt{1+\omega^{2}\tau_{2}^{2}}}{\cos\zeta}+(1-a))\left(\frac{-\omega\tau_{1}}{1+\omega^{2}\tau_{1}^{2}}\right)-(1-a)\omega\tau_{2}\left(\frac{1}{1+\omega^{2}\tau_{1}^{2}}\right)\right)
\]

\end_inset


\begin_inset Formula 
\[
+(1-a)\omega\tau_{2}
\]

\end_inset

which is zero.
 The right-side coefficient becomes, after similar division,
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\frac{a\sqrt{1+\omega^{2}\tau_{2}^{2}}}{\cos\zeta}+(1-a)+\left((\frac{a\sqrt{(1+\omega^{2}\tau_{2}^{2}}}{\cos\zeta}+(1-a))\left(\frac{-\omega\tau_{1}}{1+\omega^{2}\tau_{1}^{2}}\right)-(1-a)\omega\tau_{2}\left(\frac{1}{1+\omega^{2}\tau_{1}^{2}}\right)\right)\omega\tau_{1}
\]

\end_inset


\begin_inset Formula 
\[
-\left((\frac{a\sqrt{(1+\omega^{2}\tau_{2}^{2}}}{\cos\zeta}+(1-a))\left(\frac{1}{1+\omega^{2}\tau_{1}^{2}}\right)-(1-a)\omega\tau_{2}\left(\frac{\omega\tau_{1}}{1+\omega^{2}\tau_{1}^{2}}\right)\right)
\]

\end_inset


\begin_inset Formula 
\[
=\frac{a\sqrt{1+\omega^{2}\tau_{2}^{2}}}{\cos\zeta}+(1-a)\left(1-\frac{1+\omega^{2}\tau_{1}^{2}}{1+\omega^{2}\tau_{1}^{2}}\right)-\frac{a\sqrt{(1+\omega^{2}\tau_{2}^{2}}}{\cos\zeta}\left(\frac{1+\omega^{2}\tau_{1}^{2}}{1+\omega^{2}\tau_{1}^{2}}\right)
\]

\end_inset

here is awhich is also zero.
 These results then verify that the differential equation is satisfied for
 the case where the true signal is a continuous sine wave.
\end_layout

\begin_layout Paragraph
Comments regarding Fig.
\begin_inset space ~
\end_inset

1:
\end_layout

\begin_layout Standard
The solution in Sect.
\begin_inset space ~
\end_inset

2.1 of the paper specifies the amplitude and phase of the response to a unit-ampl
itude sinusoidal input, and so specifies the magnitude and phase of the
 transfer function.
 This section uses assumed values for the response parameters (
\begin_inset Formula $a$
\end_inset

, 
\begin_inset Formula $\tau_{1}$
\end_inset

 and 
\begin_inset Formula $\tau_{2}$
\end_inset

) as examples because those parameters have not been determined yet, but
 the values are those that result from subsequent analysis.
 The function 
\begin_inset Quotes eld
\end_inset

LTphase(f, P)
\begin_inset Quotes erd
\end_inset

, included in the code chunk labelled 
\begin_inset Quotes eld
\end_inset

LTsolution
\begin_inset Quotes erd
\end_inset

, was constructed to represent the solution so that it could be used throughout
 the paper\SpecialChar endofsentence
 Its arguments are the frequency 
\begin_inset Quotes eld
\end_inset

f
\begin_inset Quotes erd
\end_inset

, which can be a vector, and the values of the parameters, provided as 
\begin_inset Quotes eld
\end_inset

P
\begin_inset Quotes erd
\end_inset

 which should be a list with named components 
\begin_inset Quotes eld
\end_inset

a
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

tau1
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

tau2.
\begin_inset Quotes erd
\end_inset

 The function returns a list with two component vectors representing the
 amplitude (or gain) and phase at the specified frequencies.
\end_layout

\begin_layout Standard
It is useful for the 
\begin_inset Quotes eld
\end_inset

LTphase()
\begin_inset Quotes erd
\end_inset

 function to be able to accept a frequency of zero because conventional
 FFT results in R have the first coefficient equal to the constant for zero
 frequency.
 The function appropriately returns gain = 1 and phase = 0 for zero frequency.
 When given negative frequencies, it returns the complex conjugates of the
 values at the corresponding positive frequencies; i.e., the same amplitudes
 but (-1) times the phase.
 
\end_layout

\begin_layout Standard
The two-component faceted plot of the transfer function (Fig.
\begin_inset space ~
\end_inset

1) is generated by 
\begin_inset Quotes eld
\end_inset

Ranadu::ggplotWAC()
\begin_inset Quotes erd
\end_inset

, a plot function based on the 
\begin_inset Quotes eld
\end_inset

ggplot2
\begin_inset Quotes erd
\end_inset

 package (
\begin_inset CommandInset citation
LatexCommand citet
key "wickham2009"
literal "false"

\end_inset

) that combines the plots of amplitude (or gain) and phase of the transfer
 function into one plot.
 See 
\begin_inset Quotes eld
\end_inset

help(ggplotWAC)
\begin_inset Quotes erd
\end_inset

 in R for information on the use of this routine to generate plots with
 multiple panels like this, and the 
\begin_inset Quotes eld
\end_inset

ggplot2
\begin_inset Quotes erd
\end_inset

 book in the reference list for complete information on using that package.
\end_layout

\begin_layout Standard
At the end of Sect.
\begin_inset space ~
\end_inset

2.1 there is a brief discussion of how the transfer function can be used
 to correct the measurements to compensate for the time response of the
 sensor.
 This is included here as a brief reference because the correction procedure
 is used in some subsequent sections.
 It is developed in more detail in Appendix A, but that discussion is relegated
 to an appendix because the correction methods are straightforward and have
 been used and discussed in previous work.
\end_layout

\begin_layout Subsection
Re: Section 2.2 (The response to dynamic heating):
\end_layout

\begin_layout Standard
Section
\begin_inset space ~
\end_inset

2 determines the transfer function for some representative airborne thermometers
 by observing the response to fluctuations in dynamic heating.
 The first equation (Eq.
\begin_inset space ~
\end_inset

(15)) is so complicated because the simple version (
\begin_inset Formula $\alpha_{r}V^{2}/(2C_{p})$
\end_inset

) uses the measured true airspeed (
\begin_inset Formula $V$
\end_inset

) and the standard calculation of that involves the ambient temperature.
 If there are errors in the measurement of ambient temperature, they enter
 the estimate of 
\begin_inset Formula $Q$
\end_inset

\SpecialChar endofsentence
 For that reason, the expression is revised to depend only on the absolute
 recovery temperature (
\begin_inset Formula $T_{r}$
\end_inset

) and other factors that can be determined without reference to the ambient
 temperature.
 This makes possible the iteration process used here.
\end_layout

\begin_layout Standard
The formula used to calculate the dynamic heating variable 
\begin_inset Formula $Q$
\end_inset

 is as follows:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Q=\frac{{V^{2}}}{2c_{p}}=\frac{M^{2}T_{r}/5}{1+\alpha_{r}M^{2}/5}
\]

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $V$
\end_inset

 is the airspeed, 
\begin_inset Formula $c_{p}$
\end_inset

 the specific heat of air, 
\begin_inset Formula $M$
\end_inset

 the Mach number, 
\begin_inset Formula $T_{r}$
\end_inset

 the (true) absolute recovery temperature, and 
\begin_inset Formula $\alpha_{r}$
\end_inset

 the recovery factor.
 The substitution 
\begin_inset Formula $c_{v}=\frac{5}{2}R$
\end_inset

 has been used, where 
\begin_inset Formula $R$
\end_inset

 is the gas constant for air.
 Initially 
\begin_inset Formula $T_{m}$
\end_inset

 was used in place of 
\begin_inset Formula $T_{r}$
\end_inset

, but once valid transfer-function parameters were found the measurements
 were corrected to obtain better values for 
\begin_inset Formula $T_{r}$
\end_inset

.
 The change in the results was insignificant.
\end_layout

\begin_layout Subsection
Re Sect.
\begin_inset space ~
\end_inset

2.3, Data Sources
\end_layout

\begin_layout Standard
No additional information seems needed here.
 Someone wanting to reproduce this work can request the data files as described
 here.
 This work is all based on publicly available data sets that are preserved
 with associated Document Object Identifiers (DOIs).
\end_layout

\begin_layout Subsection
Re Sect.
 2.4, Fits to the Measurements
\end_layout

\begin_layout Standard
The initial few paragraphs are justification for using the dynamic-heating
 term to characterize the response of the temperature sensor.
 In the course of investigating this, some plots were constructed that were
 not included in the final paper.
 An example was the variance spectra for the two terms on the right side
 of Eq.
\begin_inset space ~
\end_inset

(16).
 That figure is included here as Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:Qprime}
\end_layout

\end_inset

.
 It shows the extent to which the second term dominates over the first for
 the entire frequency range.
 That helps justify attributing the variance in dynamic heating primarily
 to the variance in the Mach number, so that to a first approximation the
 true variance in the temperature-dependent first term in Eq.
\begin_inset space ~
\end_inset

(16) can be neglected.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<Qprime, include=TRUE, fig.height=3.4, fig.pos='t', fig.cap='Frequency-weighted
 spectral variance for $
\backslash

\backslash
delta T_m/T_m$ and 0.4$
\backslash

\backslash
delta M/M$ as functions of frequency ($
\backslash

\backslash
nu$) for a low-level flight segment from VOCALS flight 3, 21 Oct 2008 11:39:00
 -- 11:52:00 UTC.
 The wavelength scale shows the correspondence between frequency and wavelength
 at the average airspeed.
 The two terms are labeled 
\begin_inset Quotes eld
\end_inset

Tm
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

Mach
\begin_inset Quotes erd
\end_inset

 in the legend.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

load(file='DT.Rdata')
\end_layout

\begin_layout Plain Layout

DT$Mach <- (DT$MACH - mean(DT$MACH, na.rm = TRUE)) / 
\end_layout

\begin_layout Plain Layout

            mean(DT$MACH, na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

DT$Tm <- (DT$TTRR - mean(DT$TTRR, na.rm = TRUE)) / 
\end_layout

\begin_layout Plain Layout

          (273.15 + mean(DT$TTRR, na.rm = TRUE))
\end_layout

\begin_layout Plain Layout

DT$Mach <- DT$Mach * 0.4
\end_layout

\begin_layout Plain Layout

g <- VSpec(DT, 'Mach', ylim = c(1.e-10, 1.e-4))
\end_layout

\begin_layout Plain Layout

VSpec(DT, 'Tm', add = g) + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Re.
\begin_inset space ~
\end_inset

Sect.
\begin_inset space ~
\end_inset

2.4.1: An unheated temperature sensor
\end_layout

\begin_layout Standard
The danger in the approach taken is that, if fluctuations in dynamic heating
 (via fluctuations in airspeed) are not the dominant source of variation
 in the measured recovery temperature (
\begin_inset Formula $T_{m}$
\end_inset

) then the measured phase and amplitude ratio for the cross-spectrum of
 
\begin_inset Formula $T_{m}$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 will be contaminated by other causes of fluctuation in the measured recovery
 temperature.
 Indeed, if such fluctuations in 
\begin_inset Formula $T_{m}$
\end_inset

 are large compared to fluctuations in 
\begin_inset Formula $Q$
\end_inset

 then the amplitude ratio determined from the variance spectra will not
 reflect the transfer function and cannot be used to determine it.
 Therefore regions and frequency intervals were sought where it appeared
 that the fluctuations in 
\begin_inset Formula $T_{m}$
\end_inset

 arose primarily from fluctuations in 
\begin_inset Formula $Q$
\end_inset

\SpecialChar endofsentence
 This should be the case where the intensity of turbulence is high and would
 produce much larger fluctuations in 
\begin_inset Formula $T_{m}$
\end_inset

 than the existing fluctuations in ambient temperature.
 
\end_layout

\begin_layout Standard
The selection of data and combination into a unified data set is described
 in the text of the paper and won't be repeated here.
 Some trial-and-error investigation of the number of bins to use in the
 construction of Fig.
\begin_inset space ~
\end_inset

2 in the paper led to the choice of 200 bins, which determines the number
 of plotted points and error bars in the plot.
 Although it leads to reduced clarity in the plots, a large number of bins
 was settled upon to avoid significant distortion of the mean when calculated
 for a region where the variable changes rapidly, as for example approaching
 10
\begin_inset space ~
\end_inset

Hz in this figure.
 Too large an interval, with the average defined at the mid-point of the
 interval, could distort the means toward higher values compared to the
 true distribution and hence would bias the determination of response variables.
 These plots have a more convincing appearance when a smaller number of
 bins is used, and became vary noisy if a much larger number of bins is
 used, so 200 bins was the compromise used in the paper for the unheated
 Rosemount sensor.
 Because the data sets used for other sensors were much smaller, smaller
 numbers of bins were used for those sensors.
\end_layout

\begin_layout Standard
A modified version of the Ranadu function 
\begin_inset Quotes eld
\end_inset

CohPhase()
\begin_inset Quotes erd
\end_inset

, named 
\begin_inset Quotes eld
\end_inset

CohP()
\begin_inset Quotes erd
\end_inset

 in the .Rmd code, was used to combine the measurements of phase and amplitude
 for the flight segments listed in Table
\begin_inset space ~
\end_inset

1 of the paper.
 That function was modified to return a special data.frame containing the
 frequency limits of the bins and, for each frequency in the values returned
 by R function 
\begin_inset Quotes eld
\end_inset

spec.pgram()
\begin_inset Quotes erd
\end_inset

, the assignment of that frequency to one of the 200 logarithmically spaced
 bins in the phase and amplitude of the two spectra at that frequency.
 This function 
\begin_inset Quotes eld
\end_inset

CohP()
\begin_inset Quotes erd
\end_inset

 was called for each of the six ten-minute flight segments, with the measured
 recovery temperature and the expected forcing by dynamic heating (i.e., 
\begin_inset Formula $T_{m}$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

) and then the results from all calls were averaged in each of the frequency
 bins.
 The result was an average value (with standard deviation) for the phase
 and amplitude ratio, as needed to determine the transfer function.
 The observed phase at each bin-average frequency then was plotted in Fig.
\begin_inset space ~
\end_inset

2a to show the results for the phase.
 (The measurement used for 
\begin_inset Formula $T_{m}$
\end_inset

 was 
\begin_inset Quotes eld
\end_inset

TTRR
\begin_inset Quotes erd
\end_inset

 from the netCDF file.)
\begin_inset Foot
status open

\begin_layout Plain Layout
At the time of the VOCALS project the recovery temperatures had names like
 TTRR instead of RTRR\SpecialChar endofsentence
 Those names were changed subsequently to reflect that
 these are better described as recovery temperatures rather than total temperatu
res.
 In this analysis, the variable TTRR has been renamed RTRR to reflect the
 current usage.
 There is no variable RTRR in the referenced data files.
\end_layout

\end_inset

 Two-standard-deviation values for the standard deviation of the mean are
 plotted because one-standard-deviation limits appeared hard to distinguish
 in this plot.
 The error-bar plot was generated using the ggplot2 function 
\begin_inset Quotes eld
\end_inset

geom_errorbar()
\begin_inset Quotes erd
\end_inset

 with the limits specified using the bin-average mean values and standard
 deviations.
\end_layout

\begin_layout Standard
The plotted 
\begin_inset Quotes eld
\end_inset

theoretical response
\begin_inset Quotes erd
\end_inset

 was generated by 
\begin_inset Quotes eld
\end_inset

LTphase()
\begin_inset Quotes erd
\end_inset

 using the standard values of the response parameters as found later by
 fitting to these values and the corresponding values for the amplitude
 ratio.
 The plotted frequencies are limited to those above 
\begin_inset Formula $10^{-2}\mathrm{Hz}$
\end_inset

 because, below that frequency, bins had too few independent measurements
 to provide good statistics, although the available measurements below 0.01
\begin_inset space ~
\end_inset

Hz were consistent with zero phase shift as would be expected from the theoretic
al response.
 The frequency interval was also limited to <12
\begin_inset space ~
\end_inset

Hz because the highest-frequency points in the plot otherwise departed significa
ntly from the trend by being much higher (about 
\begin_inset Formula $-43^{\circ}$
\end_inset

) and so appearing to be outliers that should be excluded from the fit.
 The highest frequency included in the plot also shows some possible deviation
 and maybe should also be excluded.
\end_layout

\begin_layout Standard
Figure
\begin_inset space ~
\end_inset

2b was generated in similar fashion, using the ratio of amplitudes (the
 square roots of the ratio of variance spectra) in place of the phase.
 For the fit the calculation of the chi-square included the deviations from
 the experimental phases and the experimental amplitude ratios with equal
 weights, except that the experimental amplitude ratios were only included
 for the frequency range from 0.1 to 3
\begin_inset space ~
\end_inset

Hz.
 This range was selected because outside that range the values departed
 significantly and systematically from the theoretical prediction.
 The R function 
\begin_inset Quotes eld
\end_inset

optim()
\begin_inset Quotes erd
\end_inset

, part of the standard 
\begin_inset Quotes eld
\end_inset

stats
\begin_inset Quotes erd
\end_inset

 package, was used for this fit.
 In the case of the unheated Rosemount sensor, the fit used the default
 Nelder-Mead minimization method without imposed constraints on the values
 of the three parameters.
 This function returned a calculated Hessian and that was used to determine
 estimates of the uncertainty in the parameters.
 The function reported that it converged to a solution, and at the point
 of convergence the chi-square was 3892 for 218 degrees of freedom.
 In the calculation of the reported uncertainty limits the reported Hessian
 was divided by 4 to account for the use of two-standard-deviation standard
 deviations and then the square roots of the diagonal elements of the inverted
 Hessian matrix were reported.
 (This ignores significant correlations among the error estimates that perhaps
 should be considered and reported.)
\end_layout

\begin_layout Standard
The paper then reports on an iteration in which the measured recovery temperatur
e was first corrected using the parameters as determine in the fit and then
 the fit was repeated.
 This process was performed outside the .Rmd code by changing the dynamic-heating
 term in lines 866 to 871 to 
\begin_inset Quotes eld
\end_inset

DH2
\begin_inset Quotes erd
\end_inset

, which was calculated by using the corrected 
\begin_inset Quotes eld
\end_inset

RT
\begin_inset Quotes erd
\end_inset

 variable in place of the measured variable (
\begin_inset Quotes eld
\end_inset

TTRR
\begin_inset Quotes erd
\end_inset

).
 The result produced only a small change to the fit parameters, within estimated
 uncertainty, even after only one iteration so the iteration procedure was
 not included in the processing code.
 Instead, the values obtained after iteration were those quoted in the paper.
\end_layout

\begin_layout Standard

\series bold
\emph on
\bar under
Investigation of the high-frequency amplitude ratio in Fig.
\begin_inset space ~
\end_inset

2b:
\end_layout

\begin_layout Standard
A troubling aspect of Fig.
\begin_inset space ~
\end_inset

2b is the departure from the fit for frequencies above about 3
\begin_inset space ~
\end_inset

Hz.
 The correction to the recovery temperature discussed in the previous paragraph
 was used to show that this did not correct the problem.
 The amplitude ratio is the ratio of the fluctuations in 
\begin_inset Formula $T_{m}$
\end_inset

(TTRR) or, after correction, 
\begin_inset Formula $T_{r}$
\end_inset

, to those in 
\begin_inset Formula $Q$
\end_inset

, so the explanation could be either too large fluctuations in 
\begin_inset Formula $T_{m}$
\end_inset

 (e.g., from noise) or too small fluctuations in 
\begin_inset Formula $Q$
\end_inset

 (e.g., from attenuation of the signal).
 
\begin_inset Formula $Q$
\end_inset

 depends on 
\begin_inset Formula $V^{2}$
\end_inset

 so the variance spectrum for 
\begin_inset Formula $Q$
\end_inset

 would be expected to show a -5/3 slope on a logarithmic plot if that is
 the case for 
\begin_inset Formula $V$
\end_inset

.
 It is less clear what slope to expect for the measured recovery temperature
 TTRR, although in an inertial subrange the air temperature might be expected
 to exhibit -5/3 slope.
 The manuscript argues that a filtered version of dynamic heating should
 be used, so it is useful to correct the dynamic heating to see the shape
 of the resulting air temperature.
 This is shown as AT in the following plot.
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

include=FALSE
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

source('chunks/initialize.R')
\end_layout

\begin_layout Plain Layout

load (file = './DVOCALS.Rdata')
\end_layout

\begin_layout Plain Layout

  source('chunks/theme_WAC.R')
\end_layout

\begin_layout Plain Layout

  ## Special test: Filter TTRR
\end_layout

\begin_layout Plain Layout

  ## D$TTRR <- signal::filter( signal::butter (3, 0.7), D$TTRR)
\end_layout

\begin_layout Plain Layout

  ## D <- transferAttributes(DVOCALS, D)
\end_layout

\begin_layout Plain Layout

  ## Revise the calculation of dynamic heating to avoid dependence on AT:
\end_layout

\begin_layout Plain Layout

  D$MACH <- MachNumber(D$PSXC, D$QCXC)
\end_layout

\begin_layout Plain Layout

  recoveryFactor <- attr(D[, 'ATRR'], 'RecoveryFactor')
\end_layout

\begin_layout Plain Layout

  XXA <-  D$MACH ^ 2 / 5
\end_layout

\begin_layout Plain Layout

  D$DH <- (D$TTRR + 273.15) * XXA / (1 + recoveryFactor * XXA)
\end_layout

\begin_layout Plain Layout

  D$DH2 <- (D$RT + 273.15) * XXA / (1 + recoveryFactor * XXA)
\end_layout

\begin_layout Plain Layout

  ## Further adjust dynamic-heating for sensor response:
\end_layout

\begin_layout Plain Layout

  reviseQ <- function (.data, P) {
\end_layout

\begin_layout Plain Layout

    # P is Param1, e.g.; alphaR is recovery factor
\end_layout

\begin_layout Plain Layout

    .data$Q <- .data$TASX ^ 2 / 2010
\end_layout

\begin_layout Plain Layout

    aV <- P$a
\end_layout

\begin_layout Plain Layout

    tau1V <- P$tau1
\end_layout

\begin_layout Plain Layout

    tau2V <- P$tau2
\end_layout

\begin_layout Plain Layout

    Rate <- attr (.data, 'Rate')
\end_layout

\begin_layout Plain Layout

    fS <- function(y, i) {
\end_layout

\begin_layout Plain Layout

      (.data$Q[i] - y) / (tau2V * Rate)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    fM <- function (y, i) {
\end_layout

\begin_layout Plain Layout

      (aV * .data$Q[i] + (1 - aV) * TsQ[i] - y) / (Rate * tau1V)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    TsQ <- rk4.integrate (fS, .data$Q[1], 1:nrow(.data))
\end_layout

\begin_layout Plain Layout

    Qp <- rk4.integrate (fM, .data$Q[1], 1:nrow(.data))
\end_layout

\begin_layout Plain Layout

    return (Qp)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  a <- 0.733 # 0.713
\end_layout

\begin_layout Plain Layout

  tau1 <- 0.0308  # 0.0335
\end_layout

\begin_layout Plain Layout

  tau2 <- 0.447
\end_layout

\begin_layout Plain Layout

  Param1 <- list(
\end_layout

\begin_layout Plain Layout

    a = a,
\end_layout

\begin_layout Plain Layout

    tau1 = tau1,
\end_layout

\begin_layout Plain Layout

    tau2 = tau2
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

  D$DH3 <- reviseQ(D, Param1)
\end_layout

\begin_layout Plain Layout

  # D$RTT <- D$REF + D$DH3
\end_layout

\begin_layout Plain Layout

  ## temporary: shift D$AT later in time
\end_layout

\begin_layout Plain Layout

  # D$AT <- ShiftInTime (D$AT, .rate=25, .shift=40)
\end_layout

\begin_layout Plain Layout

  Tasm <- mean(D$TASX, na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

  DT1 <- D %>% selectTime(65000, 70000)
\end_layout

\begin_layout Plain Layout

  DT2 <- D %>% selectTime(73300, 74300)
\end_layout

\begin_layout Plain Layout

  DT3 <- D %>% selectTime(104600, 105600)
\end_layout

\begin_layout Plain Layout

  DT4 <- D %>% selectTime(114200, 115200)  ## 113900, 115200
\end_layout

\begin_layout Plain Layout

  DT5 <- D %>% selectTime(124300, 125300)
\end_layout

\begin_layout Plain Layout

  DT6 <- D %>% selectTime(133000, 134000)
\end_layout

\begin_layout Plain Layout

  DZV <- rbind(DT1, DT2, DT3, DT4, DT5, DT6)
\end_layout

\begin_layout Plain Layout

  rhozero <- 1013.25 * 100 / (287.05 * 288.15)
\end_layout

\begin_layout Plain Layout

  .Var1 <- 'TTRR'
\end_layout

\begin_layout Plain Layout

  .Var2 <- 'DH'
\end_layout

\begin_layout Plain Layout

  .Var3 <- 'ATRR'
\end_layout

\begin_layout Plain Layout

  .Var4 <- 'AT'
\end_layout

\begin_layout Plain Layout

  .Var5 <- 'DH3'
\end_layout

\begin_layout Plain Layout

  .Var6 <- 'DH2'
\end_layout

\begin_layout Plain Layout

  spans <- 25
\end_layout

\begin_layout Plain Layout

  if(exists('sp')) {rm('sp')}
\end_layout

\begin_layout Plain Layout

  for (.data in list(DT1, DT2, DT3, DT4, DT5, DT6)) {
\end_layout

\begin_layout Plain Layout

   Z <-
\end_layout

\begin_layout Plain Layout

          capture.output (Vr <-
\end_layout

\begin_layout Plain Layout

                            SmoothInterp(detrend (.data[, 
\end_layout

\begin_layout Plain Layout

                              c('Time', .Var1)]), .Length = 0))
\end_layout

\begin_layout Plain Layout

     
\end_layout

\begin_layout Plain Layout

    Z <-
\end_layout

\begin_layout Plain Layout

          capture.output (VrC <-
\end_layout

\begin_layout Plain Layout

                            SmoothInterp(detrend (.data[, 
\end_layout

\begin_layout Plain Layout

                              c('Time', .Var2)]), .Length = 0))
\end_layout

\begin_layout Plain Layout

     Z <-
\end_layout

\begin_layout Plain Layout

          capture.output (VrA <-
\end_layout

\begin_layout Plain Layout

                            SmoothInterp(detrend (.data[, 
\end_layout

\begin_layout Plain Layout

                              c('Time', .Var3)]), .Length = 0))
\end_layout

\begin_layout Plain Layout

      Z <-
\end_layout

\begin_layout Plain Layout

          capture.output (VrB <-
\end_layout

\begin_layout Plain Layout

                            SmoothInterp(detrend (.data[, 
\end_layout

\begin_layout Plain Layout

                              c('Time', .Var4)]), .Length = 0))
\end_layout

\begin_layout Plain Layout

     Z <-
\end_layout

\begin_layout Plain Layout

          capture.output (VrD <-
\end_layout

\begin_layout Plain Layout

                            SmoothInterp(detrend (.data[, 
\end_layout

\begin_layout Plain Layout

                              c('Time', .Var5)]), .Length = 0))
\end_layout

\begin_layout Plain Layout

      Z <-
\end_layout

\begin_layout Plain Layout

          capture.output (VrE <-
\end_layout

\begin_layout Plain Layout

                            SmoothInterp(detrend (.data[, 
\end_layout

\begin_layout Plain Layout

                              c('Time', .Var6)]), .Length = 0))
\end_layout

\begin_layout Plain Layout

    Rate <- attr(.data, 'Rate')
\end_layout

\begin_layout Plain Layout

    vcv <- cbind(ts(Vr, frequency = Rate), ts(VrC, frequency = Rate))
\end_layout

\begin_layout Plain Layout

    vcv2 <- cbind(ts(VrA, frequency = Rate), ts(VrB, frequency = Rate))
\end_layout

\begin_layout Plain Layout

    vcv3 <- cbind(ts(VrD, frequency = Rate), ts(VrE, frequency = Rate))
\end_layout

\begin_layout Plain Layout

    P <-
\end_layout

\begin_layout Plain Layout

      spec.pgram(
\end_layout

\begin_layout Plain Layout

        vcv,
\end_layout

\begin_layout Plain Layout

        detrend = FALSE,
\end_layout

\begin_layout Plain Layout

        fast = TRUE,
\end_layout

\begin_layout Plain Layout

        plot = FALSE,
\end_layout

\begin_layout Plain Layout

        spans = spans
\end_layout

\begin_layout Plain Layout

      )
\end_layout

\begin_layout Plain Layout

    P2 <-
\end_layout

\begin_layout Plain Layout

      spec.pgram(
\end_layout

\begin_layout Plain Layout

        vcv2,
\end_layout

\begin_layout Plain Layout

        detrend = FALSE,
\end_layout

\begin_layout Plain Layout

        fast = TRUE,
\end_layout

\begin_layout Plain Layout

        plot = FALSE,
\end_layout

\begin_layout Plain Layout

        spans = spans
\end_layout

\begin_layout Plain Layout

      )
\end_layout

\begin_layout Plain Layout

    P3 <-
\end_layout

\begin_layout Plain Layout

      spec.pgram(
\end_layout

\begin_layout Plain Layout

        vcv3,
\end_layout

\begin_layout Plain Layout

        detrend = FALSE,
\end_layout

\begin_layout Plain Layout

        fast = TRUE,
\end_layout

\begin_layout Plain Layout

        plot = FALSE,
\end_layout

\begin_layout Plain Layout

        spans = spans
\end_layout

\begin_layout Plain Layout

      )
\end_layout

\begin_layout Plain Layout

    # plot(P$freq, P$spec[,1], log='xy', type='l', col='blue')
\end_layout

\begin_layout Plain Layout

    # lines(P$freq, P$spec[,2], col='forestgreen')
\end_layout

\begin_layout Plain Layout

    if(!exists('sp')) {
\end_layout

\begin_layout Plain Layout

      sp <- rep(0, 6*length(P$freq))
\end_layout

\begin_layout Plain Layout

      dim(sp) <- c(length(P$freq), 6)
\end_layout

\begin_layout Plain Layout

      sp[, 1:2] <- P$spec
\end_layout

\begin_layout Plain Layout

      sp[, 3:4] <- P2$spec
\end_layout

\begin_layout Plain Layout

      sp[, 5:6] <- P3$spec
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      sp[, 1:2] <- sp[, 1:2] + P$spec
\end_layout

\begin_layout Plain Layout

      sp[, 3:4] <- sp[, 3:4] + P2$spec
\end_layout

\begin_layout Plain Layout

      sp[, 5:6] <- sp[, 5:6] + P3$spec
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  sp <- sp / 6
\end_layout

\begin_layout Plain Layout

  DP <- data.frame(freq=P$freq, TTRR=P$freq*sp[,1], Q=P$freq*sp[,2], 
\end_layout

\begin_layout Plain Layout

                   AT=P$freq*sp[,4])
\end_layout

\begin_layout Plain Layout

  g <- ggplotWAC(DP, xlim=c(0.01,15)) +  
\end_layout

\begin_layout Plain Layout

          ylab('frequency x spectral variance')
\end_layout

\begin_layout Plain Layout

  g <-   g + scale_x_log10(
\end_layout

\begin_layout Plain Layout

    breaks = trans_breaks("log10", function(x)
\end_layout

\begin_layout Plain Layout

      10 ^ x, n = 4),
\end_layout

\begin_layout Plain Layout

    labels = trans_format("log10", math_format(expr = 10 ^ .x))
\end_layout

\begin_layout Plain Layout

  ) + xlab('frequency [Hz]')
\end_layout

\begin_layout Plain Layout

  g <- g + scale_y_log10(
\end_layout

\begin_layout Plain Layout

      breaks = trans_breaks("log10", function(x)
\end_layout

\begin_layout Plain Layout

        10 ^ x, n = 4),
\end_layout

\begin_layout Plain Layout

      #limits = ylim,
\end_layout

\begin_layout Plain Layout

      labels = trans_format("log10", math_format(10 ^ .x))
\end_layout

\begin_layout Plain Layout

    ) +
\end_layout

\begin_layout Plain Layout

    annotation_logticks(sides = 'trbl') +
\end_layout

\begin_layout Plain Layout

    coord_cartesian(xlim = c(0.01, 15), ylim = c(1.e-5, 1.e-2))
\end_layout

\begin_layout Plain Layout

g <- g + theme_WAC()
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=data.frame(x=c(1e-2,10), y=c(2.e-3, 2.e-5)), aes(x=x,
 y=y), colour='darkorange')
\end_layout

\begin_layout Plain Layout

## Add a theoretical line for recovery temperature:
\end_layout

\begin_layout Plain Layout

freq <- P$freq
\end_layout

\begin_layout Plain Layout

RTX <- 10^((log10(freq)+2)*(-2/3))*1.e-3
\end_layout

\begin_layout Plain Layout

## Add dynamic heating:
\end_layout

\begin_layout Plain Layout

# load('AR.Rdata')
\end_layout

\begin_layout Plain Layout

# D$QF <- as.vector(signal::filter(AR, D$Q))
\end_layout

\begin_layout Plain Layout

## Modify by the transfer function:
\end_layout

\begin_layout Plain Layout

source('chunks/LTphase.R')
\end_layout

\begin_layout Plain Layout

E <- LTphase(P$freq, Param1)
\end_layout

\begin_layout Plain Layout

# RTX <- (sqrt(RTX) + recoveryFactor * Tasm^2/2010 * E$Amp)^2
\end_layout

\begin_layout Plain Layout

RTX <- RTX * E$Amp^2
\end_layout

\begin_layout Plain Layout

# g <- g + geom_path(data=data.frame(freq=freq, RTX=RTX), aes(x=freq, y=RTX),
 colour='red', lty=2)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  # plot(P$freq, sp[,1], log='xy', type='l', col='blue')
\end_layout

\begin_layout Plain Layout

  # lines(P$freq, sp[,2], col='forestgreen')
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

include=TRUE, fig.cap='Variance spectra for the measured recovery temperature
 (TTRR) and for dynamic heating (Q) for the six flight legs used for Fig.
 2.
 The variance spectrum for the air temperature after correction for dynamic
 heating as in the manuscript (AT) is also shown.
 The orange line is a reference line with the expected -2/3 slope.'
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

print(g)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The variance spectra for 
\begin_inset Formula $Q$
\end_inset

 and TTRR both seem to display high-frequency problems:
\end_layout

\begin_layout Enumerate
The spectrum for 
\begin_inset Formula $Q$
\end_inset

 appears too small at high frequency.
 The expectation is that this should have 
\begin_inset Formula $-2/3$
\end_inset

 slope on this weighted plot, as indicated by the orange reference line.
 The spectral density for 
\begin_inset Formula $Q$
\end_inset

 starts to depart below the expected slope for frequencies above about 5
 Hz, and there may be excess variance around 5 Hz.
\end_layout

\begin_layout Enumerate
The variance spectrum for AT still has excess variance at high frequency,
 although the excess is smaller than for the uncorrected air temperature
 (not shown).
 This is not the expected behavior for a sensor having the time response
 otherwise found in this study; instead, the expected shape would be 
\begin_inset Formula $-2/3$
\end_inset

 slope for low frequency and substantial attenuation of the measurement
 at high frequency.
 
\end_layout

\begin_layout Standard
The next plot shows, as RM, a calculated prediction of how the variance
 spectrum of the recovery temperature would look if the true air temperature
 were as shown by the orange line.
 The result resembles the shape of the measurement (TTRR) reasonably for
 frequencies below about 3 Hz but shows a significant departure above 3
\begin_inset space ~
\end_inset

Hz, matching the decrease in the filtered dynamic-heating term (QP).
 
\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

include=FALSE
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

DP2 <- data.frame(freq=P$freq, TTRR=P$freq*sp[,1], RM=P$freq*sp[,5]+RTX,
 
\end_layout

\begin_layout Plain Layout

                   QP=P$freq*sp[,5])
\end_layout

\begin_layout Plain Layout

  g <- ggplotWAC(DP2, xlim=c(0.01,15)) +  
\end_layout

\begin_layout Plain Layout

          ylab('frequency x spectral variance')
\end_layout

\begin_layout Plain Layout

  g <-   g + scale_x_log10(
\end_layout

\begin_layout Plain Layout

    breaks = trans_breaks("log10", function(x)
\end_layout

\begin_layout Plain Layout

      10 ^ x, n = 4),
\end_layout

\begin_layout Plain Layout

    labels = trans_format("log10", math_format(expr = 10 ^ .x))
\end_layout

\begin_layout Plain Layout

  ) + xlab('frequency [Hz]')
\end_layout

\begin_layout Plain Layout

  g <- g + scale_y_log10(
\end_layout

\begin_layout Plain Layout

      breaks = trans_breaks("log10", function(x)
\end_layout

\begin_layout Plain Layout

        10 ^ x, n = 4),
\end_layout

\begin_layout Plain Layout

      #limits = ylim,
\end_layout

\begin_layout Plain Layout

      labels = trans_format("log10", math_format(10 ^ .x))
\end_layout

\begin_layout Plain Layout

    ) +
\end_layout

\begin_layout Plain Layout

    annotation_logticks(sides = 'trbl') +
\end_layout

\begin_layout Plain Layout

    coord_cartesian(xlim = c(0.01, 15), ylim = c(1.e-6, 1.e-2))
\end_layout

\begin_layout Plain Layout

g <- g + theme_WAC()
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=data.frame(x=c(1e-2,10), y=c(1.e-3, 1.e-5)), aes(x=x,
 y=y), colour='darkorange')
\end_layout

\begin_layout Plain Layout

# g <- g + geom_path(data=data.frame(freq=freq, RTX=D$), aes(x=freq, y=RTX),
 colour='red', lty=2)
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Flex Chunk
status open

\begin_layout Plain Layout

\begin_inset Argument 1
status open

\begin_layout Plain Layout

include=TRUE, fig.cap='The predicted measurement (RM) if the air temperature
 has the spectrum shown as the orange line and the modified dynamic-heating
 term (QP) is added.
 The actual measurement is also shown (TTRR).'
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

print(g)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The source of the excess variance in the measured recovery temperature has
 not been identified, but it appears that this is the primary cause of the
 high-frequency departure from theory in Fig.
\begin_inset space ~
\end_inset

2b of the manuscript.
 In this study, it has been assumed that this departure is spurious and
 the contribution to the amplitude ratio above 3
\begin_inset space ~
\end_inset

Hz should be ignored when fitting the transfer function to the measurements.
 For this reason, the fit used only the amplitude ratios for frequencies
 below 3
\begin_inset space ~
\end_inset

Hz (although the phase was used up to 12
\begin_inset space ~
\end_inset

Hz because it seemed reasonable in this extended range).
\end_layout

\begin_layout Standard

\series bold
\emph on
\bar under
Extension to GV measurements
\end_layout

\begin_layout Standard
At the end of the discussion of the unheated sensor, there is mention of
 a similar evaluation performed on the GV\SpecialChar endofsentence
 The .Rmd file includes code for
 this, but the results were not included in the paper except to quote the
 results.
 The relevant code chunk is labelled 
\begin_inset Quotes eld
\end_inset

GVcheck
\begin_inset Quotes erd
\end_inset

.
 That code will generate figures similar to Fig.
\begin_inset space ~
\end_inset

2 and will fit to the observations to determine the fit parameters.
 
\end_layout

\begin_layout Subsubsection
The heated Rosemount sensor
\end_layout

\begin_layout Standard
A study of the heated Rosemount sensor was included in the original file
 but excluded from the paper to reduce its length.
 The sensor is seldom used and has largely been replaced by the heated HARCO
 sensor, which is designed to have the same characteristics as the original.
 In the .lyx file the inclusion of this material is controlled by the 
\begin_inset Quotes eld
\end_inset

Extra
\begin_inset Quotes erd
\end_inset

 branch which is not included in the paper but could be added by activating
 this branch.The results are included in the summary of parameters (Table
\begin_inset space ~
\end_inset

3).
 Here is the text that would have been included in the paper but was excluded:
\end_layout

\begin_layout Standard
\begin_inset CommandInset line
LatexCommand rule
offset "2ex"
width "100col%"
height "1pt"

\end_inset


\end_layout

\begin_layout Subsubsection*
The heated Rosemount sensor
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<XTR3>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

bestW <- c(0.0, 0.1635184, 0.9017476)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename figure/heatVarSpec-1.pdf
	width 90text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Variance spectrum for the recovery temperature from the heated Rosemount
 sensor (RTWH) and for the unheated Rosemount 102E4AL sensor (RTRR), for
 a low-level flight segment in the marine boundary layer.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
During the same flight used to study the unheated sensor, a heated Rosemount
 sensor was also present.
 Data were assembled as for the unheated sensor and the preceding analysis
 was repeated, except that two of the flight segments were omitted because
 they led to erratic indications of the phase.
 The heated sensor had almost no response to any fluctuations above 1
\begin_inset space ~
\end_inset

Hz, as shown in Fig.
\begin_inset space ~
\end_inset

3.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename figure/VphaseW-1.pdf
	width 90text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Phase lag of recovery temperature vs.
\backslash

\backslash
 dynamic heating, for the measurements (error bars) from a Rosemount heated
 sensor, and the theoretical response for the best-fit parameters to the
 measurements with frequency below 1 Hz (green line).
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The measured phase between the measured recovery temperature and the calculated
 dynamic heating is shown in Fig.
\begin_inset space ~
\end_inset

2.
 Above 1
\begin_inset space ~
\end_inset

Hz, the lack of response led to erratic estimates of the phase and the coherence
 between the measured recovery temperature and dynamic heating was consistent
 with zero, so those measurements of the phase were omitted from the fit.
 Similarly, the amplitude for frequencies above 1
\begin_inset space ~
\end_inset

Hz was not used in the fit, and measurements of amplitude for frequency
 below 0.13
\begin_inset space ~
\end_inset

Hz were similarly omitted because for these frequencies there appeared to
 be significant fluctuations in recovery temperature caused by real changes
 in air temperature and not primarily changes in dynamic heating.
 The best-fit parameters so obtained were 
\begin_inset Formula $a=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestW[1], 2)}
\end_layout

\end_inset

, 
\begin_inset Formula $\tau_{1}=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestW[2], 2)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

s and 
\begin_inset Formula $\tau_{2}=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestW[3], 2)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

s; these values are the basis for the theoretical lines in Figs.
\begin_inset space ~
\end_inset

4 and 5.
\begin_inset Foot
status open

\begin_layout Plain Layout
The fit was constrained to keep 
\begin_inset Formula $a\geq0$
\end_inset

.
 Still smaller values of the 
\begin_inset Formula $\chi^{2}$
\end_inset

 were obtained for negative 
\begin_inset Formula $a$
\end_inset

, but this would be inconsistent with the assumed model of heat transfer
 to the wire.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename figure/checkW-1.pdf
	width 90text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
The ratio of the spectral amplitude for the measurement of recovery temperature
 ($T_m(t)$) from the heated Rosemount sensor to that for dynamic heating
 ($Q$), shown as the plotted data points.
 The green line is the prediction from the transfer function determined
 from the best-fit values matching the phase lag and amplitude ratio between
 these variables.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The phase shift leads to these conclusions:
\end_layout

\begin_layout Enumerate
A two-time-constant formula does not provide a very good representation
 of the low-frequency portion of the observations that is between 0.01 and
 0.04
\begin_inset space ~
\end_inset

Hz.
 This may indicate that still another time constant is involved in the response
 of this sensor and that the two-equation representation provided by Part
 1 Eqns.
\begin_inset space ~
\end_inset

(3) and (4) is incomplete.
\end_layout

\begin_layout Enumerate
The observed phase shift falls below 
\begin_inset Formula $-90^{\circ}$
\end_inset

 above about 0.3
\begin_inset space ~
\end_inset

Hz.
 This is impossible for a single-time-constant sensor but is possible, as
 the theoretical line shows, for a two-time-constant representation of the
 response, so it is conclusive that at least two time constants are involved.
 This also indicates that wrong-sign contributions to sensible-heat flux
 would be measured by this sensor above about 0.3
\begin_inset space ~
\end_inset

Hz.
\end_layout

\begin_layout Enumerate
The low value of 
\begin_inset Formula $a$
\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestW[1], 2)}
\end_layout

\end_inset

, indicates that the primary heat transfer from the wire is not to the air
 but to the support.
 For 
\begin_inset Formula $a$
\end_inset

 equal to zero, the differential equations TN Eq.
\begin_inset space ~
\end_inset

(3) and (4) do not separately constrain 
\begin_inset Formula $\tau_{1}$
\end_inset

 and 
\begin_inset Formula $\tau_{2}$
\end_inset

.
 The fit results show complete negative correlation for the errors in these
 parameters, so they cannot be determined independently.
 The result, however, is not equivalent to a single time constant, as demonstrat
ed by the measured phase shifts below 
\begin_inset Formula $-90^{\circ}$
\end_inset

.
 The solution to the differential equations with 
\begin_inset Formula $a=0$
\end_inset

 becomes
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
C_{1}=b\cos\zeta\left(\frac{-\omega\tau_{1}}{1+\omega^{2}\tau_{1}^{2}}\right)+b\sin\zeta\left(\frac{1}{1+\omega^{2}\tau_{1}^{2}}\right)
\]

\end_inset


\begin_inset Formula 
\[
C_{2}=b\cos\zeta\left(\frac{1}{1+\omega^{2}\tau_{1}^{2}}\right)+b\sin\zeta\left(\frac{\omega\tau_{1}}{1+\omega^{2}\tau_{1}^{2}}\right)
\]

\end_inset


\begin_inset Formula 
\begin{align*}
c & =\sqrt{C_{1}^{2}+C_{2}^{2}}=2b^{2}\frac{1+\omega^{2}\tau_{1}^{2}}{(1+\omega^{2}\tau_{1}^{2})^{2}}=2\left(\frac{1}{1+\omega^{2}\tau_{2}^{2}}\right)\left(\frac{1}{1+\omega^{2}\tau_{1}^{2}}\right)
\end{align*}

\end_inset


\begin_inset Formula 
\[
\tan\phi=(C_{1}/C_{2})=\frac{-\omega\tau_{1}\cos\zeta+\sin\zeta}{\cos\zeta+\omega\tau_{1}\sin\zeta}=\frac{\tan\zeta-\omega\tau_{1}}{1+\omega\tau_{1}\tan\zeta}=\frac{-\omega(\tau_{2}+\tau_{1})}{1-\omega^{2}\tau_{1}\tau_{2}}
\]

\end_inset

These equations show that, for any solution, the values of 
\begin_inset Formula $\tau_{1}$
\end_inset

 and 
\begin_inset Formula $\tau_{2}$
\end_inset

 can be exchanged and the solution will remain the same.
 The particular solution found was influenced by the initial parameters
 for the search function, but reversed value for 
\begin_inset Formula $\tau_{1}$
\end_inset

 and 
\begin_inset Formula $\tau_{2}$
\end_inset

 could be obtained for other initial conditions.
 Nevertheless, it appears that the best interpretation is that the support
 responds more slowly, with 
\begin_inset Formula $\tau_{2}=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestW[3], 2)}
\end_layout

\end_inset

, and the sensing wire responds faster with time constant 
\begin_inset Formula $\tau_{1}=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestW[2], 2)}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename figure/rfHeated-1.pdf
	width 90text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
The transfer function for the heated Rosemount sensor on the C-130 research
 aircraft, based on the best-fit parameters that match the observed phase
 shift relative to dynamic heating.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The transfer function for this sensor is shown in Fig.
\begin_inset space ~
\end_inset

4.
 It does not appear to be feasible to measure sensible-heat flux with this
 sensor, even with the correction procedures to be developed in the Appendix,
 because above about 1
\begin_inset space ~
\end_inset

Hz there does not appear to be enough signal to amplify by using the transfer
 function.
 Also, the phase shift is less than 
\begin_inset Formula $-90^{\circ}$
\end_inset

 above this frequency.
\end_layout

\begin_layout Standard
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
(this is the end of the section re the heated Rosemount sensor, excluded
 from the paper.)
\end_layout

\begin_layout Subsubsection
Comments on Sect.
\begin_inset space ~
\end_inset

2.4.2, Heated sensors
\end_layout

\begin_layout Standard
The first try was based on WECAN data, but the results did not seem to give
 a response dominated by dynamic-heating forcing.
 That code still resides in the .Rmd file, along with an early analysis based
 on limited SOCRATES data, but those were superceded by a set of flight
 segments from the SOCRATES and CSET experiments, and that is the data set
 used in the paper to characterize the HARCO sensor\SpecialChar endofsentence
 Procedures followed
 the pattern explained above for the unheated Rosemount sensor, and a transfer
 function for the HARCO was plotted as Fig.
\begin_inset space ~
\end_inset

4 in the paper using the same procedures.
 The fit provided by Eqs.
\begin_inset space ~
\end_inset

(17)–(19) has no theoretical basis, but it provides a reasonable fit to
 the observations and is a considerable improvement over the three-parameter
 fit.
 The variable 
\begin_inset Formula $\nu_{0}$
\end_inset

 was defined only to provide a dimensionless argument to the 
\begin_inset Formula $\log()$
\end_inset

 function.
\end_layout

\begin_layout Subsubsection
Comments on Sect.
 2.4.3, Expected dependence on flight conditions
\end_layout

\begin_layout Standard
The dependence attributed to 
\begin_inset CommandInset citation
LatexCommand citet
key "stickney1994goodrich"
literal "false"

\end_inset

 was obtained from my approximation to the central line in their Fig.
\begin_inset space ~
\end_inset

12.
 The uncertainty in that estimate is large; slopes ranging from about 
\begin_inset Formula $-0.6$
\end_inset

 to 
\begin_inset Formula $-0.75$
\end_inset

 fall within the uncertainty limits of the plot.
 
\begin_inset CommandInset citation
LatexCommand citet
key "collis1959two"
literal "false"

\end_inset

 and 
\begin_inset CommandInset citation
LatexCommand citet
key "khan2005fluid"
literal "false"

\end_inset


\color black
 indicate that the Nusselt number should vary as 
\begin_inset Formula $\mathrm{Re}^{0.5}$
\end_inset

 for a cylindrical wire, suggesting that 
\begin_inset Formula $\tau_{1}$
\end_inset

 should vary as 
\begin_inset Formula $\mathrm{Re}^{-0.5}$
\end_inset

, but that does appear to be outside the likely uncertainty limits in the
 referenced figure.
 It would seem appropriate to use Re at the sensor wire rather than the
 free-stream Re – i.e., use the airspeed, air density, and dynamic viscosity
 
\begin_inset Formula $\mu$
\end_inset

 evaluated for recovery conditions: 
\begin_inset Formula $V_{p}=\sqrt{1-\alpha_{r}}V$
\end_inset

, 
\begin_inset Formula $p_{p}=p+q\approx p(1+M^{2}/5)^{-2/7}$
\end_inset

, 
\begin_inset Formula $\rho_{p}=p_{p}/(R(273.15+T_{r}))$
\end_inset

, leading to
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\mathrm{Re}^{*}=\rho_{p}V_{p}d/\mu
\]

\end_inset

where the temperature dependence of 
\begin_inset Formula $\mu$
\end_inset

 is approximately proportional to 
\begin_inset Formula $\sqrt{273.15+T_{r}}$
\end_inset

.
 Because of this, the Stickney et al.
\begin_inset space ~
\end_inset

parameter 
\begin_inset Formula $Z$
\end_inset

 has almost the same temperature dependence, because 
\begin_inset Formula $Z=M\rho/\rho_{0}=V\rho/(\rho_{o}\sqrt{\gamma RT_{K}})$
\end_inset

 with 
\begin_inset Formula $T_{k}=T+273.15$
\end_inset

.
 It is then possible to compare the ratios of 
\begin_inset Formula $\mathrm{Re}^{*}$
\end_inset

 and 
\begin_inset Formula $Z$
\end_inset

 for different flight conditions.
 For 
\begin_inset Formula $Z=0.3,$
\end_inset

 
\begin_inset Formula $\mathrm{Re}^{*}$
\end_inset

 is about 75, so it is useful to normalize both to those values and then
 consider how the time constant would vary with either 
\begin_inset Formula $(Z/0.3)^{-0.68}$
\end_inset

 or 
\begin_inset Formula $(\mathrm{Re}^{*}/75)^{-0.5}.$
\end_inset

 Appropriate flight conditions against which to test this prediction were
 difficult to find, but one candidate was from the 
\begin_inset Quotes eld
\end_inset

DC3
\begin_inset Quotes erd
\end_inset

 project, flight 11, 21:00 to 22:00 UTC, a flight segment at about 11.5 km
 altitude.
 An estimate of 
\begin_inset Formula $\tau_{1}$
\end_inset

 from that flight leg was 
\begin_inset Formula $\tau_{1}=0.037$
\end_inset


\begin_inset space ~
\end_inset

s, while 
\begin_inset Formula $Z^{-0.68}$
\end_inset

 predicts 0.036 and 
\begin_inset Formula $\left(\mathrm{Re}^{*}\right)$
\end_inset


\begin_inset Formula $^{-0.5}$
\end_inset

 predicts about 0.033.
 The results aren't very different but they seem closer to the Stickney
 representation.
 Therefore, it seems better to stay with the Stickney representation, which
 was based on wind-tunnel measurements with the sensor rather than idealized-cyl
inder results.
 It was interesting that there did not seem to be a similar variation in
 
\begin_inset Formula $\tau_{2}$
\end_inset

; if anything, the results favored a smaller value.
 Using the expected dependence for the sensor is probably not appropriate
 for the support, so no change was suggested for the second time constant,
 but it would be useful to find more information on that time constant.
 
\color inherit
This would be a useful topic for future work.
\end_layout

\begin_layout Subsection
Sect.
 2.5, response to a step change
\end_layout

\begin_layout Standard
The VOCALS project provided a good opportunity to search for discontinuities
 topping the marine boundary layer because most flights included numerous
 climbs and descents through that structure.
 A large number of these were examined in a search for sharp transitions,
 but almost all showed evidence of mixing at the top and were not sharp
 as would be desired to test response to a step change.
 The case selected was the best case, and indeed the only good case, from
 about 50 examined.
 Some other projects were also considered, but good cases where the unheated
 Rosemount was in use were not found.
 It appears that this is a difficult way to test the response characteristics
 of the sensor, although other situations (terrestrial boundary layer, frontal
 surface, etc.) might provide better opportunities.
\end_layout

\begin_layout Subsection
Application to a 
\begin_inset Quotes eld
\end_inset

speed run
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Initial drafts of this paper included a section showing how the sensor response
 introduces hysteresis into measurements during a 
\begin_inset Quotes eld
\end_inset

speed run
\begin_inset Quotes erd
\end_inset

, where the airspeed changes during level flight and causes a change in
 dynamic heating.
 This material is included here but was excluded from the submitted version
 of the paper.
 
\end_layout

\begin_layout Standard
An example is shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:SRDW}
\end_layout

\end_inset

, where the airspeed was increased steadily in level flight from near the
 lower limit of the flight envelope to near the upper limit and then was
 decreased back to the starting value.
 A plot of recovery temperature should also increase and decrease as the
 dynamic heating changes, but with a lag caused by the sensor response.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\lang american
The assumed model provided by 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 leads to a prediction of the time lag.
 Because the assumed response of the support is characterized by a simple
 time constant, during the speed run the support will lag in temperature
 by 
\begin_inset Formula $\tau_{2}$
\end_inset

.
 Then, from 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

, 
\begin_inset Formula $T_{m}(t)$
\end_inset

 will lag by 
\begin_inset Formula $\tau_{1}$
\end_inset

 behind the temperature to which the sensor responds, which is 
\begin_inset Formula $aT(t)+(1-a)T(t-\tau_{2})$
\end_inset

.
 For a ramp input such that 
\begin_inset Formula $T(t)=T_{0}+kt$
\end_inset

, the solution to 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is that the measured temperature 
\begin_inset Formula $T_{m}(t)$
\end_inset

 lags 
\begin_inset Formula $T(t)$
\end_inset

 by 
\begin_inset Formula $\psi$
\end_inset

, so that 
\begin_inset Formula $T_{m}(t)=T_{0}+k(t-\psi)$
\end_inset

.
 Then
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
k\tau_{1}=a(T_{0}+kt)+(1-a)(T_{0}+k(t-\tau_{2})-T_{0}-kt+k\psi
\]

\end_inset


\end_layout

\begin_layout Plain Layout

\lang american
which requires the recovery-temperature lag to be
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\psi=\tau_{1}+(1-a)\tau_{2}\label{eq:delta}
\end{equation}

\end_inset


\end_layout

\end_inset

 This lag will produce hysteresis in the measured temperature during the
 speed run.
\end_layout

\begin_layout Standard

\lang american
\begin_inset ERT
status open

\begin_layout Plain Layout

<<SRDW, include=TRUE, fig.pos='t', fig.height=3.2, fig.cap='History of the airspeed
 during a  
\begin_inset Quotes eld
\end_inset

speed-run
\begin_inset Quotes erd
\end_inset

 maneuver where the airspeed varied during level flight over the available
 speed range of the aircraft.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Project <- 'DEEPWAVE'
\end_layout

\begin_layout Plain Layout

Flight <- 'rf15h'
\end_layout

\begin_layout Plain Layout

startTime <- 32300
\end_layout

\begin_layout Plain Layout

endTime <- 32815
\end_layout

\begin_layout Plain Layout

fname <- file.path(DataDirectory(), Project, '/', Project,
\end_layout

\begin_layout Plain Layout

                   Flight, '.nc', fsep = '')
\end_layout

\begin_layout Plain Layout

FI <- DataFileInfo(fname, LLrange = FALSE)
\end_layout

\begin_layout Plain Layout

iv <- which(grepl(
\begin_inset Quotes eld
\end_inset

^RT
\begin_inset Quotes erd
\end_inset

, FI$Variables))
\end_layout

\begin_layout Plain Layout

ProjDir <- Project
\end_layout

\begin_layout Plain Layout

VL <- c(
\end_layout

\begin_layout Plain Layout

  'TASX',
\end_layout

\begin_layout Plain Layout

  'EWX',
\end_layout

\begin_layout Plain Layout

  'PSXC',
\end_layout

\begin_layout Plain Layout

  'RTX',
\end_layout

\begin_layout Plain Layout

  'RTH1',
\end_layout

\begin_layout Plain Layout

  'RTH2',
\end_layout

\begin_layout Plain Layout

  'RTF1',
\end_layout

\begin_layout Plain Layout

  'ATX',
\end_layout

\begin_layout Plain Layout

  'GGALT',
\end_layout

\begin_layout Plain Layout

  'PITCH',
\end_layout

\begin_layout Plain Layout

  'ADIFR',
\end_layout

\begin_layout Plain Layout

  'QCF',
\end_layout

\begin_layout Plain Layout

  'AKRD',
\end_layout

\begin_layout Plain Layout

  'WIC',
\end_layout

\begin_layout Plain Layout

  'QCXC'
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

VL <- c(VL, FI$Variables[iv])
\end_layout

\begin_layout Plain Layout

VL <- unique(VL)
\end_layout

\begin_layout Plain Layout

DSR <- getNetCDF (
\end_layout

\begin_layout Plain Layout

  sprintf ('%s%s/%s%s.nc', DataDirectory (),
\end_layout

\begin_layout Plain Layout

           ProjDir, Project, Flight),
\end_layout

\begin_layout Plain Layout

  VL,
\end_layout

\begin_layout Plain Layout

  Start = startTime,
\end_layout

\begin_layout Plain Layout

  End = endTime
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

DSR %>% select(Time, TASX) %>% 
\end_layout

\begin_layout Plain Layout

  selectTime(32310, 32700) %>% 
\end_layout

\begin_layout Plain Layout

  plotWAC()
\end_layout

\begin_layout Plain Layout

## Find the average Z: (but there is significant Mach number variation...)
\end_layout

\begin_layout Plain Layout

load('PAR.Rdata')
\end_layout

\begin_layout Plain Layout

rhozero <- 1013.25 * 100 / (287.05 * 288.15)
\end_layout

\begin_layout Plain Layout

Z <- MachNumber(DSR$PSXC, DSR$QCXC) * 100 * DSR$PSXC / 
\end_layout

\begin_layout Plain Layout

     (287.05 * (273.15 + DSR$ATX)) / rhozero
\end_layout

\begin_layout Plain Layout

ParamS <- Param1
\end_layout

\begin_layout Plain Layout

ParamS$tau1 <- ParamS$tau1 * (mean(Z, na.rm = TRUE) / 0.3) ^ -0.6
\end_layout

\begin_layout Plain Layout

ParamS$tau2 <- ParamS$tau2 * (mean(Z, na.rm = TRUE) / 0.3) ^ -0.6
\end_layout

\begin_layout Plain Layout

ParamHZ <- Param1
\end_layout

\begin_layout Plain Layout

ParamHZ$tau1 <- ParamHZ$tau1 * (mean(Z, na.rm = TRUE) / 0.3) ^ -0.6
\end_layout

\begin_layout Plain Layout

ParamHZ$tau2 <- ParamHZ$tau2 * (mean(Z, na.rm = TRUE) / 0.3) ^ -0.6
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\lang american
\begin_inset Branch Extra
inverted 0
status open

\begin_layout Standard

\lang american
\begin_inset ERT
status open

\begin_layout Plain Layout

<<XTR>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

ParamWZ <- ParamW
\end_layout

\begin_layout Plain Layout

ParamWZ$tau1 <- ParamW$tau1 * (mean(Z, na.rm = TRUE) / 0.3) ^ -0.6
\end_layout

\begin_layout Plain Layout

ParamWZ$tau2 <- ParamW$tau2 * (mean(Z, na.rm = TRUE) / 0.3) ^ -0.6
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\lang american
For the Rosemount 102E4AL, the fitted values from Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-unheated-Rosemount"
plural "false"
caps "false"
noprefix "false"

\end_inset

 would then cause a lag of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(Param1$tau1+(1-Param1$a)*Param1$tau2, 2)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

s, which is hard to detect.
\begin_inset Branch Extra
inverted 0
status open

\begin_layout Standard

\lang american
For the heated Rosemount the expected lag is about 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestW[2]+(1-bestW[1])*bestW[3], 2)}
\end_layout

\end_inset

.
\end_layout

\end_inset

For the heated HARCO sensor the predicted lag would be 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestSH[2]+(1-bestSH[1])*bestSH[3], 2)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

s, which is easily observed.
\end_layout

\end_inset

Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:SRRTH1delay}
\end_layout

\end_inset

a shows this hysteresis, which appears as the difference between the segment
 with increasing speed and that with decreasing speed.
\begin_inset Note Note
status open

\begin_layout Plain Layout

\lang american
The delay can be estimated by shifting the measurements later in time and
 repeating the fit to search for the smallest standard deviation about the
 fitted line.
 The smallest standard deviation occurs for a shift of 2.225
\begin_inset space ~
\end_inset

s, larger than the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(ParamHZ$tau1+(1-ParamHZ$a)*ParamHZ$tau2, 2)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

s expected from the phase-lag analysis.
\end_layout

\end_inset

 A correction based on simply shifting the measurements in time works reasonably
 but doesn't take into account that the Mach number and hence the time parameter
s vary significantly during the speed run.
 A better test of the time-response parameters is to apply the first correction
 scheme outlined in the Appendix to the measurements, with varying response
 parameters dependent on the Mach number.
 The specific correction equation used is Eq.
\begin_inset space ~
\end_inset

(A2) for the heated sensor.
 Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:srRTH1delay}
\end_layout

\end_inset

b shows that the delay is mostly removed by this procedure.
 The residual standard deviation about the regression fit for recovery temperatu
re as a function of 
\begin_inset Formula $V^{2}/(2C_{p})$
\end_inset

 is reduced from 
\begin_inset Formula $0.26^{\circ}$
\end_inset

C before correction to 
\begin_inset Formula $0.10^{\circ}$
\end_inset

C after correction.
 The minimum standard deviation results from increasing the time constants
 an additional 10%, so measurements from this speed-run maneuver are consistent
 with the predicted time response as found in Sect.
\begin_inset space ~
\end_inset

2.4 of the paper to within about this uncertainty.
\end_layout

\begin_layout Standard

\lang american
\begin_inset ERT
status open

\begin_layout Plain Layout

<<SRnodelay, include=FALSE, fig.cap='The recovery temperature measured by
 a heated HARCO sensor during the speed-run maneuver shown in the previous
 figure.
 The abscissa is the dynamic-heating term without the recovery factor, where
 $V$ is the airspeed and $Cp$ is the specific heat at constant pressure.
 The measurements while the airspeed was increasing are shown by the green
 line and those for decreasing airspeed by the red line.
 The dashed orange line indicates the regression fit, with standard deviation
 about the fit of 0.26$^{
\backslash

\backslash
circ}$C.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Cp <- SpecificHeats (DSR$EWX / DSR$PSXC)[, 1]
\end_layout

\begin_layout Plain Layout

DSR$X <- DSR$TASX ^ 2 / (2 * Cp)
\end_layout

\begin_layout Plain Layout

Rate <- 1
\end_layout

\begin_layout Plain Layout

if (grepl('h', Flight)) {
\end_layout

\begin_layout Plain Layout

  Rate <- 25
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

DSR$RT <- DSR$RTH1
\end_layout

\begin_layout Plain Layout

DSS <- DSR
\end_layout

\begin_layout Plain Layout

DSR <- DSR %>% selectTime(32310, 32700)
\end_layout

\begin_layout Plain Layout

DSR <- transferAttributes(DSS, DSR)
\end_layout

\begin_layout Plain Layout

cf <- coef(fm <- lm (RT ~ X, data = DSR))
\end_layout

\begin_layout Plain Layout

rms <- summary(fm)$sigma
\end_layout

\begin_layout Plain Layout

RTSEL <- 'RTH1'
\end_layout

\begin_layout Plain Layout

xp <- c(min(DSR$X, na.rm = TRUE), max(DSR$X, na.rm = TRUE))
\end_layout

\begin_layout Plain Layout

yp <- cf[1] + cf[2] * xp
\end_layout

\begin_layout Plain Layout

d <- data.frame(xp = xp, yp = yp)
\end_layout

\begin_layout Plain Layout

Xlab <- expression(paste(V ^ 2, '/(2', C[p], ')', sep = ''))
\end_layout

\begin_layout Plain Layout

dX <- c(0, diff(DSR$X))
\end_layout

\begin_layout Plain Layout

dXS <- SmoothInterp(dX)
\end_layout

\begin_layout Plain Layout

DSR$RT2 <- DSR$RT
\end_layout

\begin_layout Plain Layout

DSR$RT1 <- DSR$RT
\end_layout

\begin_layout Plain Layout

DSR$RT2[dXS <= 0] <- NA  # Don't plot decreasing-speed as green
\end_layout

\begin_layout Plain Layout

DSR$RT1[dXS >= 0] <- NA
\end_layout

\begin_layout Plain Layout

delay <- 0
\end_layout

\begin_layout Plain Layout

g <- ggplot (data = DSR, aes(x = X, y = RT))
\end_layout

\begin_layout Plain Layout

if (Rate == 1) {
\end_layout

\begin_layout Plain Layout

  g <- g + geom_point(colour = 'blue')
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(aes(y = RT1, colour = 'decreasing'),
\end_layout

\begin_layout Plain Layout

                   na.rm = TRUE,
\end_layout

\begin_layout Plain Layout

                   lwd = 1.1)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(aes(y = RT2, colour = 'increasing'),
\end_layout

\begin_layout Plain Layout

                   lwd = 1.1,
\end_layout

\begin_layout Plain Layout

                   na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(
\end_layout

\begin_layout Plain Layout

  data = d,
\end_layout

\begin_layout Plain Layout

  aes(x = xp, y = yp),
\end_layout

\begin_layout Plain Layout

  colour = 'darkorange',
\end_layout

\begin_layout Plain Layout

  lwd = 1.5,
\end_layout

\begin_layout Plain Layout

  lty = 2
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

# g <-
\end_layout

\begin_layout Plain Layout

#  g + ggtitle(sprintf(
\end_layout

\begin_layout Plain Layout

#    'sensor is %s; fit coefficients %.1f %.2f rms %.3f; no delay',
\end_layout

\begin_layout Plain Layout

#    RTSEL,
\end_layout

\begin_layout Plain Layout

#    cf[1],
\end_layout

\begin_layout Plain Layout

#    cf[2],
\end_layout

\begin_layout Plain Layout

#    rms
\end_layout

\begin_layout Plain Layout

#  ))
\end_layout

\begin_layout Plain Layout

g <- g + scale_colour_manual (
\end_layout

\begin_layout Plain Layout

  name = 'airspeed: ',
\end_layout

\begin_layout Plain Layout

  values = c("increasing" = "forestgreen", "decreasing" = "blue")
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

# print (sprintf('RTX is %s; fit coefficients %.3f %.3f rms %.2f; delay %d
 ms',
\end_layout

\begin_layout Plain Layout

#   RTSEL, cf[1], cf[2], rms, input$sliderSR))
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  g + ylab(expression(paste('Recovery Temperature [', degree, 'C]'))) +
 
\end_layout

\begin_layout Plain Layout

  xlab(Xlab) + 
\end_layout

\begin_layout Plain Layout

  theme_WAC(1)
\end_layout

\begin_layout Plain Layout

g1 <- g + theme(plot.title = element_text(size = 12))
\end_layout

\begin_layout Plain Layout

DXX <- DSR  ## save for the next chunk
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\lang american
\begin_inset ERT
status open

\begin_layout Plain Layout

<<srRTH1delay, include=TRUE, fig.height=3.3, fig.width=6.5, fig.cap='The recovery
 temperature as measured by a heated HARCO sensor during the speed-run maneuver
 shown in the previous figure (a) and the same measurement after correction
 (b).
 The abscissa is the dynamic-heating term without the recovery factor, where
 $V$ is the airspeed and $Cp$ is the specific heat at constant pressure.
 The measurements while the airspeed was increasing are shown by the green
 lines and those for decreasing airspeed by the blue lines.
 The dashed orange lines indicate the regression fits, with standard deviation
 about the fit of 0.26$^{
\backslash

\backslash
circ}$C (uncorrected) and 0.10$^{
\backslash

\backslash
circ}$C (after correction).'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

delay <- -2200
\end_layout

\begin_layout Plain Layout

DSR <- DSS
\end_layout

\begin_layout Plain Layout

rhozero <- 1013.25 * 100 / (287.05 * 288.15)
\end_layout

\begin_layout Plain Layout

bestSH <- c(0.0, 0.05849842, 1.28791645)
\end_layout

\begin_layout Plain Layout

MRHO <- MachNumber(DSR$PSXC, DSR$QCXC) * DSR$PSXC * 100 / 
\end_layout

\begin_layout Plain Layout

        (287.05 * (273.15 + DSR$ATX)) / rhozero
\end_layout

\begin_layout Plain Layout

a <- bestSH[1]
\end_layout

\begin_layout Plain Layout

tau1 <- bestSH[2] * (0.3 / MRHO) ^ 0.6  ## Note that these are variable
\end_layout

\begin_layout Plain Layout

tau2 <- bestSH[3] * (0.3 / MRHO) ^ 0.6
\end_layout

\begin_layout Plain Layout

## RT is the working solution
\end_layout

\begin_layout Plain Layout

Rate <- attr (DSR, 'Rate')
\end_layout

\begin_layout Plain Layout

DSR$DTMDT <- c(0, diff(DSR$RTH1, 2), 0) * Rate / 2
\end_layout

\begin_layout Plain Layout

DSR$DTM2DT2 <- (c(diff(DSR$RTH1), 0) - c(0, diff(DSR$RTH1))) * Rate^2
\end_layout

\begin_layout Plain Layout

DSR$RT <- (tau1 + tau2) * DSR$DTMDT + DSR$RTH1 + tau1 * tau2 * DSR$DTM2DT2
\end_layout

\begin_layout Plain Layout

# DSR$RT <- ShiftInTime(DSR[, RTSEL], .rate=Rate, .shift = delay)
\end_layout

\begin_layout Plain Layout

DSR <- DSR %>% selectTime(32310, 32700)
\end_layout

\begin_layout Plain Layout

DSR <- transferAttributes(DSS, DSR)
\end_layout

\begin_layout Plain Layout

N <- 2^13  ## encompasses the speed run
\end_layout

\begin_layout Plain Layout

Nby2 <- N / 2
\end_layout

\begin_layout Plain Layout

N1 <- (N - nrow(DSR)) %/% 2
\end_layout

\begin_layout Plain Layout

N2 <- N - nrow(DSR) - N1
\end_layout

\begin_layout Plain Layout

RTH1 <- c(rep(DSR$RTH1[1], N1), DSR$RTH1, rep(DSR$RTH1[nrow(DSR)], N2))
\end_layout

\begin_layout Plain Layout

ff1 <- fft(RTH1)
\end_layout

\begin_layout Plain Layout

RTH <- Re(fft(ff1, inverse=TRUE)) / N
\end_layout

\begin_layout Plain Layout

df <- Rate / N
\end_layout

\begin_layout Plain Layout

frq <- c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
\end_layout

\begin_layout Plain Layout

fr <- log(frq[1:(Nby2+1)])
\end_layout

\begin_layout Plain Layout

## Get the transfer function from the fitted parameterized form:
\end_layout

\begin_layout Plain Layout

## (Coefficients are transferred from where they are used in the main paper:)
\end_layout

\begin_layout Plain Layout

cfHARCO <- c(-155.20736, -62.80924, -6.35164, 67.17185)
\end_layout

\begin_layout Plain Layout

cfrHARCO <- c(0.160796040, -0.136460209, -0.076042545, -0.030920784, -0.003244361)
\end_layout

\begin_layout Plain Layout

Ph <- cfHARCO[1] + cfHARCO[2] * fr + 
\end_layout

\begin_layout Plain Layout

           cfHARCO[3] * fr^2 + cfHARCO[4] * atan(frq[1:(Nby2+1)])
\end_layout

\begin_layout Plain Layout

Ph[1] <- 0
\end_layout

\begin_layout Plain Layout

G <- cfrHARCO[1] + fr * (cfrHARCO[2] + fr * fr * (cfrHARCO[3] + 
\end_layout

\begin_layout Plain Layout

           fr * (cfrHARCO[4] + fr * cfrHARCO[5])))
\end_layout

\begin_layout Plain Layout

G[frq[1:length(fr)] < 0.024] <- 1
\end_layout

\begin_layout Plain Layout

G[frq[1:length(fr)] > 2] <- G[which.min(abs(frq-2))]
\end_layout

\begin_layout Plain Layout

H <- rep(complex(modulus=0), N)
\end_layout

\begin_layout Plain Layout

H[1:(Nby2+1)] <- complex(modulus=G, argument=Ph * pi / 180)
\end_layout

\begin_layout Plain Layout

H[(Nby2+2):N] <- rev(Conj(H[2:Nby2]))
\end_layout

\begin_layout Plain Layout

RTC <- Re(fft(ff1 / H, inverse = TRUE)) / N
\end_layout

\begin_layout Plain Layout

DSR$RTC <- RTC[(N1+1):(N-N2)]
\end_layout

\begin_layout Plain Layout

cf <- coef(fm <- lm (RT ~ X, data = DSR))
\end_layout

\begin_layout Plain Layout

xp <- c(min(DSR$X, na.rm = TRUE), max(DSR$X, na.rm = TRUE))
\end_layout

\begin_layout Plain Layout

yp <- cf[1] + cf[2] * xp
\end_layout

\begin_layout Plain Layout

d <- data.frame(xp = xp, yp = yp)
\end_layout

\begin_layout Plain Layout

rms <- summary(fm)$sigma
\end_layout

\begin_layout Plain Layout

DSR$RT2C <- DSR$RT
\end_layout

\begin_layout Plain Layout

DSR$RT1C <- DSR$RT
\end_layout

\begin_layout Plain Layout

DSR$RT2C[dXS <= 0] <- NA  # Don't plot decreasing-speed as green
\end_layout

\begin_layout Plain Layout

DSR$RT1C[dXS >= 0] <- NA
\end_layout

\begin_layout Plain Layout

# DXX$RT1C <- DSR$RT1C
\end_layout

\begin_layout Plain Layout

# DXX$RT2C <- DSR$RT2C
\end_layout

\begin_layout Plain Layout

# DXX$Time <- DXX$X
\end_layout

\begin_layout Plain Layout

# g <- DXX %>% select(Time, RT1, RT2, RT1C, RT2C) %>%
\end_layout

\begin_layout Plain Layout

#              ggplotWAC(panels=2, labelP=c)'      uncorrected', 
\end_layout

\begin_layout Plain Layout

#              '      corrected'), labelL=c('decreasing', 'increasing'))
 + 
\end_layout

\begin_layout Plain Layout

#        xlab(Xlab) 
\end_layout

\begin_layout Plain Layout

g <- ggplot (data = DSR, aes(x = X, y = RT))
\end_layout

\begin_layout Plain Layout

if (Rate == 1) {
\end_layout

\begin_layout Plain Layout

  g <- g + geom_point(colour = 'blue')
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(aes(y = RT1C, colour = 'decreasing'),
\end_layout

\begin_layout Plain Layout

                   na.rm = TRUE,
\end_layout

\begin_layout Plain Layout

                   lwd = 1.2)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(aes(y = RT2C, colour = 'increasing'),
\end_layout

\begin_layout Plain Layout

                   lwd = 1.2,
\end_layout

\begin_layout Plain Layout

                   na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(
\end_layout

\begin_layout Plain Layout

  data = d,
\end_layout

\begin_layout Plain Layout

  aes(x = xp, y = yp),
\end_layout

\begin_layout Plain Layout

  colour = 'darkorange',
\end_layout

\begin_layout Plain Layout

  lwd = 1.5,
\end_layout

\begin_layout Plain Layout

  lty = 2
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  g + scale_colour_manual (
\end_layout

\begin_layout Plain Layout

    name = 'airspeed: ',
\end_layout

\begin_layout Plain Layout

    values = c("increasing" = "forestgreen", "decreasing" = "blue")
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

# print (sprintf('RTX is %s; fit coefficients %.3f %.3f rms %.2f; delay %d
 ms',
\end_layout

\begin_layout Plain Layout

#   RTSEL, cf[1], cf[2], rms, input$sliderSR))
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  g + ylab(expression(paste('Recovery Temperature [', degree, 'C]'))) +
 xlab(Xlab) + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

g2 <- g + theme(plot.title = element_text(size = 12))
\end_layout

\begin_layout Plain Layout

g1 <- g1 + theme(legend.position=c(0.99, 0.92))
\end_layout

\begin_layout Plain Layout

g2 <- g2 + theme(legend.position = 'none')
\end_layout

\begin_layout Plain Layout

g1 <- g1 + ylim(c(-11, 4.5))
\end_layout

\begin_layout Plain Layout

g2 <- g2 + ylim(c(-11, 4.5))
\end_layout

\begin_layout Plain Layout

g2 <- g2 + ylab('')
\end_layout

\begin_layout Plain Layout

g1 <- g1 + annotate('text', x=8, y=3, label='(a)', size=5)
\end_layout

\begin_layout Plain Layout

g2 <- g2 + annotate('text', x=17, y=3, label='(b)', size=5)
\end_layout

\begin_layout Plain Layout

grid.newpage()
\end_layout

\begin_layout Plain Layout

vp1 <- viewport(width=0.57, height=0.9, x=0.25, y=0.45)
\end_layout

\begin_layout Plain Layout

vp2 <- viewport(width=0.57, height=0.9, x=0.68, y=0.45)
\end_layout

\begin_layout Plain Layout

# grid.rect(0.5, 0.5, width = unit(5, "npc"), name = 'a', vp = vp1)
\end_layout

\begin_layout Plain Layout

# grid.rect(0.5, 0.5, width = unit(5, "npc"), name = 'b', vp = vp2)
\end_layout

\begin_layout Plain Layout

plot(g2, vp=vp2)
\end_layout

\begin_layout Plain Layout

plot(g1, vp=vp1)
\end_layout

\begin_layout Plain Layout

# grid.newpage()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The initial approach was to shift the measurements in time to minimize the
 standard deviation about the fit, but the problem with this is that the
 Mach number varies significantly during the speed run so the appropriate
 time shift should also vary significantly.
 A confusing and unresolved conflict with this measurement is that delaying
 the temperature measurements by 2.25
\begin_inset space ~
\end_inset

s produces the minimum residual standard deviation in the fit, but that
 is significantly longer than the predicted shift of about 1.35
\begin_inset space ~
\end_inset

s.
 There may be some additional timing error that affects the measurement,
 but none has been found.
 Inconsistency in these results led to omission of this evidence from the
 paper.
\end_layout

\begin_layout Section
Comments on Section 3: Correcting for Dynamic Heating
\end_layout

\begin_layout Subsection
The Digital Filter Coefficients
\end_layout

\begin_layout Standard
The paper presents only a cursory discussion of the digital filter used
 to correct dynamic heating for the response of the sensor.
 Here some additional details are included as well as the specific coefficients
 used.
 The filter was specified in the code chunk labeled 
\begin_inset Quotes eld
\end_inset

designFilter
\begin_inset Quotes erd
\end_inset

, following suggestions from 
\begin_inset CommandInset citation
LatexCommand citet
key "Press:1992:NRC:148286"
literal "false"

\end_inset

.
 These steps were followed:
\end_layout

\begin_layout Enumerate
The impulse function was found from the inverse Fourier transform of the
 transfer function.
 For 25
\begin_inset space ~
\end_inset

Hz measurements, the transfer function was evaluated at frequencies in the
 range 0–12.5
\begin_inset space ~
\end_inset

Hz with a resolution of (1/600)
\begin_inset space ~
\end_inset

Hz and at the corresponding negative frequencies.
 This solution is stored in a vector with frequencies in the order 0–12.5
\begin_inset space ~
\end_inset

Hz, then 
\begin_inset Formula $-12.5$
\end_inset

 to 
\begin_inset Formula $-(1/600)$
\end_inset

 Hz as needed for the inverse Fourier transform.
\end_layout

\begin_layout Enumerate
The resulting impulse function then has 15,000 values, but most except for
 those near the start and end of the sequence are very small.
 Therefore only the initial 101 and trailing 100 coefficients were retained
 and all others were set to zero.
 (For the slower heated sensor, a length of 301 samples was used.) Specifically,
 all values in the array representing the impulse function were set to zero
 for indices k with values 
\begin_inset Formula $M+2\leq k\leq N-M$
\end_inset

 where 
\begin_inset Formula $N$
\end_inset

=15000 is the length of the calculated impulse function and 
\begin_inset Formula $M=100$
\end_inset

 or 150 to leave 201 or 301 non-zero coefficients.
 This gave coefficients spanning about 8 s at 25
\begin_inset space ~
\end_inset

Hz for the unheated sensor and 12
\begin_inset space ~
\end_inset

s for the heated sensor, times long compared to the expected impulse response
 of the sensor.
 The sum of the coefficients obtained in this was was larger than 0.99, but
 to ensure proper normalization they were scaled to give a sum of unity.
\end_layout

\begin_layout Enumerate
Appropriate moving-average coefficients were then constructed by shifting
 the trailing negative-frequency components to the start of the array to
 give an eight-second or 12-s moving-average filter that represents the
 response of the sensor.
\end_layout

\begin_layout Enumerate
After filtering, the result then must be shifted backward in time to compensate
 for the 4-s or 6-s delays.
\end_layout

\begin_layout Standard
A sample of the approach used is listed below.
 For more details, see the 
\begin_inset Quotes eld
\end_inset

designFilter
\begin_inset Quotes erd
\end_inset

 code chunk.
\end_layout

\begin_layout LyX-Code
NP <- 15000  ## Assume q 10-min segment
\end_layout

\begin_layout LyX-Code
df <- 25 / NP  ## The frequency resolution
\end_layout

\begin_layout LyX-Code
frq <- c(seq(0, 12.5, by=df), seq(-12.5+df, -df, by=df))
\end_layout

\begin_layout LyX-Code
E <- LTphase(frq, P)  ## This function returns the gain and phase in deg.
\end_layout

\begin_layout LyX-Code
G <- complex(modulus=E$Amp, argument=E$Phase * pi / 180) # the transfer
 fn
\end_layout

\begin_layout LyX-Code
NG <- length(G)
\end_layout

\begin_layout LyX-Code
GT <- fft(G, inverse=TRUE) / NG  # get the impulse function
\end_layout

\begin_layout LyX-Code
## Limit to 200 coefficients (8 s at 25 Hz)
\end_layout

\begin_layout LyX-Code
Lshift <- 100  ## below, will need to shift by 100 40-ms samples
\end_layout

\begin_layout LyX-Code
GT[(Lshift + 2):(NP - Lshift)] <- complex(modulus=0)
\end_layout

\begin_layout LyX-Code
GTT <- GT[GT != complex(modulus=0)]
\end_layout

\begin_layout LyX-Code
## Reorder:
\end_layout

\begin_layout LyX-Code
GTT <- c(GTT[(Lshift + 2):length(GTT)], GTT[1:(Lshift + 1)])
\end_layout

\begin_layout LyX-Code
AR <- Arma(Re(GTT) / sum(Re(GTT)), 1) # Normalize to avoid <1% bias
\end_layout

\begin_layout LyX-Code
## Result is appropriate coefficients to use for filtering; 
\end_layout

\begin_layout LyX-Code
## e.g., if DF is data.frame with Q measured dynamic heating:
\end_layout

\begin_layout LyX-Code
DF$QF <- as.vector(signal::filter(AR, DF$Q)) ## standard R
\end_layout

\begin_layout LyX-Code
## the following is a function to shift in time:
\end_layout

\begin_layout LyX-Code
DF$QF <- ShiftInTime(DF$QF, .shift=-Lshift * 40, .rate=25)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<designFilter, include=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

load('PAR.Rdata')
\end_layout

\begin_layout Plain Layout

P <- Param1
\end_layout

\begin_layout Plain Layout

NP <- 15000  ## Assume 10-min segment
\end_layout

\begin_layout Plain Layout

df <- 25 / NP
\end_layout

\begin_layout Plain Layout

df1 <- 1 / NP
\end_layout

\begin_layout Plain Layout

frq <- c(seq(0, 12.5, by = df), seq(-12.5 + df,-df, by = df))
\end_layout

\begin_layout Plain Layout

frq1 <- c(seq(0, 0.5, by = df1), seq(-0.5 + df1,-df1, by = df1))
\end_layout

\begin_layout Plain Layout

NP <- length(frq)
\end_layout

\begin_layout Plain Layout

NP1 <- length(frq1)
\end_layout

\begin_layout Plain Layout

E <- LTphase(frq, P)
\end_layout

\begin_layout Plain Layout

EH <- LTphase(frq, ParamSH)
\end_layout

\begin_layout Plain Layout

EHB <- LTphase(frq, ParamSH)
\end_layout

\begin_layout Plain Layout

EG <- LTphase(frq, ParamSF)
\end_layout

\begin_layout Plain Layout

E1 <- LTphase(frq1, P)
\end_layout

\begin_layout Plain Layout

EH1 <- LTphase(frq1, ParamSH)
\end_layout

\begin_layout Plain Layout

EHB1 <- LTphase(frq1, ParamSH)
\end_layout

\begin_layout Plain Layout

EG1 <- LTphase(frq1, ParamSF)
\end_layout

\begin_layout Plain Layout

## --------------------------
\end_layout

\begin_layout Plain Layout

G <- complex(modulus = E$Amp, argument = E$Phase * pi / 180)
\end_layout

\begin_layout Plain Layout

NG <- length(G)
\end_layout

\begin_layout Plain Layout

GT <- fft(G, inverse = TRUE) / NG  # get the impulse function
\end_layout

\begin_layout Plain Layout

## Limit to 200 coefficients (8 s at 25 Hz)
\end_layout

\begin_layout Plain Layout

Lshift <- 100
\end_layout

\begin_layout Plain Layout

GT[(Lshift + 2):(NP - Lshift)] <- complex(modulus = 0)
\end_layout

\begin_layout Plain Layout

GTT <- GT[GT != complex(modulus = 0)]
\end_layout

\begin_layout Plain Layout

## Reorder:
\end_layout

\begin_layout Plain Layout

GTT <- c(GTT[(Lshift + 2):length(GTT)], GTT[1:(Lshift + 1)])
\end_layout

\begin_layout Plain Layout

AR <- signal::Arma(Re(GTT) / sum(Re(GTT)), 1) # Normalize to avoid <1% bias
\end_layout

\begin_layout Plain Layout

## --------------------------
\end_layout

\begin_layout Plain Layout

GG <- complex(modulus = EG$Amp, argument = EG$Phase * pi / 180)
\end_layout

\begin_layout Plain Layout

GTG <- fft(GG, inverse = TRUE) / NG  # get the impulse function
\end_layout

\begin_layout Plain Layout

GTG[(Lshift + 2):(NP - Lshift)] <- complex(modulus = 0)
\end_layout

\begin_layout Plain Layout

GTTG <- GTG[GTG != complex(modulus = 0)]
\end_layout

\begin_layout Plain Layout

## Reorder:
\end_layout

\begin_layout Plain Layout

GTTG <- c(GTTG[(Lshift + 2):length(GTTG)], GTTG[1:(Lshift + 1)])
\end_layout

\begin_layout Plain Layout

ARG <-   signal::Arma(Re(GTTG) / sum(Re(GTTG)), 1) # Normalize to avoid
 <1% bias
\end_layout

\begin_layout Plain Layout

## --------------------------
\end_layout

\begin_layout Plain Layout

GH <- complex(modulus = EH$Amp, argument = EH$Phase * pi / 180)
\end_layout

\begin_layout Plain Layout

NG <- length(GH)
\end_layout

\begin_layout Plain Layout

GTH <- fft(GH, inverse = TRUE) / NG  # get the impulse function
\end_layout

\begin_layout Plain Layout

## Limit to 300 coefficients (12 s at 25 Hz)
\end_layout

\begin_layout Plain Layout

LshiftH <- 150
\end_layout

\begin_layout Plain Layout

GTH[(LshiftH + 2):(NP - LshiftH)] <- complex(modulus = 0)
\end_layout

\begin_layout Plain Layout

GTTH <- GTH[GTH != complex(modulus = 0)]
\end_layout

\begin_layout Plain Layout

## Reorder:
\end_layout

\begin_layout Plain Layout

GTTH <- c(GTTH[(LshiftH + 2):length(GTTH)], GTTH[1:(LshiftH + 1)])
\end_layout

\begin_layout Plain Layout

ARH <- signal::Arma(Re(GTTH) / sum(Re(GTTH)), 1)
\end_layout

\begin_layout Plain Layout

## --------------------------
\end_layout

\begin_layout Plain Layout

GHB <- complex(modulus = EHB$Amp, argument = EHB$Phase * pi / 180)
\end_layout

\begin_layout Plain Layout

NG <- length(GHB)
\end_layout

\begin_layout Plain Layout

GTHB <- fft(GHB, inverse = TRUE) / NG  # get the impulse function
\end_layout

\begin_layout Plain Layout

## Limit to 300 coefficients (12 s at 25 Hz)
\end_layout

\begin_layout Plain Layout

LshiftH <- 150
\end_layout

\begin_layout Plain Layout

GTHB[(LshiftH + 2):(NP - LshiftH)] <- complex(modulus = 0)
\end_layout

\begin_layout Plain Layout

GTTHB <- GTHB[GTHB != complex(modulus = 0)]
\end_layout

\begin_layout Plain Layout

## Reorder:
\end_layout

\begin_layout Plain Layout

GTTHB <-   c(GTTHB[(LshiftH + 2):length(GTTHB)], GTTHB[1:(LshiftH + 1)])
\end_layout

\begin_layout Plain Layout

ARHB <- signal::Arma(Re(GTTHB) / sum(Re(GTTHB)), 1)
\end_layout

\begin_layout Plain Layout

## --------------------------
\end_layout

\begin_layout Plain Layout

G1 <- complex(modulus = E1$Amp, argument = E1$Phase * pi / 180)
\end_layout

\begin_layout Plain Layout

NG1 <- length(G1)
\end_layout

\begin_layout Plain Layout

GT1 <- fft(G1, inverse = TRUE) / NG1  # get the impulse function
\end_layout

\begin_layout Plain Layout

## Limit to 20 coefficients (20 s at 1 Hz)
\end_layout

\begin_layout Plain Layout

Lshift1 <- 10
\end_layout

\begin_layout Plain Layout

GT1[(Lshift1 + 2):(NP1 - Lshift1)] <- complex(modulus = 0)
\end_layout

\begin_layout Plain Layout

GTT1 <- GT1[GT1 != complex(modulus = 0)]
\end_layout

\begin_layout Plain Layout

## Reorder:
\end_layout

\begin_layout Plain Layout

GTT1 <- c(GTT1[(Lshift1 + 2):length(GTT1)], GTT1[1:(Lshift1 + 1)])
\end_layout

\begin_layout Plain Layout

AR1 <- signal::Arma(Re(GTT1) / sum(Re(GTT1)), 1)
\end_layout

\begin_layout Plain Layout

## --------------------------
\end_layout

\begin_layout Plain Layout

GH1 <- complex(modulus = EH1$Amp, argument = EH1$Phase * pi / 180)
\end_layout

\begin_layout Plain Layout

NG1 <- length(GH1)
\end_layout

\begin_layout Plain Layout

GTH1 <- fft(GH1, inverse = TRUE) / NG1  # get the impulse function
\end_layout

\begin_layout Plain Layout

LshiftH1 <- 10
\end_layout

\begin_layout Plain Layout

GTH1[(LshiftH1 + 2):(NP1 - LshiftH1)] <- complex(modulus = 0)
\end_layout

\begin_layout Plain Layout

GTTH1 <- GTH1[GTH1 != complex(modulus = 0)]
\end_layout

\begin_layout Plain Layout

GTTH1 <-   c(GTTH1[(LshiftH1 + 2):length(GTTH1)], GTTH1[1:(LshiftH1 + 1)])
\end_layout

\begin_layout Plain Layout

ARH1 <- signal::Arma(Re(GTTH1) / sum(Re(GTTH1)), 1)
\end_layout

\begin_layout Plain Layout

## --------------------------
\end_layout

\begin_layout Plain Layout

GHB1 <- complex(modulus = EHB1$Amp, argument = EHB1$Phase * pi / 180)
\end_layout

\begin_layout Plain Layout

NG1 <- length(GHB1)
\end_layout

\begin_layout Plain Layout

GTHB1 <- fft(GHB1, inverse = TRUE) / NG1  # get the impulse function
\end_layout

\begin_layout Plain Layout

LshiftH1 <- 10
\end_layout

\begin_layout Plain Layout

GTHB1[(LshiftH1 + 2):(NP1 - LshiftH1)] <- complex(modulus = 0)
\end_layout

\begin_layout Plain Layout

GTTHB1 <- GTHB1[GTHB1 != complex(modulus = 0)]
\end_layout

\begin_layout Plain Layout

GTTHB1 <- c(GTTHB1[(LshiftH1 + 2):length(GTTHB1)], GTTHB1[1:(LshiftH1 +
 1)])
\end_layout

\begin_layout Plain Layout

ARHB1 <- signal::Arma(Re(GTTHB1) / sum(Re(GTTHB1)), 1)
\end_layout

\begin_layout Plain Layout

## --------------------------
\end_layout

\begin_layout Plain Layout

GG1 <- complex(modulus = EG1$Amp, argument = EG1$Phase * pi / 180)
\end_layout

\begin_layout Plain Layout

NG1 <- length(GG1)
\end_layout

\begin_layout Plain Layout

GTG1 <- fft(GG1, inverse = TRUE) / NG1  # get the impulse function
\end_layout

\begin_layout Plain Layout

LshiftH1 <- 10
\end_layout

\begin_layout Plain Layout

GTG1[(LshiftH1 + 2):(NP1 - LshiftH1)] <- complex(modulus = 0)
\end_layout

\begin_layout Plain Layout

GTTG1 <- GTG1[GTG1 != complex(modulus = 0)]
\end_layout

\begin_layout Plain Layout

GTTG1 <- c(GTTG1[(LshiftH1 + 2):length(GTTG1)], GTTG1[1:(LshiftH1 + 1)])
\end_layout

\begin_layout Plain Layout

ARG1 <- signal::Arma(Re(GTTG1) / sum(Re(GTTG1)), 1)
\end_layout

\begin_layout Plain Layout

# save(AR, ARH, ARHB, ARG, AR1, ARH1, ARHB1, ARG1,
\end_layout

\begin_layout Plain Layout

#     Lshift, LshiftH, Lshift1, LshiftH1, file = 'AR.Rdata')
\end_layout

\begin_layout Plain Layout

## --------------------------
\end_layout

\begin_layout Plain Layout

# DF2$QF <- as.vector(signal::filter(AR, DF2$Q))
\end_layout

\begin_layout Plain Layout

# DF2$QF <- ShiftInTime(DF2$QF, .shift=(-(Lshift + 1) * 40), .rate = 25)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plotImpulse, include=TRUE, fig.height=4>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

layout(matrix(1:2, ncol=1), widths=c(8,8), heights=c(6.5,8))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1, oma=c(1.1,0,0,0))
\end_layout

\begin_layout Plain Layout

dP1 <- data.frame(Time = (1 : 100) * 0.04, R = Re(GT[1:100]), 
\end_layout

\begin_layout Plain Layout

                 H = 10*Re(GTH[1:100]))
\end_layout

\begin_layout Plain Layout

plotWAC(dP1, xlab='Time [s]', ylab='impulse response', lwd = c(2, 2), 
\end_layout

\begin_layout Plain Layout

        lty = c(1, 2), legend.position = NA)
\end_layout

\begin_layout Plain Layout

legend(2, 0.3, legend=c('Rosemount', 'HARCO x 10'), 
\end_layout

\begin_layout Plain Layout

       col=c('blue', 'forestgreen'), lwd=c(2,2), lty=c(1,2))
\end_layout

\begin_layout Plain Layout

abline(h=0, lty=2) 
\end_layout

\begin_layout Plain Layout

text(4, 0.3, labels='(a)', cex=1.5)
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

dP2 <- data.frame(Time = (0 : 200) * 0.04, R = Re(GTT), 
\end_layout

\begin_layout Plain Layout

                 H = 10 * Re(GTTH[51 :251]))
\end_layout

\begin_layout Plain Layout

plotWAC(dP2, xlab='Time [s]', ylab='filter coef.', lwd = c(2, 2), 
\end_layout

\begin_layout Plain Layout

        lty = c(1, 2), legend.position = NA)
\end_layout

\begin_layout Plain Layout

legend(0.5, 0.3, legend=c('Rosemount', 'HARCO x 10'), 
\end_layout

\begin_layout Plain Layout

       col=c('blue', 'forestgreen'), lwd=c(2,2), lty=c(1,2))
\end_layout

\begin_layout Plain Layout

abline(h=0, lty=2)
\end_layout

\begin_layout Plain Layout

text(8, 0.3, labels='(b)', cex=1.5)
\end_layout

\begin_layout Plain Layout

layout(matrix(1:1, ncol=1), widths=c(8), heights=c(5.5))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
The impulse response function found from the inverse Fourier transform of
 the transfer function for the unheated Rosemount 102E4AL sensor and for
 the heated HARCO sensor , and the filter functions determined from those
 impulse response functions.
\end_layout

\end_inset

(a) The impulse response function found from the inverse Fourier transform
 of the transfer function for the unheated Rosemount 102E4AL sensor (Rosemount)
 and for the heated HARCO sensor (HARCO), using the response parameters
 from Table
\begin_inset space ~
\end_inset

3 of the paper.
 The impulse response for the HARCO sensor is multiplied by 10.
\begin_inset Newline newline
\end_inset

(b) A filter function (moving-average coefficients spanning 8 s) obtained
 from the impulse response function.
 The filtered result must be shifted forward in time by 4 s to compensate
 for the delay introduced by the filter.
 The coefficients are multiplied by 10 for the HARCO sensor.
\begin_inset CommandInset label
LatexCommand label
name "fig:plotImpulse"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:plotImpulse}
\end_layout

\end_inset

a shows the impulse function for the unheated and heated sensors, and Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:plotImpulse}
\end_layout

\end_inset

b shows corresponding moving-average coefficients for a filter obtained
 from this impulse function.
\begin_inset Note Note
status open

\begin_layout Plain Layout

\lang american
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\lang american
It would be useful to check if the causal filter from only the coefficients
 shown in the first figure performs adequately, because that could be implemente
d in sequential processing.
\end_layout

\end_inset

 – checked this; doesn't work
\end_layout

\end_inset

 There is significant ringing in the filter for the unheated sensor because
 the shorter time constant for the sensor, 0.03
\begin_inset space ~
\end_inset

s, is smaller than the time between 25-Hz samples.
 The impulse response for the slower heated sensor leads to a much broader
 impulse response function.
 
\end_layout

\begin_layout Standard
The digital-filter coefficients and the transfer-function parameters on
 which they are based are stored in two data file, respectively 
\begin_inset Quotes eld
\end_inset

ARF.Rdata
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

PAR.Rdata
\begin_inset Quotes erd
\end_inset

.
 The following table documents the correspondence between the two files:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
aircraft / sensor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
ARMA coefficients
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Data Rate
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Parameter file
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
required time shift, samples
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C-130 / unheated
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
25 Hz
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Param1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C-130 / heated
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ARH
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
25 Hz
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ParamSH
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
150
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GV / unheated
\begin_inset Formula $^{*}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ARG
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
25 Hz
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ParamSF
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C-130 / unheated
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AR1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 Hz
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Param1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C-130 / heated
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ARH1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 Hz
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ParamSH
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GV / unheated
\begin_inset Formula $^{*}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ARG1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 Hz
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ParamSF
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Formula $^{*}$
\end_inset

The listed values for GV / unheated are not used in the paper because it
 is thought that they were not determined as well as for the C-130 / unheated
 sensor.
 The C-130 / unheated values are used instead.
\end_layout

\begin_layout Subsection
Other filtering methods 
\end_layout

\begin_layout Standard
Two other calculations can produce the appropriately filtered response to
 dynamic heating 
\begin_inset Formula $Q^{\prime}(t)$
\end_inset

:
\end_layout

\begin_layout Enumerate
Section
\begin_inset space ~
\end_inset

2.1 in the paper showed that the transfer function is represented reasonably
 by the solution to two coupled differential equations.
 Numerical integration of those equations can then produce the predicted
 response of the sensor to dynamic heating.
 The equations, revised to apply to dynamic heating, are these:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\frac{dQ_{qs}(t)}{dt}=\frac{Q(t)-Q_{qs}(t)}{\tau_{2}}
\]

\end_inset


\begin_inset Formula 
\[
\frac{dQ^{\prime}(t)}{dt}=\frac{\left\{ aQ(t)=(1-a)Q_{qs}(t)\right\} -Q^{\prime}(t)}{\tau_{1}}
\]

\end_inset

where the first equation describes the effect of dynamic heating on the
 support structure of the temperature sensor, leading to support-structure
 variations in temperature of 
\begin_inset Formula $Q_{qs}(t)$
\end_inset

 and the second describes the response of the sensing wire to the combined
 effects of this influence on the support temperature and the dynamic-heating
 term.
 This separation relies on the linearity of the underlying equations, which
 makes it possible to represent the effect of dynamic heating in isolation
 from real fluctuations in temperature.
 Euler integration of these differential equations led to erroneous results
 at high frequency arising from inadequate resolution in the integration,
 so a fourth-order Runge-Kutta integration with dynamic adjustment of the
 time step, as described by 
\begin_inset CommandInset citation
LatexCommand citet
key "cash1990variable"
literal "false"

\end_inset

, was used.
 
\end_layout

\begin_layout Enumerate
The response specified by the frequency-domain transfer function 
\begin_inset Formula $H(\nu)$
\end_inset

 can be realized by Fourier transforms, by first calculating the Fourier
 transform of the dynamic-heating signal (here denoted 
\begin_inset Formula $\hat{Q}(\nu)=\mathcal{F}^{-1}(Q(t))$
\end_inset

 where 
\begin_inset Formula $\mathcal{F}$
\end_inset

 denote the Fourier transform) and then using the inverse Fourier transform
 
\begin_inset Formula $\mathcal{F}^{-1}$
\end_inset

 to find the sensor response from 
\begin_inset Formula $Q^{\prime}(t)=\mathcal{F}^{-1}(H\{\nu)\hat{Q}(\nu))$
\end_inset

.
 
\end_layout

\begin_layout Standard
As noted in the paper, for 25
\begin_inset space ~
\end_inset

Hz measurements from the unheated sensor the numerical integration appeared
 to provide less satisfactory results than the other two methods, even with
 the step-adjusted numerical integration technique.
 The first time constant for that probe is comparable to the time between
 samples, apparently leading to accumulation of errors during the integration.
 To see if this was indeed the problem, the 25-Hz measurements were interpolated
 to 125-Hz samples, smoothed with a low-pass Butterworth filter with 25-Hz
 cutoff, and then integrated with 125-Hz resolution.
 The result was in much better agreement with the results from the other
 two methods, so this is consistent with attribution of the discrepancy
 to problems with the 25-Hz integration.
 (This was done in special separate steps, not incorporated into the RMarkdown
 file, so the code does not reflect this check.)
\end_layout

\begin_layout Standard
A special processing script, 
\begin_inset Quotes eld
\end_inset

CorrectTemperature.R
\begin_inset Quotes erd
\end_inset

, is included in the project archive.
 It will process an existing netCDF data file to incorprate this filtering,
 and it adds a new measurement of ambient temperature to the archive which
 corrects for the sensor response to dynamic heating as described in the
 paper.
\end_layout

\begin_layout Section
Comments on Section 4 (Flux of Sensible Heat)
\end_layout

\begin_layout Standard
Figure 10 was generated using some special code developed for this purpose,
 function 
\begin_inset Quotes eld
\end_inset

plotCS()
\begin_inset Quotes erd
\end_inset

 defined in the 
\begin_inset Quotes eld
\end_inset

initial3
\begin_inset Quotes erd
\end_inset

 code chunk.
 A related plot function is available from 
\begin_inset Quotes eld
\end_inset

Ranadu::flux()
\begin_inset Quotes erd
\end_inset

 but in order to combine the two plots from SOCRATES and CSET into one plot
 
\begin_inset Quotes eld
\end_inset

plotCS()
\begin_inset Quotes erd
\end_inset

 was used to place the appropriate plots into viewports that were passed
 to the function.
 There is an inactive remnant call to 
\begin_inset Quotes eld
\end_inset

flux()
\begin_inset Quotes erd
\end_inset

 in the 
\begin_inset Quotes eld
\end_inset

SOCp1
\begin_inset Quotes erd
\end_inset

 code chunk that was used originally but has been replaced by calls to plotCS().
 The earlier calls to 
\begin_inset Quotes eld
\end_inset

Ranadu:CohSpec)
\begin_inset Quotes erd
\end_inset

 were also replaced by direct calls to the 
\begin_inset Quotes eld
\end_inset

fft()
\begin_inset Quotes erd
\end_inset

 function in the same way as was done in 
\begin_inset Quotes eld
\end_inset

CohSpec()
\begin_inset Quotes erd
\end_inset

.
 The smoothing of the cospectrum discussed in the paper was accomplished
 using the 
\begin_inset Quotes eld
\end_inset

zoo::rollapply()
\begin_inset Quotes erd
\end_inset

 function to calculate the running means with various lengths.
\end_layout

\begin_layout Standard
Following the introductory discussion of the cospectrum, there was a now-suppres
sed section that plotted and discussed the quadrature spectrum.
 This section is included in the 
\begin_inset Quotes eld
\end_inset

Extra
\begin_inset Quotes erd
\end_inset

 branch in the .lyx file so it is accessible to anyone interested, but the
 material and discussion did not seem be contribute to the main theme of
 this section in any significant way so it has been omitted from the standard
 branch.
 It is worth noting, however, that the quadrature spectrum showed more indicatio
n of significant values than might have been expected, and some aspects
 of that distribution were not understood or explained convincingly in the
 suppressed material.
 An alternative to the correction procedure used in this section would be
 to transform between the cospectrum and quadrature spectrum according to
 the transfer-function phase angle, and that was explored but was abandoned
 when it did not appear to produce results consistent with the approach
 taken here.
 
\end_layout

\begin_layout Standard
The following are comments on the simulation at the end of this section.
 The generation of a variance spectrum with 
\begin_inset Formula $-5/3$
\end_inset

 slope (spectral variance vs frequency) started by using work from an earlier
 study, documented 
\begin_inset CommandInset href
LatexCommand href
name "here"
target "https://drive.google.com/open?id=1TIcrpjZ9BQRBaLle31zc_lzKafL4Xbee"
literal "false"

\end_inset

.
 In the course of working on this paper, it became evident that there is
 a better way: generate a Gaussian noise spectrum (flat vs.
\begin_inset space ~
\end_inset

frequency) and then modify the spectral density to have 
\begin_inset Formula $-5/3$
\end_inset

 slope before transforming back to the simulated measurement sequence.
 This was the approach used in the paper\SpecialChar endofsentence
 It is much faster than the original
 method used in the referenced document above.
 However, there appeared to be some advantages to the original method in
 terms of accuracy and consistency of results for different random sequences.
 Perhaps those advantages arose from generating originally at 50
\begin_inset space ~
\end_inset

Hz and then reducing the sample rate, or they may have arisen from generation
 as complete sine waves spanning the entire time period (which is unrealistic).
 In the code chunk 
\begin_inset Quotes eld
\end_inset

generate
\begin_inset Quotes erd
\end_inset

 in the .Rmd file, some truncation is included for frequency components smaller
 than 0.02
\begin_inset space ~
\end_inset

Hz, as a commented option.
 This seemed to improve the consistency of the results at the highest frequency
 and so was included in the latest simulation used in the paper.
 The code in 
\begin_inset Quotes eld
\end_inset

generate
\begin_inset Quotes erd
\end_inset

 may be useful elsewhere.
 The resulting time series are saved in 
\begin_inset Quotes eld
\end_inset

DF.Rdata
\begin_inset Quotes erd
\end_inset

 for that reason and to avoid needing to re-generate the series with each
 processing run.
\end_layout

\begin_layout Section
Comments on Appendix A: Correcting the Temperature
\end_layout

\begin_layout Subsection
Integrating the equations
\end_layout

\begin_layout Standard
When this was written it was developed from the differential equations,
 and it was only later realized that the solution is the same as that obtained
 by Inverarity by a quite different method.
 That is the primary reason that this was relegated to an appendix.
 The integration of Eqns.
\begin_inset space ~
\end_inset

(4) and (6) in the paper is straightforward, but the reduction to a single
 integration as in Eqn.
\begin_inset space ~
\end_inset

(A1) in the paper replaces one of the integrations with a more straightforward
 evaluation using a fourth-order central-difference representation for the
 derivative 
\begin_inset Formula $dT_{m}(t)/dt$
\end_inset

.
 The formula used for the derivative is:
\end_layout

\begin_layout LyX-Code
DTMDT <-  (c(0, 8*diff(TTRR, 2), 0) - 
\end_layout

\begin_layout LyX-Code
              c(0, 0, diff(TTRR, 4), 0, 0)) * Rate / 12
\end_layout

\begin_layout LyX-Code
## The second-order expression would be:
\end_layout

\begin_layout LyX-Code
## DTMDT <- c(0, diff(TTRR, 2), 0) * Rate / 2
\end_layout

\begin_layout Standard
Other possible representations of the derivative, including the second-order
 centered finite-difference expression above and Savitzky-Golay calculation
 of the first derivative, were also tried but the above choice worked best.
\end_layout

\begin_layout Standard
The use of the new routine 
\begin_inset Quotes eld
\end_inset

rk4.integrate()
\begin_inset Quotes erd
\end_inset

 was important in the case of 25-Hz measurements from the unheated sensor
 because the standard Runge-Kutta package for R (and an Euler integration
 as used by Inverarity) led to obvious numerical problems associated with
 the small time constant 
\begin_inset Formula $\tau_{1}$
\end_inset

 for the unheated sensor.
 
\end_layout

\begin_layout Standard
For the heated HARCO sensor, another finite-difference expression is needed
 for the second derivative.
 Because this sensor is slow, a second-order centered expression was adequate,
 so this expression was used for 
\begin_inset Formula $d^{2}T_{m}(t)/dt^{2}$
\end_inset

:
\end_layout

\begin_layout LyX-Code
DTM2DT2 <- (c(diff(RTH1), 0) - c(0, diff(RTH1))) * Rate^2
\end_layout

\begin_layout Subsection
Comparison to the Inverarity solution
\end_layout

\begin_layout Standard
\begin_inset CommandInset citation
LatexCommand citet
key "InverarityJTech2000"
literal "false"

\end_inset

 developed an equation equivalent to the following expression for the solution
 of the differential equations:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
T_{a}(t_{k})=T_{a}(t_{0})+\frac{\mathrm{1}}{2\alpha\delta t}\frac{dT_{m}(t_{k})}{dt}-\beta\Delta T_{m}(t_{k})+\gamma(1-\beta)I_{k}
\]

\end_inset

where 
\begin_inset Formula $\alpha=(A_{1}/\tau_{1}+A_{2}/\tau_{2}),$
\end_inset


\begin_inset Formula $\beta=\frac{1}{\alpha}(1/\tau_{1}+1/\tau_{2})-\frac{1}{\alpha^{2}\tau_{1}\tau_{2}}$
\end_inset

, 
\begin_inset Formula $\gamma=\frac{1}{\alpha\tau_{1}\tau_{2}}$
\end_inset

 and
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
I_{k}=e^{-\gamma\delta t}I_{k-1}+\frac{\delta t}{2}\left(e^{-\gamma\delta t}(T_{m}(t_{k-1})-T_{a}(t_{0}))+T_{m}(t_{k})-T_{a}(t_{0})\right)
\]

\end_inset

with 
\begin_inset Formula $I_{0}=0$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<Inverarity, include=TRUE, fig.cap='Comparison between the solution developed
 in the paper (green line, RT) and that proposed by Inverarity (red line,
 RT1).
 The original measurement is shown as TTRR (blue line), and the calculated
 temperature of the support is shown as Ts (cyan line).'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Get a sample time series to which to apply corrections:
\end_layout

\begin_layout Plain Layout

load(file='DT.Rdata')
\end_layout

\begin_layout Plain Layout

DT$RTI <- DT$TTRR
\end_layout

\begin_layout Plain Layout

Rate <- attr (DT, 'Rate')
\end_layout

\begin_layout Plain Layout

DT$DTMDT <- c(0, diff(DT$TTRR, 2), 0) * Rate / 2
\end_layout

\begin_layout Plain Layout

# DT$DTMDT <-  (c(0, 8*diff(DT$TTRR, 2), 0) - 
\end_layout

\begin_layout Plain Layout

#               c(0, 0, diff(DT$TTRR, 4), 0, 0)) * Rate / 12
\end_layout

\begin_layout Plain Layout

a <- 0.73
\end_layout

\begin_layout Plain Layout

tau1 <- 0.031
\end_layout

\begin_layout Plain Layout

tau2 <- 0.45
\end_layout

\begin_layout Plain Layout

A2 <- (1-a)/(1-tau1/tau2)
\end_layout

\begin_layout Plain Layout

A1 <- 1-A2
\end_layout

\begin_layout Plain Layout

alpha <- A1/tau1+A2/tau2
\end_layout

\begin_layout Plain Layout

beta <- (1 / tau1 + 1 / tau2) / alpha - 1/(alpha^2 * tau1 * tau2)
\end_layout

\begin_layout Plain Layout

gamma <- 1/(alpha*tau1*tau2)
\end_layout

\begin_layout Plain Layout

Ik <- 0
\end_layout

\begin_layout Plain Layout

for (k in 2:nrow(DT)) {
\end_layout

\begin_layout Plain Layout

  Ik <- exp(-gamma/Rate)*Ik + 
\end_layout

\begin_layout Plain Layout

        (1/(2*Rate))*(exp(-gamma/Rate)*(DT$TTRR[k]-DT$TTRR[1]) + 
\end_layout

\begin_layout Plain Layout

        DT$TTRR[k]-DT$TTRR[1]) 
\end_layout

\begin_layout Plain Layout

  DT$RTI[k] <- DT$TTRR[1] + (1/alpha)*DT$DTMDT[k] +
\end_layout

\begin_layout Plain Layout

                 beta * (DT$TTRR[k]-DT$TTRR[1]) +
\end_layout

\begin_layout Plain Layout

                 gamma * (1 - beta) * Ik
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

## Method-1 solution:
\end_layout

\begin_layout Plain Layout

DT$Ts <- DT$RT
\end_layout

\begin_layout Plain Layout

# DT$DTMDT <- (DT$DTMDT + c(0, DT$DTMDT[1:(nrow(DT)-1)])) / 2
\end_layout

\begin_layout Plain Layout

# DT$DTMDT <- as.vector (signal::filter(signal::sgolay(1, 3, m=1), DT$TTRR))
 * Rate
\end_layout

\begin_layout Plain Layout

fS <- function(y, i) {
\end_layout

\begin_layout Plain Layout

  # Eq.
 Ts3
\end_layout

\begin_layout Plain Layout

  ((tau1 * DT$DTMDT[i] + DT$TTRR[i] - (1 - a) * y)/a - y) / (Rate * tau2)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DT$Ts <- rk4.integrate (fS, DT$Ts[1], 1:nrow(DT))
\end_layout

\begin_layout Plain Layout

DT$RT <- (1 / a) * (tau1 * DT$DTMDT + DT$TTRR - (1 - a) * DT$Ts)
\end_layout

\begin_layout Plain Layout

## Get Inverarity solution:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DT %>% select(Time, TTRR, RT, RTI, Ts) %>% 
\end_layout

\begin_layout Plain Layout

  selectTime(114500, 114505) %>% 
\end_layout

\begin_layout Plain Layout

  plotWAC()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:Inverarity}
\end_layout

\end_inset

 shows the equivalence between this solution and the one proposed in this
 paper, for corresponding response functions.
\end_layout

\begin_layout Subsection
Fourier transformation
\end_layout

\begin_layout Standard
There are some standard considerations when dealing with Fourier transforms
 that are perhaps worth discussing here.
 The standard representation of the Fourier transform has frequencies ordered
 from 0 to the Nyquist frequency in steps given by 
\begin_inset Formula $\delta f=\mathrm{Rate/N}$
\end_inset

 where Rate is the sample rate (e.g., 25
\begin_inset space ~
\end_inset

Hz) and N is the length of the time series.
 These are followed by negative frequencies ranging from (
\begin_inset Formula $-\nu_{Nq}+\delta f)$
\end_inset

 to 
\begin_inset Formula $-\delta f$
\end_inset

, for a total length of 
\begin_inset Formula $N$
\end_inset

.
 When the transfer function is specified, it needs to be specified for these
 same frequencies.
 This is done conveniently by the 
\begin_inset Quotes eld
\end_inset

LTphase()
\begin_inset Quotes erd
\end_inset

 function if the first argument to the function is frequencies as specified.
 Then normal R operations can be used with the resulting complex vectors.
 The basic correction procedures is then concisely specified as
\end_layout

\begin_layout LyX-Code
RTcorr <- Re(fft(fft(RTm) / H, inverse = TRUE)) / N
\end_layout

\begin_layout Standard
where RTm is the original measurement, RTcorr is the corrected measurement,
 H is the transfer function, and N is the length of the time series.
\end_layout

\begin_layout Standard
This will fail if there are missing-value measurements in the time sequence,
 so interpolation is used routinely via the Ranadu routine 
\begin_inset Quotes eld
\end_inset

SmoothInterp()
\begin_inset Quotes erd
\end_inset

, but with argument .Length=0 to suppress smoothing.
\end_layout

\begin_layout Standard
Because of the cyclic nature of the Fourier transform, spurious effects
 often arise at the start and end of the time series unless modifications
 are introduced.
 In the cases presented in this paper, means and trends are removed and
 then the time series is padded at the start and end with zeroes.
 The results are then used only for a subset of the original valid time
 sequence.
 
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Note Note
status collapsed

\begin_layout Section
\begin_inset Note Note
status open

\begin_layout Section
TN Sect.
\begin_inset space ~
\end_inset

5: Correcting the cospectrum
\end_layout

\begin_layout Subsection
TN Sect.
\begin_inset space ~
\end_inset

5.1: Outline of the correction procedure
\end_layout

\begin_layout Plain Layout
Three methods are discussed.
 The first was coded into the 
\begin_inset Quotes eld
\end_inset

Ranadu
\begin_inset Quotes erd
\end_inset

 function 
\begin_inset Quotes eld
\end_inset

flux()
\begin_inset Quotes erd
\end_inset

 to provide an optional correction to the cospectrum.
 The procedure is to pass the time-response parameters to this function
 in a list (
\begin_inset Quotes eld
\end_inset

Par
\begin_inset Quotes erd
\end_inset

) so that the corresponding transfer function can be generated and applied
 to correct the cospectrum.
 Only the time-response parameters from the list are used; other characteristics
 (b, zeta, frq) are generated in 
\begin_inset Quotes eld
\end_inset

flux()
\begin_inset Quotes erd
\end_inset

 from the time-response parameters and the frequencies generated there.
\end_layout

\begin_layout Plain Layout
Here is some elaboration on the three methods:
\end_layout

\begin_layout Subsubsection
Integration of the differential equations
\end_layout

\begin_layout Plain Layout
The key decision made here regards the derivative 
\begin_inset Formula $\frac{dT_{m}(t)}{dt}$
\end_inset

 entering both the integrated equation for the support temperature and then
 the solution for 
\begin_inset Formula $T_{r}(t)$
\end_inset

.
 The examples use a centered finite-difference formula, either second or
 fourth order.
 The expressions used are:
\end_layout

\begin_layout LyX-Code
c(0, diff(Data$Tm, 2), 0) * Rate / 2  ## second-order
\end_layout

\begin_layout LyX-Code
## fourth-order alternative
\end_layout

\begin_layout LyX-Code
(c(0, 8*diff(Data$Tm, 2), 0) - 
\end_layout

\begin_layout LyX-Code
              c(0, 0, diff(Data$Tm, 4), 0, 0)) * Rate / 12
\end_layout

\begin_layout Plain Layout
Either choice involves some smoothing and so attenuates the variance at
 the highest frequency.
 The fourth-order option performs slightly better at 4–7
\begin_inset space ~
\end_inset

Hz.
\end_layout

\begin_layout Subsubsection
Fourier transformation
\end_layout

\begin_layout Plain Layout
Unless end-effects are treated, the cyclic nature of a Fourier representation
 introduces noise as a result of the jumps that occur at the end points.
 This has been addressed in two ways in the examples.
 First, for short-period time segments, the mean and slope of the series
 to be transformed is removed and then it is placed in the center of a larger
 series padded with zeroes at each end.
 After transformation, the original time period is extracted.
 Alternately, a longer series of real measurements, perhaps twice the desired
 duration, is used in the transformation and then the embedded portion represent
ing the times of interest is extracted.
 Preliminary evaluations indicate that these perform well, but (esp.
\begin_inset space ~
\end_inset

in the latter case) additional checks would be useful.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
TN Sect.
\begin_inset space ~
\end_inset

5.2: Application to examples
\end_layout

\begin_layout Plain Layout
The plots for these examples were all generated by 
\begin_inset Quotes eld
\end_inset

Ranadu::flux()
\begin_inset Quotes erd
\end_inset

, optionally with time-response parameters provided to use when calculating
 the corrected cospectrum.
 The corrected plots show the corrected cospectrum, but they also indicate
 (as a dashed brown line) the exceedance that was obtained before correction.
 For more information on 
\begin_inset Quotes eld
\end_inset

Ranadu::flux()
\begin_inset Quotes erd
\end_inset

 see R help for this function or the 
\begin_inset CommandInset href
LatexCommand href
name "“flux.Rd”"
target "https://github.com/NCAR/Ranadu/blob/WAC/man/flux.Rd"
literal "false"

\end_inset

 help file in the GitHub repository.
 Some additional aspects of this routine are described here because of their
 importance to this study:
\end_layout

\begin_layout Enumerate
The arguments include 
\begin_inset Quotes eld
\end_inset

scaleFactor
\begin_inset Quotes erd
\end_inset

, which is multiplied to the cospectrum to obtain a flux.
 For sensible heat, the scale factor is air density multiplied by specific
 heat at constant pressure (
\begin_inset Formula $\rho_{a}C_{p}$
\end_inset

), as shown by TN eq.
\begin_inset space ~
\end_inset

(1).
 This can be a vector of length equal to the number of rows in the data.frame
 supplied to 
\begin_inset Quotes eld
\end_inset

flux( )
\begin_inset Quotes erd
\end_inset

, and that is how it is supplied as used in the TN.
 It can also be a single value.
\end_layout

\begin_layout Enumerate
Units can be specified using the 
\begin_inset Quotes eld
\end_inset

bquote()
\begin_inset Quotes erd
\end_inset

 function.
 For the sensible-heat examples, the appropriate specification is 
\begin_inset Quotes eld
\end_inset

Units = bquote("W" ~ m ^ -2)
\begin_inset Quotes erd
\end_inset

.
 The units are also used in the title to the plot where the calculated flux
 is displayed.
\end_layout

\begin_layout Enumerate
The default number of smoothing bins (argument 
\begin_inset Quotes eld
\end_inset

smoothBins
\begin_inset Quotes erd
\end_inset

) is zero, and in that case no binning and smoothing will occur and the
 average-value dots will not appear on the plot.
 The option to plot an uncertainty ribbon (
\begin_inset Quotes eld
\end_inset

plotRibbon
\begin_inset Quotes erd
\end_inset

) will have no effect because this depends on the binning process to determine
 the standard deviation that is plotted in the ribbon.
\end_layout

\begin_layout Enumerate
In addition to the plot, 
\begin_inset Quotes eld
\end_inset

flux( )
\begin_inset Quotes erd
\end_inset

 also returns a data.frame containing the cospectrum and quadrature spectrum
 along with the exceedance distributions (called 
\begin_inset Quotes eld
\end_inset

ogives
\begin_inset Quotes erd
\end_inset

 in that data.frame).
 This makes it possible to construct plots in other formats.
 This may be useful in cases where the logarithmic plot generated by 
\begin_inset Quotes eld
\end_inset

flux( )
\begin_inset Quotes erd
\end_inset

 is not appropriate.
\end_layout

\begin_layout Enumerate
As plotted, the cospectrum is weighted by frequency, as is appropriate for
 a logarithmic abscissa.
 Although the units are listed as supplied, the true units for a plot in
 this format are those units per logarithm in frequency.
 This weighting would preserve the relationship between area and the contributio
n to variance if the ordinate axis were linear, but in this case of a logarithmi
c ordinate axis one must take the logarithmic scale into account when visually
 relating area on the plot to the contribution to variance.
\end_layout

\begin_layout Enumerate
\begin_inset Quotes eld
\end_inset

flux( )
\begin_inset Quotes erd
\end_inset

 calls 
\begin_inset Quotes eld
\end_inset

Ranadu::CohPhase( )
\begin_inset Quotes erd
\end_inset

 to calculate the cospectrum.
 That routine in turn calls the 
\begin_inset Quotes eld
\end_inset

fft( )
\begin_inset Quotes erd
\end_inset

 function from the R 
\begin_inset Quotes eld
\end_inset

stats
\begin_inset Quotes erd
\end_inset

 package to calculate the Fourier transforms and then finds the cospectrum
 and quadrature spectrum from the product of those transforms.
 The scaling convention is that the integral of the variance spectrum over
 positive frequencies will equal the total variance.
\end_layout

\begin_layout Enumerate
The argument 
\begin_inset Quotes eld
\end_inset

Par
\begin_inset Quotes erd
\end_inset

 should only be supplied if a corrected cospectrum using those parameters
 should be calculated and plotted, 
\emph on
and at present it is specific to temperature sensors.

\emph default
 The 
\begin_inset Quotes eld
\end_inset

flux( )
\begin_inset Quotes erd
\end_inset

 routine calculates the solution to the differential equations using only
 the three response parameters (a, tau1, tau2) in 
\begin_inset Quotes eld
\end_inset

Par
\begin_inset Quotes erd
\end_inset

, which should be a list containing at least those values.
 The solution does not call 
\begin_inset Quotes eld
\end_inset

LTphase()
\begin_inset Quotes erd
\end_inset

 but recalculates the equation solution specified by TN Eqs.
\begin_inset space ~
\end_inset

(7) and (8), and then it divides the calculated cospectrum by the gain (amplitud
e) of the transfer function to correct for the sensor time response.
 It also divides by the cosine of the phase of the transfer function.
\end_layout

\begin_layout Plain Layout
Some of the numbers quoted don't arise directly from the code but are from
 special evaluations performed by replication of segments of the code.
 For example, the fraction of the flux missed was evaluated by running the
 same code without the correction procedure and noting how the measured
 flux changed, and in the SOCRATES case the estimate of flux from frequencies
 above 1
\begin_inset space ~
\end_inset

Hz was estimated similarly by special execution of the 
\begin_inset Quotes eld
\end_inset

SOCp1
\begin_inset Quotes erd
\end_inset

 code chunk with the wavelength limit changed to 125
\begin_inset space ~
\end_inset

m.
 For true reproducibility, these steps should have been incorporated into
 the .Rmd file; perhaps that can be fixed eventually.
\end_layout

\begin_layout Subsection
TN Sect.
\begin_inset space ~
\end_inset

5.3: Correcting the temperature directly
\end_layout

\begin_layout Plain Layout
The method described here is applied to 25-Hz time series and will fail
 if applied to 1-Hz measurements because, for the short first time constant
 of the unheated Rosemount 102E4AL sensor, the Runge-Kutta integration becomes
 unstable and generates large errors if the time step is as large as one
 second.
 Appendix B discusses an alternate integration method that can be applied
 to 1 Hz files.
\end_layout

\begin_layout Plain Layout
There is a suppressed segment discussing the heated Rosemount sensor and
 the special considerations that arise because the best-fit value for the
 parameter 
\begin_inset Formula $a$
\end_inset

 is zero.
 That segment can be retrieved by activating the 
\begin_inset Quotes eld
\end_inset

Extra
\begin_inset Quotes erd
\end_inset

 branch in the LyX file or using the appropriate .Rmd file.
 The problem addressed there might have some interest because the best-fit
 result for the heated Rosemount led to modified differential equations
 that needed a different method for their solution.
\end_layout

\begin_layout Plain Layout
For Fourier transforms used here and elsewhere in the TN, the structure
 of the complex length-N vector produced by 
\begin_inset Quotes eld
\end_inset

fft()
\begin_inset Quotes erd
\end_inset

 is as follows:
\end_layout

\begin_layout Enumerate
The first entry is the constant zero-frequency value.
 For real-number input to fft(), this will be a real number (imaginary part
 zero).
\end_layout

\begin_layout Enumerate
The next N/2 values have positive frequencies in increments of 
\begin_inset Quotes eld
\end_inset

Rate / N
\begin_inset Quotes erd
\end_inset

 from a minimum frequency of 
\begin_inset Quotes eld
\end_inset

Rate / N
\begin_inset Quotes erd
\end_inset

 (e.g., for a 25-Hz file spanning 10 min with N = 15000, 
\begin_inset Formula $\delta\nu=1/600\,\mathrm{Hz}$
\end_inset

) up to the Nyquist frequency of 
\begin_inset Quotes eld
\end_inset

Rate/2
\begin_inset Quotes erd
\end_inset

.
 There value at the Nyquist frequency will be real (imaginary part zero)
 for real input to fft().
 That frequency only appears once; the value is the same for the frequencies
 +Rate/2 and 
\begin_inset Formula $-$
\end_inset

Rate/2 so it is not duplicated.
\end_layout

\begin_layout Enumerate
These are followed by the N/2-1 frequencies from 
\begin_inset Quotes eld
\end_inset

-Rate/2+
\begin_inset Formula $\delta\nu"$
\end_inset

 to 
\begin_inset Formula $-\delta\nu$
\end_inset

.
 For real-number input to the fft() function, these will be the complex
 conjugates of the corresponding values for positive frequencies.
\end_layout

\begin_layout Plain Layout
To match this sequence of frequencies, transfer functions are generated
 at frequencies specified, for example, by statements like this:
\end_layout

\begin_layout LyX-Code
f <- fft (DT$TTRR)
\end_layout

\begin_layout LyX-Code
N <- length(f)
\end_layout

\begin_layout LyX-Code
df <- Rate / N
\end_layout

\begin_layout LyX-Code
frq <- c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
\end_layout

\begin_layout Plain Layout
The function generating the transfer function (here, LTphase( )) must be
 valid for negative and zero frequency.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:bibliography"

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "WAC"
options "bibtotoc,plainnat"

\end_inset


\end_layout

\begin_layout Standard
\align center

\family sans
\color blue
– End of Memo –
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%
\backslash
attach{attachment}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%
\backslash
attachm{first
\backslash

\backslash
second}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

%
\backslash
cc{first attachment
\backslash

\backslash
second
\backslash

\backslash
3rd att}
\end_layout

\end_inset


\end_layout

\end_body
\end_document
