%% LyX 2.3.4.2 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[11pt,twoside,english,american,12pt,twoside,american]{article}
\usepackage{mathptmx}
\usepackage{helvet}
\renewcommand{\ttdefault}{lmtt}
\renewcommand{\familydefault}{\rmdefault}
\usepackage[T1]{fontenc}
\usepackage[letterpaper]{geometry}
\geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1.2in,rmargin=1in}
\usepackage{fancyhdr}
\pagestyle{fancy}
\setcounter{tocdepth}{2}
\setlength{\parskip}{\medskipamount}
\setlength{\parindent}{0pt}
\usepackage{color}
\definecolor{page_backgroundcolor}{rgb}{1, 1, 1}
\pagecolor{page_backgroundcolor}
\usepackage{babel}
\usepackage{float}
\usepackage{url}
\usepackage{amsmath}
\usepackage{esint}
\usepackage[authoryear]{natbib}
\PassOptionsToPackage{normalem}{ulem}
\usepackage{ulem}
\usepackage[unicode=true,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=true,pdfborder={0 0 0},pdfborderstyle={},backref=section,colorlinks=true]
 {hyperref}
\hypersetup{pdftitle={The Delayed Response of Airborne Thermometers, Part 1},
 pdfauthor={William A. Cooper},
 pdfsubject={Assessment of Measurements of Sensible-Heat Flux},
 pdfkeywords={sensible heat flux, temperature, time response of sensors, NCAR Research Aviation Facility, research aircraft, NCAR/EOL/RAF},
  linkcolor=blue, citecolor={blue}}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
%% Because html converters don't know tabularnewline
\providecommand{\tabularnewline}{\\}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\definecolor{fgcolor}{rgb}{0.345, 0.345, 0.345}\definecolor{messagecolor}{rgb}{0, 0, 0}\definecolor{warningcolor}{rgb}{1, 0, 1}\definecolor{errorcolor}{rgb}{1, 0, 0}\setlength{\headheight}{14.5pt}\usepackage{babel}


\definecolor{fgcolor}{rgb}{0.345, 0.345, 0.345}\definecolor{messagecolor}{rgb}{0, 0, 0}\definecolor{warningcolor}{rgb}{1, 0, 1}\definecolor{errorcolor}{rgb}{1, 0, 0}\usepackage{babel}
% macro for italic page numbers in the index
\newcommand{\IndexDef}[1]{\textit{#1}}
\newcommand{\IndexPrimary}[1]{\textbf{#1}}
% force a page break at the start of sections
\let\stdsection\section
\renewcommand{\section}{\newpage\stdsection}


% workaround for a makeindex bug,
% see sec. "Index Entry Order"
% only uncomment this when you are using makindex
%\let\OrgIndex\index 
%\renewcommand*{\index}[1]{\OrgIndex{#1}}
%\usepackage{splitidx}

% workaround for a makeindex bug,
% see sec. "Index Entry Order"
% only uncomment this when you are using makindex
\let\OrgIndex\index 
\renewcommand*{\index}[1]{\OrgIndex{#1}}
\usepackage{splitidx}
%\indexsetup{noclearpage}
\AtBeginDocument{
  \def\labelitemii{\(\circ\)}
  \def\labelitemiii{\(\triangleright\)}
}
\usepackage[font={normal,sl}]{caption}% set captions slanted

\IfFileExists{upquote.sty}{\usepackage{upquote}}{}

\newenvironment{lylist}[1]{\begin{list}{}
{\settowidth{\labelwidth}{#1}
\setlength{\leftmargin}{\labelwidth}
\addtolength{\leftmargin}{\labelsep}
\renewcommand{\makelabel}[1]{##1\hfil}}}{\end{list}}
\newcommand{\datetoday}{\number\day\space
     \ifcase\month\or January\or February\or March\or April\or May\or
     June\or July\or August\or September\or October\or November\or
     December\fi
     \space\number\year}
\newcommand{\EOLmemo}{\null \vskip-1.5truein
{\raggedright \textsf{\textsc{\large \textcolor{blue}{Earth Observing Laboratory}}}}\par
{\raggedright \textsf{\textsl{\textcolor{blue}{Memorandum:}}}} \par \vskip6pt
{\color{blue}{\hrule}}\par
\vskip0.3truein \leftline{\hskip \longindent \datetoday} \vskip0.2truein
\thispagestyle{empty}}
\newcommand{\attachm}[1]{\begin{lylist}{Attachments:00}
\item [Attachments:] {#1}
\end{lylist}}
\newcommand{\cc}[1]{\begin{lylist}{Attachments:00}
\item [cc:] {#1}
\end{lylist}}
\newcommand{\attach}[1]{\begin{lylist}{Attachments:00}
\item [Attachment:] {#1}
\end{lylist}}

\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\pagenumbering{gobble}
%\usepackage{xcolor}
%\providecolor{lyxadded}{rgb}{0,0,1}
%\providecolor{lyxdeleted}{rgb}{1,0,0}
%% Change tracking with ulem
%\DeclareRobustCommand{\lyxadded}[3]{{\color{lyxadded}{}#3}}
%\DeclareRobustCommand{\lyxdeleted}[3]{{\color{lyxdeleted}\sout{#3}}}

\makeatother

\begin{document}
\title{The Delayed Response of Airborne Thermometers:\\
Effect on Measuring the Flux of Sensible Heat}
\author{William A. Cooper and others...}
\date{\textcolor{red}{DRAFT} May 2020}

\maketitle
National Center for Atmospheric Research\\
Earth Observing Laboratory\\
Research Aviation Facility

\vfill{}
\cleardoublepage{} \pagenumbering{roman}

\renewcommand{\contentsname}{Table of Contents} \tableofcontents{}
\vfill{}
\eject

%% LyX 2.2.2 created this file.  For more info, see http://www.lyx.org/.

%\phantomsection \addcontentsline{toc}{section}{List of Figures}

\listoffigures

\clearpage %\phantomsection \addcontentsline{toc}{section}{List of Tables}

\listoftables

\clearpage{}

\renewcommand{\abstractname}{Preface and Abstract}\thispagestyle{plain}\begin{abstract}

Most measurements of temperature from research aircraft rely on sensors
that have inadequate response for the most demanding applications,
including especially measurements of the flux of sensible heat. This
paper discusses three aspects related to the time response of airborne
sensors. First, it uses a new method to characterize the time response
in terms of the frequency-domain transfer function; then it demonstrates
that standard data processing introduces errors in measured air temperature
by exaggerating the influence of dynamic heating on temperature sensors;
and finally it uses these results to propose a correction scheme to
improve measurements of the flux of sensible heat. Initially, the
transfer function describing the time response of two standard airborne
thermometers is found by observing the response to turbulent dynamic
heating in regions where that is the dominant cause of fluctuations
in the measurement. Differential equations for the response are consistent
with the observed transfer function, and the observations constrain
the parameters in those differential equations with low uncertainty.
The transfer functions can then be inverted to obtain corrected measurements
of the recovery temperature. They also predict how sensors will respond
to fluctuations in the recovery temperature, and those predictions
demonstrate that the sensed recovery temperature often does not respond
to high-frequency components imposed by dynamic heating. Therefore,
the common practice of subtracting the full dynamic heating to obtain
the air temperature from the recovery temperature introduces errors
that can be especially significant for heated sensors that are inherently
slow. The correction procedure developed in the last section is based
on using the transfer function to correct the measured recovery temperature
before correcting for dynamic heating. The over-arching goal is to
be able to assess errors that might be present in measurements of
the flux of sensible heat and to apply corrections for those errors.
Examples and a simulation illustrate that, without correction, measurements
of sensible-heat flux with an unheated Rosemount 102E4AL sensor can
be more than 30\% too low, but the proposed correction procedure removes
this error and results in reliable measurements with negligible error
attributable to the response time of the sensor.

\end{abstract}

\clearpage{}

\section*{Acknowledgements}

\label{sec:acknowledgements}

This material is based upon work supported by the National Center
for Atmospheric Research, which is a major facility sponsored by the
National Science Foundation under Cooperative Agreement No. 1852977.
Any opinions, findings and conclusions or recom-mendations expressed
in this publication are those of the author(s) and do not necessarily
reflect the views of the National Science Foundation. Measurements
used here (\citet{VOCALS2011}, \citet{SOCRATES2019}, \citet{WECAN2018})
were collected in research projects (\citet{wood2011vamos}, \citet{albrecht2019cloud},
\citet{mcfarquhar2014southern}) that used the NSF/NCAR research aircraft.
Project descriptions and additional information can be found at \href{https://www.eol.ucar.edu/field_projects/}{this URL}.
The referenced project teams conducted the experiments, with flight
operations, data acquisition and processing, and other project support
by the Research Aviation Facility, Earth Observing Laboratory, National
Center for Atmospheric Research (NCAR). The analyses reported here
were mostly performed using R (\citet{Rlanguage}), with \index{RStudio}RStudio
(\citet{RStudio2012}) and \index{knitr}knitr (\citet{Xie2014a,Xie2014b}).
Data files in netCDF format have been read and written using the R
\index{R language!package!ncdf4}package ``ncdf4''; cf.~\citet{ncdf4}.
Substantial use also was made of the \index{ggplot2}\index{R language!package!ggplot2}``ggplot2''
package (\citet{wickham2009}) for R, and extensive use was made of
the ``stats'' package, part of Core R\@. Some of the numerical
integrations used the Runge-Kutta function from the ``rmutil'' package
(\citet{runge.kutta}).

\thispagestyle{plain}\clearpage{}

\thispagestyle{empty}

\cleardoublepage{}

\pagenumbering{arabic}

\section{Introduction}

Research aircraft routinely measure air temperature, but the standard
sensors do not respond fast enough to meet many scientific needs.
In particular, measurements of the flux of sensible heat need faster
response than is typically available, as do measurements of near-discontinuous
changes such as those at the top of boundary layers or at cloud boundaries.
The measurement of sensible-heat flux requires, for the standard eddy-correlation
measurement, that temperature be measured with sufficient response
to resolve the spectrum of contributions to the flux. Various recent
reviews of priorities for research in atmospheric science have called
attention to the important roles that fluxes of various quantities
play in climate science and have advocated increased focus on those
fluxes; e.g., \citet{NAP6021}.

The basis for the measurement of the flux of sensible heat ($F_{s})$
by eddy correlation is this equation:

\begin{equation}
F_{s}=\rho_{a}\thinspace C_{p}\left\langle w^{\prime}T^{\prime}\right\rangle \label{eq:heatFlux}
\end{equation}
where $\rho_{a}$ is the density of air, $C_{p}$ the specific heat
of air at constant pressure, $w$ the vertical wind, and $T$ the
temperature. Primes in this equation denote fluctuations from the
mean and angle brackets denote an ensemble average. The measurement
thus depends on having a temperature sensor that can respond to the
range of fluctuations making significant contributions to the heat
flux. \citet{FrieheKhelif1992} suggested that 4--5~Hz is ``just
adequate'' (for flight at around 125~m/s) and that 25~Hz would
be desirable to resolve some interesting aspects of the temperature
structure. If the response of the temperature sensor is reduced or
shifted in phase at a particular frequency, an error will be introduced
into the measurement of sensible-heat flux. \citet{LawsonRodi1992}
argued that sensible-heat flux measured by some of the fastest sensors
then in common use produced measurements of sensible heat flux about
21\% too low compared to the measurements from their faster thermocouple-based
sensor. To avoid significant errors in this measurement, it therefore
is essential to characterize the time response of the temperature
sensor used and, where necessary, to apply corrections to compensate
for that response.

\section{Determining the Transfer Function\label{sec:theTransferFn}}

In this first section, the time response of some standard airborne
temperature sensors is characterized in terms of a frequency-domain
transfer function that relates the measurand (the recovery temperature)
to the measurement (the sensor output) in ways that are invertible.
Two coupled differential equations with three parameters are proposed
as the basis for this characterization, but the transfer function
is determined independent of those equations. Because the equations
predict a transfer function matching the observations, they provide
a useful generalization when the measurements are fitted to a three-parameter
equation consistent with those equations. The measured transfer functions
then are used in the sections that follow to access how common measurements
are affected.

<<initialization, echo=FALSE,include=FALSE>>=
## This chunk loads some needed R packages and defines a function
## used for the Laplace-transform solution of the governing
## differential equations.

setwd('~/RStudio/SensibleHeatFlux')
source('chunks/initialize.R')
opts_chunk$set(fig.height = 3.5, digits = 3)
thisFileName <- "SensibleHeatFluxPaper"
library(rmutil)      ## provides the runge-kutta integration function
CACHE <- FALSE
Directory <- DataDirectory ()
## standard values:
frq <- seq(0.01, 25, by = 0.01)
Phi <- rep(0, length(frq))
H <- rep(0, length(frq))
a <- 0.733 # 0.713
tau1 <- 0.0308  # 0.0335
tau2 <- 0.447
# The Laplace-transform solution, given the parameters in P:
LTphase <- function(f, P) {
  ## f=frequency; P=Param
  tau1 <- P$tau1
  tau2 <- P$tau2
  a <- P$a
  b <- sqrt(1 / (1 + (2 * pi * f * tau2) ^ 2))
  zeta <- -atan(2 * pi * f * tau2)
  C1 <- 1 / (1 + 4 * pi ^ 2 * f ^ 2 * tau1 ^ 2) *
    (-(a + (1 - a) * b * cos(zeta)) * 2 * pi * f * tau1 +
       (1 - a) * b * sin(zeta))
  C2 <- 1 / (1 + 4 * pi ^ 2 * f ^ 2 * tau1 ^ 2) *
    ((a + (1 - a) * b * cos(zeta)) +
       (1 - a) * b * sin(zeta) * 2 * pi * f * tau1)
  cTF <- sqrt(C1 ^ 2 + C2 ^ 2)
  phiTF <- atan2(C1, C2) * 180 / pi
  return(list('Amp' = cTF, 'Phase' = phiTF))
}

@

\subsection{Theory\label{subsec:Theory}}

The errors considered here apply to the measurement from the sensor,
the ``recovery temperature,'' rather than the final temperature
after correction for dynamic heating. Because the sensor cannot respond
to rapid fluctuations, the standard correction for dynamic heating
introduces errors into the measured air temperature that are then
amplified by a correction procedure. This will be addressed in the
next section, but for this reason the present section will discuss
only the recovery temperature.

\citet{PayneEtAl1994} provided a particularly illuminating analysis
of the expected response of a temperature sensor and developed their
results in terms of a transfer function. They represent the response
of the sensor in terms of two coupled differential equations, one
representing the temperature of the sensing wire and a second representing
the temperature of the structure that supports that wire. Their analysis
in terms of fundamental representation of the heat transport leads
to reasonable consistency with previous two-time-constant models like
that of \citet{mccarthy1973method} but poor agreement with the empirical
evidence regarding the time-response parameters in those models. They
note, however, that the empirical evidence is not as consistent or
convincing as would be desirable. One goal of the present work is
to develop a different and readily available method of determining
those parameters. 

Previous studies have demonstrated that a simple first-order exponential
equation with one time constant does not represent the time response
of airborne temperature sensors. The suggested explanation (\citet{NCAR_OpenSky_TECH-NOTE-000-000-000-064}
is that heat is transferred to the sensing wire of standard sensors
not only from the air but also from the supporting structure that
is in contact with the wire. Friehe and Khelif (\citet{FrieheKhelif1992}),
following other prior work including that of \citet{rodi1972analysis}
and \citet{mccarthy1973method}, suggested representing the two-time-constant
response via the following functional form:\\
\begin{equation}
\Theta(t)=A_{1}e^{-t/\tau_{1}}+A_{2}e^{-t/\tau_{2}}\label{eq:FrieheKehlif}
\end{equation}
where $\Theta(t)$ is the normalized history of the measured temperature
decaying from an initial value of unity to a final value of zero.
The sum of the coefficients $A_{1}$ and $A_{2}$ must then be 1.
The values for \{$A_{1},\,A_{2},\,\tau_{1},\,\tau_{2}$\} suggested
by \citet{FrieheKhelif1992} were \{0.65, 0.35, 0.09~s, 0.5~s\}.

Following the approach of \citet{PayneEtAl1994}, the time response
of the sensor will be represented by two coupled differential equations,
one that describes the response of the support on which the sensing
wire is wound to the air temperature and a second that describes the
response of the sensing wire to two inputs, one from the support and
one from the air. No attempt is made here to determine the parameters
from first principles as in \citet{PayneEtAl1994}, however; instead,
parameters entering the equations are determined empirically. The
equations are:\\
\begin{equation}
\frac{dT_{s}(t)}{dt}=\frac{T_{r}(t)-T_{s}(t)}{\tau_{2}}\label{eq:Ts}
\end{equation}
\begin{align}
\frac{dT_{m}(t)}{dt} & =\frac{a(T_{r}(t)-T_{m}(t))+(1-a)(T_{s}(t)-T_{m}(t))}{\tau_{1}}\label{eq:Tm}\\
= & \frac{\left\{ aT_{r}(t)+(1-a)T_{s}(t)\right\} -T_{m}(t)}{\tau_{1}}\nonumber 
\end{align}
where $T_{s}(t)$ is the temperature of the \uline{s}upport, $T_{m}(t)$
the \uline{m}easured temperature of the sensing wire, and $T_{r}(t)$
the true \uline{r}ecovery temperature that is the measurand. For
heat transfer to or from the wire, the parameter $a$ then represents
the fraction of the heat transferred by the air, while $(1-a)$ is
transferred to or from the support. The wire responds to the combined
transfers of heat with characteristic time constant $\tau_{1}$ while
the support structure responds to the air temperature more slowly,
with time constant $\tau_{2}$. It is straightforward to apply \eqref{eq:Ts}
and \eqref{eq:Tm} to changing but not necessarily discrete conditions,
so a general response to a given air-temperature history can be predicted
by numerical integration of these equations. Furthermore, the equations
are linear and, for constant values of the parameters, they are also
time-invariant (i.e., ``LTI'') descriptions of the response. As
a result, a particular signal for $T_{r}(t)$ can be decomposed into
its sinusoidal Fourier components and each will satisfy these equations
independently. The first equation does not involve the measurement,
so for a particular history of recovery temperature $T_{r}(t)$ the
support temperature can be determined solely by integration of \eqref{eq:Ts}.
Then, with $T_{s}(t)$ determined, \eqref{eq:Tm} can be integrated
to find the expected measurement $T_{m}(t)$ for a specified measurand
history $T_{r}(t)$. The inverse process, finding $T_{r}(t)$ from
the measurements $T_{m}(t)$, is also straightforward and only slightly
more complicated, as discussed in Appendix~\ref{sec:Correcting-the-Temperature}.

For a sinusoidal input these equations have analytic solutions after
any transient response from initial conditions has decayed. If the
actual recovery temperature is $T_{r}(t)=\sin\omega t$ where $\omega$
is the angular frequency, then the solutions for $T_{s}(t)$ and $T_{m}(t)$
are given by the following equations:

\begin{equation}
T_{s}(t)=b\sin(\omega t+\zeta)\label{eq:TsSolved}
\end{equation}
\begin{equation}
T_{m}(t)=c\sin(\omega t+\phi)=C_{1}\cos\omega t+C_{2}\sin\omega t\label{eq:TmSolved}
\end{equation}
\\
where\\
\[
b=\frac{1}{\sqrt{1+\omega^{2}\tau_{2}^{2}}}
\]
\[
\zeta=-\arctan(\omega\tau_{2})
\]
\begin{align*}
C_{1}= & \frac{-\omega}{(1+\omega^{2}\tau_{1}^{2})}\left(\tau_{1}a+\frac{(1-a)(\tau_{1}+\tau_{2})}{(1+\omega^{2}\tau_{2}^{2})}\right)
\end{align*}
\begin{align*}
C_{2}= & \left(\frac{1}{1+\omega^{2}\tau_{1}^{2}}\right)\left(a+\frac{(1-a)(1-\omega^{2}\tau_{1}\tau_{2})}{(1+\omega^{2}\tau_{2}^{2})}\right)
\end{align*}
\begin{equation}
c=\sqrt{C_{1}^{2}+C_{2}^{2}}\label{eq:responseAmp}
\end{equation}
\begin{equation}
\phi=\arctan(C_{1}/C_{2})\label{eq:responsePhase}
\end{equation}

\citet{mccarthy1973method} used the derivative of the step-function
response to find the impulse response function and, from its Fourier
transform, the sensor response function. That leads to the following
alternate expressions for $C_{1}$ and $C_{2}$:\\
\[
C_{1}=-\omega\left(\frac{A_{1}\tau_{1}}{1+\omega^{2}\tau_{1}^{2}}+\frac{A_{2}\tau_{2}}{1+\omega^{2}\tau_{2}^{2}}\right)
\]
\[
C_{2}=\left(\frac{A_{1}}{1+\omega^{2}\tau_{1}^{2}}+\frac{A_{2}}{1+\omega^{2}\tau_{2}^{2}}\right)
\]
With $A_{2}=(1-a)/(1-\tau_{1}/\tau_{2})$ and $A_{1}=1-A_{2},$ these
are equivalent to the expressions for the same coefficients given
above \eqref{eq:responseAmp}. This demonstrates that the equations
\eqref{eq:Ts} and \eqref{eq:Tm} are a representation of the response
equivalent to \eqref{eq:FrieheKehlif} and to the equations used by
\citet{mccarthy1973method} and \citet{InverarityJTech2000}, among
others.

The transfer function $H(\omega)=c(\omega)e^{i\phi(\omega)}$ then
characterizes how the sensor will respond to a unit-amplitude sine
wave with angular frequency $\omega=2\pi\nu$ where $\nu$ is the
frequency. For a particular set of parameters ($a=$\Sexpr{round(a, 3)},
$\tau_{1}=$\Sexpr{round(tau1, 4)}~s, $\tau_{2}=$\Sexpr{round(tau2, 3)}~s),\footnote{These parameters are approximately representative of an unheated Rosemount
102E4AL sensor used on the NSF/NCAR C-130, as will be demonstrated
in Sect.~\eqref{subsec:The-unheated-Rosemount}.} the amplitude response and phase delay of the transfer function are
shown in Fig.~\ref{fig:LTsolution}. Similar plots of the amplitude
(but not the phase) have been shown by \citet{mccarthy1973method}
and \citet{nicholls1978measurements}. Modified transfer functions
for two small changes to these parameters are also shown to illustrate
the sensitivity of the solution to these parameters. This figure illustrates
that serious errors will enter estimates of the sensible heat flux
if temperature fluctuations at frequencies above 1~Hz make a significant
contribution to the flux. The contribution to the cospectrum of temperature
and vertical wind will be reduced by the product of the amplitude
and the cosine of the phase so at 10-Hz the error is about 86\%,
but even at 1~Hz the error is about 28\%. 

<<LTsolution, include = TRUE, fig.height=3.7, fig.cap = 'The amplitude and phase for the frequency domain transfer function of the Rosemount 102E4AL temperature sensor. The parameters representing that sensor, labeled "best", are $a$=0.733, $\\tau_1=0.0308$ s and $\\tau_2=0.447$ s. To illustrate sensitivity,  the curves labeled "t1=0.05" and "t2=0.6" use instead $\\tau_1=0.05$ s and $\\tau_2=0.6$ s, respectively.'>>=

zeta <- -atan(2 * pi * frq * tau2)
b <- cos(zeta)
Param <- list(
  a = a,
  tau1 = tau1,
  tau2 = tau2,
  b = b,
  zeta = zeta,
  frq = frq
)
Param1 <- Param
Param3 <- Param
Param4 <- Param
Param3$tau1 <- 0.05
Param4$tau2 <- 0.6

## Use the Laplace-transform solution
H1 <- LTphase(frq, Param1)
cTF <- H1$Amp
phiTF <- H1$Phase
H3 <- LTphase(frq, Param3)
cTF3 <- H3$Amp
phiTF3 <- H3$Phase
H4 <- LTphase(frq, Param4)
cTF4 <- H4$Amp
phiTF4 <- H4$Phase
dfAP <- data.frame(
  'Time' = frq,
  'Amp' = cTF,
  'Amp3' = cTF3,
  'Amp4' = cTF4,
  'Phase' = phiTF,
  'Phase3' = phiTF3,
  'Phase4' = phiTF4
)
Panel2Label <- bquote('   Phase [' * degree ~ ']')
g <-
  ggplotWAC(
    dfAP,
    panels = 2,
    labelP = c(bquote('    ' ~ 'Amplitude'), Panel2Label), 
    labelL = c('best', 't1=0.05', 't2=0.6'),
    lty = c(1, 1, 2)
  )
g <- g + xlab('frequency [Hz]') + ylab(bquote('transfer function H(' * nu ~ ')'))
g <-
  g + scale_x_log10(
    breaks = trans_breaks("log10", function(x)
      10 ^ x, n = 4),
    labels = trans_format("log10", math_format(expr = 10 ^ .x))
  ) + xlab('frequency [Hz]')
g <- g + annotation_logticks(sides = 'tb')
g + theme_WAC(1) + theme(legend.position = c(0.3, 0.65))

@

These equations and their solution provide a basis for correcting
either the measured temperature or the sensible-heat flux calculated
from the cospectrum in \eqref{eq:heatFlux}. Corrected values can
be obtained by several methods including integration of the equations
for the derivatives or by dividing the Fourier transform of the time
series by the transfer function and then using inverse Fourier transformation
to recover the corrected time series. Those correction schemes are
discussed in detail in Appendix A. To support such corrections, the
next section determines the transfer function experimentally. 

\subsection{The response to dynamic heating\label{subsec:Dynamic-heating}}

The evaluation of the time response that follows relies on the dynamic
heating produced by airspeed fluctuations. In steady conditions a
temperature sensor exposed to the air stream will measure the recovery
temperature, defined as the ambient temperature increased by the effect
of dynamic heating. Dynamic heating fluctuates as the airspeed fluctuates,
so in a turbulent wind field fluctuations with a measurable frequency
spectrum are imposed on the sensor. These fluctuations are often significantly
larger than real fluctuations in the ambient temperature. Dynamic
heating of temperature sensors is discussed for example by \citet{BangeEtAl2013.ch2}
(cf.~their Eq.~2.23), who express dynamic heating $Q$ as\\
\begin{equation}
Q=\alpha_{r}\frac{V^{2}}{2C_{p}}=T_{r}\left(\frac{\alpha_{r}M^{2}R_{a}/(2C_{v})}{1+\alpha_{r}M^{2}R_{a}/(2C_{v})}\right)\label{eq:DHterm}
\end{equation}
where $\alpha_{r}$ is the ``recovery factor'' characterizing the
extent to which the air is brought to rest relative to the sensor,
$V$ is the airspeed, $C_{p}$ and $C_{v}$ are respectively the specific
heat of air at constant pressure and constant volume. $T_{r}$ is
the (true) recovery temperature expressed in absolute units, $M$
the Mach number, and $R_{a}$ the gas constant for air. The ambient
air temperature $T_{a}$ is related to the recovery temperature and
the dynamic heating via\\
\begin{equation}
T_{r}=T_{a}+Q\,\,\,.\label{eq:recoveryTemperature}
\end{equation}
Because dynamic heating can exceed $20^{\circ}\mathrm{C}$ at jet-aircraft
flight speeds, it is often the dominant cause of fluctuations in the
recovery temperature. If the fluctuations in dynamic heating are higher
in frequency than those to which the sensor can respond, corresponding
fluctuations will be attenuated in the measured spectrum and the phase
of the measured response relative to the imposed signal will vary,
from near $0^{\circ}$ for fluctuations slow compared to sensor response
to near $90^{\circ}$ or even more\footnote{A sensor with a first-order time constant cannot produce a phase lag
of more than $90^{\circ}$, but larger lags are possible for systems
characterized by two time constants.} for fluctuations fast compared to that response. The amplitude and
phase of the recovery temperature relative to the dynamic-heating
forcing therefore can be used as sensitive indicators of the response
characteristics of the sensor and can constrain parameters like $a$,
$\tau_{1}$ and $\tau_{2}$ that fit the predictions to the observations.
The evaluation in terms of the amplitude ratio and phase shift of
the recovery temperature in response to dynamic heating will be used
to characterize the transfer function and to determine if it is represented
adequately by the parameterized form given by \eqref{eq:responseAmp}
and \eqref{eq:responsePhase}.

\subsection{Data sources}

The present investigation uses measurements from two NSF/NCAR (National
Science Foundation / National Center for Atmospheric Research) research
aircraft, a Gulfstream V (hereafter, GV) and a Hercules C-130. The
temperature sensors producing the measurements are in widespread use
so these results should have broad applicability. Some aspects of
the uncertainty limits associated with these measurements of temperature
are included in an NCAR Technical Note (\citet{Cooper2016ncartn}),
which focused on the measurements of wind from the GV\@. That document
included an estimate that the standard uncertainty in measurements
of temperature from the GV is about $0.3^{\circ}\mathrm{C}$ and referenced
\citet{CooperEtAl2014} for supporting evidence. This limit applies
when the temperature being measured is varying slowly but does not
apply when the temperature changes rapidly. It is well known, however,
that temperature sensors in common use on research aircraft have time-response
characteristics that can affect the measurements. \citet{FrieheKhelif1992}
and \citet{LawsonRodi1992}, among many others, provide reviews of
the evidence for delayed response of the standard sensors. In particular,
the unheated Rosemount 102E4AL sensor has been used widely as a fast-responding
sensor, so it will be a focus of this three-part study.

This research uses data archives produced by three research projects,
the VOCALS (VAMOS Ocean-Cloud-Atmosphere-Land Study), CSET (Cloud
Systems Evolution in the Trades) and SOCRATES (Southern Ocean Clouds,
Radiation, Aerosol Transport Experimental Study) experiments. The
field projects are described by \citet{wood2011vamos}, \citet{albrecht2019cloud}
and \citet{mcfarquhar2014southern}, respectively. All included low-level
flight segments over the Pacific Ocean that are used in this paper.
The reference list includes appropriate DOI references to the measurements.

\subsection{Fits to the measurements}

Because the airspeed $V$ is itself conventionally determined using
the processed air temperature $T_{a}$, via $V=M\sqrt{\gamma R_{a}T_{a}}$
where $\gamma=C_{p}/C_{v}$, the second expression in \eqref{eq:DHterm}
provides the advantage that it does not rely on prior calculation
of the air temperature $T_{a}$ but can be calculated from only the
recovery temperature $T_{r}$ and the Mach number. The Mach number
in turn depends only on measurements of the dynamic and ambient pressures,
with a small adjustment for the water vapor pressure. However, the
available measurement is not the true recovery temperature $T_{r}$
but instead the measured temperature $T_{m}$ which may not include
high-frequency fluctuations in $T_{r}$. This in turn affects the
estimated fluctuations determined from \eqref{eq:DHterm}. To minimize
this problem, regions were sought where the fluctuations in dynamic
heating were the dominant cause of fluctuations in recovery temperature.
Temporarily consider these approximations: $\alpha_{r}\approx1$,
$R_{a}/(2C_{v})\approx1/5$, and $M$ small enough that the denominator
of the right side of \eqref{eq:DHterm} can be assumed equal to unity.
Dynamic heating then is approximately $Q\approx T_{r}M^{2}/5$ and
fluctuations in $Q$ are related to those in $T_{r}$ and $M$ according
to\\
\begin{equation}
\frac{\delta Q}{Q}\approx\frac{\delta T_{r}}{T_{r}}+\frac{2}{5}\frac{\delta M}{M}\label{eq:QprimeOverQ}
\end{equation}
Because the measured recovery temperature $T_{m}$ may not include
true high-frequency fluctuations in $T_{r}$, the measured phase and
amplitude of the response to the dynamic-heating term may be distorted
from the correct value at frequencies where $\delta T_{m}/T_{m}$
differs from $\delta T_{r}/T_{r}$. In regions where the last term
in \eqref{eq:QprimeOverQ} dominates, underestimation of the fluctuations
in the recovery temperature arising from sensor response will cause
less significant errors in the measured fluctuations in dynamic heating
$Q$, and those errors can be addressed by correction procedures.

For a representative low-level flight segment with moderate turbulence
where the airspeed fluctuations were approximately consistent with
an eddy dissipation rate of $3\times10^{-4}\,\mathrm{m}^{2}\mathrm{s}^{-3}$,
the variance of the second term in \eqref{eq:QprimeOverQ} is more
than 100 times that of the first, indicating that the fluctuations
in the first term are less than 10\% of those in the second term.
Therefore the right side of \eqref{eq:DHterm} with $T_{m}$ in place
of $T_{r}$ was used initially to represent dynamic heating. Once
a set of parameters was determined, $T_{r}(t)$ was calculated using
the first correction procedure discussed in Appendix~\ref{sec:Correcting-the-Temperature}.
Using this estimate of $T_{r}(t)$ in place of $T_{m}(t)$ led to
a small change in the fitted values of the parameters, but the estimate
became stable after only one iteration.

<<TASX, include = FALSE, fig.height = 3.4, fig.cap = 'Spectral variance $P(\\nu)$ for airspeed ($V$) as a function of frequency $\\nu$ from a segment from VOCALS C-130 flight 3, 11:39:00 -- 11:52:00 UTC. The dotted orange lines show the spectral variance for various values of the eddy dissipation rate, with the heavy-dotted line representing $10^{-4}$ m$^2$ s$^{-3}$. The wavelength scale shows the correspondence between frequency and wavelength at the average airspeed.'>>=

reviseDH <-
  function (.data, P, alphaR) {
    # P is Param1, e.g.; alphaR is recovery factor
    .data$Q <- .data$TASX ^ 2 / 2010
    aV <- P$a
    tau1V <- P$tau1
    tau2V <- P$tau2
    Rate <- attr (.data, 'Rate')
    fS <- function(y, i) {
      (.data$Q[i] - y) / (tau2V * Rate)
    }
    fM <- function (y, i) {
      (aV * .data$Q[i] + (1 - aV) * TsQ[i] - y) / (Rate * tau1V)
    }
    TsQ <- rk4.integrate (fS, .data$Q[1], 1:nrow(.data))
    Qp <- rk4.integrate (fM, .data$Q[1], 1:nrow(.data))
    return (.data$ATX + alphaR * (.data$Q - Qp))
  }
if (file.exists ('./DVOCALS.Rdata')) {
  load (file = './DVOCALS.Rdata')
  DVOCALS <- D
} else {
  D <- getNetCDF(
    file.path(DataDirectory(), 'VOCALS/VOCALSrf03h.nc'),
    c(
      'TASX',
      'PALT',
      'TTRR',
      'ATRR',
      'TTWH',
      'WIC',
      'ATX',
      'PSXC',
      'QCXC'
    )
  )
  D$DH <- D$TASX ^ 2 / 2010
  ## For use later, "filter" the dynamic-heating term and revise the temperature:
  alphaR <- attr(D[, 'ATRR'], 'RecoveryFactor')
  D$AT <- reviseDH(D, Param1, alphaR)
  ## Find a corrected recovery temperature to use in the estimate of dynamic heating:
  a <- Param1$a
  tau1 <- Param1$tau1
  tau2 <- Param1$tau2
  ## RT is the working solution; Ts is the support temperature
  D$Ts <- D$TTRR
  Rate <- attr (D, 'Rate')
  D$DTMDT <-
    c(0, diff(D$TTRR, 2), 0) * Rate / 2  ## Average this and one-sample-advanced
  # D$DTMDT <- (D$DTMDT + c(0, D$DTMDT[1:(nrow(D)-1)])) / 2
  # DT$DTMDT <- as.vector (signal::filter(signal::sgolay(1, 3, m=1), DT$TTRR)) * Rate
  fS <- function(y, i) {
    # Eq. Ts3
    ((1 / a) * (tau1 * D$DTMDT[i] + D$TTRR[i] - (1 - a) * y) - y) / (Rate * tau2)
  }
  D$Ts <- rk4.integrate (fS, D$Ts[1], 1:nrow(D))
  D$RT <- (1 / a) * (tau1 * D$DTMDT + D$TTRR - (1 - a) * D$Ts)
  # D %>% select(Time, TTRR, RT, Ts) %>% selectTime(114500, 114505) %>% plotWAC()
  save(D, file = './DVOCALS.Rdata')
  DVOCALS <- D
}
## Revise the calculation of dynamic heating to avoid dependence on AT:
D$MACH <- MachNumber(D$PSXC, D$QCXC)
XXA <- attr(D[, 'ATRR'], 'RecoveryFactor') * D$MACH ^ 2 / 5
D$DH <- (D$TTRR + 273.15) * XXA / (1 + XXA)
D$DH2 <- (D$RT + 273.15) * XXA / (1 + XXA)
## temporary: shift D$AT later in time
# D$AT <- ShiftInTime (D$AT, .rate=25, .shift=40)
Tasm <- mean(D$TASX, na.rm = TRUE)
DT <- D %>% selectTime(113900, 115200)
## Save it for use in the workflow document:
save(DT, file='DT.Rdata')
# select six boundary-layer segments of 10 min each:
DT1 <- D %>% selectTime(65000, 70000)
DT2 <- D %>% selectTime(73300, 74300)
DT3 <- D %>% selectTime(104600, 105600)
DT4 <- D %>% selectTime(114200, 115200)  ## 113900, 115200
DT5 <- D %>% selectTime(124300, 125300)
DT6 <- D %>% selectTime(133000, 134000)
DZV <- rbind(DT1, DT2, DT3, DT4, DT5, DT6)
rhozero <- 1013.25 * 100 / (287.05 * 288.15)
# omitting 832-841, 920-951, 955-1005 -- look problematic
# g <- VSpec(DT, 'TTRR', spans=99, xlim=c(0.01,15), ylim=c(1.e-5, 1.e-1))
# g <- VSpec(DT, 'ATRR', spans=99, add=g)
# VSpec(DT, 'DH', spans=99, add=g) + theme_WAC()
DT$V <- DT$TASX
VSpec(DT, 'V', VLabel='V=airspeed', spans = 99, ylim=c(1.e-3, 10)) + theme_WAC(1)

@

<<extra2, include=FALSE, echo=FALSE>>=

## This is a special version with features not in the standard Ranadu version
CohP <-
  function (.data,
            .Var1,
            .Var2,
            col = 'blue',
            spans = 25,
            smoothBins = 50,
            plotType = 'ggplot',
            showErrors = 0,
            returnCospectrum = FALSE) {
    if (is.data.frame(.data)) {
      if (.Var1 %in% names(.data)) {
        Z <-
          capture.output (Vr <-
                            SmoothInterp(detrend (.data[, c('Time', .Var1)]), .Length = 0))
      } else {
        print(sprintf(
          'CohPhase ERROR: Variable %s is not in the supplied data.frame',
          .Var1
        ))
        return (NA)
      }
      if (.Var2 %in% names(.data)) {
        Z <-
          capture.output (VrC <-
                            SmoothInterp(detrend (.data[, c('Time', .Var2)]), .Length = 0))
      } else {
        print(sprintf(
          'CohPhase ERROR: Variable %s is not in the supplied data.frame',
          .Var2
        ))
        return (NA)
      }
    } else {
      print('CohPhase ERROR: first argument is not a data.frame.')
      return (NA)
    }
    if (is.null(attr(.data, 'Rate'))) {
      print ('CohPhase warning: Rate attribute missing from data.frame, so using Rate=1')
      Rate <- 1
    } else {
      Rate <- attr(.data, 'Rate')
    }
    vcv <- cbind(ts(Vr, frequency = Rate), ts(VrC, frequency = Rate))
    P <-
      spec.pgram(
        vcv,
        detrend = FALSE,
        fast = TRUE,
        plot = FALSE,
        spans = spans
      )
    df1 <- data.frame(P$coh, log(P$freq))
    df2 <- data.frame (P$phase, log(P$freq))
    df3 <- data.frame (P$spec[, 1], log(P$freq))
    df4 <- data.frame (P$spec[, 2], log(P$freq))
    pf1 <- binStats (df1, bins = smoothBins)
    pf2 <- binStats (df2, bins = smoothBins)
    pf3 <- binStats (df3, bins = smoothBins)
    pf4 <- binStats (df4, bins = smoothBins)
    pf1 <- pf1[!is.na (pf1$ybar),]
    pf2 <- pf2[!is.na (pf2$ybar),]
    pf3 <- pf3[!is.na (pf3$ybar),]
    pf4 <- pf4[!is.na (pf4$ybar),]
    # pf1$sigma[pf1$nb > 1] <- pf1$sigma[pf1$nb > 1] / sqrt(pf1$nb[pf1$nb > 2])
    pf1$sigma[pf1$nb <= 1] <- NA # pf1$ybar[pf1$nb <= 1] * 0.5
    # pf2$sigma[pf2$nb > 1] <- pf2$sigma[pf2$nb > 1] / sqrt(pf2$nb[pf2$nb > 2])
    pf2$sigma[pf2$nb <= 1] <- NA # pf2$ybar[pf2$nb <= 1] * 0.5is
    if (plotType != 'ggplot') {
      pf1 <- binStats (df1, bins = smoothBins, addBin = TRUE)
      pf2 <- binStats (df2, bins = smoothBins, addBin = TRUE)
      pf3 <- binStats (df3, bins = smoothBins, addBin = TRUE)
      pf4 <- binStats (df4, bins = smoothBins, addBin = TRUE)
      return(cbind(pf1, pf2, pf3, pf4)[, c(2, 1, 3, 4, 6, 7, 10)])
    } else {
      d2 <-
        data.frame(
          Time = exp(pf1$xc),
          coherence = pf1$ybar,
          phase = pf2$ybar * 180 / pi,
          clo = (pf1$ybar - showErrors * pf1$sigma),
          chi = pf1$ybar + showErrors * pf1$sigma,
          plo = (pf2$ybar - showErrors * pf2$sigma) * 180 / pi,
          phi = (pf2$ybar + showErrors * pf2$sigma) * 180 / pi
        )
      d2$clo[!is.na(d2$clo) & (d2$clo < 0)] <- 0
      labelP <- c('coherence', 'phase [degrees]')
      g <- ggplotWAC(
        d2[, c(1, 2, 3)],
        panels = 2,
        labelP = labelP,
        col = col,
        lwd = c(1.0),
        lty = c(1),
        xlab = 'freq'
      )
      g <-
        g + xlab('frequency [Hz]') + ylab (sprintf ('%s x %s', .Var1, .Var2))
      g <-
        g + scale_x_log10(
          breaks = trans_breaks("log10", function(x)
            10 ^ x, n = 4),
          labels = trans_format("log10", math_format(expr = 10 ^ .x))
        ) + xlab('frequency [Hz]')
      if (showErrors > 0 && smoothBins > 5) {
        da <- data.frame(d2[, c(1, 4, 5)])
        db <- data.frame(d2[, c(1, 6, 7)])
        names(da) <- c('Time', 'ymin', 'ymax')
        names(db) <- c('Time', 'ymin', 'ymax')
        da$PanelGroup <- labelP[1]
        db$PanelGroup <- labelP[2]
        d <- rbind(db, da)
        g <-
          g + geom_ribbon(
            data = d,
            aes(
              x = Time,
              ymin = ymin,
              ymax = ymax
            ),
            colour = 'grey',
            alpha = 0.15,
            inherit.aes = FALSE
          )
      }
      g <- g + theme_WAC(1) + theme(legend.position = 'none')
      if (returnCospectrum) {
        CS <-
          sqrt(P$coh[, 1] * P$spec[, 1] * P$spec[, 2] / (1 + tan(P$phase[, 1]) ^
                                                           2))
        v1 <- SmoothInterp(.data[, .Var1], .Length = 0)
        v2 <- SmoothInterp(.data[, .Var2], .Length = 0)
        v1 <- detrend(data.frame(Time = .data$Time, v1))
        v2 <- detrend(data.frame(Time = .data$Time, v2))
        ff1 <- fft(v1)
        ff2 <- fft(v2)
        G <- Re(ff1 * Conj(ff2)) / nrow(.data)
        GQ <- Im(ff1 * Conj(ff2)) / nrow(.data)
        N <- nrow(.data) %/% 2
        S1 <- Re(ff1 * Conj(ff1) / nrow(.data))
        S2 <- Re(ff2 * Conj(ff2) / nrow(.data))
        G <- G[2:(N + 1)]
        GQ <- GQ[2:(N + 1)]
        S1 <- S1[2:(N + 1)]
        S2 <- S2[2:(N + 1)]
        frq <- c(1:N) * Rate / nrow(.data)
        spec1 <- 2 * S1 / Rate
        spec2 <- 2 * S2 / Rate
        cospec <- 2 * G / Rate
        quad <- 2 * GQ / Rate
        # cospectrum - i * quadrature = (gain spectrum) * exp(i*(phase spectrum))
        # sqrt(cospectrum^2 + quadrature^2) is the amplitude or gain spectrum
        return(data.frame(
          freq = frq,
          cospec = cospec,
          quad = quad,
          spec1 = spec1,
          spec2 = spec2
        ))
      } else {
        return(g)
      }
    }
  }
RX <- CohPhase(DT, 'TTRR', 'DH', plotType = 'Ranadu')
SB <- 200
RXX <- CohPhase(DT1, 'TTRR', 'DH', plotType = 'Ranadu', smoothBins = SB)
Z <-
  capture.output (Vr <-
                    SmoothInterp(detrend (DT1[, c('Time', 'TTRR')]), .Length = 0))
Z <-
  capture.output (VrC <-
                    SmoothInterp(detrend (DT1[, c('Time', 'DH')]), .Length = 0))
Rate <- attr(DT1, 'Rate')
vcv <- cbind(ts(Vr, frequency = Rate), ts(VrC, frequency = Rate))
P <- spec.pgram(
  vcv,
  detrend = FALSE,
  fast = TRUE,
  plot = FALSE,
  spans = 25
)
df1 <- data.frame(P$coh, log(P$freq))
df2 <- data.frame (P$phase, log(P$freq))
pf1 <- binStats (df1, bins = SB)
pf2 <- binStats (df2, bins = SB)
## Use DH2 to get the time-response-corrected-RT Q
RX1 <- CohP(DT1, 'TTRR', 'DH', plotType = 'Ranadu', smoothBins = SB)
RX2 <- CohP(DT2, 'TTRR', 'DH', plotType = 'Ranadu', smoothBins = SB)
RX3 <- CohP(DT3, 'TTRR', 'DH', plotType = 'Ranadu', smoothBins = SB)
RX4 <- CohP(DT4, 'TTRR', 'DH', plotType = 'Ranadu', smoothBins = SB)
RX5 <- CohP(DT5, 'TTRR', 'DH', plotType = 'Ranadu', smoothBins = SB)
RX6 <- CohP(DT6, 'TTRR', 'DH', plotType = 'Ranadu', smoothBins = SB)
phase <- rep(0, SB)
nphase <- rep(0, SB)
phase2 <- rep(0, SB)
ar <- rep(0, SB)
ar2 <- rep(0, SB)
nar <- rep(0, SB)
for (RX in list(RX1, RX2, RX3, RX4, RX5, RX6)) {
  for (i in 2:nrow(RX)) {
    phase[RX$BIN.1[i]] <- phase[RX$BIN.1[i]] + RX$P.phase[i]
    nphase[RX$BIN.1[i]] <- nphase[RX$BIN.1[i]] + 1
    phase2[RX$BIN.1[i]] <- phase2[RX$BIN.1[i]] + RX$P.phase[i] ^ 2
    ar[RX$BIN.1[i]] <-
      ar[RX$BIN.1[i]] + sqrt(RX$P.spec...1.[i] / RX$P.spec...2.[i])
    ar2[RX$BIN.1[i]] <-
      ar2[RX$BIN.1[i]] + (RX$P.spec...1.[i] / RX$P.spec...2.[i])
    nar[RX$BIN.1[i]] <- nar[RX$BIN.1[i]] + 1
  }
}
nphase[nphase == 0] <- 1
nar[nar == 0] <- 1
mphase <- phase / nphase
mphase2 <- phase2 / nphase
sdp <- sqrt(mphase2 - mphase ^ 2)
mphase <- mphase * 180 / pi
sdp <- sdp * 180 / pi
sdp <- sdp * 2 / sqrt(nphase)
ar <- ar / nar
ar2 <- ar2 / nar
sdr <- sqrt(ar2 - ar ^ 2)
sdr <- sdr * 2 / sqrt(nar)


@

\subsubsection{The unheated Rosemount 102E4AL sensor\label{subsec:The-unheated-Rosemount}}

\begin{table}[H]
\begin{centering}
\begin{tabular}{|c|c|c|}
\hline 
Segment & start & end\tabularnewline
\hline 
\hline 
1 & 6:50:00 & 7:00:00\tabularnewline
\hline 
2 & 7:33:00 & 7:43:00\tabularnewline
\hline 
3 & 10:46:00 & 10:56:00\tabularnewline
\hline 
4 & 11:42:00 & 11:52:00\tabularnewline
\hline 
5 & 12:43:00 & 12:53:00\tabularnewline
\hline 
6 & 13:30:00 & 13:40:00\tabularnewline
\hline 
\end{tabular}
\par\end{centering}
\caption{Flight segments from flight 3 of the VOCALS project, 21 October 2008.
Listed times are UTC.}
\end{table}

To characterize the response of the Rosemount 102E4AL sensor, six
ten-minute low level flight segments in the marine boundary layer
from one flight of the NCAR/NSF C-130 in the ``VOCALS'' project
(\citet{wood2011vamos}), which studied low-level clouds over the
Pacific Ocean near Chile, were selected that had simular flight conditions
including the intensity of the turbulence. The time intervals are
listed in Table 1. For each flight segment, the phase and amplitude
ratio between the measurement and the dynamic heating term were calculated,\footnote{The R routine ``spec.pgram()'' was used with 25-point modified Daniell
smoothing.} and the results for all six segments were averaged in \Sexpr{round(SB,0)}
logarithmically spaced intervals in frequency. The results for the
average phase are shown in Fig.~\ref{fig:Vphase}a. The theoretical
curve is based on best-fit parameters as determined from these measurements
and those of the amplitude ratio, discussed next.

<<include=FALSE, echo=FALSE>>=

## special ggplotWAC mod for this plot:
ggplotWACA <- function (.data, col="blue", xlab="TIME [UTC]", 
                       ylab="", lwd=1, lty=1, logxy='',
                       position=NA, lmargin=NA, ylim=NA,
                       legend.position=c(0.5, 0.92), 
                       panels=1,
                       labelL=NA, labelP=NA, 
                       gtitle=NA, theme.version=0, ...) {
  if (!is.data.frame (.data)) {
    print ("Error, first argument to ggplotWAC must be a data.frame")
  } else {
    if (!is.expression(ylab) && (ylab == "")) {
      ylab <- names(.data)[2]
      # print (attr(.data[, ylab], 'label'))
      if (!is.null (ylbl <- attr(.data[, ylab], 'label'))) {
        ylab <- ylbl
        ## Convert to appropriate expressions where needed:
        if (grepl('\\[deg C\\]', ylab)) {
          ylab <- sub ('\\[deg C\\]', '', ylab)
          ylab <- bquote(paste(.(ylab),' [','\u00b0','C]'))
        } else if (grepl('m\\^-3\\]', ylab)) {
          ylab <- sub ('m\\^-3\\]', '', ylab)
          ylab <- bquote(paste(.(ylab),m^-3, ']'))
        } else if (grepl('degree\\]', ylab)) {
          ylab <- sub ('degree\\]', '', ylab)
          ylab <- bquote(paste(.(ylab),'\u00b0',']'))
        } else if (grepl('m s\\^-2\\]', ylab)) {
          ylab <- sub('m s\\^-2\\]', '', ylab)
          ylab <- bquote(paste(.(ylab),'m ',s^-2,']'))
        }
      }
    }
    ## protect against all-missing variables
    for (j in 2:min(6, ncol(.data))) {
      if (!any (!is.na (.data[, j]))) {
        .data[1, j] <- -32767.
        .data[2, j] <- 32767.
      }
    }
    if (!is.na(position[1])) {
      h <- 0.9/position[2]
      yp <- 0.05+(position[1]-0.5)*h
      if (position[1] == 1) {
        hh <- h+0.1
      } else {
        hh <- h
        yp <- yp + 0.05
      }
      vp <- viewport(width=1, height=hh, x=0.5, y=yp)
    }
    yrange <- c(min(.data[ ,2], na.rm=TRUE), max(.data[ ,2], na.rm=TRUE))
    if (ncol(.data) > 2) {
      for (j in 3:min(6, ncol(.data))) {
        if (any (!is.na(.data[ ,j]))) {
          yl <- min(.data[ ,j], na.rm=TRUE)
          yh <- max(.data[ ,j], na.rm=TRUE)
          if (yl < yrange[1]) {yrange[1] <- yl}
          if (yh > yrange[2]) {yrange[2] <- yh}
        }
      }
    }
    nv <- names (.data); np <- length(nv) - 1
    if (panels > 1) {
      np <- np / panels
    }
    if (!is.na(ylim[1])) {yrange <- ylim}
    if (length(col) == 1 && np > 1) {
      colrs <- c(col, 'forestgreen', 'red', 'skyblue', 'darkorange')
      colrs <- colrs[-c((np+1):length(colrs))]
    } else {
      colrs <- col
    } 
    np <- 2
    if (panels > 1) {
      np <- np / panels
    }
    clr <- nv[-1] 
    lwd <- c(lwd, rep(1,np)); lwd <- lwd[-c((np+1):length(lwd))]
    lty <- c(lty, rep(1,np)); lty <- lty[-c((np+1):length(lty))]
    if (panels == 1) {
      names(colrs) <- clr
      names(clr) <- clr
      names(lwd) <- clr
      names(lty) <- clr
    }
    ## now handle the faceting case:
    if (panels > 1) {
      DL <- nrow (.data); DC <- ncol(.data) - 1
      lines_per_panel <- DC / panels
      if (is.na(labelP[1])) {
        labelP <- 'panel1'
        for (k in 2:panels) {
          labelP <- c(labelP, sprintf('panel%d',k))
        }
      }
      VarGroup <- rep (gl (lines_per_panel, DL, labels=labelL), panels)
      PanelGroup <- gl (panels, lines_per_panel*DL, labels=labelP)
      dd <- data.frame(reshape2::melt(.data, 1, factorsAsStrings=TRUE), VarGroup, PanelGroup)
      colrs <- rep(colrs, panels)
      lwd <- rep(lwd, panels)
      lty <- rep(lty, panels)
      lvl <- levels(dd$VarGroup)
      g <- with(dd, ggplot (dd, aes(Time, value, colour=VarGroup, linetype=VarGroup)))
      g <- g + geom_path (aes(size=VarGroup), na.rm=TRUE)
      g <- g + scale_size_manual ('', labels=lvl, breaks=lvl, values = lwd)
      g <- g + scale_linetype_manual ('', labels=lvl, breaks=lvl, values = lty)
      g <- g + scale_colour_manual('', labels = lvl, breaks=lvl, values = colrs)
      g <- g + facet_grid (PanelGroup ~ ., scales='free_y', drop=TRUE, labeller = label_parsed)
    } else {
      a <- sprintf ("aes (x=%s)", names(.data)[1])
      g <- ggplot (data=.data, eval(parse(text=a)))
      # g <- ggplot (data=.data, aes(x=eval (parse (text=names(.data)[1]))))
      g <- g + ylim (yrange)
    }
    if (names(.data)[1] == "Time") {
      g <- g + xlab ("Time [UTC]")
    } else {
      g <- g + xlab (names(.data)[1])
    } 
    if (!is.expression(ylab) && ylab == '') {
      ylab <- names (.data)[2]
    }
    g <- g + ylab(ylab)
    if (panels == 1) {
      for (j in 1:min(np, 5)) {
        a <- sprintf ("aes (y=%s, colour='%s', size='%s', linetype='%s')", 
                      clr[j], clr[j], clr[j], clr[j])
        g <- g + geom_path (eval (parse (text=a)), na.rm=TRUE)
      }
      g <- g + scale_size_manual ("", labels=clr, breaks=clr, values = lwd)
      g <- g + scale_linetype_manual ("", labels=clr, breaks=clr, values = lty)
      g <- g + scale_colour_manual("", labels = clr, breaks=clr, values = colrs)
      # g <- g + guides(colour = guide_legend(reverse=TRUE),
      #                 linetype=guide_legend(reverse=TRUE),
      #                 size=guide_legend(reverse=TRUE))
      # print (c(clr, colrs, lwd, lty))
      # print (names(colrs))
    }
    if (length(gtitle) > 1) {
      g <- g + ggtitle (gtitle)
    }
    g <- g + theme_WAC(theme.version)
    if (panels > 1) {
      g <- g + theme(axis.text.x = element_text (size=11.5, margin=margin(15,0,0,0)))
      g <- g + theme(axis.title.x = element_text (size=12))
    }
    if (is.na(legend.position[1])) {
      g <- g + theme (legend.position='none')
    } else {
      g <- g + theme(legend.position=legend.position)
    }
    if (!is.na(position[1])) {
      if (position[1] != 1) {
        g <- g + theme(axis.title.x=element_blank(), axis.text.x=element_blank())
        g <- g + theme(axis.title.y=element_text(size=12), 
                       axis.text.y=element_text(size=12))
      } else {
        g <- g + theme(axis.title.y=element_text(size=12), 
                       axis.text.y=element_text(size=12),
                       axis.text.x=element_text(size=12),
                       axis.title.x=element_text(size=12))
      }
    }
    if (!is.na(lmargin)) {
      ## these should match values in theme_WAC()
      g <- g + theme (plot.margin=unit(c(0.3,0.3,1.1,lmargin),"lines"))
    }
    ## preserve .data in the parent environment for plotting
    # .data <<- .data
    if (!is.na(position[1])) {
      print (g, vp=vp)
    } else {
      return (g)
    }
    
    ## suppressMessages(ggsave (.plotfile, g))
    # suppressWarnings (print (g))
    
    ## left from plotWAC: implement someday?
    #       if (!is.expression(xlab)) {
    #         # get data.rate
    #         data.rate <- 1
    #         itg <- x[!is.na(x[,1]), 1]  # protect against missing values at start
    #         if ((itg[2]-itg[1]) <= 0.04) {data.rate <- 25}
    #         if ((itg[2]-itg[1]) <= 0.02) {data.rate <- 50}
    #         
    #         # print (sprintf (" data.rate is %d", data.rate))
    #         if (xlab == "TIME [UTC]") {
    #           if (length(x[, 1]) < 180*data.rate+2) {          # needs revision for high-rate data
    #             axis.POSIXct(1, x[, 1], format='%H:%M:%S', tck=0.02)
    #           } else {
    #             axis.POSIXct(1,x[, 1], format='%H:%M', tck=0.02)
    #           }
    #           axis.POSIXct(3,x[, 1], labels=NA, tck=0.02)
    #         } else {
    #           axis(1,tck=0.02)
    #           axis(3,labels=NA,tck=0.02)
    #         }
    #       } else {
    #         axis(1,tck=0.02)
    #         axis(3,labels=NA,tck=0.02)
    #       }
    #       if ('y' %in% logxy) {
    #         axis(2,at=aty,labels=labs)
    #       } else {
    #         axis(2,tck=0.02)
    #       }
    #       axis(4,labels=NA,tck=0.02)
    #     } 
  }
}


@

\begin{figure}
<<Vphase, include=TRUE, echo=FALSE, fig.height=4.5>>=

df <- data.frame(frq = exp(pf2$xc), 
                 mphase = mphase,
                 sdp = sdp)
df <- df[df$frq > 0.01, ]
df <- df[df$sdp > 0, ]
df <- df[df$frq < 12, ]
frq <- exp(pf2$xc[nar > 0])

Param5 <- Param1
Param5$tau2 <- 0.6
H5 <- LTphase(df$frq, Param5)
cTF5 <- H5$Amp
phiTF5 <- H5$Phase
# df$Amp5 <- cTF5
# plot(df$frq, df$mphase, type='p', pch=20, col='blue', log='x', xlim=c(1.e-2, 15),
#   xlab='frequency [Hz]', ylab='phase, RTRR x Q [degrees]', ylim=c(-80, 9))
# arrows(df$frq, df$mphase-df$sdp, df$frq, df$mphase+df$sdp, length=0.05, angle=90, code=3)
g <- ggplot(df, aes(x=frq, y=mphase))+geom_point()
g <- g + xlab('frequency [Hz]') + ylab (bquote('phase [' ~ degree * ']'))
g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x, n=4),
         labels = trans_format("log10", math_format(expr = 10^.x))) + xlab('frequency [Hz]')
g <- g + annotation_logticks(sides = "bt")
g <- g + geom_errorbar(aes(ymin=mphase-sdp, ymax=mphase+sdp), width=0.06)
g <- g + geom_path(data=dfAP, aes(x=Time, y=Phase), col='forestgreen', lwd=1.5)
g1 <- g + theme_WAC(1)
frq <- seq(0.01, 25, by=0.01)
dfr <- data.frame(frq=exp(pf2$xc), mrspec=ar, sdr=sdr)
dfr <- dfr[dfr$frq > 0.04, ]
dfr <- dfr[dfr$sdr > 0, ]
dfr <- dfr[dfr$frq < 12, ]
frq <- exp(pf2$xc[nar > 0])
# spec1 <- spec1[nspec1 > 0]
# spec2 <- spec2[nspec1 > 0]
# rspec <- spec1 / spec2
# plotWAC(data.frame(frq, mrspec), xlab='frequency [Hz]', ylab='amplitude ratio RTRR/Q', type='p', 
#         col='blue', log='x', pch=20, xlim=c(0.1,15), ylim=c(0,1.2))
# HR <- LTphase(frq, Param1)
# P <- Param1
# P$tau2 <- 0.84
# HR2 <- LTphase(frq, P)
# lines(frq, (HR2$Amp)^2, col='forestgreen', lwd=2)
# lines(frq, (HR$Amp)^2, col='darkorange', lwd=2, lty=2)
Param5 <- Param1
Param5$tau2 <- 0.6
H5 <- LTphase(dfr$frq, Param5)
cTF5 <- H5$Amp
phiTF5 <- H5$Phase
dfr$Amp5 <- cTF5
g <- ggplot(dfr, aes(x=frq, y=mrspec))+geom_point()
g <- g + xlab('frequency [Hz]') + ylab ('amplitude ratio')
g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x, n=4),
         labels = trans_format("log10", math_format(expr = 10^.x))) + xlab('frequency [Hz]')
g <- g + annotation_logticks(sides = "bt")
g <- g + geom_errorbar(aes(ymin=mrspec-sdr, ymax=mrspec+sdr), width=0.06)
g <- g + geom_path(data=dfAP, aes(x=Time, y=Amp, col='best', lty='best'), lwd=1.5)
g <- g + geom_path(data=dfr, aes(x=frq, y=Amp5, col='tau2=0.6', lty='tau2=0.6'), lwd=1.2)
g <-
  g + scale_colour_manual (
    name = 'fit: ',
    values = c("best" = "forestgreen", "tau2=0.6" = "darkorange")
  )
g <- g + scale_linetype_manual (name = 'fit: ', 
                                values = c('best' = 1, 'tau2=0.6'=2))
g2 <- g + ylim(0, 1.3) + theme_WAC(1)

grid.newpage()
position <- c(1, 2)
      h <- 0.9/position[2]
      yp <- 0.05+(position[1]-0.5)*h
      if (position[1] == 1) {
        hh <- h+0.1
      } else {
        hh <- h
        yp <- yp + 0.05
      }
      vp1 <- viewport(width=1, height=hh, x=0.5, y=yp)
position <- c(2, 2)
      h <- 0.9/position[2]
      yp <- 0.05+(position[1]-0.5)*h
      if (position[1] == 1) {
        hh <- h+0.1
      } else {
        hh <- h + 0.125
        yp <- yp - 0.07
      }
      vp2 <- viewport(width=1, height=hh, x=0.5, y=yp)
g2 <- g2 + theme(plot.margin=unit(c(0.3,0.3,1.1,1.7),"lines"))
suppressWarnings(print(g1, vp=vp2))
suppressWarnings(print(g2, vp=vp1))


@

\caption{(top): Phase of measured recovery temperature relative to dynamic
heating, for the measurements (with error bars) and for the theoretical
response for the best-fit parameters (green line). The error bars
indicate two-standard-deviation ranges in the mean at each plotted
point. Data from the  flight segments listed in Table 1.\protect \\
(bottom): The ratio of the spectral amplitude for the measurement
of recovery temperature ($T_{m}(t)$) to that for dynamic heating
($Q$), shown as the plotted data points. There are additional data
points at frequencies below about 0.04 Hz that do not appear in this
plot because they lie above the upper limit for the ordinate. The
green line is the prediction from the transfer function determined
from the best-fit values matching the phase lag between these variables,
and the dashed orange line is a similar result with the second time
constant $\tau_{2}$ increased from 0.447 to 0.6~s to illustrate
sensitivity to this parameter.\label{fig:Vphase}}
\end{figure}

<<checkAmplitude, include=FALSE, fig.pos='t', fig.height = 3.5, fig.cap='The ratio of the spectral amplitude for the measurement of recovery temperature ($T_m(t)$) to that for dynamic heating ($Q$), shown as the plotted data points. There are additional data points at frequencies below about 0.04 Hz that do not appear in this plot because they lie above the upper limit for the ordinate. The green line is the prediction from the transfer function determined from the best-fit values matching the phase lag between these variables, and the dashed orange line is a similar result with the second time constant $\\tau_2$ increased from 0.447 to 0.6 s to illustrate sensitivity to this parameter.'>>=

dfr <- data.frame(frq=exp(pf2$xc), mrspec=ar, sdr=sdr)
dfr <- dfr[dfr$frq > 0.01, ]
dfr <- dfr[dfr$sdr > 0, ]
dfr <- dfr[dfr$frq < 12, ]
frq <- exp(pf2$xc[nar > 0])
# spec1 <- spec1[nspec1 > 0]
# spec2 <- spec2[nspec1 > 0]
# rspec <- spec1 / spec2
# plotWAC(data.frame(frq, mrspec), xlab='frequency [Hz]', ylab='amplitude ratio RTRR/Q', type='p', 
#         col='blue', log='x', pch=20, xlim=c(0.1,15), ylim=c(0,1.2))
# HR <- LTphase(frq, Param1)
# P <- Param1
# P$tau2 <- 0.84
# HR2 <- LTphase(frq, P)
# lines(frq, (HR2$Amp)^2, col='forestgreen', lwd=2)
# lines(frq, (HR$Amp)^2, col='darkorange', lwd=2, lty=2)
Param5 <- Param1
Param5$tau2 <- 0.6
H5 <- LTphase(dfr$frq, Param5)
cTF5 <- H5$Amp
phiTF5 <- H5$Phase
dfr$Amp5 <- cTF5
g <- ggplot(dfr, aes(x=frq, y=mrspec))+geom_point()
g <- g + xlab('frequency [Hz]') + ylab ('amplitude ratio')
g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x, n=4),
         labels = trans_format("log10", math_format(expr = 10^.x))) + xlab('frequency [Hz]')
g <- g + annotation_logticks(sides = "bt")
g <- g + geom_errorbar(aes(ymin=mrspec-sdr, ymax=mrspec+sdr), width=0.06)
g <- g + geom_path(data=dfAP, aes(x=Time, y=Amp, col='best', lty='best'))
g <- g + geom_path(data=dfr, aes(x=frq, y=Amp5, col='tau2=0.6', lty='tau2=0.6'))
g <-
  g + scale_colour_manual (
    name = 'fit: ',
    values = c("best" = "forestgreen", "tau2=0.6" = "darkorange")
  )
g <- g + scale_linetype_manual (name = 'fit: ', 
                                values = c('best' = 1, 'tau2=0.6'=2))
suppressWarnings(print(g + ylim(0, 1.3) + theme_WAC(1)))

@

The ratio of the amplitude of the response to that of the dynamic-heating
signal, used as an estimate of the gain of the transfer function,
is shown in Fig.~\ref{fig:Vphase}b. It is useful to consider both
the amplitude and phase when determining the response parameters because,
as shown in Fig.~\ref{fig:LTsolution}, the amplitude of the transfer
function is more sensitive to $\tau_{2}$ than the phase but $\tau_{1}$
is a very sensitive predictor of the phase at high frequency. For
the set of favored parameters, Fig.~\ref{fig:Vphase}b shows the
standard prediction and another with $\tau_{2}$ set to 0.6~s instead,
to show the sensitivity of this result to that parameter. The best
prediction based on the measured phases consistently underestimates
the ratio of spectra for frequencies below about 0.1~Hz and above
about 3~Hz but is reasonably consistent with the observed ratio between
0.1~Hz and 3~Hz. Below 0.1~Hz it appears likely that the sensor
is responding to real fluctuations in temperature not attributable
to dynamic heating, as would be expected at these low frequencies.
Above 3~Hz the prediction is much too low, probably because there
is noise or other spurious variance in $T_{m}(t)$ not caused by dynamic
heating. 

<<fitCoefs, include=TRUE, echo=FALSE>>=

Param2 <- Param1
## Restrict dfr frequencies:
dfr <- dfr[dfr$frq > 0.1 & dfr$frq < 3, ]
minFn <- function(V) {
  Param2$a <<- V[1]
  Param2$tau1 <<- V[2]
  Param2$tau2 <<- V[3]
  Chisq <- 0
  for (i in 1:nrow(df)) {
    Chisq <- Chisq + (df$mphase[i] - LTphase(df$frq[i], Param2)$Phase)^2 / df$sdp[i]^2
  }
  for (i in 1:nrow(dfr)) {
    Chisq <- Chisq + (dfr$mrspec[i] - LTphase(dfr$frq[i], Param2)$Amp)^2 / dfr$sdr[i]^2
  }
  return (Chisq)
}
A <- optim (c(Param2$a, Param2$tau1, Param2$tau2), minFn, hessian=TRUE)
best <- A$par
Herror <- solve(A$hessian / 4)  # factor of 4 because 2-sigma errors were used?
uncLimits <- sqrt(diag(Herror))

@

The fit procedure used \eqref{eq:responseAmp} and \eqref{eq:responsePhase}
to find the theoretical value of the amplitude ratio and phase at
each frequency represented in the observations. For assumed values
of the three parameters $a$, $\tau_{1}$ and $\tau_{2}$, a chi-square
was calculated from the differences between these theoretical values
and the observed values. The frequencies used for the fit were 0.01
to 12~Hz for the measurements of phase and 0.1 to 3~Hz for the measurements
of amplitude ratio, to avoid regions where effects other than dynamic
heating appear to bias the measurements. Then a search procedure varied
these parameters to seek the minimum value of the chi-square.\footnote{The code can be found in the ``Rnw'' document that generates the
present document. It used the ``optim()'' function from the R ``stats''
package produced by the \citet{Rlanguage}.} The resulting values were $a=$ \Sexpr{round(best[1], 2)}, $\tau_{1}=$
\Sexpr{round(best[2], 3)} and $\tau_{2}=$ \Sexpr{round(best[3], 2)}.
The chi-square for the fit is about 18 times larger than expected
if the fit represents the measurements to measurement uncertainty,
so it is difficult to assign uncertainty limits to this result on
the basis of this fit because of this not-understood excess chi-square,
but the fit minimum distinguished nearby values to about three significant
digits in all three parameters. The Hessian from the fit implies that
the results with standard uncertainties are $a=$ \Sexpr{round(best[1], 3)}$\pm$\Sexpr{round(uncLimits[1], 3)},
$\tau_{1}=$ \Sexpr{round(best[2], 4)}$\pm$\Sexpr{round(uncLimits[2], 4)}
and $\tau_{2}=$ \Sexpr{round(best[3], 2)}$\pm$\Sexpr{round(uncLimits[3], 2)}.

<<correctRT, include=FALSE>>=

## Integrate to find the support temperature Ts:
a <- Param1$a
tau1 <- Param1$tau1
tau2 <- Param1$tau2
## RT is the working solution; Ts is the support temperature
DT$Ts <- DT$RT
Rate <- attr (DT, 'Rate')
DT$DTMDT <- c(0, diff(DT$TTRR, 2), 0) * Rate / 2
# DT$DTMDT <- (DT$DTMDT + c(0, DT$DTMDT[1:(nrow(DT)-1)])) / 2
# DT$DTMDT <- as.vector (signal::filter(signal::sgolay(1, 3, m=1), DT$TTRR)) * Rate
fS <- function(y, i) {  # Eq. Ts3
  ((1/a) * (tau1 * DT$DTMDT[i] + DT$TTRR[i] - (1-a) * y) - y) / (Rate * tau2)
}

DT$Ts <- rk4.integrate (fS, DT$Ts[1], 1:nrow(DT))
DT$RT <- (1/a) * (tau1 * DT$DTMDT + DT$TTRR - (1-a) * DT$Ts)
DT %>% select(Time, TTRR, RT, Ts) %>% 
       selectTime(114500, 114505) %>% 
       plotWAC()

@

To complete the iteration discussed earlier, the measured recovery
temperature was then corrected via method 1 from Appendix~A, using
the parameters from this first fit, to find a prediction for the actual
recovery temperature $T_{r}(t)$. After recalculating $Q$ using \eqref{eq:DHterm}
with that estimate of $T_{r}(t)$ in place of $T_{m}(t)$, the calculation
of phase and amplitude was repeated and the results were fitted again
by adjusting the fit parameters. Only very minor changes arose from
this procedure even after one iteration, but the iterated result is
the one used here to represent the unheated Rosemount 102E4AL sensor.

<<GVcheck>>=

## This chunk checks GV measurements for consistency with the previous results from the C-130,
## with results reasonably consistent with those results. Decided that they don't merit a
## separate result for the GV.
DSX <- getNetCDF(file.path(DataDirectory(), 'SOCRATES/rf15h.nc'),
                 standardVariables(c('ATF1', 'ATH1', 'ATH2')), 55200, 62000)
DCX <- getNetCDF(file.path(DataDirectory(), 'CSET/rf05h.nc'),
                 standardVariables(c('ATF1', 'ATH1', 'ATH2')), 175000, 205000)
rf.txt <- attr(DSX$ATF1, 'RecoveryFactor')
rf <- gsub('mach', 'MACHX', rf.txt)
rf <- gsub(' log', ' * log', rf)
rf <- gsub(' \\(', ' * \\(', rf)
rf <- with(DSX, eval(parse(text=rf)))
rf2.txt <- attr(DSX$ATH1, 'RecoveryFactor')
rf2 <- gsub('mach', 'MACHX', rf2.txt)
rf2 <- gsub(' log', ' * log', rf2)
rf2 <- gsub(' \\(', ' * \\(', rf2)
rf2 <- with(DSX, eval(parse(text=rf2)))
DSX$RTF1 <- DSX$ATF1 + rf * DSX$TASX^2 / 2010
DSX$RTF1 <- SmoothInterp(DSX$RTF1, .Length=0)
DSX$RTH1 <- DSX$ATH1 + rf2 * DSX$TASX^2 / 2010
DSX$RTH1 <- SmoothInterp(DSX$RTH1, .Length=0)
XXA <- rf * DSX$MACHX^2 / 5
DSX$Q <- (DSX$RTF1 + 273.15) * XXA / (1 + XXA)
DSX$Q <- SmoothInterp(DSX$Q, .Length=0)
DSX$Q <- ShiftInTime(DSX$Q, .rate=25, .shift=-10)
rf.txt <- attr(DCX$ATF1, 'RecoveryFactor')
rf <- gsub('mach', 'MACHX', rf.txt)
rf <- gsub(' log', ' * log', rf)
rf <- gsub(' \\(', ' * \\(', rf)
rf <- with(DCX, eval(parse(text=rf)))
rf2.txt <- attr(DCX$ATH1, 'RecoveryFactor')
rf2 <- gsub('mach', 'MACHX', rf2.txt)
rf2 <- gsub(' log', ' * log', rf2)
rf2 <- gsub(' \\(', ' * \\(', rf2)
rf2 <- with(DCX, eval(parse(text=rf2)))
DCX$RTF1 <- DCX$ATF1 + rf * DCX$TASX^2 / 2010
DCX$RTF1 <- SmoothInterp(DCX$RTF1, .Length=0)
DCX$RTH1 <- DCX$ATH1 + rf2 * DCX$TASX^2 / 2010
DCX$RTH1 <- SmoothInterp(DCX$RTH1, .Length=0)
XXA <- rf * DCX$MACHX^2 / 5
DCX$Q <- (DCX$RTF1 + 273.15) * XXA / (1 + XXA)
DCX$Q <- SmoothInterp(DCX$Q, .Length=0)
DCX$Q <- ShiftInTime(DCX$Q, .rate=25, .shift=-10)
## May need to revise this with corrected RT in second iteration
# RX <- CohPhase(DSA, 'RTF1', 'Q', plotType='Ranadu')
SB <- 100
DSX$RT <- DSX$RTF1
DCX$RT <- DCX$RTF1
## Next is for Z adjustment later
DZ <- rbind(DSX %>% selectTime(55200, 60200),
            DSX %>% selectTime(60500, 61500),
            DCX %>% selectTime(175200, 180200),
            DCX %>% selectTime(194530, 195530),
            DCX %>% selectTime(203717, 204717))
DSA <- DSX %>% selectTime(55200, 60200)
RXA <- DSX %>% selectTime(55200, 60200) %>% CohP('RT', 'Q', plotType='Ranadu', smoothBins=SB)
RXB <- DSX %>% selectTime(60500, 61500) %>% CohP('RT', 'Q', plotType='Ranadu', smoothBins=SB)
RXC <- DCX %>% selectTime(175200, 180200) %>% CohP('RT', 'Q', plotType='Ranadu', smoothBins=SB)
RXD <- DCX %>% selectTime(194530, 195530) %>% CohP('RT', 'Q', plotType='Ranadu', smoothBins=SB)
RXE <- DCX %>% selectTime(203717, 204717) %>% CohP('RT', 'Q', plotType='Ranadu', smoothBins=SB)
## May need to revise this with corrected RT in second iteration
Z <- capture.output (Vr <- SmoothInterp(detrend (DSA[, c('Time', 'RT')]), .Length=0))
Z <- capture.output (VrC <- SmoothInterp(detrend (DSA[, c('Time', 'Q')]), .Length=0))
Rate <- attr(DSA, 'Rate')
vcv <- cbind(ts(Vr, frequency=Rate), ts(VrC, frequency=Rate))
P <- spec.pgram(vcv, detrend=FALSE, fast=TRUE, plot=FALSE, spans=25)
df1SF <- data.frame(P$coh, log(P$freq))
df2SF <- data.frame (P$phase, log(P$freq))
pf1SF <- binStats (df1SF, bins=SB)
pf2SF <- binStats (df2SF, bins=SB)
phaseSF <- rep(0, SB)
nphaseSF <- rep(0, SB)
phase2SF <- rep(0, SB)
arSF <- rep(0, SB)
ar2SF <- rep(0, SB)
narSF <- rep(0, SB)
for (RX in list(RXA, RXB, RXC, RXD, RXE)) {
  for (i in 2:nrow(RX)) {
    phaseSF[RX$BIN.1[i]] <- phaseSF[RX$BIN.1[i]] + RX$P.phase[i]
    nphaseSF[RX$BIN.1[i]] <- nphaseSF[RX$BIN.1[i]] + 1
    phase2SF[RX$BIN.1[i]] <- phase2SF[RX$BIN.1[i]] + RX$P.phase[i]^2
    arSF[RX$BIN.1[i]] <- arSF[RX$BIN.1[i]] + sqrt(RX$P.spec...1.[i] / RX$P.spec...2.[i])
    ar2SF[RX$BIN.1[i]] <- ar2SF[RX$BIN.1[i]] + (RX$P.spec...1.[i] / RX$P.spec...2.[i])
    narSF[RX$BIN.1[i]] <- narSF[RX$BIN.1[i]] + 1
  }
}
nphaseSF[nphaseSF == 0] <- 1
narSF[narSF == 0] <- 1
mphaseSF <- phaseSF/nphaseSF
mphase2SF <- phase2SF/nphaseSF
sdpSF <- sqrt(mphase2SF - mphaseSF^2)
mphaseSF <- mphaseSF * 180 / pi
sdpSF <- sdpSF * 180 / pi
sdpSF <- sdpSF * 2 / sqrt(nphaseSF)
arSF <- arSF / narSF
ar2SF <- ar2SF / narSF
b <- ar2SF - arSF^2
b[near(b, 0)] <- 0
sdrSF <- sqrt(b)
sdrSF <- sdrSF * 2 / sqrt(narSF)
dfSF <- data.frame(frq=exp(pf2SF$xc), mphase=mphaseSF, sdp=sdpSF)
dfSF <- dfSF[dfSF$frq > 0.05, ]
dfSF <- dfSF[dfSF$sdp > 0, ]
dfSF <- dfSF[dfSF$frq < 8, ]
dfrSF <- data.frame(frq=exp(pf2SF$xc), mrspec=arSF, sdr=sdrSF)
dfrSF <- dfrSF[dfrSF$frq > 0.05, ]
dfrSF <- dfrSF[dfrSF$sdr > 0, ]
dfrSF <- dfrSF[dfrSF$frq < 8, ]
frq <- exp(pf2SF$xc)
Parm <- Param1
minFn <- function(V) {
  Parm$a <<- V[1]
  Parm$tau1 <<- V[2]
  Parm$tau2 <<- V[3]
  Chisq <- 0
  for (i in 1:nrow(dfSF)) {
    Chisq <- Chisq + (dfSF$mphase[i] - LTphase(dfSF$frq[i], Parm)$Phase)^2 / dfSF$sdp[i]^2
  }
  for (i in 1:nrow(dfrSF)) {
    Chisq <- Chisq + (dfrSF$mrspec[i] - LTphase(dfrSF$frq[i], Parm)$Amp)^2 / dfrSF$sdr[i]^2
  }
  return (Chisq)
}
ASF <- optim (c(Parm$a, Parm$tau1, Parm$tau2), minFn, hessian=TRUE)
bestSF <- ASF$par
HerrorSF <- solve(ASF$hessian / 4)  # factor of 4 because 2-sigma errors were used?
uncLimitsSF <- sqrt(diag(HerrorSF))
print(bestSF)
HSF <- LTphase(dfrSF$frq, Parm)
dfrSF$Amp <- HSF$Amp
dfrSF$Phase <- HSF$Phase
ParamSF <- Param2
ParGV <- Parm
rhozero <- 1013.25 * 100 / (287.05 * 288.15)
MRHO <- MachNumber(DZ$PSXC, DZ$QCXC) * DZ$PSXC * 100 / 
        (287.05 * (273.15 + DZ$ATX)) / rhozero
ParGV$tau1 <- ParGV$tau1 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ 0.6
ParGV$tau2 <- ParGV$tau2 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ 0.6

g <- ggplot(dfSF, aes(x=frq, y=mphase))+geom_point()
g <- g + xlab('frequency [Hz]') + ylab ('phase RTF1 x Q [degrees]')
g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x, n=4),
                       labels = trans_format("log10", math_format(expr = 10^.x))) + xlab('frequency [Hz]')
g <- g + annotation_logticks(sides = "bt")
g <- g + geom_errorbar(aes(ymin=mphase-sdp, ymax=mphase+sdp), width=0.06)
g <- g + geom_path(data=dfrSF, aes(x=frq, y=Phase), col='forestgreen')
# g <- g + geom_path(data=dfAPSF, aes(x=Time, y=Phase), col='darkorange')
g + theme_WAC(1)

frq <- exp(pf2SF$xc[narSF > 0])
# spec1 <- spec1[nspec1 > 0]
# spec2 <- spec2[nspec1 > 0]
# rspec <- spec1 / spec2
# plotWAC(data.frame(frq, mrspec), xlab='frequency [Hz]', ylab='amplitude ratio RTRR/Q', type='p', 
#         col='blue', log='x', pch=20, xlim=c(0.1,15), ylim=c(0,1.2))
# HR <- LTphase(frq, Param1)
# P <- Param1
# P$tau2 <- 0.84
# HR2 <- LTphase(frq, P)
# lines(frq, (HR2$Amp)^2, col='forestgreen', lwd=2)
# lines(frq, (HR$Amp)^2, col='darkorange', lwd=2, lty=2)
g <- ggplot(dfrSF, aes(x=frq, y=mrspec))+geom_point()
g <- g + xlab('frequency [Hz]') + ylab ('amplitude ratio RTF1 / Q')
g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x, n=2),
                       labels = trans_format("log10", math_format(expr = 10^.x))) + xlab('frequency [Hz]')
g <- g + annotation_logticks(sides = "bt")
g <- g + geom_errorbar(aes(ymin=mrspec-sdr, ymax=mrspec+sdr), width=0.06)
# g <- g + geom_path(data=dfAPSF, aes(x=Time, y=Amp), col='darkorange')
g <- g + geom_path(data=dfrSF, aes(x=frq, y=Amp), col='forestgreen')
suppressWarnings(print(g + ylim(0, 1.3) + theme_WAC(1)))
CohPhase(DSA, 'RTF1', 'Q')
DSA %>% select(Time, TASX, RTF1, Q, ATF1) %>% VSpec()
print(bestSF)

@

<<S11a>>=

DS11 <- getNetCDF(file.path(DataDirectory(), 'SOCRATES/SOCRATESrf11h.nc'), 
                  standardVariables(c('ATF1', 'ATH1')), 34850, 35900)
# DS11 <- DS11 %>% selectTime(44300, 44800)
dfAPSF <- dfAP[dfAP$Time > 0.5 & dfAP$Time < 8, ]
## Revise the calculation of dynamic heating to avoid dependence on AT:
rf.txt <- attr(DS11$ATF1, 'RecoveryFactor')
rf <- gsub('mach', 'MACHX', rf.txt)
rf <- gsub(' log', ' * log', rf)
rf <- gsub(' \\(', ' * \\(', rf)
rf <- with(DS11, eval(parse(text=rf)))
## RTF1 is not in the netCDF file so recalculate it:
DS11$RTF1 <- DS11$ATF1 + rf * DS11$TASX^2 / 2010
DS11$RTF1 <- SmoothInterp(DS11$RTF1, .Length=0)
## Now correct it using standard parameters:
## Integrate to find the support temperature Ts:
CorrectT <- FALSE
# CorrectT <- TRUE
if (CorrectT) {
  a <- Param1$a
  tau1 <- Param1$tau1
  tau2 <- Param1$tau2
  ## RT is the working solution; Ts is the support temperature
  DS11$Ts <- DS11$RTF1
  Rate <- attr (DS11, 'Rate')
  DS11$DTMDT <- c(0, diff(DS11$RTF1, 2), 0) * Rate / 2
  # DT$DTMDT <- (DT$DTMDT + c(0, DT$DTMDT[1:(nrow(DT)-1)])) / 2
  # DT$DTMDT <- as.vector (signal::filter(signal::sgolay(1, 3, m=1), DT$TTRR)) * Rate
  fS <- function(y, i) {  # Eq. Ts3
    ((1/a) * (tau1 * DS11$DTMDT[i] + DS11$RTF1[i] - (1-a) * y) - y) / (Rate * tau2)
  }
  
  DS11$Ts <- rk4.integrate (fS, DS11$Ts[1], 1:nrow(DS11))
  DS11$RT <- (1/a) * (tau1 * DS11$DTMDT + DS11$RTF1 - (1-a) * DS11$Ts)
} else {
  DS11$RT <- DS11$RTF1
}
XXA <- rf * DS11$MACHX^2 / 5
DS11$Q <- (DS11$RT + 273.15) * XXA / (1 + XXA)
DS11$Q <- SmoothInterp(DS11$Q, .Length=0)
## May need to revise this with corrected RT in second iteration
RX <- CohPhase(DS11, 'RT', 'Q', plotType='Ranadu')
SB <- 90
Z <- capture.output (Vr <- SmoothInterp(detrend (DS11[, c('Time', 'RT')]), .Length=0))
Z <- capture.output (VrC <- SmoothInterp(detrend (DS11[, c('Time', 'Q')]), .Length=0))
Rate <- attr(DS11, 'Rate')
vcv <- cbind(ts(Vr, frequency=Rate), ts(VrC, frequency=Rate))
P <- spec.pgram(vcv, detrend=FALSE, fast=TRUE, plot=FALSE, spans=25)
df1SF <- data.frame(P$coh, log(P$freq))
df2SF <- data.frame (P$phase, log(P$freq))
pf1SF <- binStats (df1SF, bins=SB)
pf2SF <- binStats (df2SF, bins=SB)
## Use DH2 to get the time-response-corrected-RT Q
RX1 <- CohP(DS11, 'RT', 'Q', plotType='Ranadu', smoothBins=SB)
phaseSF <- rep(0, SB)
nphaseSF <- rep(0, SB)
phase2SF <- rep(0, SB)
arSF <- rep(0, SB)
ar2SF <- rep(0, SB)
narSF <- rep(0, SB)
for (RX in list(RX1)) {
  for (i in 2:nrow(RX)) {
    phaseSF[RX$BIN.1[i]] <- phaseSF[RX$BIN.1[i]] + RX$P.phase[i]
    nphaseSF[RX$BIN.1[i]] <- nphaseSF[RX$BIN.1[i]] + 1
    phase2SF[RX$BIN.1[i]] <- phase2SF[RX$BIN.1[i]] + RX$P.phase[i]^2 
    arSF[RX$BIN.1[i]] <- arSF[RX$BIN.1[i]] + sqrt(RX$P.spec...1.[i] / RX$P.spec...2.[i])
    ar2SF[RX$BIN.1[i]] <- ar2SF[RX$BIN.1[i]] + (RX$P.spec...1.[i] / RX$P.spec...2.[i])
    narSF[RX$BIN.1[i]] <- narSF[RX$BIN.1[i]] + 1
  }
}
nphaseSF[nphaseSF == 0] <- 1
narSF[narSF == 0] <- 1
mphaseSF <- phaseSF/nphaseSF
mphase2SF <- phase2SF/nphaseSF
sdpSF <- sqrt(mphase2SF - mphaseSF^2)
mphaseSF <- mphaseSF * 180 / pi
sdpSF <- sdpSF * 180 / pi
sdpSF <- sdpSF * 2 / sqrt(nphaseSF)
arSF <- arSF / narSF
ar2SF <- ar2SF / narSF
b <- ar2SF - arSF^2
b[near(b, 0)] <- 0
sdrSF <- sqrt(b)
sdrSF <- sdrSF * 2 / sqrt(narSF)
dfSF <- data.frame(frq=exp(pf2SF$xc), mphase=mphaseSF, sdp=sdpSF)
dfSF <- dfSF[dfSF$frq > 0.5, ]
dfSF <- dfSF[dfSF$sdp > 0, ]
dfSF <- dfSF[dfSF$frq < 8, ]
dfrSF <- data.frame(frq=exp(pf2SF$xc), mrspec=arSF, sdr=sdrSF)
dfrSF <- dfrSF[dfrSF$frq > 0.5, ]
dfrSF <- dfrSF[dfrSF$sdr > 0, ]
dfrSF <- dfrSF[dfrSF$frq < 8, ]
frq <- exp(pf2SF$xc)

Param2 <- Param1
minFn <- function(V) {
  Param2$a <<- V[1]
  Param2$tau1 <<- V[2]
  Param2$tau2 <<- V[3]
  Chisq <- 0
  for (i in 1:nrow(dfSF)) {
    Chisq <- Chisq + (dfSF$mphase[i] - LTphase(dfSF$frq[i], Param2)$Phase)^2 / dfSF$sdp[i]^2
  }
  for (i in 1:nrow(dfrSF)) {
    Chisq <- Chisq + (dfrSF$mrspec[i] - LTphase(dfrSF$frq[i], Param2)$Amp)^2 / dfrSF$sdr[i]^2
  }
  return (Chisq)
}
ASF <- optim (c(Param2$a, Param2$tau1, Param2$tau2), minFn, method='L-BFGS-B', lower=0, upper=1, hessian=TRUE)
bestSF <- ASF$par
HerrorSF <- solve(ASF$hessian / 4)  # factor of 4 because 2-sigma errors were used?
uncLimitsSF <- sqrt(diag(HerrorSF))
HSF <- LTphase(dfSF$frq, Param2)
dfSF$Amp <- HSF$Amp
dfSF$Phase <- HSF$Phase
ParamSF <- Param2

g <- ggplot(dfSF, aes(x=frq, y=mphase))+geom_point()
g <- g + xlab('frequency [Hz]') + ylab ('phase RTF1 x Q [degrees]')
g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x, n=4),
                       labels = trans_format("log10", math_format(expr = 10^.x))) + xlab('frequency [Hz]')
g <- g + annotation_logticks(sides = "bt")
g <- g + geom_errorbar(aes(ymin=mphase-sdp, ymax=mphase+sdp), width=0.06)
g <- g + geom_path(data=dfSF, aes(x=frq, y=Phase), col='forestgreen')
g <- g + geom_path(data=dfAPSF, aes(x=Time, y=Phase), col='darkorange')
g + theme_WAC(1)

frq <- exp(pf2SF$xc[narSF > 0])
# spec1 <- spec1[nspec1 > 0]
# spec2 <- spec2[nspec1 > 0]
# rspec <- spec1 / spec2
# plotWAC(data.frame(frq, mrspec), xlab='frequency [Hz]', ylab='amplitude ratio RTRR/Q', type='p', 
#         col='blue', log='x', pch=20, xlim=c(0.1,15), ylim=c(0,1.2))
# HR <- LTphase(frq, Param1)
# P <- Param1
# P$tau2 <- 0.84
# HR2 <- LTphase(frq, P)
# lines(frq, (HR2$Amp)^2, col='forestgreen', lwd=2)
# lines(frq, (HR$Amp)^2, col='darkorange', lwd=2, lty=2)
g <- ggplot(dfrSF, aes(x=frq, y=mrspec))+geom_point()
g <- g + xlab('frequency [Hz]') + ylab ('amplitude ratio RTF1 / Q')
g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x, n=2),
                       labels = trans_format("log10", math_format(expr = 10^.x))) + xlab('frequency [Hz]')
g <- g + annotation_logticks(sides = "bt")
g <- g + geom_errorbar(aes(ymin=mrspec-sdr, ymax=mrspec+sdr), width=0.06)
g <- g + geom_path(data=dfAPSF, aes(x=Time, y=Amp), col='darkorange')
g <- g + geom_path(data=dfSF, aes(x=frq, y=Amp), col='forestgreen')
suppressWarnings(print(g + ylim(0, 1.3) + theme_WAC(1)))
print(bestSF)
rhozero <- 1013.25*100/(287.05*288.15)
MRHOGV <- MachNumber(DS11$PSXC, DS11$QCXC) * DS11$PSXC * 100 / (287.05 * 
                   (273.15 + DS11$ATX)) / rhozero
ParamSF$tau1 <- ParamSF$tau1 * (mean(MRHOGV, na.rm=TRUE) / 0.3)^0.6
ParamSF$tau2 <- ParamSF$tau2 * (mean(MRHOGV, na.rm=TRUE) / 0.3)^0.6

@

The airflow and typical flow angles approaching a sensor can affect
its response, so the results might change when installed on a different
location or a different aircraft. Therefore a similar evaluation examined
the response of this same sensor when flown on the NSF/NCAR GV, which
flies significantly faster than the C-130. The results of a study
using a combined low-level dataset from the SOCRATES (\citet{mcfarquhar2014southern})
and CSET (\citet{albrecht2019cloud}) experiments, which were flown
over the Pacific Ocean, were similar to but slightly different from
the coefficients determined on the C-130, with both time constants
a little smaller than found for the C-130 ($\tau_{1}=$\Sexpr{round(ParGV$tau1, 3)}
and $\tau_{2}=$\Sexpr{round(ParGV$tau2, 2)}). This might be expected
at greater airspeed, as discussed in Sect.~\ref{subsec:Expected-dependence-on}.


\subsubsection{Heated sensors\label{subsec:Heated-sensors}}

<<SOCrf08, include=FALSE>>=

DS <- getNetCDF('/Data/SOCRATES/SOCRATESrf08h.nc', 
        standardVariables(c('ATF1', 'ATH1', 'ATH2', 'RTF1', 'RTH1', 'RTH2')),
        45600, 50100)
DS$TASX <- SmoothInterp(DS$TASX, .Length=0)
DS$Q <- DS$TASX^2 / 2010
DS$ATX <- DS$ATF1
DS$AT <- reviseDH(DS, ParamSF, 0.985)
DS$AT <- SmoothInterp(DS$AT, .Length=0)
## Small time adjustment seems useful?
# DS$Q <- ShiftInTime(DS$Q, .shift=-25, .rate=25)
DS <- DS %>% selectTime(45600, 50100)
DS$RHOCP <- 100 * DS$PSXC / (287.05 * 278) * 1005
DS$RHOCP <- SmoothInterp(DS$RHOCP, .Length=0)
SB <- 50
Z <- capture.output (Vr <- SmoothInterp(detrend (DS[, c('Time', 'RTH1')]), .Length=0))
Z <- capture.output (VrB <- SmoothInterp(detrend (DS[, c('Time', 'RTH2')]), .Length=0))
Z <- capture.output (VrF <- SmoothInterp(detrend (DS[, c('Time', 'RTF1')]), .Length=0))
Z <- capture.output (VrC <- SmoothInterp(detrend (DS[, c('Time', 'Q')]), .Length=0))
Rate <- attr(DS, 'Rate')
vcv <- cbind(ts(Vr, frequency=Rate), ts(VrC, frequency=Rate))
P <- spec.pgram(vcv, detrend=FALSE, fast=TRUE, plot=FALSE, spans=25)
vcv <- cbind(ts(VrB, frequency=Rate), ts(VrC, frequency=Rate))
PB <- spec.pgram(vcv, detrend=FALSE, fast=TRUE, plot=FALSE, spans=25)
vcv <- cbind(ts(VrF, frequency=Rate), ts(VrC, frequency=Rate))
PF <- spec.pgram(vcv, detrend=FALSE, fast=TRUE, plot=FALSE, spans=25)
dfHS <- data.frame(P$coh, log(P$freq))
dfHSB <- data.frame(PB$coh, log(PB$freq))
dfHSF <- data.frame(PF$coh, log(PF$freq))
pfHS <- binStats (dfHS, bins=SB)
RXHS <- CohP(DS, 'RTH1', 'Q', plotType='Ranadu', smoothBins=SB)
pfHSB <- binStats (dfHSB, bins=SB)
RXHSB <- CohP(DS, 'RTH2', 'Q', plotType='Ranadu', smoothBins=SB)
pfHSF <- binStats (dfHSF, bins=SB)
RXHSF <- CohP(DS, 'RTF1', 'Q', plotType='Ranadu', smoothBins=SB)
phaseHS <- rep(0, SB)
nphaseHS <- rep(0, SB)
phase2HS <- rep(0, SB)
arHS <- rep(0, SB)
ar2HS <- rep(0, SB)
narHS <- rep(0, SB)
RXHS$P.spec...1.[RXHS$P.spec...1. < 0] <- 0
phaseHSB <- rep(0, SB)
nphaseHSB <- rep(0, SB)
phase2HSB <- rep(0, SB)
arHSB <- rep(0, SB)
ar2HSB <- rep(0, SB)
narHSB <- rep(0, SB)
RXHSB$P.spec...1.[RXHSB$P.spec...1. < 0] <- 0
phaseHSF <- rep(0, SB)
nphaseHSF <- rep(0, SB)
phase2HSF <- rep(0, SB)
arHSF <- rep(0, SB)
ar2HSF <- rep(0, SB)
narHSF <- rep(0, SB)
RXHSF$P.spec...1.[RXHSF$P.spec...1. < 0] <- 0
for (i in 2:nrow(RXHS)) {
  phaseHS[RXHS$BIN.1[i]] <- phaseHS[RXHS$BIN.1[i]]+RXHS$P.phase[i]
  nphaseHS[RXHS$BIN.1[i]] <- nphaseHS[RXHS$BIN.1[i]] + 1
  phase2HS[RXHS$BIN.1[i]] <- phase2HS[RXHS$BIN.1[i]]+RXHS$P.phase[i]^2 
  arHS[RXHS$BIN.1[i]] <- arHS[RXHS$BIN.1[i]] + 
             sqrt(RXHS$P.spec...1.[i] / RXHS$P.spec...2.[i])
  ar2HS[RXHS$BIN.1[i]] <- ar2HS[RXHS$BIN.1[i]] + 
             (RXHS$P.spec...1.[i] / RXHS$P.spec...2.[i])
  narHS[RXHS$BIN.1[i]] <- narHS[RXHS$BIN.1[i]] + 1
  phaseHSB[RXHSB$BIN.1[i]] <- phaseHSB[RXHSB$BIN.1[i]]+RXHSB$P.phase[i]
  nphaseHSB[RXHSB$BIN.1[i]] <- nphaseHSB[RXHSB$BIN.1[i]] + 1
  phase2HSB[RXHSB$BIN.1[i]] <- phase2HSB[RXHSB$BIN.1[i]]+RXHSB$P.phase[i]^2 
  arHSB[RXHSB$BIN.1[i]] <- arHSB[RXHSB$BIN.1[i]] + 
             sqrt(RXHSB$P.spec...1.[i] / RXHSB$P.spec...2.[i])
  ar2HSB[RXHSB$BIN.1[i]] <- ar2HSB[RXHSB$BIN.1[i]] + 
             (RXHSB$P.spec...1.[i] / RXHSB$P.spec...2.[i])
  narHSB[RXHSB$BIN.1[i]] <- narHSB[RXHSB$BIN.1[i]] + 1
  phaseHSF[RXHSF$BIN.1[i]] <- phaseHSF[RXHSF$BIN.1[i]]+RXHSF$P.phase[i]
  nphaseHSF[RXHSF$BIN.1[i]] <- nphaseHSF[RXHSF$BIN.1[i]] + 1
  phase2HSF[RXHSF$BIN.1[i]] <- phase2HSF[RXHSF$BIN.1[i]]+RXHSF$P.phase[i]^2 
  arHSF[RXHSF$BIN.1[i]] <- arHSF[RXHSF$BIN.1[i]] + 
             sqrt(RXHSF$P.spec...1.[i] / RXHSF$P.spec...2.[i])
  ar2HSF[RXHSF$BIN.1[i]] <- ar2HSF[RXHSF$BIN.1[i]] + 
             (RXHSF$P.spec...1.[i] / RXHSF$P.spec...2.[i])
  narHSF[RXHSF$BIN.1[i]] <- narHSF[RXHSF$BIN.1[i]] + 1
}
narHS[narHS <= 0] <- 1
nphaseHS[nphaseHS == 0] <- 1
mphaseHS <- phaseHS/nphaseHS
mphase2HS <- phase2HS/nphaseHS
sdpHS <- sqrt(mphase2HS - mphaseHS^2)
mphaseHS <- mphaseHS * 180 / pi
sdpHS <- sdpHS * 180 / pi
sdpHS <- sdpHS * 2 / sqrt(nphaseHS)
arHS <- arHS / narHS
ar2HS <- ar2HS / narHS
b <- ar2HS - arHS^2
b[near(b, 0)] <- 0
sdrHS <- sqrt(b)
sdrHS <- sdrHS * 2 / sqrt(narHS)
narHSB[narHSB <= 0] <- 1
nphaseHSB[nphaseHSB == 0] <- 1
mphaseHSB <- phaseHSB/nphaseHSB
mphase2HSB <- phase2HSB/nphaseHSB
sdpHSB <- sqrt(mphase2HSB - mphaseHSB^2)
mphaseHSB <- mphaseHSB * 180 / pi
sdpHSB <- sdpHSB * 180 / pi
sdpHSB <- sdpHSB * 2 / sqrt(nphaseHSB)
arHSB <- arHSB / narHSB
ar2HSB <- ar2HSB / narHSB
b <- ar2HSB - arHSB^2
b[near(b, 0)] <- 0
sdrHSB <- sqrt(b)
sdrHSB <- sdrHSB * 2 / sqrt(narHSB)
narHSF[narHSF <= 0] <- 1
nphaseHSF[nphaseHSF == 0] <- 1
mphaseHSF <- phaseHSF/nphaseHSF
mphase2HSF <- phase2HSF/nphaseHSF
sdpHSF <- sqrt(mphase2HSF - mphaseHSF^2)
mphaseHSF <- mphaseHSF * 180 / pi
sdpHSF <- sdpHSF * 180 / pi
sdpHSF <- sdpHSF * 2 / sqrt(nphaseHSF)
arHSF <- arHSF / narHSF
ar2HSF <- ar2HSF / narHSF
b <- ar2HSF - arHSF^2
b[near(b, 0)] <- 0
sdrHSF <- sqrt(b)
sdrHSF <- sdrHSF * 2 / sqrt(narHSF)

@

Measurements from two slower sensors, a heated Goodrich/Rosemount
102 sensor and a similar \href{https://www.eol.ucar.edu/instruments/heated-ambient-temperature-sensor}{\textquotedblleft Harco Model 100009-1 Deiced TAT\textquotedblright}
(HARCO) sensor, have also been evaluated, but only the latter is discussed
here because they have similar response. The spectral variance for
both these measurements has apparent rapid attenuation beginning at
about 0.1~Hz, as shown in Fig.~\ref{fig:HARCOSpec}, and the response
is attenuated seriously above about 1~Hz.

Attempts to use the same three-parameter representation of the transfer
function relative to dynamic heating led to unsatisfactory fits, so
a different approach is used here. Because the evaluation in Sect.~\ref{subsec:The-unheated-Rosemount}
provides a good representation of the unheated Rosemount 102E4AL sensor,
the measurements from that sensor, corrected as will be described
in Appendix A, were used as the reference for the assumed-correct
recovery temperature. Then the phase and amplitude ratio were found
for the transfer function required to produce the heated-probe measurements
from the unheated-probe measurements. This did not require any assumptions
about equations or parameters determining the transfer function.

<<extraUHR, include=FALSE, echo=FALSE>>=

# SB <- 30
Z <- capture.output (Vr <- SmoothInterp(detrend (DT1[, c('Time', 'TTWH')]), .Length=0))
Z <- capture.output (VrC <- SmoothInterp(detrend (DT1[, c('Time', 'DH')]), .Length=0))
Rate <- attr(DT1, 'Rate')
vcv <- cbind(ts(Vr, frequency=Rate), ts(VrC, frequency=Rate))
P <- spec.pgram(vcv, detrend=FALSE, fast=TRUE, plot=FALSE, spans=25)
df1W <- data.frame(P$coh, log(P$freq))
pf1W <- binStats (df1W, bins=SB)
RX1W <- CohP(DT1, 'TTWH', 'RT', plotType='Ranadu', smoothBins=SB)
RX2W <- CohP(DT2, 'TTWH', 'RT', plotType='Ranadu', smoothBins=SB)
RX3W <- CohP(DT3, 'TTWH', 'RT', plotType='Ranadu', smoothBins=SB)
RX4W <- CohP(DT4, 'TTWH', 'RT', plotType='Ranadu', smoothBins=SB)
RX5W <- CohP(DT5, 'TTWH', 'RT', plotType='Ranadu', smoothBins=SB)
# RX6W <- CohP(DT6, 'TTWH', 'DH', plotType='Ranadu', smoothBins=SB)
phaseW <- rep(0, SB)
nphaseW <- rep(0, SB)
phase2W <- rep(0, SB)
arW <- rep(0, SB)
ar2W <- rep(0, SB)
narW <- rep(0, SB)
for (RX in list(RX1W, RX2W, RX3W, RX4W, RX5W)) {
  for (i in 2:nrow(RX)) {
    phaseW[RX$BIN.1[i]] <- phaseW[RX$BIN.1[i]]+RX$P.phase[i]
    nphaseW[RX$BIN.1[i]] <- nphaseW[RX$BIN.1[i]] + 1
    phase2W[RX$BIN.1[i]] <- phase2W[RX$BIN.1[i]]+RX$P.phase[i]^2 
    arW[RX$BIN.1[i]] <- arW[RX$BIN.1[i]] + sqrt(RX$P.spec...1.[i] / RX$P.spec...2.[i])
    ar2W[RX$BIN.1[i]] <- ar2W[RX$BIN.1[i]] + (RX$P.spec...1.[i] / RX$P.spec...2.[i])
    narW[RX$BIN.1[i]] <- narW[RX$BIN.1[i]] + 1
  }
}
nphaseW[nphaseW == 0] <- 1
mphaseW <- phaseW/nphaseW
mphase2W <- phase2W/nphaseW
sdpW <- sqrt(mphase2W - mphaseW^2)
mphaseW <- mphaseW * 180 / pi
sdpW <- sdpW * 180 / pi
sdpW <- sdpW * 2 / sqrt(nphaseW)
arW <- arW / narW
ar2W <- ar2W / narW
sdrW <- sqrt(ar2W - arW^2)
sdrW <- sdrW * 2 / sqrt(narW)

@

<<RTH1Spec, include=FALSE, echo=FALSE, fig.pos='t', fig.height=4, fig.cap='Spectral variance $P(\\nu)$ weighted by frequency ($\\nu$) for the recovery temperature measured by a heated  and by an unheated Rosemount sensor. The background includes orange dotted lines denoting $-2/3$ slope and the wavelength scale is determined from the average airspeed.'>>=

# g <- VSpec(DT, 'TTWH', spans=99, ylim=c(1.e-6, 1))
# suppressWarnings(print(VSpec(DT, 'TTRR', add=g, spans=99) + theme_WAC(1)))
DT$temperature <- DT$TTWH
DT %>% select(Time, TASX, temperature, TTRR) %>% 
       VSpec(spans=199, VLabel=c('heated', 'unheated'), 
             xlim=c(0.03, 12), ylim=c(4.e-7, 0.01), 
             method='MEM', poles=100, smoothBins=200) + 
  theme_WAC(1)

@

<<tfHR, include=FALSE, eval=FALSE, fig.height=3.6, fig.pos='p', fig.cap='Transfer function for the heated Rosemount 102 sensor, based on measurements from the NSF/NCAR C-130 in the VOCALS project. Because the results showed high variability and inconsistency for frequencies above 1 Hz, only results for frequencies below that limit are shown. See the text for the fitted equations producing these curves.'>>=

frq <- seq(0.01, 1.1, by=0.01)
dfAPW <- data.frame('Time' = frq)
dfAPW$Amp <- cfr[1]+cfr[2]*log(frq)+cfr[3]*log(frq)^3+cfr[4]*log(frq)^5
dfAPW$Amp[dfAPW$Time < 0.09] <- 1 
APW <- LTphase(dfAPW$Time, Param2)
dfAPW$Amp2 <- APW$Amp
dfAPW$Phase <- cf[1]+cf[2]*log(frq)+cf[3]*log(frq)^2+cf[4]*atan(frq)
dfAPW$Phase2 <- APW$Phase

g <-
  ggplotWAC(
    dfAPW,
    panels = 2,
    labelP = c('    Amplitude', 'Phase [degrees]'),
    labelL = c('lfit', '3-par')
  )
g <- g + xlab('frequency [Hz]') + ylab(bquote('transfer function H(' * nu ~ ')'))
g <-
  g + scale_x_log10(
    breaks = trans_breaks("log10", function(x)
      10 ^ x, n = 3),
    labels = trans_format("log10", math_format(expr = 10 ^ .x))
  ) + xlab('frequency [Hz]')
g <- g + annotation_logticks(sides = 'tb')
g <- g + theme_WAC(1) + theme(legend.position = c(0.3, 0.65))

@

<<HARCOSpec, include = TRUE, fig.height=3, fig.pos='t', fig.cap='Spectral variance $P(\\nu)$ weighted by frequency ($\\nu$) for the recovery temperature measured by a heated  HARCO and an unheated Rosemount sensor.'>>=

DCX$temperature <- DCX$RT
DCX %>% selectTime(175200, 180200) %>% select(Time, TASX, temperature, RTH1) %>%
        VSpec(VLabel=c('unheated', 'HARCO'), ylim=c(1.e-6, 0.1)) +
        ylab(bquote('spectral variance ' ~ nu * 'P(' * nu * ')')) +    
        theme_WAC(1) + theme(legend.position=c(0.7, 0.9))

@

<<phaseG, include = FALSE, fig.show = 'asis', fig.height = 6, fig.cap = 'The phase (top) and gain (bottom) of the transfer function determined for the heated Rosemount 102 sensor (variable TTWH) and the recovery temperature obtained by applying transfer-function corrections to the measurments from the unheated Rosemount 102E4AL sensor (variable RT). Error bars are two-standard-deviation estimates of the uncertainty in the mean values shown by plotted circles. Because the results showed high variability and inconsistency for frequencies above 1 Hz, only results for frequencies below that limit are shown. The fits are described in the text.'>>=

dfW <- data.frame(frq=exp(pf1W$xc), mphase=mphaseW, sdp=sdpW)
dfrW <- data.frame(frq=exp(pf1W$xc), mrspec=arW, sdr=sdrW)
dfW <- dfW[dfW$frq > 0.01 & dfW$frq <= 1, ]
dfrW <- dfrW[dfrW$frq > 0.01 & dfrW$frq <= 1, ]
Param2 <- Param1
Param2$tau1 <- 0.5
Param2$tau2 <- 0.8
minFn <- function(V) {
  Param2$a <<- V[1]
  Param2$tau1 <<- V[2]
  Param2$tau2 <<- V[3]
  Chisq <- 0
  for (i in 1:nrow(dfW)) {
    Chisq <- Chisq + (dfW$mphase[i] - LTphase(dfW$frq[i], Param2)$Phase)^2 / dfW$sdp[i]^2
  }
  for (i in 1:nrow(dfrW)) {
    Chisq <- Chisq + (dfrW$mrspec[i] - LTphase(dfrW$frq[i], Param2)$Amp)^2 / dfrW$sdr[i]^2
  }
  return (Chisq)
}
AW <- optim (c(Param2$a, Param2$tau1, Param2$tau2), minFn, hessian=TRUE)
bestW <- AW$par
HerrorW <- solve(AW$hessian / 4)  # factor of 4 because 2-sigma errors were used?
uncLimitsW <- sqrt(diag(HerrorW))
g <- ggplot(dfW, aes(x=frq, y=mphase))+geom_point()
g <- g + xlab('frequency [Hz]') + ylab (bquote('phase [' ~ degree * ']'))
g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x, n=2),
                       labels = trans_format("log10", math_format(expr = 10^.x))) + xlab('frequency [Hz]')
g <- g + annotation_logticks(sides = "bt")
g <- g + geom_errorbar(aes(ymin=mphase-sdp, ymax=mphase+sdp), width=0.05)
# g <- g + geom_path(data=dfW, aes(x=frq, y=mphase), col='forestgreen')
cf <- coef(lm(data=dfW, mphase ~ log(frq)+I(log(frq)^2)+I(atan(frq))))
dfW$Ph <- cf[1]+cf[2]*log(dfW$frq)+cf[3]*log(dfW$frq)^2+cf[4]*atan(dfW$frq)
dfW$PhLT <- LTphase(dfW$frq, Param2)$Phase
g <- g + geom_path(data=dfW, aes(x=frq, y=Ph, col='lfit', lty='lfit'))
g <- g + geom_path(data=dfW, aes(x=frq, y=PhLT, col='3-par', lty='3-par'))
g <-
  g + scale_colour_manual (
    name = 'fit: ',
    values = c("lfit" = "forestgreen", "3-par" = "blue")
  )
g <- g + scale_linetype_manual (name = 'fit: ', 
                                values = c('lfit' = 4, '3-par'=1))
g1 <- g + theme_WAC(1) + theme(legend.position = c(0.75, 0.75),
                                legend.direction = 'vertical')
g <- ggplot(dfrW, aes(x=frq, y=mrspec))+geom_point()
g <- g + xlab('frequency [Hz]') + ylab ('amplitude ratio TTWH / RT')
g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x, n=2),
         labels = trans_format("log10", math_format(expr = 10^.x))) + xlab('frequency [Hz]')
g <- g + annotation_logticks(sides = "bt")
g <- g + geom_errorbar(aes(ymin=mrspec-sdr, ymax=mrspec+sdr), width=0.05)
# g <- g + geom_path(data=dfAP, aes(x=Time, y=Amp), col='forestgreen')
# g <- g + geom_path(data=dfr, aes(x=frq, y=Amp5), col='darkorange', lty=2)
cfr <- coef(lm(data=dfrW[dfrW$frq > 0.07, ], mrspec ~ log(frq) + I(log(frq)^3) + 
               I(log(frq)^5)))
dfrW$G <- cfr[1] + cfr[2] * log(dfrW$frq)    + 
           cfr[3] * log(dfrW$frq)^3 + cfr[4] * log(dfrW$frq)^5
dfrW$G[dfrW$frq < 0.08] <- 1
dfrW$GLT <- LTphase(dfrW$frq, Param2)$Amp
g <- g + geom_path(data=dfrW, aes(x=frq, y=G, col='lfit', lty='lfit'))
g <- g + geom_path(data=dfrW, aes(x=frq, y=GLT, col='3-par', lty='3-par'))
g <-
  g + scale_colour_manual (
    name = 'fit: ',
    values = c("lfit" = "forestgreen", "3-par" = "blue")
  )
g <- g + scale_linetype_manual (name = 'fit: ', 
                                values = c('lfit' = 4, '3-par'=1))
g2 <- g + ylim(0, 1.2) + theme_WAC(1) + theme(legend.position = c(0.75, 0.8))
# suppressWarnings(print(g + ylim(0, 1.2) + theme_WAC(1) + 
#                        theme(legend.position = c(0.75, 0.9))))
g2 <- g2 + theme(plot.margin=unit(c(0.5,0.3,1.1,1.8),"lines"))  ## small adjustment for alignment
grid.newpage()
vp2 <- viewport(y=unit(0.61, 'npc'), height=unit(0.5, 'npc'),layout.pos.row=2)
vp1 <- viewport(y=unit(0.25, 'npc'), height=unit(0.5, 'npc'),layout.pos.row=1)

print(g2, vp=vp2)
print(g1, vp=vp1)
grid.newpage()

@

To characterize the response of the heated HARCO sensor, boundary-layer
flight segments from the SOCRATES and CSET projects (referenced earlier
in connection with the unheated probe) were compiled into one data
set from the flight periods shown in Table~2. An unheated Rosemount
102E4AL sensor was also onboard, so corrected measurements from that
sensor were used as the reference against which to determine the gain
and phase of the transfer function.
\begin{table}[h]
\begin{centering}
\begin{tabular}{|c|c|c|}
\hline 
\textbf{Project / Flight} & \textbf{start {[}UTC{]}} & \textbf{end {[}UTC{]}}\tabularnewline
\hline 
\hline 
CSET / 5 & 2015-07-14 17:52:00 & 18:02:00\tabularnewline
\hline 
CSET / 5 & 2015-07-14 19:45:30 & 19:55:30\tabularnewline
\hline 
CSET / 5 & 2015-07-14 20:37:17 & 20:47:17\tabularnewline
\hline 
SOCRATES / 15 & 2018-02-24 5:52:00 & 6:02:00\tabularnewline
\hline 
SOCRATES / 15 & 2018-02-24 6:05:00 & 6:15:00\tabularnewline
\hline 
\end{tabular}
\par\end{centering}
\caption{Flight segments used to determine the response characteristics of
a heated HARCO sensor.}
\end{table}

\begin{figure}
<<GVHARCO, include = TRUE, fig.height = 4.5>>=

SB <- 50
RXA <- DSX %>% selectTime(55200, 60200) %>% CohP('RTH1', 'RT', plotType='Ranadu', smoothBins=SB)
RXB <- DSX %>% selectTime(60500, 61500) %>% CohP('RTH1', 'RT', plotType='Ranadu', smoothBins=SB)
RXC <- DCX %>% selectTime(175200, 180200) %>% CohP('RTH1', 'RT', plotType='Ranadu', smoothBins=SB)
RXD <- DCX %>% selectTime(194530, 195530) %>% CohP('RTH1', 'RT', plotType='Ranadu', smoothBins=SB)
RXE <- DCX %>% selectTime(203717, 204717) %>% CohP('RTH1', 'RT', plotType='Ranadu', smoothBins=SB)
## May need to revise this with corrected RT in second iteration
Z <- capture.output (Vr <- SmoothInterp(detrend (DSA[, c('Time', 'RTH1')]), .Length=0))
Z <- capture.output (VrC <- SmoothInterp(detrend (DSA[, c('Time', 'RT')]), .Length=0))
Rate <- attr(DSA, 'Rate')
vcv <- cbind(ts(Vr, frequency=Rate), ts(VrC, frequency=Rate))
P <- spec.pgram(vcv, detrend=FALSE, fast=TRUE, plot=FALSE, spans=25)
df1SH <- data.frame(P$coh, log(P$freq))
df2SH <- data.frame (P$phase, log(P$freq))
pf1SH <- binStats (df1SH, bins=SB)
pf2SH <- binStats (df2SH, bins=SB)
phaseSH <- rep(0, SB)
nphaseSH <- rep(0, SB)
phase2SH <- rep(0, SB)
arSH <- rep(0, SB)
ar2SH <- rep(0, SB)
narSH <- rep(0, SB)
for (RX in list(RXA, RXB, RXC, RXD, RXE)) {
  for (i in 2:nrow(RX)) {
    phaseSH[RX$BIN.1[i]] <- phaseSH[RX$BIN.1[i]] + RX$P.phase[i]
    nphaseSH[RX$BIN.1[i]] <- nphaseSH[RX$BIN.1[i]] + 1
    phase2SH[RX$BIN.1[i]] <- phase2SH[RX$BIN.1[i]] + RX$P.phase[i]^2
    arSH[RX$BIN.1[i]] <- arSH[RX$BIN.1[i]] + sqrt(RX$P.spec...1.[i] / RX$P.spec...2.[i])
    ar2SH[RX$BIN.1[i]] <- ar2SH[RX$BIN.1[i]] + (RX$P.spec...1.[i] / RX$P.spec...2.[i])
    narSH[RX$BIN.1[i]] <- narSH[RX$BIN.1[i]] + 1
  }
}
nphaseSH[nphaseSH == 0] <- 1
narSH[narSH == 0] <- 1
mphaseSH <- phaseSH/nphaseSH
mphase2SH <- phase2SH/nphaseSH
sdpSH <- sqrt(mphase2SH - mphaseSH^2)
mphaseSH <- mphaseSH * 180 / pi
sdpSH <- sdpSH * 180 / pi
sdpSH <- sdpSH * 2 / sqrt(nphaseSH)
arSH <- arSH / narSH
ar2SH <- ar2SH / narSH
b <- ar2SH - arSH^2
b[near(b, 0)] <- 0
sdrSH <- sqrt(b)
sdrSH <- sdrSH * 2 / sqrt(narSH)
dfSH <- data.frame(frq=exp(pf2SH$xc), mphase=mphaseSH, sdp=sdpSH)
dfSH <- dfSH[dfSH$frq > 0.01, ]
dfSH <- dfSH[dfSH$sdp > 0, ]
dfSH <- dfSH[dfSH$frq < 2, ]
dfrSH <- data.frame(frq=exp(pf2SH$xc), mrspec=arSH, sdr=sdrSH)
dfrSH <- dfrSH[dfrSH$frq > 0.01, ]
dfrSH <- dfrSH[dfrSH$sdr > 0, ]
dfrSH <- dfrSH[dfrSH$frq < 2, ]
frq <- exp(pf2SH$xc)
Parm <- Param1
Parm$a <- 0.1
Parm$tau1 <- 0.1
Parm$tau2 <- 1.5
minFn <- function(V) {
  Parm$a <<- V[1]
  Parm$tau1 <<- V[2]
  Parm$tau2 <<- V[3]
  Chisq <- 0
  for (i in 1:nrow(dfSH)) {
    Chisq <- Chisq + (dfSH$mphase[i] - LTphase(dfSH$frq[i], Parm)$Phase)^2 / dfSH$sdp[i]^2
  }
  for (i in 1:nrow(dfrSH)) {
    Chisq <- Chisq + (dfrSH$mrspec[i] - LTphase(dfrSH$frq[i], Parm)$Amp)^2 / dfrSH$sdr[i]^2
  }
  return (Chisq)
}
ASH <- optim (c(Parm$a, Parm$tau1, Parm$tau2), minFn, method='L-BFGS-B', 
              lower=0, hessian=TRUE)
bestSH <- ASH$par
HerrorSH <- solve(ASH$hessian / 4)  # factor of 4 because 2-sigma errors were used?
uncLimitsSH <- sqrt(diag(HerrorSH))
# print(bestSH)
HSH <- LTphase(dfrSH$frq, Parm)
dfrSH$Amp <- HSH$Amp
dfrSH$Phase <- HSH$Phase
ParamSH <- Param2

g <- ggplot(dfSH, aes(x=frq, y=mphase))+geom_point(size=1.3)
g <- g + xlab('frequency [Hz]') + ylab (bquote('phase [' * degree * ']'))
g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x, n=2),
                       labels = trans_format("log10", math_format(expr = 10^.x))) + xlab('frequency [Hz]')
g <- g + annotation_logticks(sides = "bt")
g <- g + geom_errorbar(aes(ymin=mphase-sdp, ymax=mphase+sdp), width=0.08)
g <- g + geom_path(data=dfrSH, aes(x=frq, y=Phase), col='forestgreen')
cf <- coef(lm(data=dfSH, mphase ~ log(frq)+I(log(frq)^2)+I(atan(frq))))
dfSH$Ph <- cf[1]+cf[2]*log(dfSH$frq) + cf[3]*log(dfSH$frq)^2 + 
           cf[4]*atan(dfSH$frq)
dfSH$PhLT <- LTphase(dfSH$frq, Parm)$Phase
g <- g + geom_path(data=dfSH, aes(x=frq, y=Ph, col='lfit', lty='lfit'), lwd = 1.2)
g <- g + geom_path(data=dfSH, aes(x=frq, y=PhLT, col='3-par', lty='3-par'), lwd = 1.2)
# g <- g + geom_path(data=dfAPSH, aes(x=Time, y=Phase), col='darkorange')
g <-
  g + scale_colour_manual (
    name = 'fit: ',
    values = c("lfit" = "forestgreen", "3-par" = "blue")
  )
g <- g + scale_linetype_manual (name = 'fit: ', 
                                values = c('lfit' = 4, '3-par'=1))
g1 <- g + theme_WAC(1) + theme(legend.position = c(0.75, 0.75),
                               legend.direction = 'vertical')

frq <- exp(pf2SH$xc[narSH > 0])
g <- ggplot(dfrSH, aes(x=frq, y=mrspec))+geom_point(size=1.3)
g <- g + xlab('frequency [Hz]') + ylab ('amplitude ratio')
g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x, n=2),
                       labels = trans_format("log10", math_format(expr = 10^.x))) + xlab('frequency [Hz]')
g <- g + annotation_logticks(sides = "bt")
g <- g + geom_errorbar(aes(ymin=mrspec-sdr, ymax=mrspec+sdr), width=0.08)
# g <- g + geom_path(data=dfAPSH, aes(x=Time, y=Amp), col='darkorange')
cfr <- coef(lm(data=dfrSH, mrspec ~ log(frq) + I(log(frq)^3) + 
               I(log(frq)^5)))
cfr <- coef(lm(data=dfrSH, mrspec ~ log(frq) + I(log(frq)^3) +
            I(log(frq)^4)+I(log(frq)^5)))
fr <- log(dfrSH$frq)
dfrSH$G <- cfr[1] + fr * (cfr[2] + fr * fr * (cfr[3] + fr * (cfr[4] + 
                     fr * cfr[5])))
dfrSH$G[dfrSH$frq < 0.024] <- 1
dfrSH$GLT <- LTphase(dfrSH$frq, Parm)$Amp
g <- g + geom_path(data=dfrSH, aes(x=frq, y=G, col='lfit', lty='lfit'), lwd = 1.2)
g <- g + geom_path(data=dfrSH, aes(x=frq, y=GLT, col='3-par', lty='3-par'), lwd = 1.2)
g <-
  g + scale_colour_manual (
    name = 'fit: ',
    values = c("lfit" = "forestgreen", "3-par" = "blue")
  )
g <- g + scale_linetype_manual (name = 'fit: ', 
                                values = c('lfit' = 4, '3-par'=1))
g2 <- g + ylim(0, 1.1) + theme_WAC(1) + theme(legend.position = 'none')
g2 <- g2 + theme(plot.margin=unit(c(0.3, 0.3, 1.1, 2.15), "lines"))  ## small adjustment for alignment
g2 <- g2 + theme(axis.title.y = element_text(vjust = 4))
g1 <- g1 + theme(axis.title.y = element_text(vjust = 0))
grid.newpage()
vp2 <- viewport(y=unit(0.57, 'npc'), height=unit(0.51, 'npc'),                  
                layout.pos.row=2)
vp1 <- viewport(y=unit(0.25, 'npc'), height=unit(0.5, 'npc'),layout.pos.row=1)
print(g1, vp=vp2)
print(g2, vp=vp1)
grid.newpage()
# suppressWarnings(print(g + ylim(0, 1.3) + theme(legend.position = c(0.75, 0.9)) + theme_WAC(1)))
# CohPhase(DSA, 'RTH1', 'RTF1')
# DSA %>% select(Time, TASX, RTH1, RT, ATH1) %>% VSpec()
# print(bestSH)
## Save for later use:
cfHARCO <- cf
cfrHARCO <- cfr

@

\caption{The phase (top) and gain (bottom) for the transfer function characterizing
a heated HARCO temperature sensor. The measurements are indicated
by error bars that show two-standard-deviation limits from the mean
value). Two fits to the measurements, one based on the three-parameter
representation (``3-par'') and one on a polynomial fit (``lfit''),
are described in the text.\label{fig:GVHARCO}}
\end{figure}

The measured phase and amplitude ratio for this data set are shown
in Fig.~\ref{fig:GVHARCO}. The fits for the response function defined
by \eqref{eq:responseAmp} and \eqref{eq:responsePhase} are shown
as the blue lines labeled ``3-par'' in that figure. The fitted values
for \{$a,\,\tau_{1},\,\tau_{2}$\} were \{0, \Sexpr{round(bestSH[2], 2)},
\Sexpr{round(bestSH[3], 2)}\}, and to obtain this result the fit
had to be constrained to keep $a$ non-negative. A value of zero for
the parameter $a$ would indicate that no heat is transferred from
the sensing wire to the air, but instead all is transferred to the
support which has a relatively slow characteristic response. 

The three-parameter fit is not consistent with the measurement errors
even though it provides an approximate representation of the transfer
function. The apparent reason is that there is conflict between the
constraints imposed by the amplitude ratio and the phase, such that
either could be represented reasonably but not both. The actual transfer
function has some complex features, including frequencies where the
phase shift reaches values below $-90^{\circ}$ (not possible for
a simple exponential time response) and values of the phase shift
of about $-38^{\circ}$ at 0.1~Hz where the amplitude ratio is still
high (about 0.75). The amplitude decreases to $e^{-1}$ at about 0.34~Hz,
as would be the case for a first-order time constant of about 1.3~s,
so this could be considered another measure of the response. However,
that value does not extrapolate well to other frequencies and the
phase shift at 0.34~Hz is approximately $-73^{\circ}$, which would
indicate that the measurement of a real contribution to sensible-heat
flux at this frequency would be only about 10\% of the correct value.

Because the three-parameter fit distorted the measured result, fits
in the logarithm of the frequency were used to provide a better representation
of the measurements, as shown by the dashed green lines labeled ``lfit''.
Those fits are given by these equations and coefficients, with $x=\log_{e}(\nu/\nu_{0})$
where $\nu$ is the frequency, $\omega=2\pi\nu$ and $\nu_{0}=1\,\mathrm{Hz}$:\\
\begin{equation}
\mathrm{for}\,\nu>0.024\,\mathrm{Hz,\,\,}H(\omega)=(h_{0}+h_{1}x+h_{2}x^{3}+h_{3}x^{4}+h_{4}x^{5})e^{i\phi(\omega)}\label{eq:lfitH}
\end{equation}
\[
\mathrm{for\:\nu\leq0.024\,\mathrm{Hz},\quad}H(\omega)=1
\]
\[
\phi(\omega)=p_{0}+p_{1}x+p_{2}x^{2}+p_{3}\arctan(\nu/\nu_{0})
\]
The coefficients obtained by fitting to the observations are $h_{0-4}=$\{$\Sexpr{round(cfr[1], 3)}$,
$\Sexpr{round(cfr[2], 3)}$, $\Sexpr{format(cfr[3], digits=3, nsmall=4)}$,
$\Sexpr{round(cfr[4], 4)}$, $\Sexpr{round(cfr[5], 5)}$\} and $p_{0-3}=$\{$\Sexpr{round(cf[1], 1)}$,
$\Sexpr{round(cf[2], 1)}$, $\Sexpr{round(cf[3], 2)}$, $\Sexpr{round(cf[4], 1)}$\}.
This fit can be used to represent the transfer function better than
the three-parameter fit (with negative-frequency values defined as
the complex conjugate of the values at the corresponding positive
frequency), although the fit needs to be modified above about 2~Hz
because those values were not constrained by the measurements. A suggested
modification is to duplicate the value at 2~Hz to higher frequencies;
this appears to be adequate because there is so little variance measured
by this sensor at these frequencies, but it is important to avoid
possible zeroes that otherwise arise from extrapolation.


\subsubsection{Expected dependence on flight conditions\label{subsec:Expected-dependence-on}}

Based on measurements in a wind tunnel, \citet{GoodrichTR5755} indicated
that the fast-response characteristic time $\tau_{1}$ for the unheated
Rosemount 102E4AL sensor varies approximately as $\log(Z^{-0.6})$
where $Z=M\rho_{a}/\rho_{s}$ with $M$ the Mach number, $\rho_{a}$
the air density and $\rho_{0}$ the air density under standard conditions.
The mean value of $Z$ for the flight segments used to find the best-fit
parameters was $Z=0.3$, so this suggests that the first characteristic
time for that sensor is best represented by

\begin{equation}
\tau_{1}^{\prime}(Z)=\tau_{1}\left(\frac{0.3}{Z}\right)^{0.6}\,\,\,.\label{eq:tau1prime}
\end{equation}

 There is no similar evidence for $\tau_{2}$, but it might be expected
to have similar dependence because this is approximately the Reynolds
number dependence and the Nusselt number characterizing ventilated
heat transfer often is represented by a power-law relationship to
the Reynolds number. If both heat transfer terms scale similarly,
it might be expected that $a$ will be unchanged.

For these reasons, the time parameters obtained in preceding sections
have been adjusted to a reference value of $Z=0.3$ in Table~\ref{tab:Parameters}.
For other conditions, it is suggested that the best estimate will
be to multiply $\tau_{1}$ and $\tau_{2}$ by $(0.3/Z)^{0.6}$. (Having
these parameters vary is in conflict with the ``LTI'' assumption
leading to the transfer function, but these variations are minor over
short times so incorporating this variation should produce reasonable
results.)

<<adjustP, include=FALSE>>=

rhozero <- 1013.25 * 100 / (287.05 * 288.15)
MRHO <- MachNumber(DZV$PSXC, DZV$QCXC) * DZV$PSXC * 100 / 
        (287.05 * (273.15 + DZV$ATX)) / rhozero
Param1$tau1 <- Param1$tau1 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ 0.6
Param1$tau2 <- Param1$tau2 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ 0.6
MRHO <- MachNumber(DS$PSXC, DS$QCXC) * DS$PSXC * 100 / 
        (287.05 * (273.15 + DS$ATX)) / rhozero
# ParamHS$tau1 <- ParamHS$tau1 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ 0.6
# ParamHS$tau2 <- ParamHS$tau2 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ 0.6
# ParamHSB$tau1 <- ParamHSB$tau1 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ 0.6
# ParamHSB$tau2 <- ParamHSB$tau2 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ 0.6
bestSH[2] <- bestSH[2] * (mean(MRHO, na.rm = TRUE) / 0.3) ^ 0.6
bestSH[3] <- bestSH[3] * (mean(MRHO, na.rm = TRUE) / 0.3) ^ 0.6

@
\begin{center}
\begin{table}[h]
\begin{centering}
\begin{tabular}{|c|c|c|c|}
\hline 
\textbf{sensor} & \textbf{$a$} & \textbf{$\tau_{1}$} {[}s{]} & \textbf{$\tau_{2}$} {[}s{]}\tabularnewline
\hline 
\hline 
unheated Rosemount 102E4ALon C-130 & \Sexpr{round(Param1$a, 2)} & \Sexpr{round(Param1$tau1, 3)} & \Sexpr{round(Param1$tau2,2)}\tabularnewline
\hline 
unheated Rosemount 102E4AL on GV & \Sexpr{format(ParGV$a, digits=2, nsmall=2)} & \Sexpr{round(ParGV$tau1, 3)} & \Sexpr{format(ParGV$tau2, digits=2, nsmall=2)}\tabularnewline
\hline 
heated HARCO & \Sexpr{format(bestSH[1], digits=1, nsmall=1)} & \Sexpr{format(bestSH[2], digits=2, nsmall=2)} & \Sexpr{format(bestSH[3], digits=2, nsmall=2)}\tabularnewline
\hline 
\end{tabular}
\par\end{centering}
\centering{}\caption{Parameters for the time response of available temperature sensors
on the NSF/NCAR aircraft, adjusted to $Z=0.3$. For other conditions,
scale as represented for $\tau_{1}^{\prime}$ in \eqref{eq:tau1prime}.\label{tab:Parameters}}
\end{table}
\par\end{center}


\subsection{Response to a step change}

<<VOCALSrf03, include=FALSE, echo=FALSE, fig.height=4, fig.cap='Temperature measured during descent through an inversion capping the marine boundary layer, from VOCALS flight 3, starting at 8:13:50 UTC. The descent rate was approximately 5 m/s. The dashed red line shows a dry-adiabatic lapse rate in the marine boundary layer, and the dashed blue line is a reference line indicating the location of the top of the boundary layer.'>>=

Data <-
  getNetCDF(
    file.path(DataDirectory(), 'VOCALS/VOCALSrf03h.nc'),
    c(
      'PALT',
      'GGALT_NTL',
      'ATX',
      'ATRL',
      'ATRR',
      'ATWH',
      'DPXC',
      'PSXC',
      'QCXC',
      'TTRR'
    )
  )
Data %>% select(Time, PALT, ATRR) %>% 
  selectTime(81350, 81358) %>%
  select(ATRR) %>% 
  plot(
    type = 'b',
    pch = 20,
    ylab = bquote('ATRR [' * degree ~ 'C]'),
    xlab = 'sample number',
    col = 'blue'
  )
x <- 0:250
y <- 6.9 - x * 5 / 25 * 10 / 1000
lines(x, y, col = 'red', lty = 2)
abline(v = 10, col = 'black', lty = 2)
## Get Z for scaling the time constants:
rhozero <- 1013.25 * 100 / (287.05 * 288.15)
Z <- MachNumber(Data$PSXC, Data$QCXC) * 100 * Data$PSXC /
  (287.05 * (273.15 + Data$ATRR)) / rhozero
ParamS <- ParamSF
ParamS$tau1 <- ParamS$tau1 * (mean(Z, na.rm = TRUE) / 0.3) ^ 0.6
ParamS$tau2 <- ParamS$tau2 * (mean(Z, na.rm = TRUE) / 0.3) ^ 0.6

@

<<tfit, include=TRUE, echo=FALSE, fig.pos='t', fig.cap='(blue dots): Temperature measured at 25 Hz during descent through an inversion capping the marine boundary layer, from VOCALS flight 3, starting at 8:13:50 UTC. The descent rate was approximately 5 m/s. The dashed red line shows a dry-adiabatic lapse rate in the marine boundary layer, and the dashed black line is a reference line indicating the location of the top of the boundary layer.The  prediction using the parameters listed in the text is shown as the magenta line, mostly over the blue dots representing the measurements. The dashed brown line is the calculated temperature of the support that contacts the sensing wire.'>>=

Data %>% select(Time, PALT, ATRR) %>% 
  selectTime(81350, 81358) %>% 
  select(ATRR) %>% 
  plot(
    type = 'b',
    pch = 20,
    ylab = bquote('temperature [' * degree ~ 'C]'),
    xlab = 'sample number @ 25 Hz',
    col = 'blue'
  )
x <- 0:200
y <- 6.9 - x * 5 / 25 * 10 / 1000
lines(x[11:200], y[11:200], col = 'red', lty = 2)
lines(c(10, 10), c(y[11], 14.3), col = 'black', lty = 2)
xx <- 0:2000
yy <- 6.9 - xx * 5 / 250 * 10 / 1000
yy[1:110] <- 14.30
# calculate the response, given tau:
tau <- 0.05
taua <- 0.09
tau2 <- 0.90
tau2a <- 1.0
a <- 0.62
aa <- 0.65
tau <- Param1$tau1
# tau2 <- Param1$tau2
tau2a <- 1.1
taua <- 0.05
a <- Param1$a
a <- ParamS$a
tau1 <- ParamS$tau1
tau2 <- ParamS$tau2
tau1a <- 0.06
tau2a <- 1.3
aa <- a - 0.02
ym <- yy
ymf <- ym
yr <- yy
yra <- yy
for (i in 2:2000) {
  yr[i] <- yr[i - 1] + (yy[i] - yr[i - 1]) * 0.004 / tau2
  yra[i] <- yra[i - 1] + (yy[i] - yra[i - 1]) * 0.004 / tau2a
}
for (i in 2:2000) {
  ym[i] <-
    ym[i - 1] + (a * yy[i] + (1 - a) * yr[i] - ym[i - 1]) * 0.004 / tau1
  ymf[i] <-
    ymf[i - 1] + (aa * yy[i] + (1 - aa) * yra[i] - ymf[i - 1]) * 0.004 / tau1a
}
lines(xx / 10, ym, col = 'magenta', lwd = 2, lty=1)
# lines(xx / 10, ymf, col = 'darkorange', lwd = 2)
lines(xx / 10,
      yr,
      col = 'brown',
      lwd = 2,
      lty = 2)
legend('topright', legend=c('measured','predicted', 'support'),
       lwd=c(2, 2, 2), lty=c(1, 1, 2),
       col=c('blue', 'magenta', 'brown'),
       pch = c(19, NA, NA))

@

Previous studies have mostly used sharp temperature changes in the
atmosphere, for example from climbs through the inversion at the top
of a boundary layer, to study the time response. A search of representative
VOCALS climbs and descents through inversions capping the marine boundary
layer found that almost all have measurable structure and are not
discrete transitions, but there was one near-ideal example. Figure
\ref{fig:tfit} shows the time history of the measured temperature
for 8~s from VOCALS flight 3, starting at 8:13:50 UTC, when the aircraft
descended through the top of the marine boundary layer at approximately
1000~ft/min (around 5~m/s). The temperature structure in this case
was remarkably consistent with a near-constant temperature above the
inversion and a near-adiabatic temperature structure below the inversion.

The suggested measurand history, if the discontinuity at the inversion
is discrete, is that shown by the dashed black and dashed red lines..
The predicted time response from \eqref{eq:Tm} for assumed time constants
for the unheated Rosemount 102E4AL sensor adjusted for air density
and flight speed is shown as the magenta line in Fig.~\ref{fig:tfit}.
The predicted response is consistent with the observations and supports
the approximate validity of the parameters determined from fits to
the response to dynamic heating.

<<specialVSpec>>=

## SPECIAL FOR SHOWING TRANSFER-FUNCTION MOD
VSpecC <-
  function (.data,
            .Variable = NA,
            VLabel = NA,
            col = NA,
            type = 'spectrum',
            corrected = FALSE,
            method = NA,
            xlim = NA,
            ylim = NA,
            Par = NA,
            # c(0.001, 15), ylim=c(0.0001,1),
            spans = 49,
            ae = 0.2,
            smoothBins = 0,
            segLength = 512,
            poles = 50,
            resolution = 0.0001,
            showErrors = 0,
            WavelengthScale = TRUE,
            ADD = NA,
            add = NA,
            EDR = FALSE,
            WACtheme = NA) {
    if (!is.data.frame(.data)) {
      # See if the first argument can be split into a data.frame and a variable:
      X <- substitute(.data)
      if (is.call(X)) {
        V <- try(eval(X), silent = TRUE)
        if (grepl('Error', V[[1]])) {
          V <- eval(plyr::as.quoted(X))  # eval(X) for names()
        }
        if (is.character(V[1])) {
          
        } else {
          V <- plyr::as.quoted(X)
          if (is.symbol(V[[1]])) {
            V <- vapply(V, deparse, 'character')
          }
        }
      } else {
        V <- plyr::as.quoted(X)
        if (is.symbol(V[[1]])) {
          V <- vapply(V, deparse, 'character')
        }
      }
      # print (c('first argument evaluates to', V))
      # Extract data.frame:
      .data <- get(V[[1]])
      .Variable <- V[[2]]
    }
    # print(str(.data))
    if (is.data.frame(.data)) {
      ## must be true, or exit. Needs to contain Time and TASX
      ## in addition to .Variable
      nm <- names(.data)
      V <- try(is.na(.Variable), silent = TRUE)
      if (grepl('Error', V[[1]])) {
        X <- substitute(.Variable)
        if (is.call(X)) {
          V <- try(eval(X), silent = TRUE)
          if (grepl('Error', V[[1]])) {
            V <- eval(plyr::as.quoted(X))  # eval(X) for names()
          }
          if (is.character(V[1])) {
            
          } else {
            V <- plyr::as.quoted(X)
            if (is.symbol(V[[1]])) {
              V <- vapply(V, deparse, 'character')
            }
          }
        } else {
          V <- plyr::as.quoted(X)
          if (is.symbol(V[[1]])) {
            V <- vapply(V, deparse, 'character')
          }
        }
        .Variable <- V
      }
      if (is.na(.Variable[1])) {
        nm <- nm[-which('Time' == nm)]
        nm <- nm[-which('TASX' == nm)]
        .Variable <- nm
        if (length(.Variable) > 3) {
          .Variable <- .Variable[1:3]
        }
      }
    } else {
      print('VSpec ERROR: first argument is not a data.frame.')
      return (NA)
    }
    if (is.null(attr(.data, 'Rate'))) {
      print ('VSpec warning: Rate attribute missing from data.frame, so using Rate=1')
      Rate <- 1
    } else {
      Rate <- attr(.data, 'Rate')
    }
    if (is.na(xlim[1])) {
      if (Rate == 1) {
        xlim <- c(0.001, 1)
      } else {
        xlim <- c(0.001, 15)
      }
    }
    if (is.na(ylim[1])) {
      ylim <- c(1.e-4, 1.)
    }
    if (!is.na(method)) {
      type <- method
    }  ## method over-rides if present
    for (.V in .Variable) {
      if (.V %in% names(.data)) {
        NV <- which(.V == .Variable)
        Z <- capture.output (v <- detrend (.data[, c('Time', .V)]))
        if (!is.na(VLabel[1]) &&
            length(VLabel) >= NV) {
          ## use this alternate name in legend
          V <- VLabel[NV]
        } else {
          V <- .V
        }
      } else {
        print(sprintf(
          'VSpec ERROR: Variable %s is not in the supplied data.frame',
          .V
        ))
        return (NA)
      }
      if (type != 'spectrum' &&
          type != 'Welch' && type != 'MEM' && type != 'mem') {
        print (sprintf ('type %s is unavailable; using type=spectrum', type))
        type <- 'spectrum'
      }
      siglim <- 1  ## 1-sigma error limits
      if (type == 'spectrum') {
        if (!is.null(spans[1])) {
          if (!(spans[1] %% 2)) {
            spans[1] <- spans[1] + 1
          }
          if (spans[1] <= 5) {
            spans <- NULL
          }
        }
        S <-
          spectrum (ts(
            SmoothInterp(v, .maxGap = 1000 * Rate, .Length = 0),
            frequency = Rate
          ),
          span = spans,
          plot = FALSE)
        freq <- S$freq
        if (corrected) {
          ARX <- LTphase(freq, Par)
          S$spec <- S$spec / ARX$Amp ^ 2
        }
        fpf <- 2 * S$spec * freq
      } else if (type == 'Welch') {
        ## bspec section
        ## force segLength to a power of 2
        segl <- segLength
        rsl <- log(segl) / log(2)
        ns <- round (rsl)
        if (2 ^ ns != segl) {
          if (2 ^ ns > segl) {
            segl <- 2 ^ (ns - 1)
          }
          else {
            segl <- 2 ^ (ns + 1)
          }
          segLength <- segl
          print (sprintf ('reset segLength to %d', segLength))
        }
        S2 <-
          bspec::welchPSD (
            ts(SmoothInterp(v, .Length = 0), frequency = Rate),
            seglength = segLength,
            windowfun = bspec::hammingwindow
          )
        # ci <- quantile.bspec(BSP, probs = c(0.025, 0.975),
        #   two.sided = FALSE)
        coverage <- 0.683
        tail <- 1 - coverage
        df <- 2 * 9 * S2$segments / 11 ##1.768849
        upper.quantile <-
          1 - tail * pchisq(df, df, lower.tail = FALSE)
        lower.quantile <- tail * pchisq(df, df)
        ci <- 1 / (qchisq(c(upper.quantile, lower.quantile), df) / df)
        df <- 1.46 * (S2$segments + 1)
        lower.limit <- qchisq (pnorm(-siglim), df) / df
        upper.limit <- qchisq (pnorm(siglim), df) / df
        # ci <- 0.5 + (ci-0.5) / sqrt(9 * S2$segments / 11)
        # print (sprintf ('ci2=%.3f -- %.3f segments %d', ci[1], ci[2], S2$segments))
        freq <- S2$frequency[-1]
        fpf <- S2$power[-1] * freq
      } else if (type == 'MEM' || type == 'mem') {
        ## MEM section
        A <- memCoef (v, poles)
        ld <- nrow(.data)
        fmin <- log (Rate / ld)
        fmax <- log (0.5 * Rate)
        bins <- as.integer (1 / resolution)
        df <- (fmax - fmin) / bins
        fdtl <- fmin + df * (0:bins)
        freq <- exp (fdtl)
        psComplex <- memEstimate (freq / Rate, A) / Rate
        ps <- 2 * Rate * Mod (psComplex) ^ 2
        fpf <- freq * ps
      }
      tasAverage <- mean(.data$TASX, na.rm = TRUE)
      if (EDR) {
        ps <- fpf / freq
        fpf <- (2 * pi / tasAverage) * (1.5 * ps) ^ 1.5 * freq ^ 2.5
      }
      if (smoothBins > 9) {
        bs1 <- binStats(data.frame(fpf, log(freq)), bins = smoothBins)
        bs1 <-
          rbind (bs1,
                 data.frame(
                   xc = bs1$xc[nrow(bs1)],
                   ybar = bs1$ybar[nrow(bs1)],
                   sigma = bs1$sigma[nrow(bs1)],
                   nb = 1
                 ))
        bs1 <- bs1[!is.na(bs1$ybar), ]
        freq <- exp(bs1$xc)
        fpf <- bs1$ybar
        bs1$sigma <- ifelse (bs1$nb > 2, bs1$sigma / sqrt(bs1$nb), NA)
        rna <- is.na(bs1$sigma)
        bs1$sigma[rna] <- bs1$ybar[rna] / 2
        # bs1 <<- bs1
      }
      if (.V == .Variable[1]) {
        DF <- data.frame(freq, fpf)
      } else if (.V == .Variable[2]) {
        DF$fpf2 <- fpf
      } else if (.V == .Variable[3]) {
        DF$fpf3 <- fpf
      }
    }
    
    VL <- .Variable
    if (!is.na(VLabel[1])) {
      VL <- VLabel
    }
    if (is.na(col[1])) {
      col = c("blue", "forestgreen", "black", "darkorange")
    }
    if (!is.na(add[1])) {
      ADD <- add
    }
    for (.V in .Variable) {
      NV <- which(.V == .Variable)
      if (is.na(ADD[1])) {
        if (NV == 1) {
          ## first call: redefine VSpecDF
          try(rm(list = names(VSpecEnv), envir = VSpecEnv), silent = TRUE)
          VSpecEnv$Variable <- .Variable
          assign('VSpecDF1', DF, envir = VSpecEnv)
          labx <- 'frequency [Hz]'
          if (EDR) {
            # laby <- sprintf('eddy dissipation rate for %s', .V)
            laby <-
              expression(paste("eddy dissipation rate [m" ^ "2", "s" ^ "-3", "]"))
          } else {
            laby <- sprintf('variance spectrum fP(f) for %s', .V)
          }
          g <- ggplot(data = DF)
          g <-
            g + geom_path (aes(
              x = freq,
              y = fpf,
              colour = VL[1]
            ),
            data = DF,
            na.rm = TRUE) +
            xlab(labx) + ylab (laby)
          .clinesVSpec <- col[1]
          names(.clinesVSpec) <- VL[1]
          VSpecEnv$clinesVSpec <- .clinesVSpec
        }
        if (NV == 2) {
          g <-
            g + geom_path (aes(
              x = freq,
              y = fpf2,
              colour = VL[2]
            ),
            data = DF,
            na.rm = TRUE)
          cl2 <- ifelse (length(col) >= 2, col[2], 'forestgreen')
          names(cl2) <- VL[2]
          .clinesVSpec <- c(VSpecEnv$clinesVSpec, cl2)
          VSpecEnv$clinesVSpec <- .clinesVSpec
        } else if (NV == 3) {
          g <-
            g + geom_path (aes(
              x = freq,
              y = fpf3,
              colour = VL[3]
            ),
            data = DF,
            na.rm = TRUE)
          cl3 <- ifelse (length(col) >= 3, col[3], 'black')
          names(cl3) <- VL[3]
          .clinesVSpec <- c(VSpecEnv$clinesVSpec, cl3)
          VSpecEnv$clinesVSpec <- .clinesVSpec
        }
      } else {
        ## assign name based on elements in clinesVSpec
        N <- length(VSpecEnv$clinesVSpec) + 1
        nc <- names(VSpecEnv$clinesVSpec)
        .clinesVSpec <- c(VSpecEnv$clinesVSpec, col[N])
        names(.clinesVSpec) <- c(nc, V)
        VSpecEnv$clinesVSpec <- .clinesVSpec
        VName <- sprintf('VSpecDF%d', N)
        assign(VName, DF, pos = VSpecEnv)
        if (N == 2) {
          VSpecEnv$VSpecVar2 <- V
          g <-
            ADD + geom_path (
              aes(
                x = freq,
                y = fpf,
                colour = VSpecEnv$VSpecVar2
              ),
              data = get(VName, envir = VSpecEnv),
              na.rm = TRUE
            )
        } else if (N == 3) {
          VSpecEnv$VSpecVar3 <- V
          g <-
            ADD + geom_path (
              aes(
                x = freq,
                y = fpf,
                colour = VSpecEnv$VSpecVar3
              ),
              data = get(VName, envir = VSpecEnv),
              na.rm = TRUE
            )
        } else if (N == 4) {
          VSpecEnv$VSpecVar4 <- V
          g <-
            ADD + geom_path (
              aes(
                x = freq,
                y = fpf,
                colour = VSpecEnv$VSpecVar4
              ),
              data = get(VName, envir = VSpecEnv),
              na.rm = TRUE
            )
        }
      }
    }
    
    g <-
      suppressMessages(g + scale_colour_manual (name = '', values = .clinesVSpec))
    # print (.clinesVSpec)
    if (showErrors > 0) {
      if (smoothBins > 9) {
        bse <-
          data.frame(
            x = exp(bs1$xc),
            ymin = bs1$ybar - showErrors * bs1$sigma,
            ymax = bs1$ybar + showErrors * bs1$sigma
          )
        bse$ymin[bse$ymin < ylim[1]] <- ylim[1]
      } else {
        coverage <-
          pnorm(showErrors) - pnorm(-showErrors)  ## 1-sigma, 0.68269
        tail <- 1 - coverage
        if (type == 'spectrum') {
          df <- S$df
        } else if (type == 'Welch') {
          df <- 1.46 * (S2$segments + 1)
        } else if (type == 'MEM') {
          df <- length(v) / poles
        }
        uq <- 1 - tail * pchisq(df, df, lower.tail = FALSE)
        lq <- tail * pchisq(df, df, lower.tail = TRUE)
        ci <- 1 / (qchisq(c(uq, lq), df) / df)
        lower.limit <- qchisq (pnorm(-showErrors), df) / df
        upper.limit <- qchisq (pnorm(showErrors), df) / df
        bse <-
          data.frame(x = freq,
                     ymin = lower.limit * fpf,
                     ymax = upper.limit * fpf)
      }
      # g <- g + geom_ribbon(data=bs1, aes(x=exp(xc), ymin=max(ylim[1], ybar-showErrors*sigma), ymax=ybar+showErrors*sigma),
      #   fill='cyan', alpha=0.25, show.legend=FALSE, inherit.aes=FALSE, na.rm=TRUE)
      g <- g + geom_ribbon(
        data = bse,
        aes(x = x, ymin = ymin, ymax = ymax),
        fill = 'gray50',
        alpha = 0.5,
        show.legend = FALSE,
        inherit.aes = FALSE,
        na.rm = TRUE
      )
      # bs1$xc <- exp(bs1$xc)
    }
    if (is.na(ADD[1])) {
      g <-
        g + # scale_x_log10(
          # breaks = trans_breaks("log10", function(x)
            # 10 ^ x, n = 4),
          #limits = xlim,
          # labels = trans_format("log10", math_format(10 ^ .x))
        # ) +
        scale_y_log10(
          breaks = trans_breaks("log10", function(x)
            10 ^ x, n = 4),
          #limits = ylim,
          labels = trans_format("log10", math_format(10 ^ .x))
        ) +
        annotation_logticks(sides = 'trbl') +
        coord_cartesian(xlim = xlim, ylim = ylim)
      # g <- g + theme(panel.grid.minor = element_line(colour = "black"))
      if (EDR) {
        ## add line showing highest-decade average EDR
        imx <- length(freq)
        imn <- which (freq > freq[imx] / 20)[1]
        aveEDR <- mean(fpf[imn:imx], na.rm = TRUE)
        ttl <- sprintf ('EDR=%.2e', aveEDR)
        DFL <- data.frame(x = c(freq[imn], freq[imx]), y = rep(aveEDR, 2))
        g <-
          g + geom_path(data = DFL,
                        aes(x = x, y = y),
                        lwd = 1.5,
                        colour = 'red')
        g <- g + ggtitle (bquote(.(ttl) ~ ' m' ^ 2 ~ 's' ^ -3))
        # g <- g + ggtitle(sprintf(' mean eddy dissipation rate %.2e m^2/s^3', aveEDR))
      } else {
        for (i in (-8:0)) {
          a = ae * 10. ^ (i * (2 / 3)) * tasAverage ^ (2 / 3)
          lw = ifelse(i == -4, 1.2, 0.5)
          DFL <-
            data.frame(x = xlim, y = c(a / xlim[1] ^ (2 / 3), a / xlim[2] ^ (2 / 3)))
          # print(DFL)
          g <-
            g + geom_path (
              data = DFL,
              aes(x = x, y = y),
              colour = 'darkorange',
              lwd = lw,
              lty = 3
            )
        }
      }
      if (WavelengthScale) {
        yl <- c(ylim[1] * 1.2, ylim[1] * 1.5)
        lclr <- 'slategrey'
        for (j1 in c(10, 100, 1000, 10000, 100000)) {
          DFL2 <- data.frame(x = rep(tasAverage / j1, 2), y = yl)
          g <-
            g + geom_path(
              data = DFL2,
              aes(x = x, y = y),
              colour = lclr,
              lwd = 1.0
            )
          if (j1 != 100000) {
            for (j2 in 2:9) {
              DFL2 <- data.frame(x = rep(tasAverage / (j1 * j2), 2), y = yl)
              g <-
                g + geom_path(
                  data = DFL2,
                  aes(x = x, y = y),
                  colour = lclr,
                  lwd = 0.6
                )
            }
          }
        }
        DFL2 <-
          data.frame (x = tasAverage * c(1 / 10, 1 / 100000), y = rep(yl[1], 2))
        g <-
          g + geom_path(data = DFL2,
                        aes(x = x, y = y),
                        colour = lclr,
                        lwd = 1.0)
        g <- g + annotate(
          "text",
          x = tasAverage * c(1 / 100000, 1 / 10000, 1 / 1000, 1 / 100, 1 /
                               10),
          y = rep(yl[2] * 1.5, 5),
          label = c("100 km", "10 km", "1 km", "0.1 km", " "),
          colour = lclr
        )
      }
      # g <- g + theme_WAC()
    }
    if (!is.na(WACtheme)) {
      g <- g + theme_WAC()
    }
    return(g)
  }


@

\subsection{Uses of the transfer functions}

The transfer functions have two potential uses: (i) to predict how
airborne thermometers will respond; and (ii) to correct measurements
to compensate for the time response of the sensors. The two sections
that follow are examples of these two uses. In the next section, the
transfer functions are used to assess how sensors respond to dynamic
heating and to develop appropriate correction schemes. Then the following
section applies the transfer functions to improve measurements of
the flux of sensible heat.

The preceding discussion has focused on the recovery temperature that
is the measurand, as expressed by \eqref{eq:recoveryTemperature},
because the sensor responds to that temperature. Corrections should
be made to the measurement of the recovery temperature, here represented
by $T_{m}$, to obtain an improved estimate of the measurand. It is
an error to apply the corrections to the air temperature after correction
for dynamic heating (as in, e.g., \citet{mccarthy1973method}, \citet{InverarityJTech2000},
\citet{nicholls1978measurements} and others) because then the correction
is applied also to the dynamic-heating term to which it does not apply.
This will introduce noise into the calculated air temperature if the
sensor cannot respond fully to fluctuations in dynamic heating.

\section{Correcting for Dynamic Heating}

Airborne thermometers sense the recovery temperature produced when
air is compressed as it enters the housing. Data-processing algorithms
used to produce data archives from most airborne measurement platforms
subtract an independent estimate of dynamic heating to obtain a resulting
measurement of the ambient air temperature. The dynamic-heating term
can exceed $20^{\circ}\mathrm{C}$ at jet-aircraft flight speeds,
so the correction is large and fluctuations in this term are often
the dominant source of variations in the recovery temperature. As
described in Sect.~\ref{subsec:Dynamic-heating}, when the sensor
cannot respond to fluctuations in dynamic heating, this procedure
introduces errors and excess noise into the resulting air temperature.
A modified correction procedure is proposed here that instead corrects
for dynamic heating only after filtering to match the response of
the temperature sensor. This removes a significant source of error
present in many temperature measurements made from research aircraft.

<<reinit, echo=FALSE,include=FALSE>>=
# Is this needed still?
reviseDH <-
  function (.data, P, alphaR) {
    # P is Param1, e.g.; alphaR is recovery factor
    .data$Q <- .data$TASX ^ 2 / 2010
    aV <- P$a
    tau1V <- P$tau1
    tau2V <- P$tau2
    Rate <- attr (.data, 'Rate')
    fS <- function(y, i) {
      (.data$Q[i] - y) / (tau2V * Rate)
    }
    fM <- function (y, i) {
      (aV * .data$Q[i] + (1 - aV) * TsQ[i] - y) / (Rate * tau1V)
    }
    TsQ <- rk4.integrate (fS, .data$Q[1], 1:nrow(.data))
    Qp <- rk4.integrate (fM, .data$Q[1], 1:nrow(.data))
    return (.data$ATX + alphaR * (.data$Q - Qp))
  }
## This is a special version with features not in the standard Ranadu version
CohP <-
  function (.data,
            .Var1,
            .Var2,
            col = 'blue',
            spans = 25,
            smoothBins = 50,
            plotType = 'ggplot',
            showErrors = 0,
            returnCospectrum = FALSE) {
    if (is.data.frame(.data)) {
      if (.Var1 %in% names(.data)) {
        Z <-
          capture.output (Vr <-
                            SmoothInterp(detrend (.data[, c('Time', .Var1)]), .Length = 0))
      } else {
        print(sprintf(
          'CohPhase ERROR: Variable %s is not in the supplied data.frame',
          .Var1
        ))
        return (NA)
      }
      if (.Var2 %in% names(.data)) {
        Z <-
          capture.output (VrC <-
                            SmoothInterp(detrend (.data[, c('Time', .Var2)]), .Length = 0))
      } else {
        print(sprintf(
          'CohPhase ERROR: Variable %s is not in the supplied data.frame',
          .Var2
        ))
        return (NA)
      }
    } else {
      print('CohPhase ERROR: first argument is not a data.frame.')
      return (NA)
    }
    if (is.null(attr(.data, 'Rate'))) {
      print ('CohPhase warning: Rate attribute missing from data.frame, so using Rate=1')
      Rate <- 1
    } else {
      Rate <- attr(.data, 'Rate')
    }
    vcv <- cbind(ts(Vr, frequency = Rate), ts(VrC, frequency = Rate))
    P <-
      spec.pgram(
        vcv,
        detrend = FALSE,
        fast = TRUE,
        plot = FALSE,
        spans = spans
      )
    df1 <- data.frame(P$coh, log(P$freq))
    df2 <- data.frame (P$phase, log(P$freq))
    df3 <- data.frame (P$spec[, 1], log(P$freq))
    df4 <- data.frame (P$spec[, 2], log(P$freq))
    pf1 <- binStats (df1, bins = smoothBins)
    pf2 <- binStats (df2, bins = smoothBins)
    pf3 <- binStats (df3, bins = smoothBins)
    pf4 <- binStats (df4, bins = smoothBins)
    pf1 <- pf1[!is.na (pf1$ybar),]
    pf2 <- pf2[!is.na (pf2$ybar),]
    pf3 <- pf3[!is.na (pf3$ybar),]
    pf4 <- pf4[!is.na (pf4$ybar),]
    # pf1$sigma[pf1$nb > 1] <- pf1$sigma[pf1$nb > 1] / sqrt(pf1$nb[pf1$nb > 2])
    pf1$sigma[pf1$nb <= 1] <- NA # pf1$ybar[pf1$nb <= 1] * 0.5
    # pf2$sigma[pf2$nb > 1] <- pf2$sigma[pf2$nb > 1] / sqrt(pf2$nb[pf2$nb > 2])
    pf2$sigma[pf2$nb <= 1] <- NA # pf2$ybar[pf2$nb <= 1] * 0.5is
    if (plotType != 'ggplot') {
      pf1 <- binStats (df1, bins = smoothBins, addBin = TRUE)
      pf2 <- binStats (df2, bins = smoothBins, addBin = TRUE)
      pf3 <- binStats (df3, bins = smoothBins, addBin = TRUE)
      pf4 <- binStats (df4, bins = smoothBins, addBin = TRUE)
      return(cbind(pf1, pf2, pf3, pf4)[, c(2, 1, 3, 4, 6, 7, 10)])
    } else {
      d2 <-
        data.frame(
          Time = exp(pf1$xc),
          coherence = pf1$ybar,
          phase = pf2$ybar * 180 / pi,
          clo = (pf1$ybar - showErrors * pf1$sigma),
          chi = pf1$ybar + showErrors * pf1$sigma,
          plo = (pf2$ybar - showErrors * pf2$sigma) * 180 / pi,
          phi = (pf2$ybar + showErrors * pf2$sigma) * 180 / pi
        )
      d2$clo[!is.na(d2$clo) & (d2$clo < 0)] <- 0
      labelP <- c('coherence', 'phase [degrees]')
      g <- ggplotWAC(
        d2[, c(1, 2, 3)],
        panels = 2,
        labelP = labelP,
        col = col,
        lwd = c(1.0),
        lty = c(1),
        xlab = 'freq'
      )
      g <-
        g + xlab('frequency [Hz]') + ylab (sprintf ('%s x %s', .Var1, .Var2))
      g <-
        g + scale_x_log10(
          breaks = trans_breaks("log10", function(x)
            10 ^ x, n = 4),
          labels = trans_format("log10", math_format(expr = 10 ^ .x))
        ) + xlab('frequency [Hz]')
      if (showErrors > 0 && smoothBins > 5) {
        da <- data.frame(d2[, c(1, 4, 5)])
        db <- data.frame(d2[, c(1, 6, 7)])
        names(da) <- c('Time', 'ymin', 'ymax')
        names(db) <- c('Time', 'ymin', 'ymax')
        da$PanelGroup <- labelP[1]
        db$PanelGroup <- labelP[2]
        d <- rbind(db, da)
        g <-
          g + geom_ribbon(
            data = d,
            aes(
              x = Time,
              ymin = ymin,
              ymax = ymax
            ),
            colour = 'grey',
            alpha = 0.15,
            inherit.aes = FALSE
          )
      }
      g <- g + theme_WAC(1) + theme(legend.position = 'none')
      if (returnCospectrum) {
        CS <-
          sqrt(P$coh[, 1] * P$spec[, 1] * P$spec[, 2] / (1 + tan(P$phase[, 1]) ^
                                                           2))
        v1 <- SmoothInterp(.data[, .Var1], .Length = 0)
        v2 <- SmoothInterp(.data[, .Var2], .Length = 0)
        v1 <- detrend(data.frame(Time = .data$Time, v1))
        v2 <- detrend(data.frame(Time = .data$Time, v2))
        ff1 <- fft(v1)
        ff2 <- fft(v2)
        G <- Re(ff1 * Conj(ff2)) / nrow(.data)
        GQ <- Im(ff1 * Conj(ff2)) / nrow(.data)
        N <- nrow(.data) %/% 2
        S1 <- Re(ff1 * Conj(ff1) / nrow(.data))
        S2 <- Re(ff2 * Conj(ff2) / nrow(.data))
        G <- G[2:(N + 1)]
        GQ <- GQ[2:(N + 1)]
        S1 <- S1[2:(N + 1)]
        S2 <- S2[2:(N + 1)]
        frq <- c(1:N) * Rate / nrow(.data)
        spec1 <- 2 * S1 / Rate
        spec2 <- 2 * S2 / Rate
        cospec <- 2 * G / Rate
        quad <- 2 * GQ / Rate
        # cospectrum - i * quadrature = (gain spectrum) * exp(i*(phase spectrum))
        # sqrt(cospectrum^2 + quadrature^2) is the amplitude or gain spectrum
        return(data.frame(
          freq = frq,
          cospec = cospec,
          quad = quad,
          spec1 = spec1,
          spec2 = spec2
        ))
      } else {
        return(g)
      }
    }
  }
a <- 0.733 # 0.713
tau1 <- 0.0308  # 0.0335
tau2 <- 0.447
Param <- list(
  a = a,
  tau1 = tau1,
  tau2 = tau2
)
Param1 <- Param
ParamSH <- Param
ParamSH$a <- 0
ParamSH$tau1 <- 0.05681167 
ParamSH$tau2 <- 1.25078040
ParamSF <- Param
ParamSF$a <- 0.652
ParamSF$tau1 <- 0.0295
ParamSF$tau2 <- 1.04
source('./chunks/rk4.integrate.R')

@

\selectlanguage{english}%
<<S15, include=TRUE, fig.cap='The weighted variance spectrum as a function of frequency $\\nu$ for the recovery temperature measured by a Rosemount 102E4AL sensor. The spectra for the dynamic-heating term and for the calculated air temperature after this correction is applied are also shown.'>>=

DS <-
  getNetCDF('/Data/SOCRATES/SOCRATESrf15h.nc',
            standardVariables(c('ATF1', 'UXC')),
            60000,
            61500)
rf.txt <- attr(DS$ATF1, 'RecoveryFactor')
rf <- gsub('mach', 'MACHX', rf.txt)
rf <- gsub(' log', ' * log', rf)
rf <- gsub(' \\(', ' * \\(', rf)
rf <- with(DS, eval(parse(text=rf)))
rf <- SmoothInterp(rf, .Length = 0)
## RTF1 is not in the netCDF file so recalculate it:
DS$RTF1 <- DS$ATF1 + rf * DS$TASX^2 / 2010
DS$TASX <- SmoothInterp(DS$TASX, .Length = 0)
DS$Q <- rf * DS$TASX ^ 2 / 2010
DS$ATX <- DS$ATF1  ## Replace ATX, based on ATH1 in netCDF file

DS$RT <- DS$RTF1
DS$AT <- DS$ATF1
# g <-
#   VSpec(
#     DS,
#     'RTF1',
#     spans = 99,
#     xlim = c(0.01, 15),
#     ylim = c(1.e-5, 1.e-1)
#   )
# g <- VSpec(DS, 'ATF1', spans = 99, add = g)
# VSpec(DS, 'Q', spans = 99, add = g) + theme_WAC(1)
xlim <- c(0.08, 12)
## Using VSpecC only because it doesn't set scale_x and want to set
## it specially here:
DS %>% Rmutate(Tr = RT, Ta = AT) %>%
       select(Time, TASX, Tr, Ta, Q) %>%
       VSpecC(VLabel = c('recovery temp.', 'air temp.', 'dynamic heating'),
             spans = 99, xlim = xlim, ylim=c(1.e-5, 0.03)) +
       suppressWarnings(
       scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x, n=2), 
                     labels = trans_format("log10", math_format(10^.x)))) +
      theme_WAC(1) +
      theme(legend.position=c(0.75, 0.75),
      plot.margin=unit(c(0.3,0.3,1.1,1.3),"lines"),
      legend.background=element_rect(colour='black', size=0.3, fill="ivory"),
      legend.direction="vertical", 
      legend.key.width=unit(1.3,'lines'), legend.key.height=unit(0.7,'lines'),
      legend.text=element_text(size=12)) +
      guides(colour = guide_legend(reverse = TRUE, '  legend:')) +
      ylab(bquote('spectral variance ' * nu * 'P(' * nu * ')'))
DS$AT <- reviseDH(DS, Param1, rf)
DS$AT <- SmoothInterp(DS$AT, .Length = 0)

@

\selectlanguage{american}%
Figure~\ref{fig:S15} illustrates the problem. The measurements are
from a low-level flight segment over the ocean where other indications
are reasonably consistent with an inertial sub-range. The slope of
the temperature variance spectrum would be expected to be -5/3 (or
-2/3 in this plot where the spectrum is weighted by the frequency).
The variance spectrum of the measured recovery temperature has a steeper
slope than this but that would be expected if the time response attenuates
the signal at higher frequencies. However, the variance spectrum for
the estimated ambient temperature appears to have a substantial amount
of high-frequency contamination. This matches the high-frequency portion
of the spectrum for dynamic heating. If the sensor measured the correct
recovery temperature its spectrum should exceed that of the ambient
temperature, as is the case around 0.1 to 0.5~Hz, so that the subtraction
of dynamic heating would produce smaller variance in the measured
ambient temperature. Later figures (Figs.~\ref{fig:ATATF}a and \ref{fig:ATATF}b)
will show anecdotal examples of the errors introduced by the conventional
correction.

Data processing should instead apply a correction that represents
how dynamic heating affects the sensor, and that correction should
not include fluctuations at frequencies to which the sensor does not
respond. The approach followed in this paper is therefore to use the
transfer function to characterize the response of an airborne temperature
sensor to dynamic heating so that only that response is subtracted
from the measurement. This is made possible by the assumed linearity
in response of the sensor, which is required if this part of the response
is to be separated from the more general response to the combination
of dynamic heating and true fluctuations in temperature.

<<LT, include = FALSE, fig.height=3.7, fig.cap = 'The amplitude and phase for the frequency domain transfer function of a Rosemount 102E4AL temperature sensor.'>>=

frq <- seq(0.01, 25, by = 0.01)
Phi <- rep(0, length(frq))
H <- rep(0, length(frq))
a <- 0.733 # 0.713
tau1 <- 0.0308  # 0.0335
tau2 <- 0.447
zeta <- -atan(2 * pi * frq * tau2)
b <- cos(zeta)
Param <- list(
  a = a,
  tau1 = tau1,
  tau2 = tau2,
  b = b,
  zeta = zeta,
  frq = frq
)
Param1 <- Param
Param3 <- Param
Param4 <- Param
Param3$tau1 <- 0.05
Param4$tau2 <- 0.6

## Use the Laplace-transform solution
H1 <- LTphase(frq, Param1)
cTF <- H1$Amp
phiTF <- H1$Phase
H3 <- LTphase(frq, Param3)
cTF3 <- H3$Amp
phiTF3 <- H3$Phase
H4 <- LTphase(frq, Param4)
cTF4 <- H4$Amp
phiTF4 <- H4$Phase
dfAP <- data.frame(
  'Time' = frq,
  'Amp' = cTF,
  'Phase' = phiTF
)
Panel2Label <- bquote('   Phase [' * degree ~ ']')
g <-
  ggplotWAC(
    dfAP,
    panels = 2,
    labelP = c(bquote('    ' ~ 'Amplitude'), Panel2Label)
  )
g <- g + xlab('frequency [Hz]') + ylab(bquote('transfer function H(' * nu ~ ')'))
g <-
  g + scale_x_log10(
    breaks = trans_breaks("log10", function(x)
      10 ^ x, n = 4),
    labels = trans_format("log10", math_format(expr = 10 ^ .x))
  ) + xlab('frequency [Hz]')
g <- g + annotation_logticks(sides = 'tb')
g + theme_WAC(1) + theme(legend.position = c(0.3, 0.65))

@

The transfer function shown in Fig.~\ref{fig:LTsolution} indicates
that the response to fluctuations at 5~Hz is only about 50\% of the
imposed amplitude, and at 10~Hz the response is only about 35\%.
Furthermore, the phase at 10~Hz is shifted by about $62^{\circ}$.
Using the measurement of dynamic heating $Q$ as specified by \eqref{eq:DHterm}
to correct the measured recovery temperature will therefore over-correct
and produce erroneous fluctuations in the measured air temperature
unless $Q$ is filtered to represent the sensor response..

A revised dynamic-heating adjustment filtered to represent how the
sensor will respond is denoted $Q^{\prime}$. When no correction is
applied to the measured recovery temperature $T_{m}(t)$, the ambient
temperature $T_{a}$ should be estimated from\\
\begin{equation}
T_{a}(t)=T_{m}(t)-Q^{\prime}(t)\label{eq:QprimeCorr}
\end{equation}
instead of \eqref{eq:recoveryTemperature}. The appropriate correction
can be obtained from the transfer function in several ways, as discussed
next.


\subsection{A filter for dynamic heating\label{subsec:A-filter-for}}

The impulse response of the sensor can be found from the inverse Fourier
transform of the transfer function. Once that is determined, appropriate
moving-average coefficients can be found from the impulse response,
and those coefficients define a digital filter that represents the
sensor response. The procedure used here is somewhat arbitrary and
a better filter could probably be designed, but this functions reasonably
for 25~Hz measurements. Details including the filter coefficients
are provided in Appendix B.

<<designFilter, include=FALSE>>=

P <- Param1
NP <- 15000  ## Assume 10-min segment
df <- 25 / NP
df1 <- 1 / NP
frq <- c(seq(0, 12.5, by=df), seq(-12.5+df, -df, by=df))
frq1 <- c(seq(0, 0.5, by = df1), seq(-0.5+df1, -df1, by = df1))
NP <- length(frq)
NP1 <- length(frq1)
E <- LTphase(frq, P)
EH <- LTphase(frq, ParamSH)
EHB <- LTphase(frq, ParamSH)
EG <- LTphase(frq, ParamSF)
E1 <- LTphase(frq1, P)
EH1 <- LTphase(frq1, ParamSH)
EHB1 <- LTphase(frq1, ParamSH)
EG1 <- LTphase(frq1, ParamSF)
## --------------------------
G <- complex(modulus=E$Amp, argument=E$Phase * pi / 180)
NG <- length(G)
GT <- fft(G, inverse=TRUE) / NG  # get the impulse function
## Limit to 200 coefficients (8 s at 25 Hz)
Lshift <- 100
GT[(Lshift + 2):(NP - Lshift)] <- complex(modulus=0)
GTT <- GT[GT != complex(modulus=0)]
## Reorder:
GTT <- c(GTT[(Lshift + 2):length(GTT)], GTT[1:(Lshift + 1)])
AR <- signal::Arma(Re(GTT) / sum(Re(GTT)), 1) # Normalize to avoid <1% bias
## --------------------------
GG <- complex(modulus=EG$Amp, argument=EG$Phase * pi / 180)
GTG <- fft(GG, inverse=TRUE) / NG  # get the impulse function
GTG[(Lshift + 2):(NP - Lshift)] <- complex(modulus=0)
GTTG <- GTG[GTG != complex(modulus=0)]
## Reorder:
GTTG <- c(GTTG[(Lshift + 2):length(GTTG)], GTTG[1:(Lshift + 1)])
ARG <- signal::Arma(Re(GTTG) / sum(Re(GTTG)), 1) # Normalize to avoid <1% bias
## --------------------------
GH <- complex(modulus=EH$Amp, argument=EH$Phase * pi / 180)
NG <- length(GH)
GTH <- fft(GH, inverse=TRUE) / NG  # get the impulse function
## Limit to 300 coefficients (12 s at 25 Hz)
LshiftH <- 150
GTH[(LshiftH + 2):(NP - LshiftH)] <- complex(modulus=0)
GTTH <- GTH[GTH != complex(modulus=0)]
## Reorder:
GTTH <- c(GTTH[(LshiftH + 2):length(GTTH)], GTTH[1:(LshiftH + 1)])
ARH <- signal::Arma(Re(GTTH) / sum(Re(GTTH)), 1)
## --------------------------
GHB <- complex(modulus=EHB$Amp, argument=EHB$Phase * pi / 180)
NG <- length(GHB)
GTHB <- fft(GHB, inverse=TRUE) / NG  # get the impulse function
## Limit to 300 coefficients (12 s at 25 Hz)
LshiftH <- 150
GTHB[(LshiftH + 2):(NP - LshiftH)] <- complex(modulus=0)
GTTHB <- GTHB[GTHB != complex(modulus=0)]
## Reorder:
GTTHB <- c(GTTHB[(LshiftH + 2):length(GTTHB)], GTTHB[1:(LshiftH + 1)])
ARHB <- signal::Arma(Re(GTTHB) / sum(Re(GTTHB)), 1)
## --------------------------
G1 <- complex(modulus=E1$Amp, argument=E1$Phase * pi / 180)
NG1 <- length(G1)
GT1 <- fft(G1, inverse=TRUE) / NG1  # get the impulse function
## Limit to 20 coefficients (20 s at 1 Hz)
Lshift1 <- 10
GT1[(Lshift1 + 2):(NP1 - Lshift1)] <- complex(modulus=0)
GTT1 <- GT1[GT1 != complex(modulus=0)]
## Reorder:
GTT1 <- c(GTT1[(Lshift1 + 2):length(GTT1)], GTT1[1:(Lshift1 + 1)])
AR1 <- signal::Arma(Re(GTT1) / sum(Re(GTT1)), 1)
## --------------------------
GH1 <- complex(modulus=EH1$Amp, argument=EH1$Phase * pi / 180)
NG1 <- length(GH1)
GTH1 <- fft(GH1, inverse=TRUE) / NG1  # get the impulse function
LshiftH1 <- 10
GTH1[(LshiftH1 + 2):(NP1 - LshiftH1)] <- complex(modulus=0)
GTTH1 <- GTH1[GTH1 != complex(modulus=0)]
GTTH1 <- c(GTTH1[(LshiftH1 + 2):length(GTTH1)], GTTH1[1:(LshiftH1 + 1)])
ARH1 <- signal::Arma(Re(GTTH1) / sum(Re(GTTH1)), 1)
## --------------------------
GHB1 <- complex(modulus=EHB1$Amp, argument=EHB1$Phase * pi / 180)
NG1 <- length(GHB1)
GTHB1 <- fft(GHB1, inverse=TRUE) / NG1  # get the impulse function
LshiftH1 <- 10
GTHB1[(LshiftH1 + 2):(NP1 - LshiftH1)] <- complex(modulus=0)
GTTHB1 <- GTHB1[GTHB1 != complex(modulus=0)]
GTTHB1 <- c(GTTHB1[(LshiftH1 + 2):length(GTTHB1)], GTTHB1[1:(LshiftH1 + 1)])
ARHB1 <- signal::Arma(Re(GTTHB1) / sum(Re(GTTHB1)), 1)
## --------------------------
GG1 <- complex(modulus=EG1$Amp, argument=EG1$Phase * pi / 180)
NG1 <- length(GG1)
GTG1 <- fft(GG1, inverse=TRUE) / NG1  # get the impulse function
LshiftH1 <- 10
GTG1[(LshiftH1 + 2):(NP1 - LshiftH1)] <- complex(modulus=0)
GTTG1 <- GTG1[GTG1 != complex(modulus=0)]
GTTG1 <- c(GTTG1[(LshiftH1 + 2):length(GTTG1)], GTTG1[1:(LshiftH1 + 1)])
ARG1 <- signal::Arma(Re(GTTG1) / sum(Re(GTTG1)), 1)
save(AR, ARH, ARHB, ARG, AR1, ARH1, ARHB1, ARG1, Lshift, LshiftH, Lshift1, LshiftH1,
     file='AR.Rdata')
## --------------------------
# DF2$QF <- as.vector(signal::filter(AR, DF2$Q))
# DF2$QF <- ShiftInTime(DF2$QF, .shift=(-(Lshift + 1) * 40), .rate = 25)

@

<<plotImpulse, include=TRUE, fig.height=4, fig.cap=c('(a) The impulse response function found from the inverse Fourier transform of the transfer function for the unheated Rosemount 102E4AL sensor (Rosemount) and for the heated HARCO sensor (HARCO), using the response parameters from Table 2 of Part 1. The impulse response for the HARCO sensor is multiplied by 10. (b) A filter function (moving-average coefficients spanning 8 s) obtained from the impulse response function. The filtered result must be shifted forward in time by 4 s to compensate for the delay introduced by the filter. The coefficients are multiplied by 10 for the HARCO sensor.')>>=

layout(matrix(1:2, ncol=1), widths=c(8,8), heights=c(6.5,8))
op <- par (mar=c(2,4,1,1)+0.1, oma=c(1.1,0,0,0))
dP1 <- data.frame(Time = (1 : 100) * 0.04, R = Re(GT[1:100]), 
                 H = 10*Re(GTH[1:100]))
plotWAC(dP1, xlab='Time [s]', ylab='impulse response', lwd = c(2, 2), 
        lty = c(1, 2), legend.position = NA)
legend(2, 0.3, legend=c('Rosemount', 'HARCO x 10'), 
       col=c('blue', 'forestgreen'), lwd=c(2,2), lty=c(1,2))
abline(h=0, lty=2) 
text(4, 0.3, labels='(a)', cex=1.5)
op <- par (mar=c(5,4,1,1)+0.1)
dP2 <- data.frame(Time = (0 : 200) * 0.04, R = Re(GTT), 
                 H = 10 * Re(GTTH[51 :251]))
plotWAC(dP2, xlab='Time [s]', ylab='filter coef.', lwd = c(2, 2), 
        lty = c(1, 2), legend.position = NA)
legend(0.5, 0.3, legend=c('Rosemount', 'HARCO x 10'), 
       col=c('blue', 'forestgreen'), lwd=c(2,2), lty=c(1,2))
abline(h=0, lty=2)
text(8, 0.3, labels='(b)', cex=1.5)
layout(matrix(1:1, ncol=1), widths=c(8), heights=c(5.5))

@

Figure \ref{fig:plotImpulse}a shows the impulse function for the
unheated Rosemount and heated HARCO sensors, and Fig.~\ref{fig:plotImpulse}b
shows corresponding moving-average coefficients for a filter obtained
from this impulse function. There is significant ringing in the filter
for the Rosemount sensor because the shorter time constant for the
sensor, 0.03~s, is smaller than the time between 25-Hz samples. The
impulse response for the slower HARCO sensor leads to a much broader
impulse response function. Both sets of moving-average coefficients
sum to more than 0.99 as calculated but were then normalized to sum
to 1.0.

\subsection{Other filtering methods}

Two other calculations can produce the appropriately filtered response
to dynamic heating $Q^{\prime}(t)$:
\begin{enumerate}
\item Section~\ref{sec:theTransferFn} showed that the transfer function
is represented reasonably by the solution to two coupled differential
equations. Numerical integration of those equations can then produce
the predicted response of the sensor to dynamic heating. The equations
from Sect.~\ref{subsec:Theory}, revised to apply to dynamic heating,
are these:\\
\begin{equation}
\frac{dQ_{qs}(t)}{dt}=\frac{Q(t)-Q_{qs}(t)}{\tau_{2}}\label{eq:Ts-1}
\end{equation}
\begin{equation}
\frac{dQ^{\prime}(t)}{dt}=\frac{\left\{ aQ(t)+(1-a)Q_{qs}(t)\right\} -Q^{\prime}(t)}{\tau_{1}}\label{eq:Tm-1}
\end{equation}
where the first equation describes the effect of dynamic heating on
the support structure of the temperature sensor, leading to support-structure
variations in temperature of $Q_{qs}(t).$ and the second describes
the response of the sensing wire to the combined effects of this influence
on the support temperature and the dynamic-heating term. This separation
relies on the linearity of the underlying equations, which makes it
possible to represent the effect of dynamic heating in isolation from
real fluctuations in temperature. Euler integration of these differential
equations led to erroneous results at high frequency arising from
inadequate resolution in the integration, so a fourth-order Runge-Kutta
integration\footnote{The integration method was fourth-order Runge-Kutta with adjustment
of the time step to control the estimated tolerance during the integration.
The method was based on \citet{cash1990variable}. The integration
was also tested with the R routine ``rmutil::runge.kutta'' \citet{runge.kutta}.
See the Workflow document for additional details.} was used instead.
\item The response specified by the frequency-domain transfer function $H(\nu)$
can be realized by Fourier transforms, by first calculating the Fourier
transform of the dynamic-heating signal (here denoted $\hat{Q}(\nu)=\mathcal{F}(Q(t))$
where $\mathcal{F}$ denotes the Fourier transform) and then using
the inverse Fourier transform ($\mathcal{F}^{-1}$) to estimate the
sensor response:\\
\[
Q^{\prime}(t)=\mathcal{F}^{-1}(H(\nu)\hat{Q}(\nu))
\]
\end{enumerate}
\begin{figure}
<<Integration, include=TRUE, echo=FALSE, fig.width=4.1, out.width='0.48\\linewidth', fig.show='hold', messages = FALSE>>=

# DS is the data.frame, which includes Q
a <- ParamSF$a
tau1 <- ParamSF$tau1
tau2 <- ParamSF$tau2
DS$RT <- DS$RTF1
DS$TsQ <- DS$RT
DS$Qp <- DS$Q
Rate <- attr (DS, 'Rate')
fS <- function(y, i) {
  (DS$Q[i] - y) / (Rate * tau2)
}
fM <- function (y, i) {
  (a * DS$Q[i] + (1 - a) * DS$TsQ[i] - y) / (Rate * tau1)
}
DS$TsQ <- rk4.integrate (fS, DS$Q[1], 1:nrow(DS))
DS$Qp <- rk4.integrate (fM, DS$Q[1], 1:nrow(DS))
DS$QF <- as.vector(signal::filter(ARG, DS$Q))
DS$QF <- ShiftInTime(DS$QF, .shift=-Lshift * 40, .rate=25)
ft <- fft(DS$Q[1:(nrow(DS)-1)])
df <- 25 / length(ft)
frq <- c(0, seq(df, 12.5, by = df), seq(-12.5 + df, -df, by = df))
ATF <- LTphase(frq, ParamSF)
H <- complex(modulus = ATF$Amp, argument = ATF$Phase * pi / 180)
ftq <- ft * H
DS$Qft <- c(Re(fft(ftq, inverse=TRUE) / length(ft)), 0)
DS$Qft[nrow(DS)] <- mean(DS$Qft, na.rm=TRUE)
g <- DS %>% selectTime(60200, 61300) %>% 
            select(Time, TASX, Q, QF, Qft) %>% 
            VSpecC(VLabel=c('Q', 'filter', 'FFT'), spans = 151,
            xlim = xlim, ylim = c(1.e-5, 0.008))
g <- VSpecC(DS, 'Qp', VLabel='DiffEq', spans = 151, add = g) + theme_WAC(1) +
       annotate('text', x=8, y=0.002, label='(a)', size=5) +
       suppressWarnings(
       scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x, n=2), 
                     labels = trans_format("log10", math_format(10^.x)))) +
       theme(legend.text=element_text(size=11))
suppressWarnings(print(g))
# g <- VSpec(DS, 'Q', ylim = c(1.e-6, 0.1))
# g <- VSpec(DS, 'QF', add = g)
# VSpec(DS, 'Qp', add = g) + theme_WAC(1)
DS$AT <- DS$RT - DS$QF
g2 <- DS %>% select(Time, TASX, AT, RT, ATF1) %>%
       VSpecC(VLabel = c('air temp. with filt. Q', 'msrd recovery temp.',
                        'air temp. with std. Q'), spans = 151,
             xlim = xlim, ylim = c(1.e-5, 0.05)) +
       annotate('text', x=0.1, y=0.02, label='(b)', size=5) +
       suppressWarnings(
       scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x, n=2), 
                     labels = trans_format("log10", math_format(10^.x)))) +
       theme_WAC(1) +
      theme(legend.position=c(0.65, 0.75),
      plot.margin=unit(c(0.3,0.3,1.1,1.3),"lines"),
      legend.background=element_rect(colour='black', size=0.3, fill="ivory"),
      legend.direction="vertical", 
      legend.key.width=unit(1.3,'lines'), legend.key.height=unit(0.7,'lines'),
      legend.text=element_text(size=12)) +
      guides(colour = guide_legend(reverse = TRUE, '  legend:')) +
      ylab(bquote('spectral variance ' * nu * 'P(' * nu * ')'))
  suppressWarnings(print(g2))

@

\caption{Variance spectra for the unheated Rosemount 102E4AL sensor, for the
same flight segment used for Fig.~\ref{fig:S15}.\protect \\
Left, (a): The dynamic-heating term (``Q:) and for the filtered term
obtained by integrating the differential equations for the derivatives
(``DiffEq''), by Fourier transformation with application of the
transfer function (``FFT''), or applying the digital filter (``filter'').
The result for the latter is so close to that for ``FFT'' that it
is obscured in this plot.\protect \\
Right, (b): The measurement of recovery temperature and ambient temperature
calculated using the filtered dynamic-heating term. The original variable
for ambient temperature based on standard processing is also shown.\label{fig:Integration}}

\end{figure}

Figure~\ref{fig:Integration}a shows the variance spectra that result
from all three methods when applied to measurements from an unheated
Rosemount 102E4AL sensor. The modified variance spectrum obtained
by integration of the underlying differential equations is shown as
the orange line (``DiffEq'') in Fig.~\ref{fig:Integration}a. The
dynamic-heating correction is appropriately attenuated at high frequency
after this integration. The results obtained after filtering as described
in the Sect.~\ref{subsec:A-filter-for}, labeled ``filter'', or
after Fourier transformation, labeled ``FFT'', are overlapping so
as to be indistinguishable in this plot. These corrected estimates
of the dynamic heating are attenuated even more than the result from
numerical integration and are in better agreement with the predicted
effect of the transfer function, which for example predicts attenuation
of the variance spectrum by a factor of 0.096 for the component with
frequency 10~Hz. The numerical integration was closer to the results
of the filter if the measurements are interpolated to 125~Hz with
25-Hz smoothing, integrated, and then resampled to obtain 25~Hz measurements.
This iondicated that the discrepancy in results is attributable to
accumulating numerical errors in the integration, but the integration
became awkwardly slow when performed at 125-Hz resolution. The equivalence
of the results from the digital filter and from Fourier transformation
with application of the transfer function supports the validity of
these results and suggests that these are preferable and equivalent
methods for filtering dynamic heating to match the response of the
temperature sensor.

A revised estimate of the ambient air temperature was calculated using
\eqref{eq:QprimeCorr} and the corrected dynamic-heating term $Q^{\prime}$.
The spectral variance for this air temperature, shown in Fig.~\ref{fig:Integration}b
as the blue line, is improved considerably at high frequency vs.~that
using the standard correction.

\selectlanguage{english}%
<<WECANX, include=TRUE, echo=FALSE>>=

DWECAN <- getNetCDF('/Data/WECAN/WECANrf17h.nc', standardVariables(c('RTH1',
                    'ATH1', 'RTF1', 'ATF1')), 180400, 183500)   # 182600,182900)
DWECAN$Q <- DWECAN$TASX^2 / 2010
SB <- 50
Z <- capture.output (Vr <- SmoothInterp(detrend (DWECAN[, c('Time', 'RTH1')]), .Length=0))
Z <- capture.output (VrC <- SmoothInterp(detrend (DWECAN[, c('Time', 'Q')]), .Length=0))
Rate <- attr(DWECAN, 'Rate')
vcv <- cbind(ts(Vr, frequency=Rate), ts(VrC, frequency=Rate))
P <- spec.pgram(vcv, detrend=FALSE, fast=TRUE, plot=FALSE, spans=25)
dfH <- data.frame(P$coh, log(P$freq))
pfH <- binStats (dfH, bins=SB)
RXH <- CohP(DWECAN, 'RTH1', 'Q', plotType='Ranadu', smoothBins=SB)
phaseH <- rep(0, SB)
nphaseH <- rep(0, SB)
phase2H <- rep(0, SB)
arH <- rep(0, SB)
ar2H <- rep(0, SB)
narH <- rep(0, SB)
RXH$P.spec...1.[RXH$P.spec...1. < 0] <- 0
for (i in 2:nrow(RXH)) {
  phaseH[RXH$BIN.1[i]] <- phaseH[RXH$BIN.1[i]]+RXH$P.phase[i]
  nphaseH[RXH$BIN.1[i]] <- nphaseH[RXH$BIN.1[i]] + 1
  phase2H[RXH$BIN.1[i]] <- phase2H[RXH$BIN.1[i]]+RXH$P.phase[i]^2 
  arH[RXH$BIN.1[i]] <- arH[RXH$BIN.1[i]] + 
             sqrt(RXH$P.spec...1.[i] / RXH$P.spec...2.[i])
  ar2H[RXH$BIN.1[i]] <- ar2H[RXH$BIN.1[i]] + 
             (RXH$P.spec...1.[i] / RXH$P.spec...2.[i])
  narH[RXH$BIN.1[i]] <- narH[RXH$BIN.1[i]] + 1
}
narH[narH <= 0] <- 1
nphaseH[nphaseH == 0] <- 1
mphaseH <- phaseH/nphaseH
mphase2H <- phase2H/nphaseH
sdpH <- sqrt(mphase2H - mphaseH^2)
mphaseH <- mphaseH * 180 / pi
sdpH <- sdpH * 180 / pi
sdpH <- sdpH * 2 / sqrt(nphaseH)
arH <- arH / narH
ar2H <- ar2H / narH
sdrH <- sqrt(ar2H - arH^2)
sdrH <- sdrH * 2 / sqrt(narH)

@

\selectlanguage{american}%
In the case of the heated sensors, the revision is still more significant
because they respond more slowly. Figure~\ref{fig:HarcoQ}a shows
the result of filtering the dynamic-heating term for a heated HARCO
sensor. The result of integration (``DiffEq'') and the digital filter
(``filter'') are almost identical so there is no evidence of the
numerical problems that were encountered with the integration for
the unheated Rosemount sensor. The difference vs.~the original is
quite dramatic even at 1~Hz, and the errors are significant for all
frequencies above about 0.1~Hz. Because either corrected variance
spectrum represents how the temperature sensor responds to the actual
fluctuations, subtracting the actual fluctuations in dynamic heating
instead of the filtered fluctuations introduces substantial erroneous
variability into the calculated air temperature.

\begin{figure}
<<HarcoQ, include=TRUE, echo=FALSE, fig.height=3.5, fig.width=4.1, out.width='0.48\\linewidth', fig.show='hold', messages = FALSE>>=

a <- 0.733
tau1 <- 0.299
tau2 <- 0.433
DWECAN$RT <- SmoothInterp(DWECAN$RTH1, .Length = 0)
DWECAN$TsQ <- DWECAN$RT
DWECAN$Q <- SmoothInterp(DWECAN$Q, .Length = 0)  ## avoid missing values
Rate <- attr (DWECAN, 'Rate')
rhozero <- 1013.25 * 100 / (287.05 * 288.15)
MRHO <- MachNumber(DWECAN$PSXC, DWECAN$QCXC) * DWECAN$PSXC * 100 /
                  (287.05 * (273.15 + DWECAN$ATX)) / rhozero
MRHO <- SmoothInterp(MRHO, .Length=0)
a <- ParamSH$a
tau1 <- ParamSH$tau1 * (MRHO / 0.3) ^ 0.6  ## Note that these are variable
tau2 <- ParamSH$tau2 * (MRHO / 0.3) ^ 0.6
Rate <- attr (DWECAN, 'Rate')
DWECAN$TsQ <- DWECAN$Q
DWECAN$Qp <- DWECAN$Q
fS <- function(y, i) {
  (DWECAN$Q[i] - y) / (Rate * tau2[i])
}
fM <- function (y, i) {
  (a * DWECAN$Q[i] + (1 - a) * DWECAN$TsQ[i] - y) / (Rate * tau1[i])
}
DWECAN$TsQ <- rk4.integrate (fS, DWECAN$Q[1], 1:nrow(DWECAN))
DWECAN$Qp <- rk4.integrate (fM, DWECAN$Q[1], 1:nrow(DWECAN))
DWECAN$QF <- as.vector(signal::filter(ARH, DWECAN$Q))
DWECAN$QF <- ShiftInTime(DWECAN$QF, .shift=-LshiftH * 40, .rate=25)
DWECAN %>% select(Time, TASX, Q, QF, Qp) %>% 
           VSpecC(VLabel=c('Q', 'filter', 'DiffEq'), 
                 xlim = xlim, ylim=c(1.e-6,0.8)) +
       annotate('text', x=0.1, y=0.05, label='(a)', size=5) +
       suppressWarnings(
       scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x, n=2), 
                     labels = trans_format("log10", math_format(10^.x)))) +
           theme_WAC(1) + theme(legend.text=element_text(size=12))
DWECAN$AT <- DWECAN$RT - DWECAN$QF
g <- DWECAN %>% select(Time, TASX, AT, RTH1, ATH1) %>%
      VSpecC(VLabel = c('air temp. with filt. Q', 'msrd recovery temp.',
                       'air temp. with std. Q'), 
                       xlim = xlim, ylim = c(1.e-6, 0.8)) +
       annotate('text', x=0.1, y=0.1, label='(b)', size=5) +
       suppressWarnings(
       scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x, n=2), 
                     labels = trans_format("log10", math_format(10^.x)))) +
       theme_WAC(1) +
      theme(legend.position=c(0.65, 0.8),
      plot.margin=unit(c(0.3,0.3,1.1,1.3),"lines"),
      legend.background=element_rect(colour='black', size=0.3, fill="ivory"),
      legend.direction="vertical", 
      legend.key.width=unit(1.3,'lines'), legend.key.height=unit(0.7,'lines'),
      legend.text=element_text(size=12)) +
      guides(colour = guide_legend('  legend:')) +
      ylab(bquote('spectral variance ' * nu * 'P(' * nu * ')'))
suppressWarnings(print(g))
# g <- VSpec(DWECAN, 'AT', ylim = c(1.e-6, 0.1))
# g <- VSpec(DWECAN, 'ATH1', add = g)
# # g <- VSpec(DWECAN, 'RTH1', add = g)
# suppressWarnings(print (VSpec (DWECAN, 'RTH1', add = g) + theme_WAC(1) + 
# theme(legend.position = c(0.75, 0.93))))

@

\caption{Variance spectra for the heated HARCO sensor.\protect \\
Left, (a): The unmodified dynamic-heating term (``Q'') and the two
filtered terms. The results from solving the differential equations
(``DiffEq'') or from application of the digital filter (``filter'')
are overlapping and indistiguishable in this figure.\protect \\
Right, (b): The temperature as modified by filtering the dynamic-heating
term (blue line). The other plotted spectra are for the measured recovery
temperature and the air temperature with the conventional dynamic-heating
correction.\label{fig:HarcoQ}}
\end{figure}

Figure~\ref{fig:HarcoQ}b shows how this affects the spectral variance
of the measured air temperature. The slow response of this sensor
causes the measured recovery temperature (green line) to have very
low spectral variance when the frequency is above 1~Hz, so the variance
in the standard air-temperature measurement in this frequency range
is almost entirely caused by erroneous adjustment for fluctuations
in dynamic heating to which the sensor does not respond. The correction
procedure using a filtered dynamic-heating correction removes this
excess spectral variance and produces a signal where the variance
for frequencies above about 0.1~Hz arises primarily from variance
in the measured recovery temperature. The variance spectrum for the
conventionally processed temperature looks approximately as might
be expected in an inertial subrange, but the variance above about
0.5~Hz is a false signal that does not arise from real variance in
temperature. It therefore becomes very important to use this revised
processing scheme to avoid erroneous measurements even for changes
occurring over 5~s or more. The reasonable appearance of the variance
spectrum for the standard result is misleading because the measurement
is not responding to real fluctuations in air temperature at high
frequency. The measurement with filtered dynamic heating is a better
indication of the measured fluctuations. 

\begin{figure}
<<ATATF, include=TRUE, echo=FALSE, fig.height=3,  fig.width=4.1, out.width='0.48\\linewidth', fig.show='hold', messages = FALSE>>=

if (file.exists ('./DVOCALS.Rdata')) {
  load (file = './DVOCALS.Rdata')
  DVOCALS <- D
  DVOCALS$ATC <- DVOCALS$AT
  DVOCALS$original <- DVOCALS$ATRR
  DVOCALS$corrected <- DVOCALS$ATC
  ga <- DVOCALS %>% select(Time, original, corrected) %>% 
    selectTime(80100, 80104) %>% 
    ggplotWAC(lwd = c(0.6, 1.4), legend.position = c(0.5, 0.25)) +
    ylab(bquote('temperature [' * degree * 'C]')) +
    xlab('time [s]') +
    theme(legend.direction="vertical") + 
    guides(color=guide_legend("air T:"), size = guide_legend("air T:"),
           linetype = guide_legend("air T:"))
    print (ga + annotate('text', x = DVOCALS$Time[getIndex(DVOCALS, 80100)] + 0.4, y=15.092, label='(a)', size=5))
}
DWECAN$MACHX <- SmoothInterp (DWECAN$MACHX, .Length = 0)
DWECAN$ATH1 <- SmoothInterp (DWECAN$ATH1, .Length = 0)
alphaR2 <-
  0.988 + 0.053 * log10(DWECAN$MACHX) +
  0.090 * (log10(DWECAN$MACHX)) ^ 2 +
  0.091 * (log10(DWECAN$MACHX)) ^ 3
DWECAN$corrected <- DWECAN$ATH1 + alphaR2 * (DWECAN$Q - DWECAN$Qp)
DWECAN$original <- DWECAN$ATH1
gb <- DWECAN %>% select(Time, original, corrected) %>%
  selectTime(181300, 181320) %>%
  ggplotWAC(lwd = c(0.6, 1.4), legend.position = c(0.5, 0.75)) + 
    ylab(bquote('temperature [' * degree * 'C]')) +
    xlab('time [s]') + theme(legend.direction='vertical') + 
    guides(color=guide_legend("air T:"), size = guide_legend("air T:"),
           linetype = guide_legend("air T:"))
print(gb + annotate('text', x = DWECAN$Time[getIndex(DWECAN, 181300)] + 4.2, y=17.12, label='(b)', size=5))

@

\caption{Comparison of the original measured temperature and the same temperature
after filtering the dynamic-heating correction:\protect \\
(left): An unheated Rosemount 102E4AL sensor; (right): A heated HARCO
sensor. \label{fig:ATATF}}
\end{figure}

For the unheated Rosemount 102E4AL sensor, Fig.~\ref{fig:ATATF}a
illustrates the removal of erroneous structure by filtering, and Fig.~\ref{fig:ATATF}b
shows a similar example for the heated HARCO sensor. These examples
illustrate that the erroneous fluctuations in the uncorrected measurements
can be important in many potential uses of these measurements and
should be removed as part of standard processing. The effect is particularly
significant for the HARCO sensor, for which there are large fluctuations
in Fig.~\ref{fig:ATATF}b that are caused by fluctuations in dynamic
heating to which the sensor does not respond. \footnote{For the NSF/NCAR GV, the dynamic-heating term is complicated further
by resonance in the pressure lines connecting the transducers to the
pressure sources. This is discussed in detail in Appendix B.}

<<ATATH1, include=FALSE, echo=FALSE, fig.height=3, fig.cap='The original measured temperature from a heated HARCO sensor ("AT") and the same temperature after revising the dynamic-heating correction ("ATC").'>>=

DWECAN$MACHX <- SmoothInterp (DWECAN$MACHX, .Length = 0)
DWECAN$ATH1 <- SmoothInterp (DWECAN$ATH1, .Length = 0)
alphaR2 <-
  0.988 + 0.053 * log10(DWECAN$MACHX) +
  0.090 * (log10(DWECAN$MACHX)) ^ 2 +
  0.091 * (log10(DWECAN$MACHX)) ^ 3
DWECAN$ATC <- DWECAN$ATH1 + alphaR2 * (DWECAN$Q - DWECAN$Qp)
DWECAN$AT <- DWECAN$ATH1
DWECAN %>% select(Time, AT, ATC) %>%
  selectTime(181300, 181320) %>%
  ggplotWAC() + ylab(bquote('temperature [' * degree * 'C]')) +
    xlab('time [s]')

@


\section{The Flux of Sensible Heat}


\subsection{Outline of the correction procedure\label{subsec:Outline-correction}}

The measured air temperature $T_{a}$ is normally calculated by subtracting
a dynamic-heating correction $Q$ from the measurement: $T_{a}=T_{m}-Q$
where $T_{m}$ is the measured recovery temperature. However, here
it is desired to correct the resulting measurement on the basis of
a known transfer function $H(\nu)$ that describes how the sensor
responds to the input. That input (the measurand) is the recovery
temperature $T_{r}=T_{a}+Q$, which differs from the measurement $T_{m}$
when the sensor output lags behind the input. The correction procedure
therefore should correct the measurement $T_{m}$ to obtain an improved
estimate of the recovery temperature and then use that corrected estimate
of the recovery temperature to find the air temperature.

Most past studies of temperature corrections (e.g., \citet{mccarthy1973method},
\citet{nicholls1978measurements}, \citet{InverarityJTech2000}) applied
corrections instead to the air temperature after correction for dynamic
heating. That applies the full correction for dynamic heating $Q$
without considering that the sensor may respond only partly to high-frequency
fluctuations in $Q$, which was shown in Part 2 to lead to erroneous
noise in the air temperature. Then that noise is amplified by the
correction procedure. These errors are avoided if corrections are
applied instead to the measurement of the recovery temperature. Then
the appropriate amplification of signals restores the fluctuations
produced by dynamic heating and those fluctuations are appropriately
removed by subtracting the measured dynamic heating term from the
corrected recovery temperature. 

The procedure used here is as follows:
\begin{enumerate}
\item \uline{Find the transfer function,} as in Sect.~\ref{sec:theTransferFn}.
This is best done for the conditions, sensor, and aircraft that collect
the measurements to be used for the flux measurement.
\item \uline{Find the air temperature} or, equivalently, the Fourier
representation of the air temperature. In terms of Fourier transforms,
denoted here by the symbol ``$\hat{}$'', $\hat{T}_{m}(\nu)=H(\nu)\hat{T}_{r}(\nu)$
so the value of the recovery temperature can be estimated from the
inverse Fourier transform of $\hat{T}_{m}(\nu)/H(\nu)$. The best
estimate of the Fourier representation of the air temperature is then
obtained from $\hat{T}_{a}=\hat{T}_{m}(\nu)/H(\nu)-\hat{Q}(\nu)$.
This Fourier representation of the air temperature can be multiplied
by the complex conjugate of the Fourier representation of the updraft
to yield the cospectrum representing the flux of sensible heat, with
an appropriate scale factor as specified in \eqref{eq:heatFlux-1}.\footnote{The corrected recovery temperature also can be calculated by integrating
the equations presented in Sect.~\ref{subsec:Theory}.}
\item \uline{Calculate the cumulative cospectrum} for the cross-spectrum
of temperature and updraft, with a choice made regarding which frequency
interval to include. This will normally exclude wavelengths longer
than a few kilometers.
\item \uline{Calculate the flux} from the sum of the resulting cospectrum
over an appropriate frequency interval.
\end{enumerate}
<<initial3, echo=FALSE, include=FALSE>>=
## This chunk loads some needed R packages and defines a function
## used for the Laplace-transform solution of the governing
## differential equations.


plotRibbon <- TRUE
xlim <- c(0.01, 15)
ylim <- c(0.001, 80)

plotCS <- function(CS, Units, spans=149, fL, wavelengthLimit=2000, 
                   smoothBins=100, 
                   xlim=c(0.01,15), ylim=c(0.001,80), 
                   printTitle=TRUE, CSprevious = NA,
                   plotRibbon=TRUE) {
  ylab <- bquote("f x flux cospectrum ["*.(Units)*"]")    
  CSogive <- cumsum(CS$cospec) * CS$freq[1]
  CSogive <- CSogive[length(CSogive)]-CSogive
  CS$ogive <- CSogive
  CS$cospec <- SmoothInterp(CS$cospec, .Length=0)  # treat NAs
  s25 <- spans %/% 25; s10 <- spans %/% 10; s3 <- spans %/% 3
  s25 <- s25 + (s25 + 1) %% 2
  s10 <- s10 + (s10 + 1) %% 2
  s3 <- s3 + (s3 + 1) %% 2
  CS$cospec <- zoo::rollapply(CS$cospec, FUN = mean, fill='extend', width = s25)
  CS$cospec[CS$freq > 0.01] <- zoo::rollapply(CS$cospec, FUN = mean, fill='extend', width = s10)[CS$freq > 0.01]
  CS$cospec[CS$freq > 0.1] <- zoo::rollapply(CS$cospec, FUN = mean, fill='extend', width = s3)[CS$freq > 0.1]
  CS$cospec[CS$freq > 1] <- zoo::rollapply(CS$cospec, FUN = mean, fill='extend', width = spans)[CS$freq > 1]
  FluxL <- CSogive[which(CS$freq > fL)[1]]
  Flux <- CSogive[which(CS$freq > 0.01)[1]]
  attr(CS, 'Flux') <- Flux
  attr(CS, 'FluxL') <- FluxL
  attr(CS, 'wavelengthLimit') <- wavelengthLimit
  ## Construct the plot:
  CS$ncospec <- -1 * CS$cospec
  ## Weight by frequency for log-abscissa plot:
  CS$cospec <- CS$cospec * CS$freq
  CS$ncospec <- CS$ncospec * CS$freq
  # plotWAC(CS, xlab='frequency [Hz]', ylab=ylab, log='xy',
  #     col = c('skyblue', 'forestgreen', 'red'), lwd = c(2, 2, 2), 
  #     lty = c(1, 2, 1),
  #     xlim=c(0.05, 15), ylim=c(0.01,250), legend.position=NA)
  if (smoothBins > 5) {
    BS <- binStats(data.frame(CS$cospec, log(CS$freq)), bins = smoothBins)
    # lines(exp(BS$xc), BS$ybar, lwd=2, col='brown')
    BS$nybar <- -1 * BS$ybar
    BS$ybar[BS$ybar < 0] <- NA
    BS$nybar[BS$nybar < 0] <- NA
    BS$xc <- exp(BS$xc)
    # lines(exp(BS$xc), BS$nybar, lwd=2, col='magenta')
    attr(CS, 'smoothed data.frame') <- BS
    bse <- data.frame(x = BS$xc, ymin = BS$ybar - BS$sigma, ymax = BS$ybar + BS$sigma,
                      yminN = BS$nybar - BS$sigma, ymaxN = BS$nybar + BS$sigma)
    # lines(exp(BS$xc), BS$nybar, lwd=2, col='magenta')
  }
  if (smoothBins > 5) {
    bse$ymin[bse$ymin < ylim[1]] <- ylim[1]
    bse$yminN[bse$yminN < ylim[1]] <- ylim[1]
  }
  g <- ggplot(data = CS, aes(x=freq))
  g <- g + geom_path(aes(y = cospec, colour='cospectrum', linetype='cospectrum'))
  g <- g + geom_path(aes(y = ncospec, colour='-cospectrum', linetype='-cospectrum'))
  g <- g + geom_path(aes(y = ogive, colour='exceedance', linetype='exceedance'), lwd=1.2)
  if (is.data.frame(CSprevious)) {
    g <- g + geom_path(data=CSprevious, aes(x = freq, y = ogive,
                          colour='exceedance'), lty=2, lwd=1.2)
    if ('ogive2' %in% names(CSprevious)) {
      g <- g + geom_path(data=CSprevious, aes(x = freq, y = ogive2,
                          colour='generated', linetype='generated'), lwd=1.3)
    }
  }
  if (smoothBins > 5) {
    # g <- g + geom_path(data = BS, aes(x=xc, y=ybar), colour='blue', lwd=1.2)
    # g <- g + geom_path(data = BS, aes(x=xc, y=nybar), colour='deeppink3', lwd=1.2)
    g <- g + geom_point(data = BS, aes(x=xc, y=ybar), colour='black', pch=19)
    g <- g + geom_point(data = BS, aes(x=xc, y=nybar), colour='darkred', pch=19)
    if (plotRibbon) {
      # GeomRibbon$handle_na <- function(data, params) {  data }
      g <- g + geom_ribbon(data=bse, aes(x=x, ymin=ymin, ymax=ymax),
        fill='blue', alpha=0.2, show.legend=FALSE, inherit.aes=FALSE, na.rm=FALSE)
      g <- g + geom_ribbon(data=bse, aes(x=x, ymin=yminN, ymax=ymaxN),
                fill='red', alpha=0.2, show.legend=FALSE, inherit.aes=FALSE, na.rm=FALSE)
      
      # g <- g + geom_path(data=bse, aes(x=x, y=ymin), lty=1, lwd=0.5, col='magenta') +
      #          geom_path(data=bse, aes(x=x, y=ymax), lty=1, lwd=0.5, col='magenta')
    }
  }
  g <- g + geom_path(data=data.frame(x=rep(fL, 2), y=ylim), aes(x=x, y=y), linetype=2)
  g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x, n=4), #limits = xlim, 
    labels = trans_format("log10", math_format(10^.x))) +
    scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x, n=4), #limits = ylim,             
      labels = trans_format("log10", math_format(10^.x))) +
    annotation_logticks(sides='trbl') +
    coord_cartesian(xlim=xlim, ylim=ylim)
  g <- g + xlab('frequency [Hz]') + ylab(ylab)
  g <- suppressWarnings(g + scale_colour_manual (name='', 
    values=c('cospectrum'='blue', '-cospectrum'='red', 'exceedance'='brown',
             'generated' = 'forestgreen')))
  g <- g + scale_linetype_manual (name='', values=c('cospectrum'=1, '-cospectrum'=1, 'exceedance'=1, 'generated' = 4))
  g <- g + guides(col=guide_legend(reverse = TRUE), linetype=guide_legend(reverse = TRUE))
  ttl <- bquote('Total flux '~.(format(Flux, digits=3))~.(Units)*'; partial <'*.(format((wavelengthLimit/1000), digits=2))~'km:'~.(format(FluxL, digits=3))~.(Units))
  if (printTitle) {
    g <- g + labs(title=ttl)
  }
  suppressWarnings(print(g + theme_WAC(1) + theme(plot.title = element_text(size=12)) +
                             theme(legend.position=c(0.5, 0.91))))
  g <<- g  ## Save for adding uncorrected cospec for debugging...
  # par(bg = 'gray95')
  # plotWAC(data.frame(exp(BSF1$xc), BSF1$ybar, BSF1$nybar), 
  #   col = c('blue', 'red'), ylab = ylab,
  #   xlab='frequency [Hz]', log='xy', xlim=c(0.05,15),
  #   ylim=c(0.01,250), legend.position=NA)
  # lines(CSF1, col='gray50')
  # lines(exp(BSF1$xc), BSF1$ybar, col='blue', lwd=2)
  # lines(exp(BSF1$xc), BSF1$ybar+BSF1$sigma, col='blue', lwd=1)
  # lines(exp(BSF1$xc), BSF1$ybar-BSF1$sigma, col='blue', lwd=1)
  return(CS)
}


@

\vfill\eject

\subsection{Examples of Measured Cospectra and Fluxes}

<<SOCrf15, include=FALSE>>=

load(file='AR.Rdata')  ## get ARG, etc.
DS <-
  getNetCDF('/Data/SOCRATES/SOCRATESrf15h.nc',
            standardVariables(c('ATF1')),
            55500,
            62000)
Rate <- attr(DS, 'Rate')
rhozero <- 1013.25 * 100 / (287.05 * 288.15)
MRHO <- DS$MACHX * DS$PSXC * 100 / 
        (287.05 * (273.15 + DS$ATX)) / rhozero
ParamFS1 <- ParamSF
ParamFS1$tau1 <- ParamFS1$tau1 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ -0.6
ParamFS1$tau2 <- ParamFS1$tau2 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ -0.6
DS$TASX <- SmoothInterp(DS$TASX, .Length = 0)
DS$Q <- DS$TASX ^ 2 / 2010
DS$ATX <- DS$ATF1
# DS$AT <- reviseDH(DS, ParamFS1, rf)  # rf was calculated in an earlier code chunk
## Replace this by the filtered result:
## Recalculate AT using the dynamic-heating filter:
DS$ATX <- SmoothInterp(DS$ATX, .Length=0)
DS$PSXC <- SmoothInterp(DS$PSXC, .Length=0)
DS$QCXC <- SmoothInterp(DS$QCXC, .Length=0)
DS$MACH <- SmoothInterp(MachNumber(DS$PSXC, DS$QCXC), .Length=0)
DS$alphaR <- RecoveryFactor(DS$MACH, 'UNHEATED') 
DS$Q <- DS$TASX^2 / (2 * SpecificHeats()[1])
DS$QF <- as.vector(signal::filter(ARG, DS$Q))
DS$QF <- ShiftInTime(DS$QF, .shift=-Lshift * 40, .rate=25)
DS$AT <- DS$ATX + DS$alphaR * (DS$Q - DS$QF)
DS$AT <- SmoothInterp(DS$AT, .Length = 0)
DS$RTF1 <-
  DS$ATF1 + DS$alphaR * DS$Q  ## This variable isn't in the available file
DS$RTF1 <- SmoothInterp(DS$RTF1, .Length = 0)
## Estimate the corrected recovery temperature:
aV <- ParamFS1$a
tau1V <- ParamFS1$tau1
tau2V <- ParamFS1$tau2
DS$DTMDT <- c(0, diff(DS$RTF1, 2), 0) * Rate / 2

fSS <- function(y, i) {  # Eq. Ts3
    ((1/aV) * (tau1V * DS$DTMDT[i] + DS$RTF1[i] - (1-aV) * y) - y) / (Rate * tau2V)
  }

DS$Ts <- rk4.integrate (fSS, DS$RTF1[1], 1:nrow(DS))
DS$RTC <- (1/aV) * (tau1V * DS$DTMDT + DS$RTF1 - (1-aV) * DS$Ts)
DS$ATC <- DS$RTC - DS$alphaR * DS$QF
## Small time adjustment seems useful?
# DS$Q <- ShiftInTime(DS$Q, .shift = -25, .rate = 25)
DS$RHOCP <- 100 * DS$PSXC / (287.05 * 278) * 1005
DS$RHOCP <- SmoothInterp(DS$RHOCP, .Length = 0)

@

Two examples of measured cospectra illustrate the effect of the correction.
The first example is from the ``Southern Ocean Clouds, Radiation,
Aerosol Transport Experimental Study'' (SOCRATES) (flight 15, 24
January 2018, 6:00:00 to 6:15:00 UTC) and the second is from the ``Cloud
Systems Evolution in the Trades'' (CSET) experiment (flight 5, 14
July 2015, various segments from 17:50:00 to 20:50:00 UTC). The flight
segments that were used were all at low level (150~m) in the marine
boundary layer over Pacific Ocean\@. An unheated Rosemount 102E4AL
sensor was used on the NSF/NCAR GV during these projects\@. In each
case, the cospectra from three flight segments of 5 min (SOCRATES)
or 10 min (CSET) duration were averaged to produce the measured cospectra.
The flux estimates were then compared without correction and corrected
using the appropriate transfer function as determined in Part 1. 

\begin{figure}
<<SOCp1, include=TRUE, fig.height=3.5>>=

LTphaseC <- function(f, P) {
  ## f=frequency; P=Param
  tau1 <- P$tau1
  tau2 <- P$tau2
  a <- P$a
  b <- sqrt(1 / (1 + (2 * pi * f * tau2) ^ 2))
  zeta <- -atan(2 * pi * f * tau2)
  C1 <- 1 / (1 + 4 * pi ^ 2 * f ^ 2 * tau1 ^ 2) *
    (-(a + (1 - a) * b * cos(zeta)) * 2 * pi * f * tau1 +
       (1 - a) * b * sin(zeta))
  C2 <- 1 / (1 + 4 * pi ^ 2 * f ^ 2 * tau1 ^ 2) *
    ((a + (1 - a) * b * cos(zeta)) +
       (1 - a) * b * sin(zeta) * 2 * pi * f * tau1)
  cTF <- sqrt(C1 ^ 2 + C2 ^ 2)
  phiTF <- atan2(C1, C2) 
  return(complex(modulus = cTF, argument = phiTF))
}
N <- 2^13   ## 8192 covers the 5-min (7500-pt) segment
# Get the transfer function:
Par <- Param1
a <- ParamFS1$a
tau1 <- ParamFS1$tau1
tau2 <- ParamFS1$tau2
df <- Rate / N
frq <- c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
H <- LTphaseC(frq, ParamFS1) # complex(modulus=cTC, argument=phiTC)
ir <- setRange(DS, 60000, 61500)
Tasm <- mean(DS$TASX[ir], na.rm=TRUE)
D <- DS
RHO <- D$PSXC * 100 / (SpecificHeats()[3] * (D$ATX + 273.15))
scaleFactor <- mean(RHO[ir], na.rm=TRUE) * SpecificHeats()[1]
D$RTF1 <- ShiftInTime(D$RTF1, .rate=25, .shift=40)
# D$ATC <- ShiftInTime(D$ATC, .rate=25, .shift=0)
# D$WIC <- ShiftInTime(D$WIC, .rate=25, .shift=-40)
DS1 <- D %>% selectTime(60000, 60500)
DS2 <- D %>% selectTime(60500, 61000)
DS3 <- D %>% selectTime(61000, 61500)
CoSp <- rep(0, N)
CoSpUC <- rep(0, N)
.A <- 'RTF1'
.B <- 'ATC'
.C <- 'AT'
.D <- 'ATF1'
for (.data in list(DS1, DS2, DS3)) {
  N1 <- (N - nrow(.data)) %/% 2
  N2 <- N - nrow(.data) - N1
  WP <- c(rep(0, N1), detrend(.data[, c('Time', 'WIC')]), rep(0, N2))
  TP <- c(rep(0, N1), detrend(.data[, c('Time', .A)]), rep(0, N2))
  TPB <- c(rep(0, N1), detrend(.data[, c('Time', .B)]), rep(0, N2))
  TPuc <- c(rep(0, N1), detrend(.data[, c('Time', .C)]), rep(0, N2))
  TPO <- c(rep(0, N1), detrend(.data[, c('Time', .D)]), rep(0, N2))
  Q  <- c(rep(0, N1), detrend(.data[, c('Time', 'Q')]), rep(0, N2))
  ff1 <- fft(TP)
  ff1uc <- fft(TPuc)
  ffb <- fft(TPB)
  ffo <- fft(TPO)
  ff2 <- fft(WP)
  ffq <- fft(Q)
  cs.orig <- 2 * Re(ff1uc * Conj(ff2)) / (Rate * nrow(.data))
  # cs <- 2 * Re(ff1 * Conj(ff2)) / (Rate * N)
  ## Estimate original recovery T and apply corrected dynamic heating:
  alphaR <- mean(.data$alphaR, na.rm = TRUE)
  cs <- 2 * Re((ff1 / H - alphaR * H * ffq) * Conj(ff2)) / (Rate * nrow(.data))
  ## supercede with direct use of ATC:
  cs <- 2 * Re((ff1uc / H) * Conj(ff2)) / (Rate * nrow(.data))
  cs <- 1/(Mod(H)*cos(Arg(H))) * 2 * Re((ff1uc) * Conj(ff2)) / (Rate * nrow(.data))
  CoSp <- CoSp + cs
  CoSpUC <- CoSpUC + cs.orig
}
CoSp <- CoSp * scaleFactor / 3
CoSpUC <- CoSpUC * scaleFactor / 3
Nby2 <- N %/% 2
CS <- data.frame(freq = frq[2:(Nby2+1)], cospec = CoSp[2:(Nby2+1)])
CS.orig <- data.frame(freq = frq[2:(Nby2+1)], cospec = CoSpUC[2:(Nby2+1)])
CSogiveUC <- cumsum(CoSpUC[2:(Nby2+1)]) * CS$freq[1]
CSogiveUC <- CSogiveUC[length(CSogiveUC)]-CSogiveUC
CS.orig$ogive <- CSogiveUC
wavelengthLimit <- 2000
fL <- Tasm / wavelengthLimit
ylim <- c(1.e-2, 120)
Units = bquote("W" ~ m ^ -2)
spans = 49
sBins <- 100
CS.corrected <- plotCS(CS, Units, spans, fL, 
                   wavelengthLimit, smoothBins=sBins, 
                   xlim, ylim, CSprevious = CS.orig) 
CS.orig$cospec <- SmoothInterp(CS.orig$cospec, .Length=0)  # treat NAs
  s25 <- spans %/% 25; s10 <- spans %/% 10; s3 <- spans %/% 3
  s25 <- s25 + (s25 + 1) %% 2
  s10 <- s10 + (s10 + 1) %% 2
  s3 <- s3 + (s3 + 1) %% 2
  CS.orig$cospec <- zoo::rollapply(CS.orig$cospec, FUN = mean, fill='extend', width = s25)
  CS.orig$cospec[CS.orig$freq > 0.01] <- zoo::rollapply(CS.orig$cospec, FUN = mean, fill='extend', width = s10)[CS.orig$freq > 0.01]
  CS.orig$cospec[CS.orig$freq > 0.1] <- zoo::rollapply(CS.orig$cospec, FUN = mean, fill='extend', width = s3)[CS.orig$freq > 0.1]
  CS.orig$cospec[CS.orig$freq > 1] <- zoo::rollapply(CS.orig$cospec, FUN = mean, fill='extend', width = spans)[CS.orig$freq > 1]
# g + geom_path(data=CS.orig, aes(x=freq, y=cospec*freq), col='forestgreen', size=1.3)

XS <-
  flux(
    DS[setRange(DS, 60000, 61500), ],
    'AT',
    Units = bquote("W"~m^-2),
    smoothBins = 50,
    scaleFactor = scaleFactor,
    wavelengthLimit = 2000,
    .plot = FALSE,
    Par = ParamFS1
  )
DCX <- getNetCDF(file.path(DataDirectory(), 'CSET/rf05h.nc'),
                 standardVariables(c('ATF1', 'ATH1', 'ATH2')), 175000, 205000)
Rate <- attr(DCX, 'Rate')
MRHO <- DCX$MACHX * DCX$PSXC * 100 / 
        (287.05 * (273.15 + DCX$ATX)) / rhozero
ParamFS1 <- ParamSF
ParamFS1$tau1 <- ParamFS1$tau1 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ -0.6
ParamFS1$tau2 <- ParamFS1$tau2 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ -0.6
DCX$TASX <- SmoothInterp(DCX$TASX, .Length = 0)
DCX$Q <- DCX$TASX ^ 2 / 2010
DCX$ATX <- DCX$ATF1
# DCX$AT <- reviseDH(DCX, ParamFS1, rf)  # rf was calculated in an earlier code chunk
## Replace this by the filtered result:
## Recalculate AT using the dynamic-heating filter:
DCX$ATX <- SmoothInterp(DCX$ATX, .Length=0)
DCX$PSXC <- SmoothInterp(DCX$PSXC, .Length=0)
DCX$QCXC <- SmoothInterp(DCX$QCXC, .Length=0)
DCX$MACH <- SmoothInterp(MachNumber(DCX$PSXC, DCX$QCXC), .Length=0)
DCX$alphaR <- RecoveryFactor(DCX$MACH, 'UNHEATED') 
DCX$Q <- DCX$TASX^2 / (2 * SpecificHeats()[1])
DCX$QF <- as.vector(signal::filter(ARG, DCX$Q))
DCX$QF <- ShiftInTime(DCX$QF, .shift=-Lshift * 40, .rate=25)
DCX$AT <- DCX$ATX + DCX$alphaR * (DCX$Q - DCX$QF)
DCX$AT <- SmoothInterp(DCX$AT, .Length = 0)
DCX$RTF1 <-
  DCX$ATF1 + DCX$alphaR * DCX$Q  ## This variable isn't in the available file
DCX$RTF1 <- SmoothInterp(DCX$RTF1, .Length = 0)
## Estimate the corrected recovery temperature:
aV <- ParamFS1$a
tau1V <- ParamFS1$tau1
tau2V <- ParamFS1$tau2
DCX$DTMDT <- c(0, diff(DCX$RTF1, 2), 0) * Rate / 2

fSS <- function(y, i) {  # Eq. Ts3
    ((1/aV) * (tau1V * DCX$DTMDT[i] + DCX$RTF1[i] - (1-aV) * y) - y) / (Rate * tau2V)
  }

DCX$Ts <- rk4.integrate (fSS, DCX$RTF1[1], 1:nrow(DCX))
DCX$RTC <- (1/aV) * (tau1V * DCX$DTMDT + DCX$RTF1 - (1-aV) * DCX$Ts)
DCX$ATC <- DCX$RTC - DCX$alphaR * DCX$QF
## Small time adjustment seems useful?
# DCX$Q <- ShiftInTime(DCX$Q, .shift = -25, .rate = 25)
DCX$RHOCP <- 100 * DCX$PSXC / (287.05 * 278) * 1005
DCX$RHOCP <- SmoothInterp(DCX$RHOCP, .Length = 0)

N <- 2^14   ## 16384 covers the 10-min (15000-pt) segments
# Get the transfer function:
a <- ParamFS1$a
tau1 <- ParamFS1$tau1
tau2 <- ParamFS1$tau2
df <- Rate / N
frq <- c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
H <- LTphaseC(frq, ParamFS1)
D <- DCX
D$RTF1 <- ShiftInTime(D$RTF1, .rate=25, .shift=40)
# D$ATC <- ShiftInTime(D$ATC, .rate=25, .shift=0)
# D$WIC <- ShiftInTime(D$WIC, .rate=25, .shift=-40)
DC1 <- D %>% selectTime(175200, 180200)
DC2 <- D %>% selectTime(194530, 195530)
DC3 <- D %>% selectTime(203717, 204717)
CoSp <- rep(0, N)
CoSpUC <- rep(0, N)
.A <- 'RTF1'
.B <- 'ATC'
.C <- 'AT'
.D <- 'ATF1'
DCF <- data.frame()
for (.data in list(DC1, DC2, DC3)) {
  N1 <- (N - nrow(.data)) %/% 2
  N2 <- N - nrow(.data) - N1
  WP <- c(rep(0, N1), detrend(.data[, c('Time', 'WIC')]), rep(0, N2))
  TP <- c(rep(0, N1), detrend(.data[, c('Time', .A)]), rep(0, N2))
  TPB <- c(rep(0, N1), detrend(.data[, c('Time', .B)]), rep(0, N2))
  TPuc <- c(rep(0, N1), detrend(.data[, c('Time', .C)]), rep(0, N2))
  TPO <- c(rep(0, N1), detrend(.data[, c('Time', .D)]), rep(0, N2))
  Q  <- c(rep(0, N1), detrend(.data[, c('Time', 'Q')]), rep(0, N2))
  ff1 <- fft(TP)
  ff1uc <- fft(TPuc)
  ffb <- fft(TPB)
  ffo <- fft(TPO)
  ff2 <- fft(WP)
  ffq <- fft(Q)
  cs.orig <- 2 * Re(ff1uc * Conj(ff2)) / (Rate * nrow(.data))
  # cs <- 2 * Re(ff1 * Conj(ff2)) / (Rate * N)
  ## Estimate original recovery T and apply corrected dynamic heating:
  alphaR <- mean(.data$alphaR, na.rm = TRUE)
  cs <- 2 * Re((ff1 / H - alphaR * H * ffq) * Conj(ff2)) / (Rate * nrow(.data))
  ## supercede with direct use of ATC:
  cs <- 2 * Re((ff1uc / H) * Conj(ff2)) / (Rate * nrow(.data))
  cs <- 1/(Mod(H)*cos(Arg(H))) * 2 * Re((ff1uc) * Conj(ff2)) / (Rate * nrow(.data))
  CoSp <- CoSp + cs
  CoSpUC <- CoSpUC + cs.orig
  DCF <- rbind(DCF, .data)
}
Tasm <- mean(DCF$TASX, na.rm=TRUE)
CoSp <- CoSp * scaleFactor / 3
CoSpUC <- CoSpUC * scaleFactor / 3
Nby2 <- N %/% 2
CS <- data.frame(freq = frq[2:(Nby2+1)], cospec = CoSp[2:(Nby2+1)])
CS.orig <- data.frame(freq = frq[2:(Nby2+1)], cospec = CoSpUC[2:(Nby2+1)])
CSogiveUC <- cumsum(CoSpUC[2:(Nby2+1)]) * CS$freq[1]
CSogiveUC <- CSogiveUC[length(CSogiveUC)]-CSogiveUC
CS.orig$ogive <- CSogiveUC
wavelengthLimit <- 2000
fL <- Tasm / wavelengthLimit
ylim <- c(1.e-2, 50)
CS.corrected <- plotCS(CS, Units, spans, fL, wavelengthLimit, 
                   smoothBins=sBins, 
                   xlim, ylim, CSprevious = CS.orig) 
CS.orig$cospec <- SmoothInterp(CS.orig$cospec, .Length=0)  # treat NAs
  s25 <- spans %/% 25; s10 <- spans %/% 10; s3 <- spans %/% 3
  s25 <- s25 + (s25 + 1) %% 2
  s10 <- s10 + (s10 + 1) %% 2
  s3 <- s3 + (s3 + 1) %% 2
  CS.orig$cospec <- zoo::rollapply(CS.orig$cospec, FUN = mean, fill='extend', width = s25)
  CS.orig$cospec[CS.orig$freq > 0.01] <- zoo::rollapply(CS.orig$cospec, FUN = mean, fill='extend', width = s10)[CS.orig$freq > 0.01]
  CS.orig$cospec[CS.orig$freq > 0.1] <- zoo::rollapply(CS.orig$cospec, FUN = mean, fill='extend', width = s3)[CS.orig$freq > 0.1]
  CS.orig$cospec[CS.orig$freq > 1] <- zoo::rollapply(CS.orig$cospec, FUN = mean, fill='extend', width = spans)[CS.orig$freq > 1]
# g + geom_path(data=CS.orig, aes(x=freq, y=cospec*freq), col='forestgreen', size=1.3)

@

\caption{\uline{(top): }The corrected flux of sensible heat for SOCRATES
flight 15, 6:00:00 to 6:15:00, a low-level flight segment over the
southern-hemisphere ocean. The ``exceedance'' is the complement
of the cumulative distribution function (i.e., the sum of contributions
from frequencies above the plotted value), and the dashed brown exceedance
line is that without transfer-function correction but with adjustment
of the dynamic-heating term to incorporate the estimated response
of the temperature sensor.\protect \\
\uline{(bottom): }Cospectrum for the flux of sensible heat, for
three 10-min flight segments from the CSET project. The dashed brown
line is the exceedance distribution before correction, which gives
a flux of 3.07 W m\$\{-2\}\$ for wavelengths smaller than 2 km and
2.06 W m\$\textasciicircum\{-2\}\$ for frequencies above 0.01 Hz.\label{fig:SOCp1}}
\end{figure}

The results are shown in Figs.~\ref{fig:SOCp1}, where the measured
fluxes of sensible heat are listed in the plot titles. This plot format
is unconventional so some explanation is provided below because this
plot will be used throughout the paper as the primary display of the
cospectrum. The cospectrum can be positive or negative, so it is usually
plotted using a linear scale for the abscissa. However, as the figure
shows, the range of ordinate values is displayed better with a logarithmic
scale, even after weighting the cospectrum by frequency. The compromise
made in this plot is to use a logarithmic scale but plot negative
values with sign reversed and with a different color, here red instead
of blue. The values plotted in red therefore should be regarded as
negative values of the plotted magnitude. There is then a dead-band
at the bottom of the plot where spectral values with very small absolute
value lie, here absolute values smaller than $10^{-2}\thinspace\mathrm{W\,m^{-2}}$.
Weighting by frequency is used as is appropriate for a logarithmic
abscissa. Other features of this plot and computation conventions
include the following:
\begin{enumerate}
\item The cospectrum (blue line) has been smoothed using Daniell smoothing,
with consecutive smoothing using width-3 for frequencies above 0.01~Hz,
then width-5 for frequencies above 0.1~Hz, then width-17 for frequencies
above 1~Hz. For these 5-min flight legs and for 25~Hz measurements,
the maximum smoothing interval corresponds to a smoother spanning
about 0.05~Hz, so most spectral features are retained even with this
strong smoothing. Additional smoothing results from averaging three
cospectra to obtain the plotted values.
\item Further smoothing is included by binning the results into 100 logarithmically
spaced intervals in frequency and averaging in those bins. That results
in the blue dots (or dark red dots for negative points).
\item A shaded ribbon denotes the standard deviation of the values in the
bins. In many cases it is too narrow to be visible.
\item The total flux indicated in the title is that arising from the part
of the flux with frequency above 0.01~Hz. This corresponds to a wavelength
of more than 10~km\@. In addition, there is another estimate of
the contribution to the flux from wavelengths below a selected limit,
here 2~km. That or a still smaller wavelength limit is often a reasonable
estimate of the part of the flux contributed by turbulent air motions
in the boundary layer, so that will be regarded as the primary measurement
of sensible-heat flux.
\item One additional line is plotted brown and labeled ``exceedance.''
That is a cumulative distribution function for the cospectrum, called
``exceedance'' because it is the contribution from all frequencies
\emph{higher} than the indicated value. At high frequency on a logarithmic
scale, where some of the most interesting variation is located, that
is more informative that the conventional cumulative distribution.
The units for exceedance are $\mathrm{W\,m}^{-2}$, not $\mathrm{W\,m}^{-2}$
per logarithmic interval as is the case for the weighted cospectrum.\footnote{The cumulative distribution termed ``exceedance'' here is sometimes
called the ogive.}
\end{enumerate}
The exceedance distributions before correction, shown as the dashed
brown lines, were calculated using a dynamic-heating correction that
was filtered to match the response of the sensor, but otherwise was
not corrected. In the two cases, without correction for the response
as represented by the transfer function, about 30\% and 44\% of the
flux, for the SOCRATES and CSET cases respectively, would be missed.
The underestimation is particularly serious at higher frequencies:
In both cases the measured contribution from frequencies above 1~Hz
is about twice as large after correction as it is without correction. 

\citet{LawsonRodi1992} estimated that, in comparison to their fast
thermocouple sensor on a slower aircraft, the unheated Rosemount sensor
underestimated the flux by about 21\% in their measurements. The magnitude
of the correction applied here is thus reasonably consistent with
expectations from that study.

By obtaining a realistic measurement of the cospectrum at high frequency,
it is possible to estimate how much of the otherwise unknown contribution
above 1~Hz has been missed and therefore to judge if the frequency
coverage is adequate. In this case, the exceedance curve is less than
2\% at 10~Hz and falls rapidly above that frequency, even after correction,
so it appears likely that additional contributions from higher frequencies
can go unmeasured without introducing serious errors into the measurement
of flux.

\subsection{Evidence from Simulated Measurements}

<<reinitialization,echo=FALSE,include=FALSE>>=

Directory <- DataDirectory ()
Flight <- 1 				
Project = "SOCRATES"			
ProjectDir <- "SOCRATES"
fname = sprintf("%s%s/%srf%02d.nc", Directory, ProjectDir, Project, Flight)

@

This section uses simulated measurements with the analysis methods
described in the preceding section to demonstrate that those correction
schemes can recover the assumed simulated conditions. The study uses
generated time series representing isotropic wind measurements that
have a specified relationship to the eddy dissipation rate and the
expected $-5/3$ slope of spectral variance vs.~frequency that is
expected for an inertial sub-range. The procedure was to generate
a Gaussian-noise spectrum, find the Fourier components, weight them
to obtain a $-5/3$ slope, and then use an inverse Fourier transform
to reconstruct the simulated measurement series. To provide a more
realistic representation of the variance spectra often observed, the
spectral variance is attenuated a low frequency to produce a peak
variance at several-kilometer wavelength.

The variance spectrum expected for an inertial sub-range has the following
form:\\
\begin{equation}
P(\nu)=C\left(\frac{2\pi}{V}\right)^{-2/3}\epsilon^{2/3}\nu^{-5/3}\label{eq:expectedSpectrum}
\end{equation}
where $C=0.5$ for the longitudinal component of the wind and 2/3
for a lateral component. An eddy dissipation rate of $10^{-3}\,\mathrm{m}^{2}\mathrm{s^{-3}}$
and a flight speed of $V=200$~m/s were used with \eqref{eq:expectedSpectrum}
to specify the desired variance spectrum. 

<<varSpecISR, include=FALSE, echo=FALSE, fig.cap="Assumed spectral variance at periodogram points.">>=

epsilon <- 1.e-3  ## mks
e23 <- epsilon ^ (2 / 3)
V <- 200   ## assumed flight speed, m/s
duration <- 1800
Rate <- 50
Nyq <- Rate / 2
C <- (2 / 3) * (2 * pi / V) ^ (-2 / 3)
# freq <- seq(1/duration, Nyq, by=1/duration)  ## unaliased
freq <- seq(1 / duration, Nyq * 5, by = 1 / duration)  ## aliased version
p <-
  C * e23 * freq ^ (-5 / 3)  ## This is variance per frequency interval,
## normalized to be positive frequencies
r <- freq > 0 & freq <= Nyq
plotWAC(
  data.frame (freq[r], p[r]),
  log = 'xy',
  xlab = 'frequency [Hz]',
  ylab = bquote('P(frequency) [m' ^ 2 ~ 's' ^ -2 ~ 'Hz' ^ -1 ~ ']'),
  col = 'blue',
  lwd = 2
)

@

<<generate, include=FALSE, echo=FALSE, fig.cap='The variance spectrum of the generated time series. Three wind components are shown: $u$ longitudinal; $v$ side lateral; $w$ upward. The simulated eddy dissipation rate was $10^{-3}$ m$^2s^{-3}$. The generated longitudinal spectral density (u) is 3/4 the lateral spectral densities (v and w), as expected in an inertial subrange. The dashed orange lines indicated the expected slope ($-2/3$ for this distribution because it is weighted by frequency), with the large-dot line representing $10^{-4}$ m$^2s^{-3}$ and other lines representing eddy dissipation rates  factors of 10 higher or lower. The spectral variance has been attenuated at low frequency to simulate the shapes that are often observed. The displayed wavelength scale was determined from the average flight speed.'>>=

if (file.exists('DF2.Rdata')) {  ## This is to avoid having this change every run
  load(file = 'DF2.Rdata')
} else {
  Rate <- 25
  duration <- 2^16 / Rate
  epsilon <- 1.e-3  ## Specify the eddy dissipation rate, mks units
  V <- 200   ## assumed flight speed, m/s
  ## Spectral variance amplitude, lateral component
  C <- (2 / 3) * (2 * pi / V) ^ (-2 / 3) * epsilon ^ (2 / 3) 
  Time <- seq(0, duration * Rate - 1) / Rate
  N <- length(Time)
  A <- sqrt(C * Rate / 2)
  u <- rnorm(N, 0, A) * sqrt(3/4)  ## sqrt(3/4) to get 3:4 ratio, spectra
  v <- rnorm(N, 0, A)
  w <- rnorm(N, 0, A)
  DF2 <- data.frame(Time = Time, TASX = V + u, u = u, v = v, w = w)
  attr(DF2, 'Rate') <- Rate
  f1 <- fft(DF2$u)
  f2 <- fft(DF2$v)
  f3 <- fft(DF2$w)
  df <- Rate / N
  frq <- c(seq(0, Rate/2, by = df), seq(-Rate/2+df, -df, by = df))
  f1[2:N] <- f1[2:N] * abs(frq[2:N]) ^ (-5/6)  ## Force -5/3 slope
  f2[2:N] <- f2[2:N] * abs(frq[2:N]) ^ (-5/6)
  f3[2:N] <- f3[2:N] * abs(frq[2:N]) ^ (-5/6)
  f_atten <- 0.05
  rf <- (abs(frq) < f_atten)
  rf[1] <- TRUE
  f1[rf] <- f1[rf] * exp(-5 * f_atten / abs(frq[rf]))  ## Truncate low-frequency
                                          ## (improves high-f accuracy)
  f2[rf] <- f2[rf] * exp(-5 * f_atten / abs(frq[rf]))
  f3[rf] <- f3[rf] * exp(-5 * f_atten / abs(frq[rf]))
  DF2$u <- Re(fft(f1, inverse = TRUE) / N)
  DF2$v <- Re(fft(f2, inverse = TRUE) / N)
  DF2$w <- Re(fft(f3, inverse = TRUE) / N)
  ## Modify time to get a POSIXct value as expected by Ranadu:
  load('chunks/Time_units.Rdata')  ## Saved from a conventional file
  attr(DF2$Time, 'units') <- Time_units$value
  tref <- sub ('seconds since ', '', attr (DF2$Time, 'units'))
  DF2$Time <- as.POSIXct(DF2$Time, tz = 'UTC', origin = tref)
  DF2 <- DF2 %>% selectTime(500, 3500)  # Select subset to avoid end effects
  save(DF2, file='DF2.Rdata')
}
DF2 %>% select(Time, TASX, u, v, w) %>% 
        VSpec(xlim=c(0.01,15), ylim=c(1.e-3, 10), method = 'MEM', poles=100) +          
        theme_WAC(1)

@

<<plotCS2, include=TRUE, echo=FALSE>>=

## plotCS is redefined here to get the form desired for a unified
## plot of the simulation results without distorting earlier plots.
plotCS <- function(CS, Units, spans=149, fL, wavelengthLimit=2000, 
                   smoothBins=100, 
                   xlim=c(0.01,15), ylim=c(0.001,80), 
                   printTitle=TRUE, CSprevious = NA,
                   plotFigure = TRUE, plotRibbon=TRUE, 
                   showNegative = TRUE, ADD = FALSE) {
  if(ADD) {
    ## Add to an existing plot definition that is saved in a previous call
    if(exists('g.CS')) g <- g.CS  ## Saved from a previous call
  }
  ylab <- bquote(nu * " x flux cospectrum ["*.(Units)*"]")    
  CSogive <- cumsum(CS$cospec) * CS$freq[1]
  CSogive <- CSogive[length(CSogive)]-CSogive
  CS$ogive <- CSogive
  CS$cospec <- SmoothInterp(CS$cospec, .Length=0)  # treat NAs
  s25 <- spans %/% 25; s10 <- spans %/% 10; s3 <- spans %/% 3
  s25 <- s25 + (s25 + 1) %% 2
  s10 <- s10 + (s10 + 1) %% 2
  s3 <- s3 + (s3 + 1) %% 2
  CS$cospec <- zoo::rollapply(CS$cospec, FUN = mean, fill='extend', width = s25)
  CS$cospec[CS$freq > 0.01] <- zoo::rollapply(CS$cospec, FUN = mean, fill='extend', width = s10)[CS$freq > 0.01]
  CS$cospec[CS$freq > 0.1] <- zoo::rollapply(CS$cospec, FUN = mean, fill='extend', width = s3)[CS$freq > 0.1]
  CS$cospec[CS$freq > 1] <- zoo::rollapply(CS$cospec, FUN = mean, fill='extend', width = spans)[CS$freq > 1]
  FluxL <- CSogive[which(CS$freq > fL)[1]]
  Flux <- CSogive[which(CS$freq > 0.01)[1]]
  attr(CS, 'Flux') <- Flux
  attr(CS, 'FluxL') <- FluxL
  attr(CS, 'wavelengthLimit') <- wavelengthLimit
  ## Construct the plot:
  CS$ncospec <- -1 * CS$cospec
  ## Weight by frequency for log-abscissa plot:
  CS$cospec <- CS$cospec * CS$freq
  CS$ncospec <- CS$ncospec * CS$freq
  # plotWAC(CS, xlab='frequency [Hz]', ylab=ylab, log='xy',
  #     col = c('skyblue', 'forestgreen', 'red'), lwd = c(2, 2, 2), 
  #     lty = c(1, 2, 1),
  #     xlim=c(0.05, 15), ylim=c(0.01,250), legend.position=NA)
  if (smoothBins > 5) {
    BS <- binStats(data.frame(CS$cospec, log(CS$freq)), bins = smoothBins)
    # lines(exp(BS$xc), BS$ybar, lwd=2, col='brown')
    BS$nybar <- -1 * BS$ybar
    BS$ybar[BS$ybar < 0] <- NA
    BS$nybar[BS$nybar < 0] <- NA
    BS$xc <- exp(BS$xc)
    # lines(exp(BS$xc), BS$nybar, lwd=2, col='magenta')
    attr(CS, 'smoothed data.frame') <- BS
    bse <- data.frame(x = BS$xc, ymin = BS$ybar - BS$sigma, ymax = BS$ybar + BS$sigma,
                      yminN = BS$nybar - BS$sigma, ymaxN = BS$nybar + BS$sigma)
    # lines(exp(BS$xc), BS$nybar, lwd=2, col='magenta')
  }
  if (smoothBins > 5) {
    bse$ymin[bse$ymin < ylim[1]] <- ylim[1]
    bse$yminN[bse$yminN < ylim[1]] <- ylim[1]
  }
  if(ADD) {
    g <- g + geom_path(data = CS, aes(y = cospec, colour='measured',
                       linetype='measured'))
    if (showNegative) {
      g <- g + geom_path(aes(y = ncospec, colour='-cosp2', 
         linetype='-cosp2'))
    }
    g <- g + geom_path(data = CS, aes(y = ogive, colour='exc-msrd', 
                       linetype='exc-msrd'), lwd=1.2)
    # g <- g + geom_point(data = CS, aes(y = ogive, colour = 'exc-msrd',
    #                    shape = 'exc-msrd'))
  } else { 
    g <- ggplot(data = CS, aes(x=freq))
    g <- g + geom_path(data = CS, aes(y = cospec, colour='generated', 
                       linetype='generated'))
    if (showNegative) {
      g <- g + geom_path(aes(y = ncospec, colour='-cosp', linetype='-cosp'))
    }
    g <- g + geom_path(aes(y = ogive, colour='exceedance',
                           linetype = 'exceedance'), lwd=1.2)
    # g <- g + geom_point(aes(y = ogive, colour = 'exceedance',
    #                         shape = 'exceedance'))
  }
  if (is.data.frame(CSprevious)) {
    g <- g + geom_path(data=CSprevious, aes(x = freq, y = ogive,
                       colour='exc-corr', linetype='exc-corr'),
                       lwd=1.2)
    # g <- g + geom_point(data = CSprevious, aes(x = freq, y = ogive,
    #                    colour = 'exc-corr', shape = 'exc-corr'))
    if ('ogive2' %in% names(CSprevious)) {
      g <- g + geom_path(data=CSprevious, aes(x = freq, y = ogive2,
                          colour='generated', linetype='generated'),
                          lwd=1.3)
      # g <- g + geom_point(data = CSprevious, aes(x = freq, y = ogive2,
      #                     colour = 'generated', shape = 'generated'))
    }
  }
  if (smoothBins > 5) {
    pclr <- ifelse(ADD, 'measured', 'generated')
    pclr <- ifelse(ADD, 'forestgreen', 'blue')
    # g <- g + geom_path(data = BS, aes(x=xc, y=ybar, colour=pclr), lwd=1.2)
    # g <- g + geom_path(data = BS, aes(x=xc, y=nybar), colour='deeppink3', lwd=1.2)
    if (ADD) {
      g <- g + geom_point(data = BS, aes(x=xc, y=ybar, colour='measured'), pch=19)
    } else {
      g <- g + geom_point(data = BS, aes(x=xc, y=ybar, colour='generated'), pch=19)
    }
    if (showNegative) {
      g <- g + geom_point(data = BS, aes(x=xc, y=nybar), colour='darkred', pch=19)
    }
    if (plotRibbon) {
      # GeomRibbon$handle_na <- function(data, params) {  data }
      g <- g + geom_ribbon(data=bse, aes(x=x, ymin=ymin, ymax=ymax),
        fill=pclr, alpha=0.2, show.legend=FALSE, inherit.aes=FALSE, na.rm=FALSE)
      if (showNegative) {
        g <- g + geom_ribbon(data=bse, aes(x=x, ymin=yminN, ymax=ymaxN),
                fill='red', alpha=0.2, show.legend=FALSE, 
                inherit.aes=FALSE, na.rm=FALSE)
      }
      # g <- g + geom_path(data=bse, aes(x=x, y=ymin), lty=1, lwd=0.5, col='magenta') +
      #          geom_path(data=bse, aes(x=x, y=ymax), lty=1, lwd=0.5, col='magenta')
    }
  }
  if (!ADD) {
  g <- g + geom_path(data=data.frame(x=rep(fL, 2), y=ylim), aes(x=x, y=y), linetype=2)
  g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x, n=2), #limits = xlim, 
    labels = trans_format("log10", math_format(10^.x))) +
    scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x, n=4), #limits = ylim,             
      labels = trans_format("log10", math_format(10^.x))) +
    annotation_logticks(sides='trbl') +
    coord_cartesian(xlim=xlim, ylim=ylim)
  g <- g + xlab('frequency [Hz]') + ylab(ylab)
  ttl <- bquote('Total flux '~.(format(Flux, digits=3))~.(Units)*'; partial <'*.(format((wavelengthLimit/1000), digits=2))~'km:'~.(format(FluxL, digits=3))~.(Units))
  if (printTitle) {
    g <- g + labs(title=ttl)
  }
  g <- g + theme_WAC(1) + theme(plot.title = element_text(size=12)) +
                             theme(legend.position=c(0.5, 0.91))
  } else {  ## this is for ADD == TRUE
   if (showNegative) {
     g <- suppressWarnings(g + scale_colour_manual (name='', 
          values=c('cosp'='blue', '-cosp'='red', 'exceedance'='brown',
             'generated' = 'forestgreen', 'measured'='forestgreen',
             '-cosp2'='darkorange', 'exceedance2'='black')))
    g <- g + scale_linetype_manual (name='', values=c('cosp'=1, 
             '-cosp'=1, 'exceedance'=1, 'generated' = 4, 'measured'=1, 
             '-cosp2'=1, 'exceedance2'=2))
    # g <- g + guides(col=guide_legend(reverse = TRUE), 
    #               linetype=guide_legend(reverse = TRUE))
  } else {
    g <- g + scale_linetype_manual (name = '', values=c('generated'=1, 
             'exceedance' = 1, 'exc-msrd' = 2, 'measured' = 1, 
             'exc-corr' = 2))
    g <- g + scale_shape_manual(name = '', values = c('generated' = 19,
             'exceedance' = NA, 'exc-msrd' = NA, 'measured' = 19, 
             'exc-corr' = NA))
#     g <- g + scale_shape_manual(name = '', guide = guide_legend(
#                override.aes = list(19, NA, NA, 19, NA)))
    g <- g + scale_colour_manual (name='', 
          values=c('generated'='blue', 'exceedance'='brown',
             'exc-msrd' = 'brown', 'measured'='forestgreen',
             'exc-corr'='black'),
              guide = guide_legend(
              override.aes = list(shape = c('generated' = 19, 
                'measured' = 19))))
    g <- g + guides(colour = guide_legend(reverse = TRUE),  
                    linetype=guide_legend(reverse = TRUE),
                    shape = guide_legend(reverse = TRUE)) 
    g <- g + guides(shape = guide_legend(override.aes = list(shape=c(19, NA, NA, 19, NA))))
    }
  }
  if (plotFigure) suppressWarnings(print(g))
  g.CS <<- g  ## Save for adding additional lines...
  # par(bg = 'gray95')
  # plotWAC(data.frame(exp(BSF1$xc), BSF1$ybar, BSF1$nybar), 
  #   col = c('blue', 'red'), ylab = ylab,
  #   xlab='frequency [Hz]', log='xy', xlim=c(0.05,15),
  #   ylim=c(0.01,250), legend.position=NA)
  # lines(CSF1, col='gray50')
  # lines(exp(BSF1$xc), BSF1$ybar, col='blue', lwd=2)
  # lines(exp(BSF1$xc), BSF1$ybar+BSF1$sigma, col='blue', lwd=1)
  # lines(exp(BSF1$xc), BSF1$ybar-BSF1$sigma, col='blue', lwd=1)
  return(CS)
}


@

Thirty-minute time series were generated for the three components
of the wind, for an eddy dissipation rate of $10^{-3}\mathrm{m}^{2}\mathrm{s}^{-3}$,
and then long-wavelength components with frequency below 0.05~Hz
were attenuated by multiplying the Fourier components by $\exp(-5*0.05/|\nu|)$
where $\nu$ is the frequency. This not only produced a more realistic
spectrum but also improved the accuracy of the high-frequency simulation,
which otherwise exhibited some variability for different random sequences. 

To generate sensible-heat flux a correlation was introduced between
the simulated temperature and updraft, as follows:
\begin{enumerate}
\item In addition to the three-component time series for the wind, another
independent time series with the same slope was generated for the
\emph{air temperature }$T_{a}$ with fluctuations $T_{a}^{\prime}$
scaled smaller by a factor of $S=1^{\circ}\mathrm{C}/(5\thinspace\mathrm{m/s)}$
in comparison to the magnitude of the wind fluctuations. 
\item Correlation between the two time series was then introduced by defining
a new temperature time series with the fluctuations $T_{c}^{\prime}=(1-r)T^{\prime}+rw^{\prime}S$
where $r=0.3$. The result will be $<w^{\prime}T_{c}^{\prime}>=r\sqrt{\sigma_{w}\sigma_{T_{c}}}$,
which will lead to a flux of sensible heat specified as\\
\[
F_{s}=\rho_{a}C_{p}r\sqrt{\sigma_{w}\sigma_{T_{c}}}
\]
\item Finally, the measured recovery temperature was simulated by adding
the dynamic-heating correction to the simulated air temperature and
then filtering the result to represent how the sensor would respond.
\end{enumerate}
In this simulation, the correlation is the same at all frequencies
so the contribution to the measured flux also extends over all frequencies,
with decreasing contributions as frequency increases. About 15\% of
the $<2.5\,\mathrm{km}$ flux is contributed by frequencies above
1~Hz, where the sensor may respond incompletely to the fluctuations
and underestimate the flux. 

<<genF, include=FALSE>>=

rc <- 0.3
DF2$T <- DF2$v / 5
DF2$T <- (1 - rc) * DF2$T + rc * DF2$w / 5 + 10
DF2$WIC <- DF2$w
DF2$Q <- 0.985 * DF2$TASX ^ 2 / 2010
## The true recovery temperature that is the measurand
DF2$RT <- DF2$T + DF2$Q  
a <- Param1$a
tau1 <- Param1$tau1
tau2 <- Param1$tau2
DF2$TsQ <- DF2$RT
DF2$Qp <- DF2$Q
Rate <- attr (DF2, 'Rate')
fS <- function(y, i) {
  (DF2$Q[i] - y) / (Rate * tau2)
}
fM <- function (y, i) {
  (a * DF2$Q[i] + (1 - a) * DF2$TsQ[i] - y) / (Rate * tau1)
}
# DF2$TsQ <- rk4.integrate (fS, DF2$Q[1], 1:nrow(DF2))
# DF2$Qp <- rk4.integrate (fM, DF2$Q[1], 1:nrow(DF2))
DF2$QF <- as.vector(signal::filter(AR, DF2$Q))
DF2$QF <- ShiftInTime(DF2$QF, .shift=-Lshift * 40, .rate=25)
## Find the measured recovery temperature Tm responding to RT
fS <- function(y, i) {
  (DF2$RT[i] - y) / (Rate * tau2)
}
fM <- function (y, i) {
  (a * DF2$RT[i] + (1 - a) * DF2$Ts[i] - y) / (Rate * tau1)
}
# DF2$Ts <- rk4.integrate (fS, DF2$RT[1], 1:nrow(DF2))
# DF2$Tm <- rk4.integrate (fM, DF2$RT[1], tv = 1:nrow(DF2))
# DF2$Tm <- rk4.integrate (fM, DF2$RT[1], 1:nrow(DF2))
DF2$TF <- as.vector(signal::filter(AR, DF2$RT))
## TF is the filtered measurement of the recovery temperature, 
## so this is what would be measured.
DF2$TF <- ShiftInTime(DF2$TF, .shift=-Lshift * 40, .rate=25) 
## The erroneous conventionally measured ambient temperature
DF2$ATm <- DF2$TF - DF2$Q 
# It would be better to use the filtered dynamic-heating
DF2$ATM <- DF2$TF - DF2$QF  
SF <- 100 * 850 / (287 * 283) * 1005
A <- flux(    ## This is the "true" flux
  DF2,
  'T',
  Units = bquote("W" ~ m ^ -2),
  smoothBins = 100,
  scaleFactor = mean(SF, na.rm=TRUE),
  wavelengthLimit = 2500,
  .plot = FALSE
)

@

<<simF, include=TRUE, fig.height=4, fig.cap='The cospectrum for the flux of sensible heat (blue line), weighted by frequency $\\nu$, for the simulated data generated as described in the text. Three 10-min segments of simulated 25 Hz data were averaged. The measured cospectrum was obtained by filtering the simulated recovery temperature and subtracting the correction for dynamic heating. For the generated and measured cospectrum, filled circles indicate the average values calculated in 50 logarithmically space intervals, and for the measured cospectrum shading indicates the standard deviation in those intervals. The exceedance lines show the contribution to flux from frequencies higher than the plotted frequency. The corrected cospectrum is not shown but is consistent with the generated cospectrum, as demonstrated by the agreement between the generated exceedance and the corrected exceedance. The units for the exceedance distributions are W m$^{-2}$, while the units for the weighted flux cospectra are W m$^{-2}$ per unit logarithmic increment.'>>=

# A <- flux(
#   DF2,
#   'ATF',
#   Units = bquote("W" ~ m ^ -2),
#   smoothBins = 100,
#   scaleFactor = mean(SF, na.rm=TRUE),
#   wavelengthLimit = 2500
# )
AF <- flux(
  DF2,
  'ATm',
  Units = bquote("W" ~ m ^ -2),
  smoothBins = 100,
  scaleFactor = mean(SF, na.rm=TRUE),
  Par = Param1,
  .plot = FALSE,
  wavelengthLimit = 2500
)

N <- 2^14   ## 16384 covers the 10-min (15000-pt) segments
# Get the transfer function:
a <- Param1$a
tau1 <- Param1$tau1
tau2 <- Param1$tau2
df <- Rate / N
frq <- c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
H <- LTphaseC(frq, Param1)
D <- DF2
# D$RTF1 <- ShiftInTime(D$RTF1, .rate=25, .shift=40)
# D$ATC <- ShiftInTime(D$ATC, .rate=25, .shift=0)
# D$WIC <- ShiftInTime(D$WIC, .rate=25, .shift=-40)
DX1 <- D %>% selectTime(500, 1500)
DX2 <- D %>% selectTime(1500, 2500)
DX3 <- D %>% selectTime(2500, 3500)
CoSp <- rep(0, N)
CoSpG <- rep(0, N)  ## cospectrum of generated T
CoSpUC <- rep(0, N)
.A <- 'ATm' # the simulated measurement of air temperature 
.B <- 'TF'  # the measured recovery temperature
.C <- 'ATM' # improved measurement using filtered Q
.D <- 'T'   # the generated air temperature
DCF <- data.frame()
for (.data in list(DX1, DX2, DX3)) {
  N1 <- (N - nrow(.data)) %/% 2
  N2 <- N - nrow(.data) - N1
  WP <- c(rep(0, N1), detrend(.data[, c('Time', 'WIC')]), rep(0, N2))
  TPuc <- c(rep(0, N1), detrend(.data[, c('Time', .A)]), rep(0, N2))
  TPB <- c(rep(0, N1), detrend(.data[, c('Time', .B)]), rep(0, N2))
  TP <- c(rep(0, N1), detrend(.data[, c('Time', .C)]), rep(0, N2))
  TPO <- c(rep(0, N1), detrend(.data[, c('Time', .D)]), rep(0, N2))
  Q  <- c(rep(0, N1), detrend(.data[, c('Time', 'Q')]), rep(0, N2))
  ff1 <- fft(TP)
  ff1uc <- fft(TPuc)
  ffb <- fft(TPB)
  ffo <- fft(TPO)
  ff2 <- fft(WP)
  ffq <- fft(Q)
  ## The original as generated
  cs.G <- 2 * Re(ffo * Conj(ff2)) / (Rate * nrow(.data))
  ## The predicted measurement before correction
  cs.orig <- 2 * Re(ff1uc * Conj(ff2)) / (Rate * nrow(.data))
  ## The predicted measurement with adjusted dynamic heating
  cs.orig <- 2 * Re(ff1 * Conj(ff2)) / (Rate * nrow(.data))
  # cs <- 2 * Re(ff1 * Conj(ff2)) / (Rate * N)
  ## The corrected cospectrum:
  cs <- 2 * Re((ffb / H - ffq) * Conj(ff2)) / (Rate * nrow(.data))
  CoSp <- CoSp + cs
  CoSpG <- CoSpG + cs.G
  CoSpUC <- CoSpUC + cs.orig
  DCF <- rbind(DCF, .data)
}
Tasm <- mean(DCF$TASX, na.rm=TRUE)
CoSp <- CoSp * scaleFactor / 3
CoSpG <- CoSpG * scaleFactor / 3
CoSpUC <- CoSpUC * scaleFactor / 3
Nby2 <- N %/% 2
CS <- data.frame(freq = frq[2:(Nby2+1)], cospec = CoSp[2:(Nby2+1)])
CS.G <- data.frame(freq = frq[2:(Nby2+1)], cospec = CoSpG[2:(Nby2+1)])
CS.orig <- data.frame(freq = frq[2:(Nby2+1)], cospec = CoSpUC[2:(Nby2+1)])
CSogiveUC <- cumsum(CoSpUC[2:(Nby2+1)]) * CS$freq[1]
CSogiveUC <- CSogiveUC[length(CSogiveUC)]-CSogiveUC
CS.orig$ogive <- CSogiveUC
wavelengthLimit <- 2500
fL <- Tasm / wavelengthLimit
ylim <- c(1.e-3, 100)
sBins <- 50
xlim <- c(0.08,15)
## This is just to get the corrected ogive
CS.corrected <- plotCS(CS, Units, spans=121, fL, wavelengthLimit, 
                   smoothBins=sBins, 
                   xlim=xlim, ylim=ylim, 
                   plotFigure = FALSE) 
CS.G <- plotCS(CS.G, Units, spans=121, fL, wavelengthLimit, 
                   smoothBins=sBins,
                   xlim, ylim, CSprevious = CS.corrected, 
                   plotFigure = FALSE,
                   showNegative = FALSE)
CS.X <- plotCS(CS.orig, Units, spans=151, fL, wavelengthLimit, 
                   smoothBins=sBins, 
                   xlim=xlim, ylim=ylim, 
                   showNegative = FALSE,
                   plotFigure = FALSE,
                   ADD = TRUE) 
CS <- CS.G
CS$cospecM <- CS.X$cospec
CS$ogiveM <- CS.X$ogive
CS$xcM <- CS.X$xc
CS$ybarM <- CS.X$ybar
CS$sigmaM <- CS.X$sigma
CS$nbM <- CS.X$nb
CS$cospecC <- CS.corrected$cospec
CS$ogiveC <- CS.corrected$ogive
CS$xcC <- CS.corrected$xc
CS$ybarC <- CS.corrected$ybar
CS$sigmaC <- CS.corrected$sigma
CS$nbC <- CS.corrected$nb
lLbl <- c('generated cospectrum', 'measured cospectrum',
                  'exceedance - generated', 'exceedance-measured',
                  'exceedance - corrected')
g <- ggplot(data = CS, aes(x=freq))
g <- g + geom_path(aes(y = cospec, colour = lLbl[1], 
            linetype = lLbl[1]), size = 1.2)
g <- g + geom_path(aes(y = cospecM, colour = lLbl[2],
            linetype = lLbl[2]), size = 1.2)
g <- g + geom_path(aes(y = ogive, colour = lLbl[3],
            linetype = lLbl[3]), size = 1.5)
g <- g + geom_path(aes(y = ogiveC, colour = lLbl[5],
            linetype = lLbl[5]), size = 1)
g <- g + geom_path(aes(y = ogiveM, colour = lLbl[4],
            linetype = lLbl[4]), size = 1.5)
g <- g + geom_point(aes(y = ogive, colour = lLbl[3],
            shape = lLbl[3]))
g <- g + geom_point(aes(y = ogiveC, colour = lLbl[5],
            shape = lLbl[5]))
g <- g + geom_point(aes(y = ogiveM, colour = lLbl[4],
            shape = lLbl[4]))
g <- g + geom_point(data = attr(CS.G, 'smoothed data.frame'),
           aes(x = xc, y = ybar, colour = lLbl[1],
               shape = lLbl[1]), cex = 2.5)
g <- g + geom_point(data = attr(CS.X, 'smoothed data.frame'),
           aes(x = xc, y = ybar, colour = lLbl[2],
               shape = lLbl[2]), cex = 2.5)
g <- g + geom_ribbon(data = attr(CS.X, 'smoothed data.frame'), 
           aes(x = xc, ymin = ybar - sigma, ymax = ybar + sigma),
           fill = 'darkgreen', alpha = 0.3, show.legend = FALSE,  
           inherit.aes = FALSE, na.rm = FALSE)
g <- g + geom_path(data=data.frame(x=rep(fL, 2), y=ylim), aes(x=x, y=y), linetype=2, lwd = 1.3)
g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x, n=2), #limits = xlim, 
                           labels = trans_format("log10", math_format(10^.x))) +
      scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x, n=4), #limits = ylim,             
                    labels = trans_format("log10", math_format(10^.x))) +
      annotation_logticks(sides='trbl') +
      coord_cartesian(xlim=xlim, ylim=ylim)
    vllt <- c(1,1,1,4,4)
    vlsh <- c(19, 19, NA, NA, NA)
    vlcl <- c('blue', 'forestgreen', 'brown', 'brown', 'black')
    vlsz <- c(0.7, 0.7, 1.5, 2, 1.2)
    names(vllt) <- lLbl
    names(vlsh) <- lLbl
    names(vlcl) <- lLbl
    names(vlsz) <- lLbl
    g <- g + scale_linetype_manual (name = '  legend:', values = vllt)
    g <- g + scale_shape_manual(name = '  legend:', values = vlsh)
#     g <- g + scale_shape_manual(name = '  legend:', guide = guide_legend(
#                override.aes = list(19, NA, NA, 19, NA)))
    g <- g + scale_colour_manual (name='  legend:', values = vlcl)
    g <- g + scale_size_manual(name = '  legend:', values = vlsz)
    g <- g + guides(colour = guide_legend(reverse = TRUE),  
                    linetype=guide_legend(reverse = TRUE),
                    shape = guide_legend(reverse = TRUE)) 
    g <- g + xlab('frequency [Hz]') + ylab(bquote(nu * " x flux cospectrum ["*.(Units)*"]"))
    g <- g + theme_WAC()
      g <- g + theme(legend.position=c(0.35, 0.3),
      plot.margin=unit(c(0.3,0.3,1.1,1.3),"lines"),
      legend.background=element_rect(colour='black', size=0.3, fill="ivory"),
      legend.direction="vertical",
      legend.key.width=unit(1.3,'lines'), legend.key.height=unit(0.7,'lines'),
      legend.text=element_text(size=12))
    suppressWarnings(print(g + theme(legend.key.size = unit(0.5, "in"))))

@

Figure \ref{fig:simF} shows (as the green line) how the simulated
cospectrum would be measured by a sensor with response parameters
\{$a,\,\tau_{1},\,\tau_{2}$\} equal to \{0.733, 0.0308, 0.447\},
as is characteristic of a Rosemount 102E4AL sensor. The simulated
measurement of air temperature was obtained by adding the dynamic-heating
correction to the simulated air temperature and then applying the
digital filter developed in Part 2 to estimate how the sensor would
respond. Then the resulting value for measured recovery temperature
was corrected for dynamic heating to obtain the value that would be
measured for the air temperature, and that value was used with the
simulated updraft to calculate the cospectrum. The resulting measured
cospectrum is significantly smaller than the generated cospectrum
for frequencies above about 1~Hz and is almost a factor of ten too
low at 10~Hz. The measured exceedamce distribution (dashed brown
line) emphasizes the extent of the missing flux at high frequency.

The cospectrum obtained using the correction procedure of Sect.~\ref{subsec:Outline-correction}
was consistent with the generated cospectrum, as illustrated by the
corrected exceedance distribution in Fig.~\ref{fig:simF} (dashed
black line). For wavelengths smaller than 2.5~km, the generated flux
of sensible heat was 39.5~W\,m$^{-2}$, the measured values before
and after correction were 33.2 and 38.5~W\,m$^{-2}.$ The correction
thus reduces the 15\% measurement error to about 2.5\%. The representation
of the high-frequency contribution is improved significantly by the
correction procedure: For the contribution to the flux from frequencies
above 3~Hz, the respective values for the generated, measured, and
corrected exceedance distributions are 15.3, 10.8, and 15.1~W\,m$^{-2}$,
so about 30\% of the contribution in this frequency range would be
missed without correction.

This test only confirms consistency between the prediction of the
transfer function and the correction procedure based on that function.
The former, when deployed in a digital filter, is dependent on the
assumptions and weaknesses in that filter, while the latter may be
influenced by end effect and window effects from calculating the Fourier
transforms. The agreement between the simulated and corrected flux
therefore provides some support for the filter developed in Part 2
and for the correction procedure developed in this paper.


\section{Summary and Conclusions}

The key findings are these:
\begin{enumerate}
\item The differential equations \eqref{eq:Ts} and \eqref{eq:Tm}, with
appropriate parameters, provide an analytical representation of the
transfer function for the recovery temperature measured by an unheated
Rosemount 102E4AL sensor. That transfer function was shown to be consistent
with measurements of the phase and amplitude ratio of the response
to dynamic-heating fluctuations. This is good evidence that the equations
provide a good representation of the time response for that sensor.
The predictions of the equations are less satisfactory when applied
to a heated HARCO sensor or a heated Rosemount sensor, possibly indicating
that the heat transfer is not represented adequately by those equations.
\item For the Rosemount 102E4AL sensor, the three parameters in those equations
(characterizing the two time constants and the fraction of heat transfer
to the air vs.~that to the structure supporting the sensing wire)
can be determined with small uncertainty by fitting the transfer function
to observations of dynamic heating. These parameters are thus constrained
well and can be relied upon to make corrections to the measurements
and otherwise to characterize the effects of time response of that
sensor.
\item Once the transfer function for the unheated Rosemount sensor has been
determined, it can be used to estimate the true recovery temperature,
and then transfer functions for other sensors can be determined by
comparison to that estimate of the measurand to which they are responding.
This approach has been used here for the slower heated sensors and
should provide a means of correcting other sensors slower than the
unheated sensor. Appendix A uses these results with standard methods
to correct the measurements from airborne temperature sensors for
their time response.
\item Because temperature sensors often do not respond fast enough to measure
high-frequency components of the dynamic-heating correction, erroneous
corrections are introduced by conventional data processing. Instead,
the corrections should be filtered to match the response of the temperature
sensor to avoid introduction of these errors. A digital filter is
proposed that can be used to correct standard processing schemes to
eliminate the errors arising from the dynamic-heating term. The errors
discussed here are prevalent in almost all existing data from research
aircraft, so application of this proposed correction method will lead
to significant improvement in those measurements.
\item A correction procedure was proposed that consists of using the transfer
function to calculate the sensible-heat flux. Three cases are presented,
all with significant correlation between temperature and updraft at
a range of frequencies including those above 1~Hz. The measured values
of sensible-heat flux would be underestimated significantly (by about
40\%, 30\%, and 44\% in the three cases) without correction.
\item The cospectrum with correction appears to be represented reasonably
at frequencies up to about 10~Hz, so the rapidly decreasing concentration
to the cospectrum from these frequencies suggests that it is not necessary
to measure contributions from frequencies above this limit. This conclusion
is tentative and needs reconsideration when applied to new cases.
\item Results of a simulation support the consistency between the response
as represented by the digital filter and the application of the transfer
function to correct the measurement of the flux of sensible heat.
\end{enumerate}

\appendix

\section{Correcting the Temperature\label{sec:Correcting-the-Temperature}}

The true recovery temperature $T_{r}$ can be retrieved from the measured
temperature $T_{m}$ in two ways, either from the differential equations
or by Fourier transformation. These methods are illustrated here.

The differential equations \eqref{eq:Ts} and \eqref{eq:Tm} provide
a basis for correcting the measured temperature to account for the
time response of the sensor. They should be applied to the recovery
temperature $T_{r}(t)$, which is the measurand. The actual measurement
is $T_{m}(t)$ and the temperature of the support is $T_{s}(t)$,
so those equations, rearranged, are:

\begin{equation}
\frac{dT_{s}(t)}{dt}=\frac{T_{r}(t)-T_{s}(t)}{\tau_{2}}\label{eq:Ts2}
\end{equation}
\begin{equation}
T_{r}(t)=\frac{1}{a}\left\{ \tau_{1}\frac{dT_{m}(t)}{dt}+T_{m}(T)-(1-a)T_{s}(t)\right\} \label{eq:Tm2}
\end{equation}

There are two unknowns ($T_{r}(t)$, the actual recovery temperature,
and $T_{s}(t)$). Those unknowns are specified by the two preceding
equations because all other terms are known, including $dT_{m}/dt$
which can be represented using the numerical derivative of the measurements
$T_{m}(t)$. The second equation can be used to eliminate $T_{r}$
from the first:\\
\begin{equation}
\frac{dT_{s}(t)}{dt}=\frac{\frac{1}{a}\left\{ \tau_{1}\frac{dT_{m}(t)}{dt}+T_{m}(T)-(1-a)T_{s}(t)\right\} -T_{s}(t)}{\tau_{2}}\label{eq:Ts3}
\end{equation}
From an initial value $T_{s}(0)$, assumed to be $T_{m}(0)$, this
equation can be integrated to find the temperature of the support,
$T_{s}(t)$. Once that is known, \eqref{eq:Tm2} specifies the estimate
of the true recovery temperature $T_{r}(t)$ without further integration.
The only choices needed are the numerical method used to find the
derivative $dT_{m}/dt$ (e.g., here centered fourth-order) and the
integration method applied to \eqref{eq:Ts3}, here fourth-order Runge-Kutta
integration with Cash-Karp (\citet{cash1990variable}) adjustment
of the step size. If a centered second-order finite-difference expression
is used for $dT_{m}(t)/dt$ and an Euler integration is used to integrate
\eqref{eq:Ts3}, this correction can be shown to be equivalent to
that developed by \citet{InverarityJTech2000}; cf.~his Eqn.~(12).
However, the correction should be applied to the recovery temperature,
not the air temperature. The sensor responds to the recovery temperature,
which includes the increase caused by dynamic heating. Applying the
correction to the recovery temperature properly corrects the response
to dynamic heating also, so the dynamic-heating correction can then
be subtracted from the corrected recovery temperature to obtain an
estimate of the air temperature. 

<<method1, include=FALSE>>=

a <- Param1$a
tau1 <- Param1$tau1
tau2 <- Param1$tau2
## RT is the working solution; Ts is the support temperature
DT$Ts <- DT$RT
Rate <- attr (DT, 'Rate')
DT$DTMDT <- c(0, diff(DT$TTRR, 2), 0) * Rate / 2
DT$DTMDT <-  (c(0, 8*diff(DT$TTRR, 2), 0) - 
              c(0, 0, diff(DT$TTRR, 4), 0, 0)) * Rate / 12
# DT$DTMDT <- (DT$DTMDT + c(0, DT$DTMDT[1:(nrow(DT)-1)])) / 2
# DT$DTMDT <- as.vector (signal::filter(signal::sgolay(1, 3, m=1), DT$TTRR)) * Rate
fS <- function(y, i) {
  # Eq. Ts3
  ((tau1 * DT$DTMDT[i] + DT$TTRR[i] - (1 - a) * y)/a - y) / (Rate * tau2)
}

DT$Ts <- rk4.integrate (fS, DT$Ts[1], 1:nrow(DT))
DT$RT <- (1 / a) * (tau1 * DT$DTMDT + DT$TTRR - (1 - a) * DT$Ts)
DT %>% select(Time, TTRR, RT, Ts) %>% 
  selectTime(114500, 114505) %>% 
  plotWAC()

@

<<meth1Example, include=FALSE, fig.height=4, fig.cap=c('Examples of the changes produced by the correction procedures. The original measurement of recovery temperature is Tm and the revised value using is RT. The estimated temperature of the support (Ts) is also shown. The plotted time is seconds after 11:45:00 UTC for VOCALS flight 3.', 'Variance spectra for the original measurement of recovery temperature (TTRR) and for the corrected value (RT).')>>=

DT %>% select(Time, TTRR, RT, Ts) %>% 
  selectTime(114500, 114505) %>% 
  plotWAC(legend.position = 'topright')
g <- VSpec(DT, 'TTRR', ylim = c(1.e-5, 0.1))
VSpec(DT, 'RT', add = g) + theme_WAC(1)

@

An alternate approach is to use Fourier transforms:
\begin{enumerate}
\item Calculate the Fourier transform of the measured time series: $\hat{T}_{m}(\omega)=\mathcal{F}\left(T_{m}(t)\right)$
where $\omega$ is angular frequency and $\mathcal{F}$ denotes the
Fourier transform.
\item Divide the result by the complex representation of the transfer function:
$\hat{T}_{r}(\omega)=\hat{T}_{m}(\omega)/H(\omega)$.
\item Use the inverse Fourier transform to find a retrieved estimate of
the true recovery temperature: $T_{r}(t)=\mathrm{Re}\left(\mathcal{F}^{-1}\left(\hat{T}_{r}(\omega)\right)\right)$
where Re denotes the real part of the complex result.
\end{enumerate}
<<setUpFFT, include=FALSE>>=

N <- length(DT$TTRR)
if (N %% 2 == 1) {
  N <- N - 1
  DT  <- DT[-nrow(DT), ]
}
f <- fft (DT$TTRR)
N <- length(f)
df <- Rate / N
frq <- c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
N2 <- N %/% 2
fmax <- 2
nlim <- which(frq > fmax)[1]
# f[nlim:N2] <- f[nlim:N2] * (fmax / frq[nlim:(N2-1)])
# f[(N2+1):(N-nlim)] <- Conj(rev(f[nlim:N2]))
## Modify the spectrum by the inverse of the response function:
AFFT <- LTphase(frq, Param1)
AFFT$frq <- frq
AFFT$Phase <- AFFT$Phase * pi / 180
H <- complex (modulus = AFFT$Amp, argument = AFFT$Phase)
xn <- Re(fft(f / H, inverse = TRUE)) / N
DT$FFT <- xn
# g <- VSpec(DT, 'TTRR', ylim=c(1.e-5, 0.1))
# g <- VSpec(DT, 'FFT', add=g)
# VSpec(DT, 'RT', add=g) + theme_WAC()
# DT %>% select(Time, TTRR, FFT) %>% selectTime(114500, 114505) %>% plotWAC()

@

<<sampleFFT, include=TRUE, fig.height=4, fig.cap=c('Example of the changes produced by the correction procedures. The original measurement of recovery temperature is Tm, produced by an unheated Rosemount sensor, and the revised values are RT (from integration) and FFT (from Fourier transforms). The dashed green line labeled "Ts" is the temperature of the support as calculated using (17). Measurements from VOCALS flight 3.', 'Variance spectra for the original measurement of recovery temperature (Tm) produced by an unheated Rosemount sensor and for the corrected values (RT and FFT) produced respectively by (16) and the Fourier-transform algorithm.')>>=

DT$Tm <- DT$TTRR
DT %>% select(Time, Tm, FFT, RT, Ts) %>% 
  selectTime(114500, 114505) %>% 
  plotWAC(col=c('blue', 'black', 'darkorange', 'forestgreen'), 
          ylab=bquote('temperature [' ~ degree * 'C]'),
          lty=c(1,1,2,2), lwd=c(2,2,2,1.5), legend.position='bottom')
# g <- VSpec(DT, 'TTRR', ylim = c(1.e-5, 0.1))
# VSpec(DT, 'FFT', add = g) + theme_WAC(1)
DT %>% select(Time, TASX, Tm, RT, FFT) %>% 
       VSpec(method='MEM', ylim=c(1.e-5, 0.1)) +
       theme_WAC(1)

@

Sample results of these correction procedures are shown in Fig.~\ref{fig:sampleFFT1}.
The agreement between the two correction methods is very good, and
both show evidence of faster and higher-amplitude response to fluctuations.
The resulting variance spectrum for the Fourier-transform method (Fig.~\ref{fig:sampleFFT2})
has high variance above about 5~Hz that is above the variance for
the corrected variable obtained from \eqref{eq:Tm2}. The increasing
variance for the Fourier-transform method is is likely the fault of
the measurement itself: The spectral variance for the original measurement
(Tm) does not decrease at high frequency as expected from the transfer
function, and the correction procedure amplifies this excess noise.
The lower variance for the variable obtained from \eqref{eq:Tm2}
at high frequency arises from the finite-difference representation
of the term $dT_{m}(t)/dt$, which results in some smoothing.

Because the heated HARCO sensor is much slower than the unheated
Rosemount 102E4AL sensor, the measurements from that slower sensor
can't be corrected to the extent possible for the unheated sensor,
but it is still useful to evaluate to what extent the measurements
can be improved. The HARCO presents a special case because the best-fit
value is $a=0$ so \eqref{eq:Tm2} can't be used. However, in this
case the differential equations can still be combined to give\\
\begin{equation}
T_{r}(t)=(\tau_{1}+\tau_{2})\frac{dT_{m}(t)}{dt}+T_{m}(t)+\tau_{2}\tau_{1}\frac{d^{2}T_{m}(t)}{dt^{2}}\label{eq:HARCOsoln}
\end{equation}
a form that can be used directly without integration because finite-difference
expressions can be used for the derivatives of the measured $T_{m}(t)$.
The solution from \eqref{eq:HARCOsoln} is very noisy if finite-difference
estimates of the derivatives are used, so smoothing of the result
was applied. Figure~\ref{fig:HARCOcorrection1} shows the result
(as ``RTH'') after a Butterworth low-pass filter with cutoff frequency
of 2~Hz smoothed the corrected measurements. This filtering is reasonable
because the variance spectrum for this sensor shows very little real
signal at frequencies above 2~Hz. In comparison to the original measurement
(labeled ``Tm''), the response of the sensor is greatly improved
by this correction procedure. It even provides a reasonable representation
of the corrected unheated Rosemount measurement (labeled ``RT'')
for the same period.

This is not as good a representation of the transfer function as is
possible with the fitted representation shown in Fig.~\ref{fig:GVHARCO}
and given by \eqref{eq:lfitH}. That fit can be used with the Fourier-transform
approach to correction. The result is shown in Fig.~\ref{fig:HARCOcorrection1}
as the black line labeled ``FFT''. This is also a significant improvement
over the original and reproduces many of the features of the best
measurement (``RT''). To obtain this result, it was necessary to
attenuate frequencies above 1.8~Hz in the Fourier transform solution
because there is a zero in the transfer function as represented by
\eqref{eq:lfitH} that otherwise invalidates the inversion. This attenuation
was accomplished by multiplying the transfer function by $e^{5\nu}$above
1.8~Hz. This arbitrarily chosen attenuation gave reasonable results,
although it is likely that better choices could be made with further
exploration. One more general measure of the improvement, beyond the
anecdotal evidence in the preceding figures, is that either correction
procedure reduced the standard deviation of the difference between
the measured value (Tm) and the estimated best value (RT) from $0.06^{\circ}$C
before correction to $0.03^{\circ}$C after correction.

The plot of variance spectra (Fig.~\ref{fig:HARCOcorrection2}) shows
that the original spectrum (blue line labeled ``Tm'') is seriously
attenuated at high frequencies relative to the reference measurement
(``RT'') and that both correction procedures restore significant
parts of the missing spectral variance. Despite its inferior representation
of the transfer function, it appears that application of \ref{eq:HARCOsoln}
provides a better match to the reference measurements. It does not
appear possible to restore the missing high-frequency fluctuations
(above about 1 or 2~Hz) because the original measurement is so severely
attenuated at these frequencies. This sensor and the similar heated
Rosemount sensor are therefore unable to detect contributions to sensible-heat
flux from this frequency range, even after corrections. It nevertheless
appears useful to apply one of these correction approaches routinely
to improve the quality of this measurement.

<<HARCOcorrection, include=TRUE, fig.height=3.5, fig.cap=c('Corrected recovery temperature as measured by a heated HARCO sensor ("RTH" and "FFT"), the uncorrected measurement ("Tm"), and the best estimate of the true recovery temperature ("RT") based on an unheated Rosemount sensor after correction. The time is seconds after 2018-02-24 5:59:00 UTC, SOCRATES flight 15. "RTH" is based on the approximate formula (20), while "FFT" results from Fourier transformation after correction using the transfer function determined from (13). Mean values have been subtracted from all to facilitate comparisons.', 'Variance spectra for some measurements of recovery temperature: "RT" (the best estimate resulting from correction of the measurements from the unheated Rosemount 102E4AL); "Tm" (the uncorrected measurement from the heated HARCO); "FFT" (the corrected HARCO measurement based on Fourier transforms); and "RTH" (the corrected HARCO measurement based on the correction formula (17)).')>>=


a <- Param1$a
tau1 <- Param1$tau1
tau2 <- Param1$tau2
## RT is the working solution; Ts is the support temperature
DSX$Ts <- DSX$RTF1
Rate <- attr (DSX, 'Rate')
DSX$DTMDT <- c(0, diff(DSX$RTF1, 2), 0) * Rate / 2
DSX$DTMDT <-  (c(0, 8*diff(DSX$RTF1, 2), 0) - 
              c(0, 0, diff(DSX$RTF1, 4), 0, 0)) * Rate / 12
# DT$DTMDT <- (DT$DTMDT + c(0, DT$DTMDT[1:(nrow(DT)-1)])) / 2
# DT$DTMDT <- as.vector (signal::filter(signal::sgolay(1, 3, m=1),
#             DT$TTRR)) * Rate
fS <- function(y, i) {  # Eq. Ts3
  ((1/a) * (tau1 * DSX$DTMDT[i] + DSX$RTF1[i] - (1-a) * y) - y) / (Rate * tau2)
}

DSX$Ts <- rk4.integrate (fS, DSX$Ts[1], 1:nrow(DSX))
DSX$RT <- (1/a) * (tau1 * DSX$DTMDT + DSX$RTF1 - (1-a) * DSX$Ts)
MRHO <- MachNumber(DSX$PSXC, DSX$QCXC) * DSX$PSXC * 100 /
                  (287.05 * (273.15 + DSX$ATX)) / rhozero
a <- bestSH[1]
tau1 <- bestSH[2] * (MRHO / 0.3) ^ 0.6  ## Note that these are variable
tau2 <- bestSH[3] * (MRHO / 0.3) ^ 0.6
Rate <- attr (DSX, 'Rate')
DSX$DTMDT <- c(0, diff(DSX$RTH1, 2), 0) * Rate / 2
DSX$DTM2DT2 <- (c(diff(DSX$RTH1), 0) - c(0, diff(DSX$RTH1))) * Rate^2
DSX$RTHC <- (tau1 + tau2) * DSX$DTMDT + DSX$RTH1 + tau1 * tau2 * DSX$DTM2DT2
DSX$RTHC <- zoo::na.approx (as.vector(DSX$RTHC), maxgap=1000*Rate,
      na.rm = FALSE, rule = 2)
CutoffPeriod <- 12.5
DSX$RTHC <- signal::filtfilt (signal::butter (3,
      2/CutoffPeriod), DSX$RTHC)
# DSX$RTHC <- SmoothInterp(DSX$RTHC, .Length=25)
DSAP <- DSX
DSAP$RTH1 <- DSAP$RTH1 - mean(DSAP$RTH1[setRange(DSAP, 55700, 60000)], na.rm=TRUE)
DSAP$RTF1P <- DSAP$RTF1 - mean(DSAP$RTF1[setRange(DSAP, 55700, 60000)], na.rm=TRUE)
DSAP$RTHC <- DSAP$RTHC - mean(DSAP$RTHC[setRange(DSAP, 55700, 60000)], na.rm=TRUE)
DSAP$RT <- DSAP$RT - mean(DSAP$RT[setRange(DSAP, 55700, 60000)], na.rm=TRUE)
# DSAP %>% selectTime(55920, 55950) %>% 
#          select(Time, RT, RTH1, RTHC) %>% 
#         ggplotWAC(col=c('blue', 'forestgreen', 'black'), lty=c(1,4,1),
#                   ylab=bquote('recovery temperature [' ~ degree * 'C]'), 
#                   lwd=c(0.8,1,1)) + xlab('time [s]') +
#         theme_WAC(1) + theme(legend.position=c(0.75, 0.9))
DSAX <- DSX %>% selectTime(55700, 60300)
DSAX <- DSAX[1:2^13, ]
ft <- fft(DSAX$RTH1)
N <- length(ft)
Rate <- attr(DSX, 'Rate')
df <- Rate / N
frq <- c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
fr <- log(abs(frq))
Gain  <- cfrHARCO[1] + fr * (cfrHARCO[2] + fr * fr * (cfrHARCO[3] + 
         fr * (cfrHARCO[4] + fr * cfrHARCO[5])))
Gain[abs(frq) < 0.024] <- 1
Phase <- cfHARCO[1] + cfHARCO[2] * fr + cfHARCO[3] * fr^2 +
         cfHARCO[4] * atan(frq)
Phase[frq < 0] <- -Phase[frq < 0]
Phase[1] <- 0
Phase <- Phase * pi / 180
TF <- complex(modulus=Gain, argument=Phase)
tlmt <- 1.8
TF[abs(frq) > tlmt] <- TF[abs(frq) > tlmt] * exp(5*abs(frq[abs(frq) > tlmt]) / tlmt)
ftx <- ft / TF
DSAX$RTFFT <- Re(fft(ftx, inverse = TRUE) / N)
N <- 2^13 
Nby2 <- N / 2
RTH1 <- DSAX$RTH1
ff1 <- fft(RTH1)
RTH <- Re(fft(ff1, inverse=TRUE)) / N
df <- Rate / N
frq <- c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
fr <- log(frq[1:(Nby2+1)])
## Get the transfer function from the fitted parameterized form:
Ph <- cfHARCO[1] + cfHARCO[2] * fr + 
           cfHARCO[3] * fr^2 + cfHARCO[4] * atan(frq[1:(Nby2+1)])
Ph[1] <- 0
G <- cfrHARCO[1] + fr * (cfrHARCO[2] + fr * fr * (cfrHARCO[3] + 
           fr * (cfrHARCO[4] + fr * cfrHARCO[5])))
G[frq[1:length(fr)] < 0.024] <- 1
G[frq[1:length(fr)] > 2] <- G[which.min(abs(frq-2))]
H <- rep(complex(modulus=0), N)
H[1:(Nby2+1)] <- complex(modulus=G, argument=Ph * pi / 180)
H[(Nby2+2):N] <- rev(Conj(H[2:Nby2]))
RTC <- Re(fft(ff1 / H, inverse = TRUE)) / N
DSAX$RTC <- RTC
dfTF <- data.frame(
  'Time' = frq,
  'Amp' = Gain,
  'Phase' = Phase
)
g <-
  ggplotWAC(
    dfTF,
    panels = 2,
    labelP = c('    Amplitude', 'Phase [degrees]')
  )
g <- g + xlab('frequency [Hz]') + ylab(bquote('transfer function H(' * nu ~ ')'))
g <-
  g + scale_x_log10(
    breaks = trans_breaks("log10", function(x)
      10 ^ x, n = 4),
    labels = trans_format("log10", math_format(expr = 10 ^ .x))
  ) + xlab('frequency [Hz]')
g <- g + annotation_logticks(sides = 'tb')
# g + theme_WAC(1) + theme(legend.position = c(0.3, 0.65))
DSAP <- DSAX
DSAP$RTH1 <- DSAP$RTH1 - mean(DSAP$RTH1[setRange(DSAP, 55700, 60000)], na.rm=TRUE)
DSAP$RTF1P <- DSAP$RTF1 - mean(DSAP$RTF1[setRange(DSAP, 55700, 60000)], na.rm=TRUE)
DSAP$RTH <- DSAP$RTHC - mean(DSAP$RTHC[setRange(DSAP, 55700, 60000)], na.rm=TRUE)
DSAP$RT <- DSAP$RT - mean(DSAP$RT[setRange(DSAP, 55700, 60000)], na.rm=TRUE)
DSAP$FFT <- DSAP$RTFFT - mean(DSAP$RTFFT[setRange(DSAP, 55700, 60000)],
                                na.rm=TRUE)
DSAP$Tm <- DSAP$RTH1
DSAP %>% selectTime(55920, 55950) %>% 
         select(Time, RT, Tm, FFT, RTH) %>% 
         ggplotWAC(c('blue', 'forestgreen', 'black', 'darkorange'),
                   ylab=bquote('recovery temperature [' ~ degree * 'C]'),
                   lty=c(1,2,1,1), lwd=c(0.8,1.2,1,0.8)) + xlab('time [s]') +
         theme_WAC(1) + 
         theme(legend.position=c(0.715, 0.93))
g <- DSAP %>% select(Time, TASX, Tm, RTH, RT) %>% 
        VSpec(xlim=c(5.e-3, 15), ylim=c(2.e-6, 1.e-2), 
        smoothBins = 100, method='MEM')
VSpec(DSAP, 'FFT', add=g, type='MEM') + theme_WAC(1)

@

\section{The Digital Filter for Dynamic Heating}

As described in Sect~\eqref{subsec:A-filter-for}, digital filters
for dynamic heating were developed from the transfer functions for
the probes studied in Part 1. The procedure was to use the inverse
Fourier transforms of those transfer functions, which give the impulse
response functions, and then design filters using coefficients determined
from those impulse functions. This appendix describes in more detail
how this was done and includes references to the coefficients that
might be used by others. The filters so obtained appear to function
as desired, although this is an area where further work will be warranted.

The procedures was as follows:
\begin{enumerate}
\item Specify the transfer function for the sensor (e.g., for the unheated
Rosemount 102E4AL sensor or the heated HARCO sensor) as determined
in Part 1.
\item For a large set of frequencies spanning the interval from $-12.5$
to $12.5$~Hz, e.g., with resolution between assumed frequencies
of (1/600)~Hz, evaluate the frequency-dependent transfer function.
This solution is stored in a vector with frequencies in the order
(0 to 12.5~Hz, then $(-12.5+1/600)$ to $-(1/600)$ Hz, as is conventional
for representations of the Fourier transform in R and also many other
languages. It was necessary to calculate the negative-frequency components
and, to obtain real-number results, to store them so that the values
representing negative frequencies are complex conjugates of those
for the corresponding positive frequencies.
\item The inverse Fourier transform then gave the impulse function at 15,000
delays, many of them representing negative delays. The values in the
central part of this array were mostly very small.
\item To obtain a manageable number of moving-average coefficients, all
values in the array representing the impulse function were set to
zero for indices k with values $M+2\leq k\leq N-M$ where $N$ is
the length of the calculated impulse function and $M=100$, which
left 201 non-zero coefficients. These coefficients then spanned 8
s at 25~Hz, a time long compared to the expected impulse response
of the sensor.
\item The upper-100 coefficients represent negative delays in the impulse
response because of the cyclic nature of the Fourier transform, so
the coefficients were re-arranged into a sequence with the last-100
coefficients first and the initial-101 coefficients moved to the end
of the array. These coefficients were then moving-average coefficients
that implement a filter matching the transfer function, except for
the omitted terms outside the 200-coefficient range that are assumed
negligible.
\item The resulting set of moving-average coefficients can then be applied
to the measured dynamic-heating term $Q$ to produce a filtered version.
\item The filtered result then needs to be shifted in time by 4~s to correct
for the offset in the filter.
\end{enumerate}
Additional details, references to filter coefficients, and relevant
R code are included in the ``Workflow'' document.

\section{Pressure-Line Resonance}

\citet{Cooper2016ncartn} showed evidence that the variance spectrum
of the longitudinal component of the wind measured by the NSF/NCAR
GV appears to have excess variance at frequencies above about 2~Hz.
Figure~\ref{fig:Qproblem} shows the problem: Both the airspeed and
the dynamic heating calculated from it have excess variance above
the expected distribution for frequencies above about 2~Hz, although
this is a turbulent region with characteristics otherwise consistent
with an inertial subrange. The lateral components of the wind do not
show this excess variance; it only appears in the longitudinal component.
It is far above the noise expected from the precision of the sensor
used to measure the dynamic pressure (estimated at about 0.1~hPa),
so there must be another source of this contamination of the signal.
A similar but less pronounced effect on a different aircraft was shown
by \citet{nicholls1978measurements} (in his Fig.~2) and was also
discussed by \citet{InverarityJTech2000}. Both references used filtering
of the final temperature measurement to give a reasonable variance
spectrum, but it will be argued here that the effect should be removed
from the dynamic-heating correction instead.

The suggested explanation (by D.~Lenschow, included in \citet{Cooper2016ncartn},
p.~140) is that there is resonance in the lines connecting the pressure
ports to the pressure transducers and effects in those lines cause
either amplification or attenuation of the pressure signals, along
with phase shifts, at various frequencies. On the NSF/NCAR GV dynamic
pressure is measured by a differential pressure transducer that connects
to a pitot-tube and, on the reference side, to the static-pressure
ports. The connecting lines are about 8-m long to the static-pressure
sources and a few meters long to the pitot tube. The extraneous variance
in the pressure lines does not influence the temperature sensor. Therefore,
subtraction of the measured dynamic-heating term from the recovery
temperature to obtain the ambient temperature introduces still more
high-frequency noise into the measurement of air temperature if the
estimate of dynamic heating is contaminated by these line effects.
When correcting for temperature-sensor time response, this additional
source of false variation in the dynamic-heating term should be removed
where possible. This appendix discusses a possible approach to that
removal.

<<Qproblem, include=TRUE, fig.cap='The variance spectrum for the dynamic-heating correction $Q$, from SOCRATES flight 15, 6:00:00 to 6:15:00 UTC, in a region thought to have characteristics of an inertial subrange. The variance spectrum for the airspeed measurement (TASX) is also shown.'>>=


DS15 <- getNetCDF(file.path(DataDirectory(), 'SOCRATES/SOCRATESrf15h.nc'), 
                  standardVariables(c('ATF1', 'PSF', 'QCF')), 55700, 61900)
DS15$Q <- RecoveryFactor(DS15$MACHX, probe = 'UNHEATED') * DS15$TASX^2 / 2010
DS15$TAS <- DS15$TASX  ## needed to get TASX to plot in VSpec 
DS15 %>% selectTime(60000, 61500) %>%
         select(Time, TASX, Q, TAS) %>% 
         VSpec(WACtheme = 1)

@

The argument presented in \citet{Cooper2016ncartn} was that line
resonance in the static pressure line used as a lower-pressure reference
for the dynamic-pressure measurement was responsible. It appears now
that this was not the correct explanation. The reason is that fluctuations
in static pressure normally make a negligible contribution to the
measured fluctuations in dynamic pressure; instead, fluctuations in
dynamic pressure are dominated by fluctua\-tions in the total pressure
delivered by the pitot tube to the differential sensor. Figure~\ref{fig:3Pplot}
shows that the dominant contributions to variance in dynamic pressure,
measured as the difference between the total and static pressure,
comes from the variance in the total pressure present in the shorter
inlet line. Resonances in both lines need to be evaluated, but the
following analysis indicates that the fluctuations in the static-pressure
line do not make any significant contribution to fluctuations in measured
dynamic pressure.

<<3Pplot, include=TRUE, fig.pos='t', fig.cap='Variance spectra for three pressure measurements: the ambient or static pressure ("PS"), the dynamic pressure ("Q"), and their sum ("PT"), the total pressure. The plots for dynamic and total pressure mostly overlap and are indistiguishable in this plot.'>>=

DS15$PTOT <- DS15$PSF + DS15$QCF
D4Here <- DS15
D4Here$PS <- D4Here$PSF
D4Here$Q <- D4Here$QCF
D4Here$PT <- D4Here$PTOT
D4Here %>% selectTime(60000, 61500) %>%
         select(Time, TASX, PS, Q, PT) %>%
         VSpec(ylim=c(1.e-4, 3)) + theme_WAC(1)

@

<<lineTF>>=

library(Bessel)
Rate <- 25
N <- 2^14
df <- Rate / N
frq <- seq(df, Rate / 2, by = df)
# AFFT <- LTphase(frq, ParamSF)
## Lenschow/Iberall calc:
LineTF <- function(frq, pinp = 1013.25, Tinp = 15, Dinp = 3.1e-3, Linp = 8, Vinp = 1.e-6) {
  izero  <- which(frq == 0)
  if (!is.null(izero)) {
    frq[izero] <- 1  ## placeholder
  }
  omega <- 2 * pi * frq
  visc <- (1.718+0.0049*Tinp)*1.e-5    # viscosity, kg/(m s)
  dens <- 100 * pinp / (StandardConstant('Rd') * (Tinp+273.15))  # air density mks
  kvisc <- visc / dens
  gIberall <- sqrt(abs(omega) / (2 * kvisc)) * Dinp / 2
  gIberall <- gIberall * complex(1, 1, -sign(omega)) 
  FIberall <- (1/1.4) * 
    (1 + (2 * 0.4 * BesselI(gIberall, 1)) / (gIberall  * BesselI(gIberall, 0))) *
    (gIberall^2/8) / (2*BesselI(gIberall, 1) / (gIberall * BesselI(gIberall, 0)) - 1)
  F2Iberall <- 1.4 / (1 + 0.4 * 2 * BesselI(gIberall, 1) /
    (gIberall * BesselI(gIberall, 0)))
  xIberall <- 32 * visc * omega / (100 * pinp) * (Linp / Dinp)^2 * FIberall
  psiIberall <- sqrt(complex(1, 0, 1) * xIberall)
  xIIberall <- Vinp / (1.4 * pi * (Dinp/2)^2 * Linp) * xIberall * F2Iberall
  psiIIberall <- complex(1, 0, 1) * xIIberall
  HIberall <- 1 / cosh(psiIberall)
  ## Enhancement for the instrument volume:
  HIberall <- 1 / (cosh(psiIberall) + psiIIberall / psiIberall * sinh(psiIberall))
  if (!is.null(izero)) {
    HIberall[izero] <- complex(1,1,0)
    frq[izero] <- 0
  }
  dIberall <- data.frame(freq = frq, Amp = Mod(HIberall), Phase = -Arg(HIberall) * 180 / pi)
  return(dIberall)
}

@

Lenschow's analysis (based on theoretical predictions of \citet{Iberall1950})
leads to a transfer function representing the effect of the line resonance
on the measurement. This transfer function was plotted in Fig.~52
of \citet{Cooper2016ncartn} and has been recalculated from the equations
in \citet{Iberall1950}, specifically Eqs.~(105) and (106) with (99)
and (95) from that reference and with the volume within the pressure
sensor at the end of the line assumed to be 300~mm$^{3}$ as used
by D\@. Lenschow, for use in the present work. That transfer function
then can be used in the same way as the time-response transfer function
to correct the measured dynamic-heating term by applying the correction
to both lines connected to the dynamic-pressure sensor. The result
should be a better estimate of the dynamic heating at the temperature
sensor because the fluctuations occurring only in the lines and not
affecting the temperature sensor will be removed.

<<correctQresonance, include=TRUE, fig.cap='The variance spectrum that results from correcting the measured static pressure ("PS") for the theoretical effect of line resonance. The corrected pressure is represented here as "PSC". To reduce suspected noise, additional attenuation is applied above 8 Hz to obtain "PSCF".'>>=

Rate <- attr(DS15, 'Rate')
## Correct TASX for the line-resonance effect:
DS15$TASX <- SmoothInterp(DS15$TASX, .Length = 0)
DS15$PTOT <- DS15$PSF + DS15$QCF
DS15$PTOT <- SmoothInterp(DS15$PTOT, .Length = 0)
DS15$PSF <- SmoothInterp(DS15$PSF, .Length = 0)
DS15$QCF <- SmoothInterp(DS15$QCF, .Length = 0)
DS15 <- DS15[1:2^15, ]
f <- fft (DS15$TASX) 
fp <- fft(DS15$PSF)
N <- length(f)
df <- Rate / N
frq <- c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
N2 <- N %/% 2
## Attenuate above 8 Hz:
fAtten <- 8
iatt <- which.min(abs(frq - fAtten))
fpf <- fp
irg <- iatt : (N - iatt)
fpf[irg] <- fpf[irg] * (fAtten / abs(frq[irg]))^10  ## 3.5 looks good!
## Modify the spectrum by the inverse of the response function:
AFFT <- LineTF(frq, mean(DS15$PSF, na.rm=TRUE), mean(DS15$ATX, na.rm=TRUE),
               Dinp = 4e-3, Linp = 9, Vinp = 0.3e-6)
# AFFT <- rbind(data.frame(Time=0, Amp=1, Phase=0), AFFT, rev(AFFT[2:N2, ]))
# AFFT$Phase[(N2+2):N] <- -AFFT$Phase[(N2+2):N]
AFFT$frq <- frq
AFFT$Phase <- AFFT$Phase * pi / 180
HI <- complex (modulus = AFFT$Amp, argument = AFFT$Phase)
f <- f / HI
fp <- fp / HI
fpf <- fpf / HI
AFFTT <- LineTF(frq, mean(DS15$PTOT, na.rm=TRUE), 
                mean(DS15$ATX + DS15$TASX^2 / 2010, na.rm=TRUE),
                Dinp = 3.1e-3, Linp = 4, Vinp = 1.e-5)
HT <- complex (modulus = AFFTT$Amp, argument = AFFTT$Phase)
xn <- Re(fft(f, inverse = TRUE)) / N
xnp <- Re(fft(fp, inverse = TRUE)) / N
xnpf <- Re(fft(fpf, inverse = TRUE)) / N  ## Best estimate of the static pressure
DS15$TASQ <- xn
DS15$PSC <- xnp
DS15$PSCF <- xnpf

fq <- fft(DS15$QCF + DS15$PSF)  ## Best estimate of total pressure in the line
fq <- fq / HT
xnq <- Re(fft(fq, inverse = TRUE)) / N
DS15$PTOTR <- xnq               ## Best estimate of the true total pressure
DS15$QCFR <- xnq - xnpf         ## Best estimate of the true dynamic pressure

DS15$Q <- DS15$TASX^2 / 2010
DS15$QQ <- DS15$TASQ^2 / 2010
DS15$SIM <- rnorm(nrow(DS15), 0, 0.34)
DS15$PS <- DS15$PSF
DS15 %>% selectTime(60000, 61500) %>% 
         select(Time, TASX, PS, PSC, PSCF) %>% 
         VSpec(spans = 99, ylim=c(1.e-5, 1.e-1)) + theme_WAC(1)

# DS15 %>% selectTime(60000, 61500) %>% 
#          select(Time, TASX, Q, QQ) %>% 
#          VSpec(ylim=c(1.e-5, 1.e-1), WACtheme=1)

@

Consider first the effect on static pressure. The predicted transfer
function is based on a theoretical analysis, so it is useful to determine
from observations if the correction based on that transfer function
is reasonable. In a region thought to represent an inertial subrange,
the slope of the variance spectrum of the longitudinal wind (and therefore
of airspeed fluctuations and also the dynamic-heating term) is expected
to exhibit a $-5/3$ slope with frequency or a $-2/3$ slope in the
frequency-weighted spectral-variance plots used here. Measurements
of static pressure from the same region shown in Figs.~\ref{fig:Qproblem}
and \ref{fig:3Pplot} were processed by calculating the Fourier transform
of the pressure, dividing by the transfer function, and using an inverse
Fourier transform to recover the corrected pressure. The result is
shown as ``PSC'' in Fig.~\ref{fig:correctQresonance}, as the green
line (mostly overlapped at low frequency by the black line). The result
seems reasonable for frequencies below about 8~Hz, but there is a
sharp increase above that point. Two possible causes are: (i) The
sensor resolution, thought to be 0.1~hPa from the manufacturer's
specified uncertainty limit, would cause a noise spectrum of about
this magnitude, although with a smaller slope; and (ii) aliasing of
higher-frequency fluctuations may contribute. The digital filters
applied to the measurements don't remove this aliasing because the
fluctuations are real fluctuations in pressure in the pressure lines
and so will still be sampled as aliased. For these reasons, additional
filtering was applied to the Fourier components before inverse transformation
to reduce frequencies above 8~Hz. The result, shown as ``PSFR''
in the figure, is a reasonable adjustment to the original variance
spectrum to account for line resonance for frequencies below 8~Hz,
and evidently excess variance at higher frequency has been removed

This approximate agreement between predictions for the measured static
pressure and the expected shape of the variance spectrum after correction,
for frequency below 8~Hz, provides some support for the theoretical
analysis by greatly improving the appearance of the variance spectrum
for pressure, although the shape is still not ideal. The spectrum
would appear better if the gain of the transfer function around 4~Hz
were approximately 40\% larger so that the variance there would be
reduced by about a factor of 2. Although the distance from the static
source to the pressure transducer is only about 3~m, it appears that
resonance in the branch of this line that continues forward to the
differential transducer affects the signal also at this location.

Analysis of the effect of line resonance on the measurement of dynamic
pressure is more complicated because resonance can occur in both lines,
the line delivering total pressure from the pitot tube and the line
delivering static pressure from the static sources. The measured quantity
at the differential pressure transducer is the difference between
the total-pressure-line resonating pressure and the ambient-pressure-line
resonating pressure, so (using primes to denote quantities in the
resonating lines) $p_{t}^{\prime}=q^{\prime}+p_{s}^{\prime}$ is the
true total pressure in the line from the pitot tube. This can be corrected
using the theoretical transfer function for that line\footnote{Assumed parameters are length 4 m, diameter 3.1 mm, sensor volume
$10^{4}\thinspace\mathrm{mm}^{3}$. These need confirmation and possible
adjustment. They were selected primarily to produce the appropriately
corrected variance spectrum for dynamic heating. The sensor volume
in particular is probably too high.} to obtain the true total pressure at the inlet to the pitot tube,
$p_{t}$. Then the best estimate of the true dynamic pressure $q$
is $q=p_{t}-p_{s}$ where corrected quantities are used for both $p_{t}$
and $p_{s}$, the latter as estimated from ``PSCF'' in Fig.~\ref{fig:correctQresonance}.
The corrected measurement of dynamic pressure, shown as ``QC'' in
Fig.~\ref{fig:QCcorr}, now exhibits a variance spectrum with the
expected high-frequency slope.

<<QCcorr, include=TRUE, fig.cap='Variance spectra for the best estimate for dynamic heating, "QC", after correction for resonance in both lines connected to the differential pressure sensor that produces the original measurement "Q". The corresponding spectrum for the measured pressure in the line connected to the static sources ("PS") is also shown.'>>=

DS15 %>% selectTime(60000, 61500) %>%
         Rmutate(Q = QCF, QC = QCFR, PS = PSF) %>%
         select(Time, TASX, Q, QC, PS) %>%
         VSpec() + theme_WAC(1)

@

This correction greatly improves the variance spectrum for dynamic
pressure by giving a slope consistent with expectations for an inertial
subrange. During this flight segment, other measurements (notably
the vertical wind) indicate $-5/3$ slope, while the uncorrected measurement
departs from that slope significantly for frequencies above about
4~Hz. Using this corrected dynamic pressure produces a longitudinal
component of the wind having a spectrum consistent with the lateral
components. The excess variance present at these frequencies therefore
should also be removed from estimates of dynamic heating based on
dynamic pressure, before the filtering to account for temperature-sensor
response (Sect.~\eqref{subsec:A-filter-for}) is applied, because
the temperature sensor in a separate housing is not affected by the
fluctuations that are removed.

\clearpage{}

\section{Reproducibility}

\index{reproducibility}This document is constructed in ways that
support duplication of the study. The code that generates the plots
and implements the correction procedure is incorporated into the same
\index{program!file}file that generated this document via \LaTeX,
using principles and techniques described by \citet{Xie2014a} as
implemented in the R \index{R language!package!knitr}package\index{knitr}
'knitr' (\citet{Xie2014b}). The program, 'Paper1.Rnw', is archived
on 'GitHub' \index{GitHub repository}in the \index{repository!github}directory\index{archive!for this document}
at \href{https://github.com/WilliamCooper/KalmanFilter.git}{this URL}.
There is some \index{supplemental material}supplemental material
in that directory, including a workflow document\index{workflow document}
for all the papers, the bibliography and some code segments saved
in the ``chunks''\index{R language!program chunks} subdirectory,
so the full directory should be downloaded in order to run the program.
The calculations use the programming \index{R language}language \index{R language!program}\index{RStudio}R
(\citet{Rlanguage}) and were run within \index{RStudio}RStudio (\citet{RStudio2012}),
so this is the most straightforward way to replicate the calculations
and the generation of this \index{program!generating this document}document.

A \index{R language!package!Ranadu}package named Ranadu,\index{R language!package!Ranadu}
containing auxillary \index{function!Ranadu}functions, is used extensively
in the R code. It is available on GitHub\index{GitHub repository}
as \href{https://github.com/WilliamCooper/Ranadu.git}{https://github.com/WilliamCooper/Ranadu.git}.
The version used for calculations in this technical note is included
in the 'zip' archive listed below.

The \index{file!data}data files used are also preserved in the NCAR/EOL
Data Archives and can be obtained via a \index{data!requesting}request
to \url{mailto:raf-dm@eol.ucar.edu} or via the ``Data Access''
links at \href{https://www.eol.ucar.edu/all-field-projects-and-deployments}{this web site}.
The original files containing the data as produced by the NCAR Earth
Observing Laboratory, Research Aviation Facility, were in \index{netCDF format}netCDF
format (cf.~\href{http://www.unidata.ucar.edu/software/netcdf/}{this URL}),
but in many cases data archives were reprocessed and the files may
change after reprocessing so a separate archive\index{archive!for this document!data}
is maintained for this document. The data files\index{file!data!archive}
in this archive contain \index{R language!data.frames}R data.frames
and are preserved as binary-format 'Rdata' files via R 'save' commands.
The code in the GitHub archive has appropriate 'load' commands to
read these data files from a subdirectory named 'Data' (/Data or \textasciitilde /Data
or /home/Data) but this is not part of the GitHub repository because
it is too large to be appropriate there. To reproduce this research,
those data files have to be transferred separately from \{??where??\}

Extensive use has been made of \index{attributes!data.frame}\index{attributes!variable}attributes
assigned to the data.frames and the variables in those data.frames.
All the attributes from the original netCDF \index{file!netCDF}files
have been transferred to the data.frames, so there is a record of
how the original data were processed, for example with \index{calibration!coefficients!used in processing}calibration
coefficients and processing dependence for the variables. Key information
like the processing date, the program version that produced the archive,
and the selection of primary variables for various measurements thus
is preserved.

(See the related list of project components on the next page that
are preserved to enhance reproducibility.)

\clearpage{}

\begin{tabular}{ll}
\textsf{\textsc{\textcolor{blue}{Project:}}} & SensibleHeatFlux\tabularnewline
\textsf{\textsc{\textcolor{blue}{Archive package:}}} & \href{https://github.com/WilliamCooper/SensibleHeatFlux/blob/master/SensibleHeatFluxPaper1.zip}{SensibleHeatFluxPaper1.zip}\tabularnewline
\textsf{\textsc{\textcolor{blue}{Contains:}}} & attachment list below\tabularnewline
\textsf{\textsc{\textcolor{blue}{Program:}}} & \href{https://github.com/WilliamCooper/SensibleHeatFlux/blob/master/Paper1.Rnw}{Paper1.Rnw}\tabularnewline
\textsf{\textsc{\textcolor{blue}{Original Data:}}} & \citet{VOCALS2011}, \tabularnewline
 & \citet{CSET2017},\tabularnewline
 & ,\citet{SOCRATES2019}\tabularnewline
\textsf{\textsc{\textcolor{blue}{Special Data Files:}}} & SensibleHeatFluxTechNote.Rdata, SensibleHeatFluxTechNote2.Rdata\tabularnewline
\textsf{\textsc{\textcolor{blue}{Workflow Document:}}} & \href{https://github.com/WilliamCooper/SensibleHeatFlux/blob/master/WorkflowSensibleHeatFlux.pdf}{WorkflowSensibleHeatFlux.pdf}\tabularnewline
\textsf{\textsc{\textcolor{blue}{Git:}}} & \index{GitHub repository}\href{https://github.com/WilliamCooper/SensibleHeatFlux.git}{https://github.com/WilliamCooper/SensibleHeatFlux.git}\tabularnewline
\end{tabular}

\attachm{Paper1.Rnw\\
Paper1.pdf\\
WorkflowSensibleHeatFlux.pdf\\
WAC.bib\\
chunks/{*}\\
SessionInfo}

\label{sec:bibliography}

\bibliographystyle{plainnat}
\phantomsection\addcontentsline{toc}{section}{\refname}\bibliography{/home/cooperw/RStudio/WAC}

\clearpage{}

% \centerline{-- Blank Page, End of this Technical Report --}
% \vfill\eject
% \clearpage
%\addcontentsline{toc}{section}{End}


\end{document}
