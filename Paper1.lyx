#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\definecolor{fgcolor}{rgb}{0.345, 0.345, 0.345}\definecolor{messagecolor}{rgb}{0, 0, 0}\definecolor{warningcolor}{rgb}{1, 0, 1}\definecolor{errorcolor}{rgb}{1, 0, 0}\setlength{\headheight}{14.5pt}\usepackage{babel}


\definecolor{fgcolor}{rgb}{0.345, 0.345, 0.345}\definecolor{messagecolor}{rgb}{0, 0, 0}\definecolor{warningcolor}{rgb}{1, 0, 1}\definecolor{errorcolor}{rgb}{1, 0, 0}\usepackage{babel}
% macro for italic page numbers in the index
\newcommand{\IndexDef}[1]{\textit{#1}}
\newcommand{\IndexPrimary}[1]{\textbf{#1}}
% force a page break at the start of sections
\let\stdsection\section
\renewcommand{\section}{\newpage\stdsection}


% workaround for a makeindex bug,
% see sec. "Index Entry Order"
% only uncomment this when you are using makindex
%\let\OrgIndex\index 
%\renewcommand*{\index}[1]{\OrgIndex{#1}}
%\usepackage{splitidx}

% workaround for a makeindex bug,
% see sec. "Index Entry Order"
% only uncomment this when you are using makindex
\let\OrgIndex\index 
\renewcommand*{\index}[1]{\OrgIndex{#1}}
\usepackage{splitidx}
%\indexsetup{noclearpage}
\AtBeginDocument{
  \def\labelitemii{\(\circ\)}
  \def\labelitemiii{\(\triangleright\)}
}
\usepackage[font={normal,sl}]{caption}% set captions slanted

\IfFileExists{upquote.sty}{\usepackage{upquote}}{}

\newenvironment{lylist}[1]{\begin{list}{}
{\settowidth{\labelwidth}{#1}
\setlength{\leftmargin}{\labelwidth}
\addtolength{\leftmargin}{\labelsep}
\renewcommand{\makelabel}[1]{##1\hfil}}}{\end{list}}
\newcommand{\datetoday}{\number\day\space
     \ifcase\month\or January\or February\or March\or April\or May\or
     June\or July\or August\or September\or October\or November\or
     December\fi
     \space\number\year}
\newcommand{\EOLmemo}{\null \vskip-1.5truein
{\raggedright \textsf{\textsc{\large \textcolor{blue}{Earth Observing Laboratory}}}}\par
{\raggedright \textsf{\textsl{\textcolor{blue}{Memorandum:}}}} \par \vskip6pt
{\color{blue}{\hrule}}\par
\vskip0.3truein \leftline{\hskip \longindent \datetoday} \vskip0.2truein
\thispagestyle{empty}}
\newcommand{\attachm}[1]{\begin{lylist}{Attachments:00}
\item [Attachments:] {#1}
\end{lylist}}
\newcommand{\cc}[1]{\begin{lylist}{Attachments:00}
\item [cc:] {#1}
\end{lylist}}
\newcommand{\attach}[1]{\begin{lylist}{Attachments:00}
\item [Attachment:] {#1}
\end{lylist}}

\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\pagenumbering{gobble}
%\usepackage{xcolor}
%\providecolor{lyxadded}{rgb}{0,0,1}
%\providecolor{lyxdeleted}{rgb}{1,0,0}
%% Change tracking with ulem
%\DeclareRobustCommand{\lyxadded}[3]{{\color{lyxadded}{}#3}}
%\DeclareRobustCommand{\lyxdeleted}[3]{{\color{lyxdeleted}\sout{#3}}}
\end_preamble
\options 12pt,twoside,american
\use_default_options false
\begin_modules
knitr
hanging
\end_modules
\maintain_unincluded_children false
\language american
\language_package babel
\inputencoding default
\fontencoding global
\font_roman "times" "default"
\font_sans "helvet" "default"
\font_typewriter "lmtt" "default"
\font_math "auto" "auto"
\font_default_family rmdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format pdf2
\output_sync 0
\bibtex_command bibtex
\index_command makeindex
\paperfontsize 11
\spacing single
\use_hyperref true
\pdf_title "The Delayed Response of Airborne Thermometers, Part 1"
\pdf_author "William A. Cooper"
\pdf_subject "Assessment of Measurements of Sensible-Heat Flux"
\pdf_keywords "sensible heat flux, temperature, time response of sensors, NCAR Research Aviation Facility, research aircraft, NCAR/EOL/RAF"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref section
\pdf_pdfusetitle false
\pdf_quoted_options " linkcolor=blue, citecolor={blue}"
\papersize letterpaper
\use_geometry true
\use_package amsmath 2
\use_package amssymb 0
\use_package cancel 0
\use_package esint 2
\use_package mathdots 0
\use_package mathtools 0
\use_package mhchem 0
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine natbib
\cite_engine_type authoryear
\biblio_style plainnat
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 0
\use_minted 0
\backgroundcolor #ffffff
\boxbgcolor #f7f7f7
\branch Extra
\selected 0
\filename_suffix 0
\color #faf0e6
\end_branch
\index Index
\shortcut idx
\color #008000
\end_index
\index Variable Names and Acronyms
\shortcut var
\color #00aaff
\end_index
\index List of Symbols
\shortcut lis
\color #ff0000
\end_index
\leftmargin 1.2in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 2
\paragraph_separation skip
\defskip medskip
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
The Delayed Response of Airborne Thermometers:
\begin_inset Newline newline
\end_inset

Part 1: Determining the Transfer Function
\end_layout

\begin_layout Author
William A.
 Cooper and others...
\end_layout

\begin_layout Date

\color red
DRAFT
\color inherit
 April 2020
\end_layout

\begin_layout Standard
National Center for Atmospheric Research
\begin_inset Newline newline
\end_inset

Earth Observing Laboratory
\begin_inset Newline newline
\end_inset

Research Aviation Facility
\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\begin_inset Newpage cleardoublepage
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{roman}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
contentsname}{Table of Contents} 
\end_layout

\end_inset


\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset

 
\begin_inset VSpace vfill
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
eject
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%% LyX 2.2.2 created this file.
  For more info, see http://www.lyx.org/.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\backslash
phantomsection 
\backslash
addcontentsline{toc}{section}{List of Figures}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
clearpage %
\backslash
phantomsection 
\backslash
addcontentsline{toc}{section}{List of Tables}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList table

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
abstractname}{Preface and Abstract}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{plain}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{abstract}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This is Part 1 of a three-part series addressing errors that are present
 in most archived measurements of temperature made from research aircraft.
 In this first part, the time response of standard airborne thermometers
 is quantified by determining the transfer function where the known input
 is turbulent dynamic heating.
 Differential equations for the response are proposed, and it is verified
 that the solutions to those differential equations provide good representations
 of the response characteristics in terms of fitted empirical coefficients.
 Those solutions then can be used to correct the measurements to compensate
 in part for the response characteristics of the sensors.
 Part 2 will use these results to demonstrate that standard data processing
 used by most operators of research aircraft introduces errors that arise
 from incorrect adjustment for dynamic heating.
 Part 3 will use the results from the first two papers to assess how these
 errors affect measurements of the flux of sensible heat and will propose
 and evaluate a method for correcting those measurements that removes a
 significant error in that measured flux.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{abstract}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Section*
Acknowledgements
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:acknowledgements"

\end_inset


\end_layout

\begin_layout Standard
This material is based upon work supported by the National Center for Atmospheri
c Research, which is a major facility sponsored by the National Science
 Foundation under Cooperative Agreement No.
 1852977.
 Any opinions, findings and conclusions or recom-mendations expressed in
 this publication are those of the author(s) and do not necessarily reflect
 the views of the National Science Foundation.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
The data used in the examples presented are from the VOCALS (VAMOS Ocean-Cloud-A
tmosphere-Land Study), SOCRATES (Southern Ocean Clouds, Radiation, Aerosol
 Transport Experimental Study) and the CSET (Cloud Systems Evolution in
 the Trades) experiments, 
\begin_inset Note Note
status open

\begin_layout Plain Layout
WE-CAN (Western wildfire Experiment for Cloud chemistry, Aerosol absorption
 and Nitrogen) projects,
\end_layout

\end_inset

each described at 
\begin_inset CommandInset href
LatexCommand href
name "this URL"
target "https://www.eol.ucar.edu/field_projects/"
literal "false"

\end_inset

.
 Citations for the data sets are included in the references.
\end_layout

\end_inset

Measurements used here (
\begin_inset CommandInset citation
LatexCommand citet
key "VOCALS2011"
literal "false"

\end_inset

, 
\begin_inset CommandInset citation
LatexCommand citet
key "SOCRATES2019"
literal "false"

\end_inset

, 
\begin_inset CommandInset citation
LatexCommand citet
key "WECAN2018"
literal "false"

\end_inset

) were collected in research projects (
\begin_inset CommandInset citation
LatexCommand citet
key "wood2011vamos"
literal "false"

\end_inset

, 
\begin_inset CommandInset citation
LatexCommand citet
key "albrecht2019cloud"
literal "false"

\end_inset

, 
\begin_inset CommandInset citation
LatexCommand citet
key "mcfarquhar2014southern"
literal "false"

\end_inset

) that used the NSF/NCAR research aircraft.
 Project descriptions and additional information can be found at 
\begin_inset CommandInset href
LatexCommand href
name "this URL"
target "https://www.eol.ucar.edu/field_projects/"
literal "false"

\end_inset

.
 The referenced project teams conducted the experiments, with flight operations,
 data acquisition and processing, and other project support by the Research
 Aviation Facility, Earth Observing Laboratory, National Center for Atmospheric
 Research (NCAR).
 The analyses reported here were mostly performed using R (
\begin_inset CommandInset citation
LatexCommand citet
key "Rlanguage"
literal "true"

\end_inset

), with 
\begin_inset Index idx
status open

\begin_layout Plain Layout
RStudio
\end_layout

\end_inset

RStudio (
\begin_inset CommandInset citation
LatexCommand citet
key "RStudio2012"
literal "true"

\end_inset

) and 
\begin_inset Index idx
status open

\begin_layout Plain Layout
knitr
\end_layout

\end_inset

knitr (
\begin_inset CommandInset citation
LatexCommand citet
key "Xie2014a,Xie2014b"
literal "true"

\end_inset

).
 Data files in netCDF format have been read and written using the R 
\begin_inset Index idx
status open

\begin_layout Plain Layout
R language!package!ncdf4
\end_layout

\end_inset

package 
\begin_inset Quotes eld
\end_inset

ncdf4
\begin_inset Quotes erd
\end_inset

; cf.
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citet
key "ncdf4"
literal "true"

\end_inset

.
 Substantial use also was made of the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
ggplot2
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
R language!package!ggplot2
\end_layout

\end_inset


\begin_inset Quotes eld
\end_inset

ggplot2
\begin_inset Quotes erd
\end_inset

 package (
\begin_inset CommandInset citation
LatexCommand citet
key "wickham2009"
literal "true"

\end_inset

) for R, and extensive use was made of the 
\begin_inset Quotes eld
\end_inset

stats
\begin_inset Quotes erd
\end_inset

 package, part of Core R\SpecialChar endofsentence
 Some of the numerical integrations used the Runge-Kutta
 function from the 
\begin_inset Quotes eld
\end_inset

rmutil
\begin_inset Quotes erd
\end_inset

 package (
\begin_inset CommandInset citation
LatexCommand citet
key "runge.kutta"
literal "false"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{plain}
\end_layout

\end_inset


\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{arabic}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Research aircraft routinely measure the air temperature, but the standard
 sensors do not respond fast enough to meet many scientific needs.
 In particular, measurements of the flux of sensible heat need faster response
 than is typically available, as do measurements of near-discontinuous changes
 such as those at the top of boundary layers or at cloud boundaries.
 The measurement of sensible-heat flux requires, for the standard eddy-correlati
on measurement, that temperature be measured with sufficient response to
 resolve the spectrum of contributions to the flux.
 Various recent reviews of priorities for research in atmospheric science
 have called attention to the important roles that fluxes of various quantities
 play in climate science and have advocated increased focus on those fluxes;
 e.g., 
\begin_inset CommandInset citation
LatexCommand citet
key "NAP6021"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
The basis for the measurement of the flux of sensible heat (
\begin_inset Formula $F_{s})$
\end_inset

 by eddy correlation is this equation:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
F_{s}=\rho_{a}\thinspace C_{p}\left\langle w^{\prime}T^{\prime}\right\rangle \label{eq:heatFlux}
\end{equation}

\end_inset

where 
\begin_inset Formula $\rho_{a}$
\end_inset

 is the density of air, 
\begin_inset Formula $C_{p}$
\end_inset

 the specific heat of air at constant pressure, 
\begin_inset Formula $w$
\end_inset

 the vertical wind, and 
\begin_inset Formula $T$
\end_inset

 the temperature.
 Primes in this equation denote fluctuations from the mean and angle brackets
 denote an ensemble average.
 The measurement thus depends on having a temperature sensor that can respond
 to the range of fluctuations making significant contributions to the heat
 flux.
 
\begin_inset CommandInset citation
LatexCommand citet
key "FrieheKhelif1992"
literal "false"

\end_inset

 suggested
\begin_inset Note Note
status open

\begin_layout Plain Layout
, without demonstration,
\end_layout

\end_inset

 that 4–5
\begin_inset space ~
\end_inset

Hz is 
\begin_inset Quotes eld
\end_inset

just adequate
\begin_inset Quotes erd
\end_inset

 (for flight at around 125
\begin_inset space ~
\end_inset

m/s) and that 25
\begin_inset space ~
\end_inset

Hz would be desirable to resolve some interesting aspects of the temperature
 structure.
 If the response of the temperature sensor is reduced or shifted in phase
 at a particular frequency, an error will be introduced into the measurement
 of sensible-heat flux.
 
\begin_inset CommandInset citation
LatexCommand citet
key "LawsonRodi1992"
literal "false"

\end_inset

 argued that sensible-heat flux measured by some of the fastest sensors
 then in common use produced measurements of sensible heat flux about 21%
 too low compared to the measurements from their faster thermocouple-based
 sensor.
 To avoid significant errors in this measurement, it therefore is essential
 to characterize the time response of the temperature sensor used and, where
 necessary, to apply corrections to compensate for that response.
\end_layout

\begin_layout Standard
In this first paper, the time response of some standard airborne temperature
 sensors is characterized in terms of a transfer function that relates the
 measurand (the recovery temperature) to the measurement (the sensor output)
 in ways that are invertible.
 Two coupled differential equations are used as the basis for this characterizat
ion, but the transfer function is determined independent of those equations.
 Because the equations predict a transfer function matching the observations,
 they provide a useful generalization when the measurements are fitted to
 a three-parameter equation consistent with those equations.
 The measured transfer functions for standard airborne thermometers then
 are used in the papers that follow to access how common measurements are
 affected.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<initialization, echo=FALSE,include=FALSE>>=
\end_layout

\begin_layout Plain Layout

## This chunk loads some needed R packages and defines a function
\end_layout

\begin_layout Plain Layout

## used for the Laplace-transform solution of the governing
\end_layout

\begin_layout Plain Layout

## differential equations.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

library(knitr)
\end_layout

\begin_layout Plain Layout

opts_chunk$set(echo = FALSE,
\end_layout

\begin_layout Plain Layout

               include = FALSE,
\end_layout

\begin_layout Plain Layout

               fig.lp = "fig:")
\end_layout

\begin_layout Plain Layout

# note that fig.pos="center" gave errors, changed to fig.align
\end_layout

\begin_layout Plain Layout

opts_chunk$set(
\end_layout

\begin_layout Plain Layout

  fig.width = 6,
\end_layout

\begin_layout Plain Layout

  fig.height = 3.5,
\end_layout

\begin_layout Plain Layout

  fig.align = "center",
\end_layout

\begin_layout Plain Layout

  digits = 4
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

thisFileName <- "SensibleHeatFluxTechNote"
\end_layout

\begin_layout Plain Layout

library(Ranadu, quietly = TRUE, warn.conflicts = FALSE)
\end_layout

\begin_layout Plain Layout

library(scales)
\end_layout

\begin_layout Plain Layout

require(numDeriv)    ## is this used?
\end_layout

\begin_layout Plain Layout

library(signal)      ## used for filtering
\end_layout

\begin_layout Plain Layout

library(reshape2)    ## used with ggplot facet plots
\end_layout

\begin_layout Plain Layout

library(grid)
\end_layout

\begin_layout Plain Layout

library(magrittr)    ## used for pipes (%>%)
\end_layout

\begin_layout Plain Layout

library(dplyr)
\end_layout

\begin_layout Plain Layout

library(nleqslv)
\end_layout

\begin_layout Plain Layout

library(rmutil)      ## provides the runge-kutta integration function
\end_layout

\begin_layout Plain Layout

options(stringsAsFactors = FALSE)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

CACHE <- FALSE
\end_layout

\begin_layout Plain Layout

setwd ('~/RStudio/SensibleHeatFlux') 
\end_layout

\begin_layout Plain Layout

Directory <- DataDirectory ()
\end_layout

\begin_layout Plain Layout

## standard values:
\end_layout

\begin_layout Plain Layout

frq <- seq(0.01, 25, by = 0.01)
\end_layout

\begin_layout Plain Layout

Phi <- rep(0, length(frq))
\end_layout

\begin_layout Plain Layout

H <- rep(0, length(frq))
\end_layout

\begin_layout Plain Layout

a <- 0.733 # 0.713
\end_layout

\begin_layout Plain Layout

tau1 <- 0.0308  # 0.0335
\end_layout

\begin_layout Plain Layout

tau2 <- 0.447
\end_layout

\begin_layout Plain Layout

# The Laplace-transform solution:
\end_layout

\begin_layout Plain Layout

LTphase <- function(f, P) {
\end_layout

\begin_layout Plain Layout

  ## f=frequency; P=Param
\end_layout

\begin_layout Plain Layout

  tau1 <- P$tau1
\end_layout

\begin_layout Plain Layout

  tau2 <- P$tau2
\end_layout

\begin_layout Plain Layout

  a <- P$a
\end_layout

\begin_layout Plain Layout

  b <- sqrt(1 / (1 + (2 * pi * f * tau2) ^ 2))
\end_layout

\begin_layout Plain Layout

  zeta <- -atan(2 * pi * f * tau2)
\end_layout

\begin_layout Plain Layout

  C1 <- 1 / (1 + 4 * pi ^ 2 * f ^ 2 * tau1 ^ 2) *
\end_layout

\begin_layout Plain Layout

    (-(a + (1 - a) * b * cos(zeta)) * 2 * pi * f * tau1 +
\end_layout

\begin_layout Plain Layout

       (1 - a) * b * sin(zeta))
\end_layout

\begin_layout Plain Layout

  C2 <- 1 / (1 + 4 * pi ^ 2 * f ^ 2 * tau1 ^ 2) *
\end_layout

\begin_layout Plain Layout

    ((a + (1 - a) * b * cos(zeta)) +
\end_layout

\begin_layout Plain Layout

       (1 - a) * b * sin(zeta) * 2 * pi * f * tau1)
\end_layout

\begin_layout Plain Layout

  cTF <- sqrt(C1 ^ 2 + C2 ^ 2)
\end_layout

\begin_layout Plain Layout

  phiTF <- atan2(C1, C2) * 180 / pi
\end_layout

\begin_layout Plain Layout

  return(list('Amp' = cTF, 'Phase' = phiTF))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<rk4Integration, include = FALSE, echo = FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## rk4.integrate
\end_layout

\begin_layout Plain Layout

## [Do entire integration in one call instead, as for runge.kutta]
\end_layout

\begin_layout Plain Layout

## [i.e., function (ya, dydt, tv, tol=0.005) and return entire vector]
\end_layout

\begin_layout Plain Layout

rk4.integrate <- function (dydt, ystart, tv, tol = 0.005) {
\end_layout

\begin_layout Plain Layout

  ## Try the full step and accept if error estimate is < tol;
\end_layout

\begin_layout Plain Layout

  ## otherwise calculate the number of steps that will give the desired
\end_layout

\begin_layout Plain Layout

  ## tolerance and divide the step into that number of smaller steps.
\end_layout

\begin_layout Plain Layout

  L <- length(tv)
\end_layout

\begin_layout Plain Layout

  yr <- rep(ystart, L)
\end_layout

\begin_layout Plain Layout

  y <- ystart
\end_layout

\begin_layout Plain Layout

  dt <- 1
\end_layout

\begin_layout Plain Layout

  for (it in 2:L) {
\end_layout

\begin_layout Plain Layout

    dt <- tv[it] - tv[it - 1]
\end_layout

\begin_layout Plain Layout

    t <- tv[it - 1]
\end_layout

\begin_layout Plain Layout

    RK4 <- rk4.step(y, t, dt, dydt)
\end_layout

\begin_layout Plain Layout

    # print (sprintf ('rk4 return for y=%.2f and t=%.1f is %.2f with error
 estimate %.3f',
\end_layout

\begin_layout Plain Layout

    #                 y1, t, RK4[[1]], RK4[[2]]))
\end_layout

\begin_layout Plain Layout

    if (abs(RK4[[2]]) <= tol) {
\end_layout

\begin_layout Plain Layout

      yr[it] <- y <- RK4[[1]]
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      N <- as.integer (1.1 * (abs(RK4[[2]]) / tol) ^ 0.3 + 1)
\end_layout

\begin_layout Plain Layout

      # print (sprintf ('error estimate is %.3f so using %d steps', RK4[[2]],
 N))
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

      for (n in 1:N) {
\end_layout

\begin_layout Plain Layout

        A <- rk4.step(y, t, dt / N, dydt)
\end_layout

\begin_layout Plain Layout

        y <- A[[1]]
\end_layout

\begin_layout Plain Layout

        if (abs(A[[2]]) > tol) {
\end_layout

\begin_layout Plain Layout

          # print (sprintf ('Warning: error estimate still too large, t=%.2f,
 y=%.2f, err=%.2f', t, y, A[[2]]))
\end_layout

\begin_layout Plain Layout

          # Try further reduced step size
\end_layout

\begin_layout Plain Layout

          M <- as.integer (1.1 * (abs(A[[2]]) / tol) ^ 0.3 + 1)
\end_layout

\begin_layout Plain Layout

          for (m in 1:M) {
\end_layout

\begin_layout Plain Layout

            y <- rk4.step(y, t, dt / (N * M), dydt)[[1]]
\end_layout

\begin_layout Plain Layout

            t <- t + dt / (N * M)
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        } else {
\end_layout

\begin_layout Plain Layout

          t <- t + dt / N
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      yr[it] <- y
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return(yr)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

## These are the coefficients used by the Runge-Kutta Cash-Karp integration:
\end_layout

\begin_layout Plain Layout

RKD <- data.frame(
\end_layout

\begin_layout Plain Layout

  a2 = 0.2,
\end_layout

\begin_layout Plain Layout

  a3 = 0.3,
\end_layout

\begin_layout Plain Layout

  a4 = 0.6,
\end_layout

\begin_layout Plain Layout

  a5 = 1,
\end_layout

\begin_layout Plain Layout

  a6 = 0.875,
\end_layout

\begin_layout Plain Layout

  b21 = 0.2,
\end_layout

\begin_layout Plain Layout

  b31 = 3 / 40,
\end_layout

\begin_layout Plain Layout

  b32 = 9 / 40,
\end_layout

\begin_layout Plain Layout

  b41 = 0.3,
\end_layout

\begin_layout Plain Layout

  b42 = -0.9,
\end_layout

\begin_layout Plain Layout

  b43 = 1.2,
\end_layout

\begin_layout Plain Layout

  b51 = -11 / 54,
\end_layout

\begin_layout Plain Layout

  b52 = 2.5,
\end_layout

\begin_layout Plain Layout

  b53 = -70 / 27,
\end_layout

\begin_layout Plain Layout

  b54 = 35 / 27,
\end_layout

\begin_layout Plain Layout

  b61 = 1631 / 55296,
\end_layout

\begin_layout Plain Layout

  b62 = 175 / 512,
\end_layout

\begin_layout Plain Layout

  b63 = 575 / 13824,
\end_layout

\begin_layout Plain Layout

  b64 = 44275 / 110592,
\end_layout

\begin_layout Plain Layout

  b65 = 253 / 4096,
\end_layout

\begin_layout Plain Layout

  c1 = 37 / 378,
\end_layout

\begin_layout Plain Layout

  c3 = 250 / 621,
\end_layout

\begin_layout Plain Layout

  c4 = 125 / 594,
\end_layout

\begin_layout Plain Layout

  c6 = 512 / 1771
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

RKD <-
\end_layout

\begin_layout Plain Layout

  cbind(
\end_layout

\begin_layout Plain Layout

    RKD,
\end_layout

\begin_layout Plain Layout

    data.frame(
\end_layout

\begin_layout Plain Layout

      dc1 = RKD$c1 - 2825 / 27648,
\end_layout

\begin_layout Plain Layout

      dc3 = RKD$c3 - 18575 / 48384,
\end_layout

\begin_layout Plain Layout

      dc4 = RKD$c4 - 13525 / 55296,
\end_layout

\begin_layout Plain Layout

      dc5 = -277 / 14336,
\end_layout

\begin_layout Plain Layout

      dc6 = RKD$c6 - 0.25
\end_layout

\begin_layout Plain Layout

    )
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

## Save this in a special environment that rk4.step() can access:
\end_layout

\begin_layout Plain Layout

if (!exists('RKCKEnv', envir = emptyenv())) {
\end_layout

\begin_layout Plain Layout

  # define if absent
\end_layout

\begin_layout Plain Layout

  assign('RKCKEnv', new.env(parent = emptyenv()), envir = globalenv())
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

RKCKEnv$RKD <- RKD
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

rk4.step <- function (y1, t, dt, dydt) {
\end_layout

\begin_layout Plain Layout

  RKD <- RKCKEnv$RKD
\end_layout

\begin_layout Plain Layout

  dydt1 <- dydt(y1, t)
\end_layout

\begin_layout Plain Layout

  trial2 <- dydt(y1 + dt * RKD$b21 * dydt1, t + RKD$a2 * dt)
\end_layout

\begin_layout Plain Layout

  trial3 <- dydt(y1 + dt *
\end_layout

\begin_layout Plain Layout

                   (RKD$b31 * dydt1 + RKD$b32 * trial2), t + RKD$a3 * dt)
\end_layout

\begin_layout Plain Layout

  trial4 <- dydt(y1 + dt *
\end_layout

\begin_layout Plain Layout

                   (RKD$b41 * dydt1 + RKD$b42 * trial2 + RKD$b43 * trial3),
\end_layout

\begin_layout Plain Layout

                 t + RKD$a4 * dt)
\end_layout

\begin_layout Plain Layout

  trial5 <- dydt(
\end_layout

\begin_layout Plain Layout

    y1 + dt *
\end_layout

\begin_layout Plain Layout

      (
\end_layout

\begin_layout Plain Layout

        RKD$b51 * dydt1 + RKD$b52 * trial2 + RKD$b53 * trial3 +
\end_layout

\begin_layout Plain Layout

          RKD$b54 * trial4
\end_layout

\begin_layout Plain Layout

      ),
\end_layout

\begin_layout Plain Layout

    t + RKD$a5 * dt
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

  trial6 <- dydt(
\end_layout

\begin_layout Plain Layout

    y1 + dt *
\end_layout

\begin_layout Plain Layout

      (
\end_layout

\begin_layout Plain Layout

        RKD$b61 * dydt1 + RKD$b62 * trial2 + RKD$b63 * trial3 +
\end_layout

\begin_layout Plain Layout

          RKD$b64 * trial4 + RKD$b65 * trial5
\end_layout

\begin_layout Plain Layout

      ),
\end_layout

\begin_layout Plain Layout

    t + RKD$a6 * dt
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

  yn <- y1 + dt *
\end_layout

\begin_layout Plain Layout

    (RKD$c1 * dydt1 + RKD$c3 * trial3 + RKD$c4 * trial4 + RKD$c6 * trial6)
\end_layout

\begin_layout Plain Layout

  err <-
\end_layout

\begin_layout Plain Layout

    dt * (RKD$dc1 * dydt1 + RKD$dc3 * trial3 + RKD$dc4 * trial4 +
\end_layout

\begin_layout Plain Layout

            RKD$dc5 * trial5 + RKD$dc6 * trial6)
\end_layout

\begin_layout Plain Layout

  # print (sprintf ('rkck.integrate return is %.5f for input y=%.5f and t=%.2f',
 yn, y, t))
\end_layout

\begin_layout Plain Layout

  return(list(yn, err))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Section
Theory
\end_layout

\begin_layout Standard
The errors considered here apply to the measurement from the sensor, the
 
\begin_inset Quotes eld
\end_inset

recovery temperature,
\begin_inset Quotes erd
\end_inset

 rather than the final temperature after correction for dynamic heating.
 Because the sensor cannot respond to rapid fluctuations, the standard correctio
n for dynamic heating introduces errors into the measured air temperature
 that are then amplified by a correction procedure.
 This will be addressed in Part 2, but for this reason the present paper
 will discuss only the recovery temperature.
\end_layout

\begin_layout Standard
\begin_inset CommandInset citation
LatexCommand citet
key "PayneEtAl1994"
literal "false"

\end_inset

 provided a particularly illuminating analysis of the expected response
 of a temperature sensor and developed their results in terms of a transfer
 function.
 They represent the response of the sensor in terms of two coupled differential
 equations, one representing the temperature of the sensing wire and a second
 representing the temperature of the structure that supports that wire.
 Their analysis in terms of fundamental representation of the heat transport
 leads to reasonable consistency with previous two-time-constant models
 like that of 
\begin_inset CommandInset citation
LatexCommand citet
key "mccarthy1973method"
literal "false"

\end_inset

 but poor agreement with the empirical evidence regarding the time-response
 parameters in those models.
 They note, however, that the empirical evidence is not as consistent or
 convincing as would be desirable.
 One goal of the present work is to develop a different and readily available
 method of determining those parameters.
 The over-arching goal is to be able to assess errors that might be present
 in measurements of the flux of sensible heat and to apply corrections for
 those errors.
 This will be the subject of Part 3.
\end_layout

\begin_layout Subsection
The differential equations and their solution
\end_layout

\begin_layout Standard
Previous studies have demonstrated that a simple first-order exponential
 equation with one time constant does not represent the time response of
 airborne temperature sensors.
 The suggested explanation (
\begin_inset CommandInset citation
LatexCommand citet
key "NCAR_OpenSky_TECH-NOTE-000-000-000-064"
literal "false"

\end_inset

 is that heat is transferred to the sensing wire of standard sensors not
 only from the air but also from the supporting structure that is in contact
 with the wire.
 Friehe and Khelif (
\begin_inset CommandInset citation
LatexCommand citet
key "FrieheKhelif1992"
literal "false"

\end_inset

), following other prior work including that of 
\begin_inset CommandInset citation
LatexCommand citet
key "rodi1972analysis"
literal "false"

\end_inset

 and 
\begin_inset CommandInset citation
LatexCommand citet
key "mccarthy1973method"
literal "false"

\end_inset

, suggested representing the two-time-constant response via the following
 functional form:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\Theta(t)=A_{1}e^{-t/\tau_{1}}+A_{2}e^{-t/\tau_{2}}\label{eq:FrieheKehlif}
\end{equation}

\end_inset

where 
\begin_inset Formula $\Theta(t)$
\end_inset

 is the normalized history of the measured temperature decaying from an
 initial value of unity to a final value of zero.
 The sum of the coefficients 
\begin_inset Formula $A_{1}$
\end_inset

 and 
\begin_inset Formula $A_{2}$
\end_inset

 must then be 1.
 The values for {
\begin_inset Formula $A_{1},\,A_{2},\,\tau_{1},\,\tau_{2}$
\end_inset

} suggested by 
\begin_inset CommandInset citation
LatexCommand citet
key "FrieheKhelif1992"
literal "false"

\end_inset

 were {0.65, 0.35, 0.09
\begin_inset space ~
\end_inset

s, 0.5
\begin_inset space ~
\end_inset

s}.
\end_layout

\begin_layout Standard
Following the approach of 
\begin_inset CommandInset citation
LatexCommand citet
key "PayneEtAl1994"
literal "false"

\end_inset

, the time response of the sensor will be represented by two coupled differentia
l equations, one that describes the response of the support on which the
 sensing wire is wound to the air temperature and a second that describes
 the response of the sensing wire to two inputs, one from the support and
 one from the air.
 No attempt is made here to determine the parameters from first principles
 as in 
\begin_inset CommandInset citation
LatexCommand citet
key "PayneEtAl1994"
literal "false"

\end_inset

, however; instead, parameters entering the equations are determined empirically.
 The equations are:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\frac{dT_{s}(t)}{dt}=\frac{T_{r}(t)-T_{s}(t)}{\tau_{2}}\label{eq:Ts}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{align}
\frac{dT_{m}(t)}{dt} & =\frac{a(T_{r}(t)-T_{m}(t))+(1-a)(T_{s}(t)-T_{m}(t))}{\tau_{1}}\label{eq:Tm}\\
= & \frac{\left\{ aT_{r}(t)+(1-a)T_{s}(t)\right\} -T_{m}(t)}{\tau_{1}}\nonumber 
\end{align}

\end_inset

where 
\begin_inset Formula $T_{s}(t)$
\end_inset

 is the temperature of the 
\bar under
s
\bar default
upport, 
\begin_inset Formula $T_{m}(t)$
\end_inset

 the 
\bar under
m
\bar default
easured temperature of the sensing wire, and 
\begin_inset Formula $T_{r}(t)$
\end_inset

 the true 
\bar under
r
\bar default
ecovery temperature that is the measurand.
 For heat transfer to or from the wire, the parameter 
\begin_inset Formula $a$
\end_inset

 then represents the fraction of the heat transferred by the air, while
 
\begin_inset Formula $(1-a)$
\end_inset

 is transferred to or from the support.
 The wire responds to the combined transfers of heat with characteristic
 time constant 
\begin_inset Formula $\tau_{1}$
\end_inset

 while the support structure responds to the air temperature more slowly,
 with time constant 
\begin_inset Formula $\tau_{2}$
\end_inset

.
 It is straightforward to apply 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to changing but not necessarily discrete conditions, so a general response
 to a given air-temperature history can be predicted by numerical integration
 of these equations.
 Furthermore, the equations are linear and, for constant values of the parameter
s, they are also time-invariant (i.e., 
\begin_inset Quotes eld
\end_inset

LTI
\begin_inset Quotes erd
\end_inset

) descriptions of the response.
 As a result, a particular signal for 
\begin_inset Formula $T_{r}(t)$
\end_inset

 can be decomposed into its sinusoidal Fourier components and each will
 satisfy these equations independently.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The step-function response of 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is the sum of two exponentials as in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:FrieheKehlif"
plural "false"
caps "false"
noprefix "false"

\end_inset

, with the same time constants but with the adjustment that 
\begin_inset Formula $A_{1}=(a-\tau_{1}/\tau_{2})/(1-\tau_{1}/\tau_{2})$
\end_inset

 and 
\begin_inset Formula $A_{2}=(1-a)/\left(1-\tau_{1}/\tau_{2}\right)$
\end_inset

.
 Because 
\begin_inset Formula $\tau_{1}$
\end_inset

 is normally small compared to 
\begin_inset Formula $\tau_{2}$
\end_inset

 for the Rosemount 102E4AL sensor, 
\begin_inset Formula $A_{1}\approx a$
\end_inset

.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The solution to 
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\frac{dT_{m}(t)}{dt}=\frac{(1-a)e^{-t/\tau_{2}}-T_{m}(t)}{\tau_{1}}
\]

\end_inset


\begin_inset Formula 
\[
T_{m}(t)=be^{-t/\tau_{a}}+(1-b)e^{-t/\tau_{b}}
\]

\end_inset


\begin_inset Formula 
\[
-b\frac{e^{-t/\tau_{a}}}{\tau_{a}}-(1-b)\frac{e^{-t/\tau_{b}}}{\tau_{b}}=\frac{(1-a)e^{-t/\tau_{2}}-be^{-t/\tau_{a}}-(1-b)e^{-t/\tau_{b}}}{\tau_{1}}
\]

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
e^{-t/\tau_{a}}:\,\,\,\frac{b}{\tau_{a}}=\frac{b}{\tau_{1}}
\]

\end_inset


\begin_inset Formula 
\[
e^{-t/\tau_{b}}:\,\,\,-\frac{1-b}{\tau_{b}}=-\frac{(1-b)}{\tau_{1}}
\]

\end_inset


\begin_inset Formula 
\[
e^{-t/\tau_{2}}:\,\,\,0=\frac{(1-a)}{\tau_{1}}
\]

\end_inset

If 
\begin_inset Formula $\tau_{a}=\tau_{1}$
\end_inset

 and 
\begin_inset Formula $\tau_{b}=\tau_{2}$
\end_inset

, 
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
(1-b)e^{-t/\tau_{b}}\left(\frac{1}{\tau_{1}}-\frac{1}{\tau_{b}}\right)=(1-a)e^{-t/\tau_{2}}\frac{1}{\tau_{1}}
\]

\end_inset


\begin_inset Formula 
\[
1-b=\frac{1-a}{\left(1-\frac{\tau_{1}}{\tau_{2}}\right)}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

The first equation does not involve the measurement, so for a particular
 history of recovery temperature 
\begin_inset Formula $T_{r}(t)$
\end_inset

 the support temperature can be determined solely by integration of 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Then, with 
\begin_inset Formula $T_{s}(t)$
\end_inset

 determined, 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 can be integrated to find the expected measurement 
\begin_inset Formula $T_{m}(t)$
\end_inset

 for a specified measurand history 
\begin_inset Formula $T_{r}(t)$
\end_inset

.
 The inverse process, finding 
\begin_inset Formula $T_{r}(t)$
\end_inset

 from the measurements 
\begin_inset Formula $T_{m}(t)$
\end_inset

, is also straightforward and only slightly more complicated, as discussed
 in Appendix
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Correcting-the-Temperature"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
For a sinusoidal input these equations have analytic solutions after any
 transient response from initial conditions has decayed.
 If the actual recovery temperature is 
\begin_inset Formula $T_{r}(t)=\sin\omega t$
\end_inset

 where 
\begin_inset Formula $\omega$
\end_inset

 is the angular frequency, then the solutions for 
\begin_inset Formula $T_{s}(t)$
\end_inset

 and 
\begin_inset Formula $T_{m}(t)$
\end_inset

 are given by the following equations:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
T_{s}(t)=b\sin(\omega t+\zeta)\label{eq:TsSolved}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
T_{m}(t)=c\sin(\omega t+\phi)=C_{1}\cos\omega t+C_{2}\sin\omega t\label{eq:TmSolved}
\end{equation}

\end_inset


\begin_inset Newline newline
\end_inset

where
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
b=\frac{1}{\sqrt{1+\omega^{2}\tau_{2}^{2}}}
\]

\end_inset


\begin_inset Formula 
\[
\zeta=-\arctan(\omega\tau_{2})
\]

\end_inset


\begin_inset Formula 
\begin{align*}
C_{1} & =\left(\frac{1}{1+\omega^{2}\tau_{1}^{2}}\right)\left(-\omega\tau_{1}\left(a+(1-a)b\cos\zeta\right)+(1-a)b\sin\zeta\right)\\
= & \frac{-\omega}{(1+\omega^{2}\tau_{1}^{2})}\left(\tau_{1}a+\frac{(1-a)(\tau_{1}+\tau_{2})}{(1+\omega^{2}\tau_{2}^{2})}\right)
\end{align*}

\end_inset


\begin_inset Formula 
\begin{align*}
C_{2} & =\left(\frac{1}{1+\omega^{2}\tau_{1}^{2}}\right)\left(a+(1-a)b\cos\zeta+\omega\tau_{1}(1-a)b\sin\zeta\right)\\
= & \left(\frac{1}{1+\omega^{2}\tau_{1}^{2}}\right)\left(a+\frac{(1-a)(1-\omega^{2}\tau_{1}\tau_{2})}{(1+\omega^{2}\tau_{2}^{2})}\right)
\end{align*}

\end_inset


\begin_inset Formula 
\begin{equation}
c=\sqrt{C_{1}^{2}+C_{2}^{2}}\label{eq:responseAmp}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
\phi=\arctan(C_{1}/C_{2})\label{eq:responsePhase}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset citation
LatexCommand citet
key "mccarthy1973method"
literal "false"

\end_inset

 used the derivative of the step-function response to find the impulse response
 function and, from its Fourier transform, the sensor response function.
 That leads to the following alternate expressions for 
\begin_inset Formula $C_{1}$
\end_inset

 and 
\begin_inset Formula $C_{2}$
\end_inset

:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
C_{1}=-\omega\left(\frac{A_{1}\tau_{1}}{1+\omega^{2}\tau_{1}^{2}}+\frac{A_{2}\tau_{2}}{1+\omega^{2}\tau_{2}^{2}}\right)
\]

\end_inset


\begin_inset Formula 
\[
C_{2}=\left(\frac{A_{1}}{1+\omega^{2}\tau_{1}^{2}}+\frac{A_{2}}{1+\omega^{2}\tau_{2}^{2}}\right)
\]

\end_inset

With 
\begin_inset Formula $A_{2}=(1-a)/(1-\tau_{1}/\tau_{2})$
\end_inset

 and 
\begin_inset Formula $A_{1}=1-A_{2},$
\end_inset

 these are equivalent to the expressions for the same coefficients given
 above 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:responseAmp"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 This demonstrates that the equations 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 are a representation of the response equivalent to 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:FrieheKehlif"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and to the equations used by 
\begin_inset CommandInset citation
LatexCommand citet
key "mccarthy1973method"
literal "false"

\end_inset

 and 
\begin_inset CommandInset citation
LatexCommand citet
key "InverarityJTech2000"
literal "false"

\end_inset

, among others.
\end_layout

\begin_layout Subsection
The transfer function
\begin_inset CommandInset label
LatexCommand label
name "subsec:The-resulting-transfer"

\end_inset


\end_layout

\begin_layout Standard
The transfer function 
\begin_inset Formula $H(\omega)=c(\omega)e^{i\phi(\omega)}$
\end_inset

 then characterizes how the sensor will respond to a unit-amplitude sine
 wave with angular frequency 
\begin_inset Formula $\omega=2\pi\nu$
\end_inset

 where 
\begin_inset Formula $\nu$
\end_inset

 is the frequency.
 For a particular set of parameters (
\begin_inset Formula $a=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(a, 3)}
\end_layout

\end_inset

, 
\begin_inset Formula $\tau_{1}=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(tau1, 4)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

s, 
\begin_inset Formula $\tau_{2}=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(tau2, 3)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

s),
\begin_inset Foot
status open

\begin_layout Plain Layout
These parameters are approximately representative of an unheated Rosemount
 102E4AL sensor used on the NSF/NCAR C-130, as will be demonstrated in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand eqref
reference "subsec:The-unheated-Rosemount"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\end_inset

 the amplitude response and phase delay of the transfer function is shown
 in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:LTsolution}
\end_layout

\end_inset

.
 Similar plots of the amplitude (but not the phase) have been shown by 
\begin_inset CommandInset citation
LatexCommand citet
key "mccarthy1973method"
literal "false"

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
(Fig.
\begin_inset space ~
\end_inset

2)
\end_layout

\end_inset

 and 
\begin_inset CommandInset citation
LatexCommand citet
key "nicholls1978measurements"
literal "false"

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
(Fig.
 3)
\end_layout

\end_inset

.
 Modified transfer functions for two small changes to these parameters are
 also shown to illustrate the sensitivity of the solution to these parameters.
 This figure illustrates that serious errors will enter estimates of the
 sensible heat flux if temperature fluctuations at frequencies above 1
\begin_inset space ~
\end_inset

Hz make a significant contribution to the flux.
 The contribution to the cospectrum of temperature and vertical wind will
 be reduced by the product of the amplitude and the cosine of the phase
 (Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:FE}
\end_layout

\end_inset

).
 Most of the 10-Hz contribution is missed, but even at 1
\begin_inset space ~
\end_inset

Hz the error is about 28%.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Characterizing the time response of sensors and correcting for that response
 when calculating fluxes therefore is an essential part of measuring fluxes
 with this sensor.
 The unheated Rosemount 102E4AL sensor is the fastest sensor available on
 the NSF/NCAR aircraft; other sensors will lead to still larger errors.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<LTsolution, include = TRUE, fig.height=3.7, fig.cap = 'The amplitude and
 phase for the frequency domain transfer function of the Rosemount 102E4AL
 temperature sensor.
 The parameters representing that sensor, labeled 
\begin_inset Quotes eld
\end_inset

best
\begin_inset Quotes erd
\end_inset

, are $a$=0.733, $
\backslash

\backslash
tau_1=0.0308$ s and $
\backslash

\backslash
tau_2=0.447$ s.
 To illustrate sensitivity,  the curves labeled 
\begin_inset Quotes eld
\end_inset

t1=0.05
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

t2=0.6
\begin_inset Quotes erd
\end_inset

 use instead $
\backslash

\backslash
tau_1=0.05$ s and $
\backslash

\backslash
tau_2=0.6$ s, respectively.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

zeta <- -atan(2 * pi * frq * tau2)
\end_layout

\begin_layout Plain Layout

b <- cos(zeta)
\end_layout

\begin_layout Plain Layout

Param <- list(
\end_layout

\begin_layout Plain Layout

  a = a,
\end_layout

\begin_layout Plain Layout

  tau1 = tau1,
\end_layout

\begin_layout Plain Layout

  tau2 = tau2,
\end_layout

\begin_layout Plain Layout

  b = b,
\end_layout

\begin_layout Plain Layout

  zeta = zeta,
\end_layout

\begin_layout Plain Layout

  frq = frq
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

Param1 <- Param
\end_layout

\begin_layout Plain Layout

Param3 <- Param
\end_layout

\begin_layout Plain Layout

Param4 <- Param
\end_layout

\begin_layout Plain Layout

Param3$tau1 <- 0.05
\end_layout

\begin_layout Plain Layout

Param4$tau2 <- 0.6
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Use the Laplace-transform solution
\end_layout

\begin_layout Plain Layout

H1 <- LTphase(frq, Param1)
\end_layout

\begin_layout Plain Layout

cTF <- H1$Amp
\end_layout

\begin_layout Plain Layout

phiTF <- H1$Phase
\end_layout

\begin_layout Plain Layout

H3 <- LTphase(frq, Param3)
\end_layout

\begin_layout Plain Layout

cTF3 <- H3$Amp
\end_layout

\begin_layout Plain Layout

phiTF3 <- H3$Phase
\end_layout

\begin_layout Plain Layout

H4 <- LTphase(frq, Param4)
\end_layout

\begin_layout Plain Layout

cTF4 <- H4$Amp
\end_layout

\begin_layout Plain Layout

phiTF4 <- H4$Phase
\end_layout

\begin_layout Plain Layout

dfAP <- data.frame(
\end_layout

\begin_layout Plain Layout

  'Time' = frq,
\end_layout

\begin_layout Plain Layout

  'Amp' = cTF,
\end_layout

\begin_layout Plain Layout

  'Amp3' = cTF3,
\end_layout

\begin_layout Plain Layout

  'Amp4' = cTF4,
\end_layout

\begin_layout Plain Layout

  'Phase' = phiTF,
\end_layout

\begin_layout Plain Layout

  'Phase3' = phiTF3,
\end_layout

\begin_layout Plain Layout

  'Phase4' = phiTF4
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  ggplotWAC(
\end_layout

\begin_layout Plain Layout

    dfAP,
\end_layout

\begin_layout Plain Layout

    panels = 2,
\end_layout

\begin_layout Plain Layout

    labelP = c('    Amplitude', 'Phase [degrees]'),
\end_layout

\begin_layout Plain Layout

    labelL = c('best', 't1=0.05', 't2=0.6'),
\end_layout

\begin_layout Plain Layout

    lty = c(1, 1, 2)
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab(bquote('transfer function H(' * nu
 ~ ')'))
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  g + scale_x_log10(
\end_layout

\begin_layout Plain Layout

    breaks = trans_breaks("log10", function(x)
\end_layout

\begin_layout Plain Layout

      10 ^ x, n = 4),
\end_layout

\begin_layout Plain Layout

    labels = trans_format("log10", math_format(expr = 10 ^ .x))
\end_layout

\begin_layout Plain Layout

  ) + xlab('frequency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = 'tb')
\end_layout

\begin_layout Plain Layout

g + theme_WAC(1) + theme(legend.position = c(0.3, 0.65))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<SEQNS, include=TRUE, echo=FALSE, fig.cap='transfer function (amplitude
 and phase) for the Rosemount 102E4AL sensor, based on the parameters a=0.72,
 $
\backslash

\backslash
tau_1$=0.032 s, $
\backslash

\backslash
tau_2$=0.6 s.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

library(nleqslv)
\end_layout

\begin_layout Plain Layout

frq <- seq(0.01, 25, by=0.01)
\end_layout

\begin_layout Plain Layout

Phi <- rep(0, length(frq))
\end_layout

\begin_layout Plain Layout

H <- rep(0, length(frq))
\end_layout

\begin_layout Plain Layout

tau2 <- 0.6
\end_layout

\begin_layout Plain Layout

tau1 <- 0.032
\end_layout

\begin_layout Plain Layout

a <- 0.72
\end_layout

\begin_layout Plain Layout

zeta <- -atan(2*pi*frq*tau2)
\end_layout

\begin_layout Plain Layout

b <- cos(zeta)
\end_layout

\begin_layout Plain Layout

Param <- list(a=a, tau1=tau1, tau2=tau2, b=b, zeta=zeta, frq=frq)
\end_layout

\begin_layout Plain Layout

f2solve <- function (x) { # x[1]=phi, x[2]=cf
\end_layout

\begin_layout Plain Layout

  phi <- x[1]
\end_layout

\begin_layout Plain Layout

  cf <- x[2]
\end_layout

\begin_layout Plain Layout

  v <- x
\end_layout

\begin_layout Plain Layout

  v[1] <- a+(1-a)*bA*cos(zeta)+cf*tau1*2*pi*frqA*sin(phi)-cf*cos(phi)
\end_layout

\begin_layout Plain Layout

  v[2] <- cf*(tau1*2*pi*frqA*cos(phi)+sin(phi))-(1-a)*bA*sin(zeta)
\end_layout

\begin_layout Plain Layout

  return(v)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

for (i in 1:length(frq)) {
\end_layout

\begin_layout Plain Layout

  xg <- c(0.1, 0.5)
\end_layout

\begin_layout Plain Layout

  bA <- b[i]
\end_layout

\begin_layout Plain Layout

  zetaA <- zeta[i]
\end_layout

\begin_layout Plain Layout

  frqA <- frq[i]
\end_layout

\begin_layout Plain Layout

  r <- nleqslv(xg, f2solve)
\end_layout

\begin_layout Plain Layout

  Phi[i] <- r$x[1]
\end_layout

\begin_layout Plain Layout

  H[i] <- r$x[2]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

Phi <- Phi * 180 / pi
\end_layout

\begin_layout Plain Layout

dfAP <- data.frame('Amplitude'=H, 'Phase'=Phi)
\end_layout

\begin_layout Plain Layout

dfAP <- data.frame('Time'=frq, 'Amplitude'=H, 'Phase'=Phi)
\end_layout

\begin_layout Plain Layout

g <- ggplotWAC(dfAP, panels=2, labelP=c('       Amplitude', '    Phase [degrees]
'))
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab('transfer function')
\end_layout

\begin_layout Plain Layout

g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=4),
\end_layout

\begin_layout Plain Layout

     labels = trans_format("log10", math_format(expr = 10^.x))) + xlab('frequency
 [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides='tb')
\end_layout

\begin_layout Plain Layout

g + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

<<FE, include=TRUE, echo=FALSE, fig.height=3, fig.cap='Fractional error in
 the cospectrum of sensible-heat flux caused by the delayed response of
 the Rosemount 102E4AL temperature sensor.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

dfFE <-
\end_layout

\begin_layout Plain Layout

  data.frame('Time' = frq,
\end_layout

\begin_layout Plain Layout

             'FractionalError' = 100 * (1 - dfAP$Amp * cos(dfAP$Phase *
 pi / 180)))
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  ggplotWAC(dfFE) + xlab('frequency [Hz]') + ylab('fractional error [%]')
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  g + scale_x_log10(
\end_layout

\begin_layout Plain Layout

    breaks = trans_breaks("log10", function(x)
\end_layout

\begin_layout Plain Layout

      10 ^ x, n = 4),
\end_layout

\begin_layout Plain Layout

    labels = trans_format("log10", math_format(expr = 10 ^ .x))
\end_layout

\begin_layout Plain Layout

  ) + xlab('frequency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = 'tb')
\end_layout

\begin_layout Plain Layout

g + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
These equations and their solution provide a basis for correcting either
 the measured temperature or the sensible-heat flux calculated from the
 cospectrum in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:heatFlux"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Corrected values can be obtained by several methods including integration
 of the equations for the derivatives or by dividing the Fourier transform
 of the time series by the transfer function and then using inverse Fourier
 transformation to recover the corrected time series.
\begin_inset Note Note
status collapsed

\begin_layout Enumerate
Solve 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for 
\begin_inset Formula $T_{r}(t)$
\end_inset

 and substitute that into 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to eliminate that unknown.
 The resulting equation can be solved for 
\begin_inset Formula $T_{s}(t)$
\end_inset

 by numerical integration from an arbitrary starting point.
 The result can then be substituted into 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to solve for 
\begin_inset Formula $T(t)$
\end_inset

, the corrected estimate of the true recovery temperature 
\begin_inset Formula $T_{r}(t)$
\end_inset

.
 Both steps require that the derivative of the measurement, 
\begin_inset Formula $dT_{m}(t)/dt$
\end_inset

, be estimated from finite differences or another higher-order formula.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Because by convention the variables in the data files represent the average
 value at the time corresponding to the midpoint of the time step, finite-differ
ence estimates need to be shifted forward by half the data period, or 0.02
\begin_inset space ~
\end_inset

s in this case of 25\SpecialChar softhyphen
Hz data.
\end_layout

\end_inset

 In practice, a fourth-order Runge-Kutta method is used here for the integration.
 Once 
\begin_inset Formula $T_{s}(t)$
\end_inset

 is known from that integration, 
\begin_inset Formula $T_{r}(t)$
\end_inset

 can be obtained by solution of the second equation without further integration.
\end_layout

\begin_layout Enumerate
Fourier transform the time series 
\begin_inset Formula $T_{m}(t)$
\end_inset

, divide the result by the transfer function, and use the inverse Fourier
 transform to recover the corrected time series.
 This is particularly suited to correction of the flux cospectrum because
 the corrected Fourier transform can be used directly
\end_layout

\end_inset

 Those correction schemes are discussed in detail in Appendix A.
 To support such corrections, the next section determines the transfer function
 experimentally.
 
\end_layout

\begin_layout Section
Determining the Tranfer Function
\end_layout

\begin_layout Standard
The evaluation of the time response that follows relies on the dynamic heating
 produced by airspeed fluctuations.
 In steady conditions a temperature sensor exposed to the air stream will
 measure the recovery temperature, defined as the ambient temperature increased
 by the effect of dynamic heating.
 Dynamic heating fluctuates as the airspeed fluctuates, so in a turbulent
 wind field fluctuations with a measurable frequency spectrum are imposed
 on the sensor.
 These fluctuations are often significantly larger than real fluctuations
 in the ambient temperature.
 Dynamic heating of temperature sensors is discussed for example by 
\begin_inset CommandInset citation
LatexCommand citet
key "BangeEtAl2013.ch2"
literal "false"

\end_inset

 (cf.
\begin_inset space ~
\end_inset

their Eq.
\begin_inset space ~
\end_inset

2.23), who expresses dynamic heating 
\begin_inset Formula $Q$
\end_inset

 as
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
Q=\alpha_{r}\frac{V^{2}}{2C_{p}}=T_{r}\left(\frac{\alpha_{r}M^{2}R_{a}/(2C_{v})}{1+\alpha_{r}M^{2}R_{a}/(2C_{v})}\right)\label{eq:DHterm}
\end{equation}

\end_inset

where 
\begin_inset Formula $\alpha_{r}$
\end_inset

 is the 
\begin_inset Quotes eld
\end_inset

recovery factor
\begin_inset Quotes erd
\end_inset

 characterizing the extent to which the air is brought to rest relative
 to the sensor, 
\begin_inset Formula $V$
\end_inset

 is the airspeed, 
\begin_inset Formula $C_{p}$
\end_inset

 and 
\begin_inset Formula $C_{v}$
\end_inset

 are respectively the specific heat of air at constant pressure and constant
 volume.
 
\begin_inset Formula $T_{r}$
\end_inset

 is the (true) recovery temperature expressed in absolute units, 
\begin_inset Formula $M$
\end_inset

 the Mach number, and 
\begin_inset Formula $R_{a}$
\end_inset

 the gas constant for air.
 The ambient air temperature 
\begin_inset Formula $T_{a}$
\end_inset

 is related to the recovery temperature and the dynamic heating via
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
T_{r}=T_{a}+Q\,\,\,.\label{eq:recoveryTemperature}
\end{equation}

\end_inset

Because dynamic heating can exceed 
\begin_inset Formula $20^{\circ}\mathrm{C}$
\end_inset

 at jet-aircraft flight speeds, it is often the dominant cause of fluctuations
 in the recovery temperature.
 If the fluctuations in dynamic heating are higher in frequency than those
 to which the sensor can respond, corresponding fluctuations will be attenuated
 in the measured spectrum and the phase of the measured response relative
 to the imposed signal will vary, from near 
\begin_inset Formula $0^{\circ}$
\end_inset

 for fluctuations slow compared to sensor response to near 
\begin_inset Formula $90^{\circ}$
\end_inset

 or even more
\begin_inset Foot
status open

\begin_layout Plain Layout
A sensor with a first-order time constant cannot produce a phase lag of
 more than 
\begin_inset Formula $90^{\circ}$
\end_inset

, but larger lags are possible for systems characterized by two time constants,
 as developed below.
\end_layout

\end_inset

 for fluctuations fast compared to that response.
 The amplitude and phase of the recovery temperature relative to the dynamic-hea
ting forcing therefore can be used as sensitive indicators of the response
 characteristics of the sensor and can constrain parameters like 
\begin_inset Formula $a$
\end_inset

, 
\begin_inset Formula $\tau_{1}$
\end_inset

 and 
\begin_inset Formula $\tau_{2}$
\end_inset

 that fit the predictions to the observations.
 The evaluation in terms of the amplitude ratio and phase shift of the recovery
 temperature in response to dynamic heating will be used to characterize
 the transfer function and to determine if it is represented adequately
 by the parameterized form given by 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:responseAmp"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:responsePhase"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subsection
Measurements
\end_layout

\begin_layout Standard
The present investigation uses measurements from two NSF/NCAR (National
 Science Foundation / National Center for Atmospheric Research) research
 aircraft, a Gulfstream V (hereafter, GV) and a Hercules C-130.
 The temperature sensors producing the measurements are in widespread use
 so these results should have broad applicability.
 Some aspects of the uncertainty limits associated with these measurements
 of temperature are included in an NCAR Technical Note (
\begin_inset CommandInset citation
LatexCommand citet
key "Cooper2016ncartn"
literal "true"

\end_inset

), which focused on the measurements of wind from the GV\SpecialChar endofsentence
 That document included
 an estimate that the standard uncertainty in measurements of temperature
 from the GV is about 
\begin_inset Formula $0.3^{\circ}\mathrm{C}$
\end_inset

 and referenced 
\begin_inset CommandInset citation
LatexCommand citet
key "CooperEtAl2014"
literal "false"

\end_inset

 for supporting evidence.
 This limit applies when the temperature being measured is varying slowly
 but does not apply when the temperature changes rapidly.
 It is well known, however, that temperature sensors in common use on research
 aircraft have time-response characteristics that can affect the measurements.
 
\begin_inset CommandInset citation
LatexCommand citet
key "FrieheKhelif1992"
literal "false"

\end_inset

 and 
\begin_inset CommandInset citation
LatexCommand citet
key "LawsonRodi1992"
literal "false"

\end_inset

, among many others, provide reviews of the evidence for delayed response
 of the standard sensors.
 In particular, the unheated Rosemount 102E4AL sensor has been used widely
 as a fast-responding sensor, so it will be a focus of this three-part study.
\end_layout

\begin_layout Standard
This research uses data archives produced by three research projects, the
 VOCALS (VAMOS Ocean-Cloud-Atmosphere-Land Study), CSET (Cloud Systems Evolution
 in the Trades) and SOCRATES (Southern Ocean Clouds, Radiation, Aerosol
 Transport Experimental Study) experiments.
 The field projects are described by 
\begin_inset CommandInset citation
LatexCommand citet
key "wood2011vamos"
literal "false"

\end_inset

, 
\begin_inset CommandInset citation
LatexCommand citet
key "albrecht2019cloud"
literal "false"

\end_inset

 and 
\begin_inset CommandInset citation
LatexCommand citet
key "mcfarquhar2014southern"
literal "false"

\end_inset

, respectively.
 All included low-level flight segments over the Pacific Ocean that are
 used in this paper.
 The reference list includes appropriate DOI references to the measurements.
\end_layout

\begin_layout Subsection
The response to dynamic heating
\end_layout

\begin_layout Standard
Because the airspeed 
\begin_inset Formula $V$
\end_inset

 is itself conventionally determined using the processed air temperature
 
\begin_inset Formula $T_{a}$
\end_inset

, via 
\begin_inset Formula $V=M\sqrt{\gamma R_{a}T_{a}}$
\end_inset

 where 
\begin_inset Formula $\gamma=C_{p}/C_{v}$
\end_inset

, the second expression in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:DHterm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 provides the advantage that it does not rely on prior calculation of the
 air temperature 
\begin_inset Formula $T_{a}$
\end_inset

 but can be calculated from only the recovery temperature 
\begin_inset Formula $T_{r}$
\end_inset

 and the Mach number.
 The Mach number in turn depends only on measurements of the dynamic and
 ambient pressures, with a small adjustment for the water vapor pressure.
 However, the available measurement is not the true recovery temperature
 
\begin_inset Formula $T_{r}$
\end_inset

 but instead the measured temperature 
\begin_inset Formula $T_{m}$
\end_inset

 which may not include high-frequency fluctuations in 
\begin_inset Formula $T_{r}$
\end_inset

.
 This in turn affects the estimated fluctuations determined from 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:DHterm"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 To minimize this problem, regions were sought where the fluctuations in
 dynamic heating were the dominant cause of fluctuations in recovery temperature.
 Temporarily consider these approximations: 
\begin_inset Formula $\alpha_{r}\approx1$
\end_inset

, 
\begin_inset Formula $R_{a}/(2C_{v})\approx1/5$
\end_inset

, and 
\begin_inset Formula $M$
\end_inset

 small enough that the denominator of the right side of 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:DHterm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 can be assumed equal to unity.
 Dynamic heating then is approximately 
\begin_inset Formula $Q\approx T_{r}M^{2}/5$
\end_inset

 and fluctuations in 
\begin_inset Formula $Q$
\end_inset

 are related to those in 
\begin_inset Formula $T_{r}$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 according to
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\frac{\delta Q}{Q}\approx\frac{\delta T_{r}}{T_{r}}+\frac{2}{5}\frac{\delta M}{M}\label{eq:QprimeOverQ}
\end{equation}

\end_inset

Because the measured recovery temperature 
\begin_inset Formula $T_{m}$
\end_inset

 may not include true high-frequency fluctuations in 
\begin_inset Formula $T_{r}$
\end_inset

, the measured phase and amplitude of the response to the dynamic-heating
 term may be distorted from the correct value at frequencies where 
\begin_inset Formula $\delta T_{m}/T_{m}$
\end_inset

 differs from 
\begin_inset Formula $\delta T_{r}/T_{r}$
\end_inset

.
 In regions where the last term in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:QprimeOverQ"
plural "false"
caps "false"
noprefix "false"

\end_inset

 dominates, underestimation of the fluctuations in the recovery temperature
 arising from sensor response will cause less significant errors in the
 measured fluctuations in dynamic heating 
\begin_inset Formula $Q$
\end_inset

, and those errors can be addressed by correction procedures.
\end_layout

\begin_layout Standard
Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:Qprime}
\end_layout

\end_inset

 shows the contributions to the dynamic-heating term from the two terms
 on the right side of 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:QprimeOverQ"
plural "false"
caps "false"
noprefix "false"

\end_inset

, except that 
\begin_inset Formula $T_{m}$
\end_inset

 is used instead of the unknown 
\begin_inset Formula $T_{r}$
\end_inset

.
 This is based on a low-level flight segment with moderate turbulence where
 the airspeed fluctuations were approximately consistent with an eddy dissipatio
n rate of 
\begin_inset Formula $3\times10^{-4}\,\mathrm{m}^{2}\mathrm{s}^{-3}$
\end_inset

.
 The variance of the second term is more than 100 times that of the first,
 indicating that the fluctuations in the first term are less than 10% of
 those in the second term.
 Therefore the right side of 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:DHterm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 with 
\begin_inset Formula $T_{m}$
\end_inset

 in place of 
\begin_inset Formula $T_{r}$
\end_inset

 was used initially to represent dynamic heating.
 Once a set of parameters was determined, 
\begin_inset Formula $T_{r}(t)$
\end_inset

 was calculated using the first correction procedure discussed in Appendix
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Correcting-the-Temperature"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Iteration using this estimate of 
\begin_inset Formula $T_{r}(t)$
\end_inset

 in place of 
\begin_inset Formula $T_{m}(t)$
\end_inset

 led to a small change in the fitted values of the parameters, and the estimate
 became stable after only one iteration.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<TASX, include = FALSE, fig.height = 3.4, fig.cap = 'Spectral variance $P(
\backslash

\backslash
nu)$ for airspeed ($V$) as a function of frequency $
\backslash

\backslash
nu$ from a segment from VOCALS C-130 flight 3, 11:39:00 -- 11:52:00 UTC.
 The dotted orange lines show the spectral variance for various values of
 the eddy dissipation rate, with the heavy-dotted line representing $10^{-4}$
 m$^2$ s$^{-3}$.
 The wavelength scale shows the correspondence between frequency and wavelength
 at the average airspeed.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

reviseDH <-
\end_layout

\begin_layout Plain Layout

  function (.data, P, alphaR) {
\end_layout

\begin_layout Plain Layout

    # P is Param1, e.g.; alphaR is recovery factor
\end_layout

\begin_layout Plain Layout

    .data$Q <- .data$TASX ^ 2 / 2010
\end_layout

\begin_layout Plain Layout

    aV <- P$a
\end_layout

\begin_layout Plain Layout

    tau1V <- P$tau1
\end_layout

\begin_layout Plain Layout

    tau2V <- P$tau2
\end_layout

\begin_layout Plain Layout

    Rate <- attr (.data, 'Rate')
\end_layout

\begin_layout Plain Layout

    fS <- function(y, i) {
\end_layout

\begin_layout Plain Layout

      (.data$Q[i] - y) / (tau2V * Rate)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    fM <- function (y, i) {
\end_layout

\begin_layout Plain Layout

      (aV * .data$Q[i] + (1 - aV) * TsQ[i] - y) / (Rate * tau1V)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    TsQ <- rk4.integrate (fS, .data$Q[1], 1:nrow(.data))
\end_layout

\begin_layout Plain Layout

    Qp <- rk4.integrate (fM, .data$Q[1], 1:nrow(.data))
\end_layout

\begin_layout Plain Layout

    return (.data$ATX + alphaR * (.data$Q - Qp))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

if (file.exists ('./DVOCALS.Rdata')) {
\end_layout

\begin_layout Plain Layout

  load (file = './DVOCALS.Rdata')
\end_layout

\begin_layout Plain Layout

  DVOCALS <- D
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  D <- getNetCDF(
\end_layout

\begin_layout Plain Layout

    file.path(DataDirectory(), 'VOCALS/VOCALSrf03h.nc'),
\end_layout

\begin_layout Plain Layout

    c(
\end_layout

\begin_layout Plain Layout

      'TASX',
\end_layout

\begin_layout Plain Layout

      'PALT',
\end_layout

\begin_layout Plain Layout

      'TTRR',
\end_layout

\begin_layout Plain Layout

      'ATRR',
\end_layout

\begin_layout Plain Layout

      'TTWH',
\end_layout

\begin_layout Plain Layout

      'WIC',
\end_layout

\begin_layout Plain Layout

      'ATX',
\end_layout

\begin_layout Plain Layout

      'PSXC',
\end_layout

\begin_layout Plain Layout

      'QCXC'
\end_layout

\begin_layout Plain Layout

    )
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

  D$DH <- D$TASX ^ 2 / 2010
\end_layout

\begin_layout Plain Layout

  ## For use later, "filter" the dynamic-heating term and revise the temperature
:
\end_layout

\begin_layout Plain Layout

  alphaR <- attr(D[, 'ATRR'], 'RecoveryFactor')
\end_layout

\begin_layout Plain Layout

  D$AT <- reviseDH(D, Param1, alphaR)
\end_layout

\begin_layout Plain Layout

  ## Find a corrected recovery temperature to use in the estimate of dynamic
 heating:
\end_layout

\begin_layout Plain Layout

  a <- Param1$a
\end_layout

\begin_layout Plain Layout

  tau1 <- Param1$tau1
\end_layout

\begin_layout Plain Layout

  tau2 <- Param1$tau2
\end_layout

\begin_layout Plain Layout

  ## RT is the working solution; Ts is the support temperature
\end_layout

\begin_layout Plain Layout

  D$Ts <- D$TTRR
\end_layout

\begin_layout Plain Layout

  Rate <- attr (D, 'Rate')
\end_layout

\begin_layout Plain Layout

  D$DTMDT <-
\end_layout

\begin_layout Plain Layout

    c(0, diff(D$TTRR, 2), 0) * Rate / 2  ## Average this and one-sample-advanced
\end_layout

\begin_layout Plain Layout

  # D$DTMDT <- (D$DTMDT + c(0, D$DTMDT[1:(nrow(D)-1)])) / 2
\end_layout

\begin_layout Plain Layout

  # DT$DTMDT <- as.vector (signal::filter(signal::sgolay(1, 3, m=1), DT$TTRR))
 * Rate
\end_layout

\begin_layout Plain Layout

  fS <- function(y, i) {
\end_layout

\begin_layout Plain Layout

    # Eq.
 Ts3
\end_layout

\begin_layout Plain Layout

    ((1 / a) * (tau1 * D$DTMDT[i] + D$TTRR[i] - (1 - a) * y) - y) / (Rate
 * tau2)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  D$Ts <- rk4.integrate (fS, D$Ts[1], 1:nrow(D))
\end_layout

\begin_layout Plain Layout

  D$RT <- (1 / a) * (tau1 * D$DTMDT + D$TTRR - (1 - a) * D$Ts)
\end_layout

\begin_layout Plain Layout

  # D %>% select(Time, TTRR, RT, Ts) %>% selectTime(114500, 114505) %>%
 plotWAC()
\end_layout

\begin_layout Plain Layout

  save(D, file = './DVOCALS.Rdata')
\end_layout

\begin_layout Plain Layout

  DVOCALS <- D
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

## Revise the calculation of dynamic heating to avoid dependence on AT:
\end_layout

\begin_layout Plain Layout

D$MACH <- MachNumber(D$PSXC, D$QCXC)
\end_layout

\begin_layout Plain Layout

XXA <- attr(D[, 'ATRR'], 'RecoveryFactor') * D$MACH ^ 2 / 5
\end_layout

\begin_layout Plain Layout

D$DH <- (D$TTRR + 273.15) * XXA / (1 + XXA)
\end_layout

\begin_layout Plain Layout

D$DH2 <- (D$RT + 273.15) * XXA / (1 + XXA)
\end_layout

\begin_layout Plain Layout

## temporary: shift D$AT later in time
\end_layout

\begin_layout Plain Layout

# D$AT <- ShiftInTime (D$AT, .rate=25, .shift=40)
\end_layout

\begin_layout Plain Layout

Tasm <- mean(D$TASX, na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

DT <- D %>% selectTime(113900, 115200)
\end_layout

\begin_layout Plain Layout

## Save it for use in the workflow document:
\end_layout

\begin_layout Plain Layout

save(DT, file='DT.Rdata')
\end_layout

\begin_layout Plain Layout

# select six boundary-layer segments of 10 min each:
\end_layout

\begin_layout Plain Layout

DT1 <- D %>% selectTime(65000, 70000)
\end_layout

\begin_layout Plain Layout

DT2 <- D %>% selectTime(73300, 74300)
\end_layout

\begin_layout Plain Layout

DT3 <- D %>% selectTime(104600, 105600)
\end_layout

\begin_layout Plain Layout

DT4 <- D %>% selectTime(114200, 115200)  ## 113900, 115200
\end_layout

\begin_layout Plain Layout

DT5 <- D %>% selectTime(124300, 125300)
\end_layout

\begin_layout Plain Layout

DT6 <- D %>% selectTime(133000, 134000)
\end_layout

\begin_layout Plain Layout

DZV <- rbind(DT1, DT2, DT3, DT4, DT5, DT6)
\end_layout

\begin_layout Plain Layout

rhozero <- 1013.25 * 100 / (287.05 * 288.15)
\end_layout

\begin_layout Plain Layout

# omitting 832-841, 920-951, 955-1005 -- look problematic
\end_layout

\begin_layout Plain Layout

# g <- VSpec(DT, 'TTRR', spans=99, xlim=c(0.01,15), ylim=c(1.e-5, 1.e-1))
\end_layout

\begin_layout Plain Layout

# g <- VSpec(DT, 'ATRR', spans=99, add=g)
\end_layout

\begin_layout Plain Layout

# VSpec(DT, 'DH', spans=99, add=g) + theme_WAC()
\end_layout

\begin_layout Plain Layout

DT$V <- DT$TASX
\end_layout

\begin_layout Plain Layout

VSpec(DT, 'V', VLabel='V=airspeed', spans = 99, ylim=c(1.e-3, 10)) + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<Qprime, include=TRUE, fig.height=3.4, fig.pos='t', fig.cap='Frequency-weighted
 spectral variance for $
\backslash

\backslash
delta T_m/T_m$ and 0.4$
\backslash

\backslash
delta M/M$ as functions of frequency ($
\backslash

\backslash
nu$) for a low-level flight segment from VOCALS flight 3, 21 Oct 2008 11:39:00
 -- 11:52:00 UTC.
 The wavelength scale shows the correspondence between frequency and wavelength
 at the average airspeed.
 The two terms are labeled 
\begin_inset Quotes eld
\end_inset

Tm
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

Mach
\begin_inset Quotes erd
\end_inset

 in the legend.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DT$Mach <- (DT$MACH - mean(DT$MACH, na.rm = TRUE)) / 
\end_layout

\begin_layout Plain Layout

            mean(DT$MACH, na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

DT$Tm <- (DT$TTRR - mean(DT$TTRR, na.rm = TRUE)) / 
\end_layout

\begin_layout Plain Layout

          (273.15 + mean(DT$TTRR, na.rm = TRUE))
\end_layout

\begin_layout Plain Layout

DT$Mach <- DT$Mach * 0.4
\end_layout

\begin_layout Plain Layout

g <- VSpec(DT, 'Mach', ylim = c(1.e-10, 1.e-4))
\end_layout

\begin_layout Plain Layout

VSpec(DT, 'Tm', add = g) + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<extra2, include=FALSE, echo=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## This is a special version with features not in the standard Ranadu version
\end_layout

\begin_layout Plain Layout

CohP <-
\end_layout

\begin_layout Plain Layout

  function (.data,
\end_layout

\begin_layout Plain Layout

            .Var1,
\end_layout

\begin_layout Plain Layout

            .Var2,
\end_layout

\begin_layout Plain Layout

            col = 'blue',
\end_layout

\begin_layout Plain Layout

            spans = 25,
\end_layout

\begin_layout Plain Layout

            smoothBins = 50,
\end_layout

\begin_layout Plain Layout

            plotType = 'ggplot',
\end_layout

\begin_layout Plain Layout

            showErrors = 0,
\end_layout

\begin_layout Plain Layout

            returnCospectrum = FALSE) {
\end_layout

\begin_layout Plain Layout

    if (is.data.frame(.data)) {
\end_layout

\begin_layout Plain Layout

      if (.Var1 %in% names(.data)) {
\end_layout

\begin_layout Plain Layout

        Z <-
\end_layout

\begin_layout Plain Layout

          capture.output (Vr <-
\end_layout

\begin_layout Plain Layout

                            SmoothInterp(detrend (.data[, c('Time', .Var1)]),
 .Length = 0))
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        print(sprintf(
\end_layout

\begin_layout Plain Layout

          'CohPhase ERROR: Variable %s is not in the supplied data.frame',
\end_layout

\begin_layout Plain Layout

          .Var1
\end_layout

\begin_layout Plain Layout

        ))
\end_layout

\begin_layout Plain Layout

        return (NA)
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      if (.Var2 %in% names(.data)) {
\end_layout

\begin_layout Plain Layout

        Z <-
\end_layout

\begin_layout Plain Layout

          capture.output (VrC <-
\end_layout

\begin_layout Plain Layout

                            SmoothInterp(detrend (.data[, c('Time', .Var2)]),
 .Length = 0))
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        print(sprintf(
\end_layout

\begin_layout Plain Layout

          'CohPhase ERROR: Variable %s is not in the supplied data.frame',
\end_layout

\begin_layout Plain Layout

          .Var2
\end_layout

\begin_layout Plain Layout

        ))
\end_layout

\begin_layout Plain Layout

        return (NA)
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      print('CohPhase ERROR: first argument is not a data.frame.')
\end_layout

\begin_layout Plain Layout

      return (NA)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if (is.null(attr(.data, 'Rate'))) {
\end_layout

\begin_layout Plain Layout

      print ('CohPhase warning: Rate attribute missing from data.frame, so
 using Rate=1')
\end_layout

\begin_layout Plain Layout

      Rate <- 1
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      Rate <- attr(.data, 'Rate')
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    vcv <- cbind(ts(Vr, frequency = Rate), ts(VrC, frequency = Rate))
\end_layout

\begin_layout Plain Layout

    P <-
\end_layout

\begin_layout Plain Layout

      spec.pgram(
\end_layout

\begin_layout Plain Layout

        vcv,
\end_layout

\begin_layout Plain Layout

        detrend = FALSE,
\end_layout

\begin_layout Plain Layout

        fast = TRUE,
\end_layout

\begin_layout Plain Layout

        plot = FALSE,
\end_layout

\begin_layout Plain Layout

        spans = spans
\end_layout

\begin_layout Plain Layout

      )
\end_layout

\begin_layout Plain Layout

    df1 <- data.frame(P$coh, log(P$freq))
\end_layout

\begin_layout Plain Layout

    df2 <- data.frame (P$phase, log(P$freq))
\end_layout

\begin_layout Plain Layout

    df3 <- data.frame (P$spec[, 1], log(P$freq))
\end_layout

\begin_layout Plain Layout

    df4 <- data.frame (P$spec[, 2], log(P$freq))
\end_layout

\begin_layout Plain Layout

    pf1 <- binStats (df1, bins = smoothBins)
\end_layout

\begin_layout Plain Layout

    pf2 <- binStats (df2, bins = smoothBins)
\end_layout

\begin_layout Plain Layout

    pf3 <- binStats (df3, bins = smoothBins)
\end_layout

\begin_layout Plain Layout

    pf4 <- binStats (df4, bins = smoothBins)
\end_layout

\begin_layout Plain Layout

    pf1 <- pf1[!is.na (pf1$ybar),]
\end_layout

\begin_layout Plain Layout

    pf2 <- pf2[!is.na (pf2$ybar),]
\end_layout

\begin_layout Plain Layout

    pf3 <- pf3[!is.na (pf3$ybar),]
\end_layout

\begin_layout Plain Layout

    pf4 <- pf4[!is.na (pf4$ybar),]
\end_layout

\begin_layout Plain Layout

    # pf1$sigma[pf1$nb > 1] <- pf1$sigma[pf1$nb > 1] / sqrt(pf1$nb[pf1$nb
 > 2])
\end_layout

\begin_layout Plain Layout

    pf1$sigma[pf1$nb <= 1] <- NA # pf1$ybar[pf1$nb <= 1] * 0.5
\end_layout

\begin_layout Plain Layout

    # pf2$sigma[pf2$nb > 1] <- pf2$sigma[pf2$nb > 1] / sqrt(pf2$nb[pf2$nb
 > 2])
\end_layout

\begin_layout Plain Layout

    pf2$sigma[pf2$nb <= 1] <- NA # pf2$ybar[pf2$nb <= 1] * 0.5is
\end_layout

\begin_layout Plain Layout

    if (plotType != 'ggplot') {
\end_layout

\begin_layout Plain Layout

      pf1 <- binStats (df1, bins = smoothBins, addBin = TRUE)
\end_layout

\begin_layout Plain Layout

      pf2 <- binStats (df2, bins = smoothBins, addBin = TRUE)
\end_layout

\begin_layout Plain Layout

      pf3 <- binStats (df3, bins = smoothBins, addBin = TRUE)
\end_layout

\begin_layout Plain Layout

      pf4 <- binStats (df4, bins = smoothBins, addBin = TRUE)
\end_layout

\begin_layout Plain Layout

      return(cbind(pf1, pf2, pf3, pf4)[, c(2, 1, 3, 4, 6, 7, 10)])
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      d2 <-
\end_layout

\begin_layout Plain Layout

        data.frame(
\end_layout

\begin_layout Plain Layout

          Time = exp(pf1$xc),
\end_layout

\begin_layout Plain Layout

          coherence = pf1$ybar,
\end_layout

\begin_layout Plain Layout

          phase = pf2$ybar * 180 / pi,
\end_layout

\begin_layout Plain Layout

          clo = (pf1$ybar - showErrors * pf1$sigma),
\end_layout

\begin_layout Plain Layout

          chi = pf1$ybar + showErrors * pf1$sigma,
\end_layout

\begin_layout Plain Layout

          plo = (pf2$ybar - showErrors * pf2$sigma) * 180 / pi,
\end_layout

\begin_layout Plain Layout

          phi = (pf2$ybar + showErrors * pf2$sigma) * 180 / pi
\end_layout

\begin_layout Plain Layout

        )
\end_layout

\begin_layout Plain Layout

      d2$clo[!is.na(d2$clo) & (d2$clo < 0)] <- 0
\end_layout

\begin_layout Plain Layout

      labelP <- c('coherence', 'phase [degrees]')
\end_layout

\begin_layout Plain Layout

      g <- ggplotWAC(
\end_layout

\begin_layout Plain Layout

        d2[, c(1, 2, 3)],
\end_layout

\begin_layout Plain Layout

        panels = 2,
\end_layout

\begin_layout Plain Layout

        labelP = labelP,
\end_layout

\begin_layout Plain Layout

        col = col,
\end_layout

\begin_layout Plain Layout

        lwd = c(1.0),
\end_layout

\begin_layout Plain Layout

        lty = c(1),
\end_layout

\begin_layout Plain Layout

        xlab = 'freq'
\end_layout

\begin_layout Plain Layout

      )
\end_layout

\begin_layout Plain Layout

      g <-
\end_layout

\begin_layout Plain Layout

        g + xlab('frequency [Hz]') + ylab (sprintf ('%s x %s', .Var1, .Var2))
\end_layout

\begin_layout Plain Layout

      g <-
\end_layout

\begin_layout Plain Layout

        g + scale_x_log10(
\end_layout

\begin_layout Plain Layout

          breaks = trans_breaks("log10", function(x)
\end_layout

\begin_layout Plain Layout

            10 ^ x, n = 4),
\end_layout

\begin_layout Plain Layout

          labels = trans_format("log10", math_format(expr = 10 ^ .x))
\end_layout

\begin_layout Plain Layout

        ) + xlab('frequency [Hz]')
\end_layout

\begin_layout Plain Layout

      if (showErrors > 0 && smoothBins > 5) {
\end_layout

\begin_layout Plain Layout

        da <- data.frame(d2[, c(1, 4, 5)])
\end_layout

\begin_layout Plain Layout

        db <- data.frame(d2[, c(1, 6, 7)])
\end_layout

\begin_layout Plain Layout

        names(da) <- c('Time', 'ymin', 'ymax')
\end_layout

\begin_layout Plain Layout

        names(db) <- c('Time', 'ymin', 'ymax')
\end_layout

\begin_layout Plain Layout

        da$PanelGroup <- labelP[1]
\end_layout

\begin_layout Plain Layout

        db$PanelGroup <- labelP[2]
\end_layout

\begin_layout Plain Layout

        d <- rbind(db, da)
\end_layout

\begin_layout Plain Layout

        g <-
\end_layout

\begin_layout Plain Layout

          g + geom_ribbon(
\end_layout

\begin_layout Plain Layout

            data = d,
\end_layout

\begin_layout Plain Layout

            aes(
\end_layout

\begin_layout Plain Layout

              x = Time,
\end_layout

\begin_layout Plain Layout

              ymin = ymin,
\end_layout

\begin_layout Plain Layout

              ymax = ymax
\end_layout

\begin_layout Plain Layout

            ),
\end_layout

\begin_layout Plain Layout

            colour = 'grey',
\end_layout

\begin_layout Plain Layout

            alpha = 0.15,
\end_layout

\begin_layout Plain Layout

            inherit.aes = FALSE
\end_layout

\begin_layout Plain Layout

          )
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      g <- g + theme_WAC(1) + theme(legend.position = 'none')
\end_layout

\begin_layout Plain Layout

      if (returnCospectrum) {
\end_layout

\begin_layout Plain Layout

        CS <-
\end_layout

\begin_layout Plain Layout

          sqrt(P$coh[, 1] * P$spec[, 1] * P$spec[, 2] / (1 + tan(P$phase[,
 1]) ^
\end_layout

\begin_layout Plain Layout

                                                           2))
\end_layout

\begin_layout Plain Layout

        v1 <- SmoothInterp(.data[, .Var1], .Length = 0)
\end_layout

\begin_layout Plain Layout

        v2 <- SmoothInterp(.data[, .Var2], .Length = 0)
\end_layout

\begin_layout Plain Layout

        v1 <- detrend(data.frame(Time = .data$Time, v1))
\end_layout

\begin_layout Plain Layout

        v2 <- detrend(data.frame(Time = .data$Time, v2))
\end_layout

\begin_layout Plain Layout

        ff1 <- fft(v1)
\end_layout

\begin_layout Plain Layout

        ff2 <- fft(v2)
\end_layout

\begin_layout Plain Layout

        G <- Re(ff1 * Conj(ff2)) / nrow(.data)
\end_layout

\begin_layout Plain Layout

        GQ <- Im(ff1 * Conj(ff2)) / nrow(.data)
\end_layout

\begin_layout Plain Layout

        N <- nrow(.data) %/% 2
\end_layout

\begin_layout Plain Layout

        S1 <- Re(ff1 * Conj(ff1) / nrow(.data))
\end_layout

\begin_layout Plain Layout

        S2 <- Re(ff2 * Conj(ff2) / nrow(.data))
\end_layout

\begin_layout Plain Layout

        G <- G[2:(N + 1)]
\end_layout

\begin_layout Plain Layout

        GQ <- GQ[2:(N + 1)]
\end_layout

\begin_layout Plain Layout

        S1 <- S1[2:(N + 1)]
\end_layout

\begin_layout Plain Layout

        S2 <- S2[2:(N + 1)]
\end_layout

\begin_layout Plain Layout

        frq <- c(1:N) * Rate / nrow(.data)
\end_layout

\begin_layout Plain Layout

        spec1 <- 2 * S1 / Rate
\end_layout

\begin_layout Plain Layout

        spec2 <- 2 * S2 / Rate
\end_layout

\begin_layout Plain Layout

        cospec <- 2 * G / Rate
\end_layout

\begin_layout Plain Layout

        quad <- 2 * GQ / Rate
\end_layout

\begin_layout Plain Layout

        # cospectrum - i * quadrature = (gain spectrum) * exp(i*(phase spectrum)
)
\end_layout

\begin_layout Plain Layout

        # sqrt(cospectrum^2 + quadrature^2) is the amplitude or gain spectrum
\end_layout

\begin_layout Plain Layout

        return(data.frame(
\end_layout

\begin_layout Plain Layout

          freq = frq,
\end_layout

\begin_layout Plain Layout

          cospec = cospec,
\end_layout

\begin_layout Plain Layout

          quad = quad,
\end_layout

\begin_layout Plain Layout

          spec1 = spec1,
\end_layout

\begin_layout Plain Layout

          spec2 = spec2
\end_layout

\begin_layout Plain Layout

        ))
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        return(g)
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

RX <- CohPhase(DT, 'TTRR', 'DH', plotType = 'Ranadu')
\end_layout

\begin_layout Plain Layout

SB <- 200
\end_layout

\begin_layout Plain Layout

RXX <- CohPhase(DT1, 'TTRR', 'DH', plotType = 'Ranadu', smoothBins = SB)
\end_layout

\begin_layout Plain Layout

Z <-
\end_layout

\begin_layout Plain Layout

  capture.output (Vr <-
\end_layout

\begin_layout Plain Layout

                    SmoothInterp(detrend (DT1[, c('Time', 'TTRR')]), .Length
 = 0))
\end_layout

\begin_layout Plain Layout

Z <-
\end_layout

\begin_layout Plain Layout

  capture.output (VrC <-
\end_layout

\begin_layout Plain Layout

                    SmoothInterp(detrend (DT1[, c('Time', 'DH')]), .Length
 = 0))
\end_layout

\begin_layout Plain Layout

Rate <- attr(DT1, 'Rate')
\end_layout

\begin_layout Plain Layout

vcv <- cbind(ts(Vr, frequency = Rate), ts(VrC, frequency = Rate))
\end_layout

\begin_layout Plain Layout

P <- spec.pgram(
\end_layout

\begin_layout Plain Layout

  vcv,
\end_layout

\begin_layout Plain Layout

  detrend = FALSE,
\end_layout

\begin_layout Plain Layout

  fast = TRUE,
\end_layout

\begin_layout Plain Layout

  plot = FALSE,
\end_layout

\begin_layout Plain Layout

  spans = 25
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

df1 <- data.frame(P$coh, log(P$freq))
\end_layout

\begin_layout Plain Layout

df2 <- data.frame (P$phase, log(P$freq))
\end_layout

\begin_layout Plain Layout

pf1 <- binStats (df1, bins = SB)
\end_layout

\begin_layout Plain Layout

pf2 <- binStats (df2, bins = SB)
\end_layout

\begin_layout Plain Layout

## Use DH2 to get the time-response-corrected-RT Q
\end_layout

\begin_layout Plain Layout

RX1 <- CohP(DT1, 'TTRR', 'DH', plotType = 'Ranadu', smoothBins = SB)
\end_layout

\begin_layout Plain Layout

RX2 <- CohP(DT2, 'TTRR', 'DH', plotType = 'Ranadu', smoothBins = SB)
\end_layout

\begin_layout Plain Layout

RX3 <- CohP(DT3, 'TTRR', 'DH', plotType = 'Ranadu', smoothBins = SB)
\end_layout

\begin_layout Plain Layout

RX4 <- CohP(DT4, 'TTRR', 'DH', plotType = 'Ranadu', smoothBins = SB)
\end_layout

\begin_layout Plain Layout

RX5 <- CohP(DT5, 'TTRR', 'DH', plotType = 'Ranadu', smoothBins = SB)
\end_layout

\begin_layout Plain Layout

RX6 <- CohP(DT6, 'TTRR', 'DH', plotType = 'Ranadu', smoothBins = SB)
\end_layout

\begin_layout Plain Layout

phase <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

nphase <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

phase2 <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

ar <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

ar2 <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

nar <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

for (RX in list(RX1, RX2, RX3, RX4, RX5, RX6)) {
\end_layout

\begin_layout Plain Layout

  for (i in 2:nrow(RX)) {
\end_layout

\begin_layout Plain Layout

    phase[RX$BIN.1[i]] <- phase[RX$BIN.1[i]] + RX$P.phase[i]
\end_layout

\begin_layout Plain Layout

    nphase[RX$BIN.1[i]] <- nphase[RX$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

    phase2[RX$BIN.1[i]] <- phase2[RX$BIN.1[i]] + RX$P.phase[i] ^ 2
\end_layout

\begin_layout Plain Layout

    ar[RX$BIN.1[i]] <-
\end_layout

\begin_layout Plain Layout

      ar[RX$BIN.1[i]] + sqrt(RX$P.spec...1.[i] / RX$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

    ar2[RX$BIN.1[i]] <-
\end_layout

\begin_layout Plain Layout

      ar2[RX$BIN.1[i]] + (RX$P.spec...1.[i] / RX$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

    nar[RX$BIN.1[i]] <- nar[RX$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

nphase[nphase == 0] <- 1
\end_layout

\begin_layout Plain Layout

nar[nar == 0] <- 1
\end_layout

\begin_layout Plain Layout

mphase <- phase / nphase
\end_layout

\begin_layout Plain Layout

mphase2 <- phase2 / nphase
\end_layout

\begin_layout Plain Layout

sdp <- sqrt(mphase2 - mphase ^ 2)
\end_layout

\begin_layout Plain Layout

mphase <- mphase * 180 / pi
\end_layout

\begin_layout Plain Layout

sdp <- sdp * 180 / pi
\end_layout

\begin_layout Plain Layout

sdp <- sdp * 2 / sqrt(nphase)
\end_layout

\begin_layout Plain Layout

ar <- ar / nar
\end_layout

\begin_layout Plain Layout

ar2 <- ar2 / nar
\end_layout

\begin_layout Plain Layout

sdr <- sqrt(ar2 - ar ^ 2)
\end_layout

\begin_layout Plain Layout

sdr <- sdr * 2 / sqrt(nar)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
The unheated Rosemount 102E4AL sensor
\begin_inset CommandInset label
LatexCommand label
name "subsec:The-unheated-Rosemount"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Segment
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
start
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
end
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6:50:00
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7:00:00
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7:33:00
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7:43:00
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10:46:00
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10:56:00
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11:42:00
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11:52:00
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12:43:00
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12:53:00
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13:30:00
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13:40:00
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Flight segments from flight 3 of the VOCALS project, 21 October 2008.
 Listed times are UTC.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To characterize the response of the Rosemount 102E4AL sensor, six ten-minute
 low level flight segments in the marine boundary layer from one flight
 of the NCAR/NSF C-130 in the 
\begin_inset Quotes eld
\end_inset

VOCALS
\begin_inset Quotes erd
\end_inset

 project (
\begin_inset CommandInset citation
LatexCommand citet
key "wood2011vamos"
literal "false"

\end_inset

), which studied low-level clouds over the Pacific Ocean near Chile, were
 selected that had simular flight conditions including the intensity of
 the turbulence.
 The time intervals are listed in Table 1.
 For each flight segment, the phase and amplitude ratio between the measurement
 and the dynamic heating term were calculated,
\begin_inset Foot
status open

\begin_layout Plain Layout
The R routine 
\begin_inset Quotes eld
\end_inset

spec.pgram()
\begin_inset Quotes erd
\end_inset

 was used with 25-point modified Daniell smoothing.
\end_layout

\end_inset

 and the results for all six segments were averaged in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(SB,0)}
\end_layout

\end_inset

 logarithmically spaced intervals in frequency.
 The results for the average phase are shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:Vphase}
\end_layout

\end_inset

.
 The theoretical curve is based on best-fit parameters as determined from
 these measurements and those of the amplitude ratio, discussed next.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<Vphase, include=TRUE, echo=FALSE, fig.height=3.5, fig.cap='Phase lag of measured
 recovery temperature behind dynamic heating, for the measurements (with
 error bars) and for the theoretical response for the best-fit parameters
 (green line).
 The error bars indicate two-standard-deviation ranges in the mean at each
 plotted point.
 Data from the  flight segments listed in Table 1.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

df <- data.frame(frq=exp(pf2$xc), mphase=mphase, sdp=sdp)
\end_layout

\begin_layout Plain Layout

df <- df[df$frq > 0.01, ]
\end_layout

\begin_layout Plain Layout

df <- df[df$sdp > 0, ]
\end_layout

\begin_layout Plain Layout

df <- df[df$frq < 12, ]
\end_layout

\begin_layout Plain Layout

# plot(df$frq, df$mphase, type='p', pch=20, col='blue', log='x', xlim=c(1.e-2,
 15),
\end_layout

\begin_layout Plain Layout

#   xlab='frequency [Hz]', ylab='phase, RTRR x Q [degrees]', ylim=c(-80,
 9))
\end_layout

\begin_layout Plain Layout

# arrows(df$frq, df$mphase-df$sdp, df$frq, df$mphase+df$sdp, length=0.05,
 angle=90, code=3)
\end_layout

\begin_layout Plain Layout

g <- ggplot(df, aes(x=frq, y=mphase))+geom_point()
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab (bquote('phase [' ~ degree * ']'))
\end_layout

\begin_layout Plain Layout

g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=4),
\end_layout

\begin_layout Plain Layout

         labels = trans_format("log10", math_format(expr = 10^.x))) + xlab('frequ
ency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = "bt")
\end_layout

\begin_layout Plain Layout

g <- g + geom_errorbar(aes(ymin=mphase-sdp, ymax=mphase+sdp), width=0.06)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfAP, aes(x=Time, y=Phase), col='forestgreen')
\end_layout

\begin_layout Plain Layout

g + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

frq <- seq(0.01, 25, by=0.01)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<checkAmplitude, include=TRUE, fig.pos='t', fig.height = 3.5, fig.cap='The
 ratio of the spectral amplitude for the measurement of recovery temperature
 ($T_m(t)$) to that for dynamic heating ($Q$), shown as the plotted data
 points.
 There are additional data points at frequencies below about 0.04 Hz that
 do not appear in this plot because they lie above the upper limit for the
 ordinate.
 The green line is the prediction from the transfer function determined
 from the best-fit values matching the phase lag between these variables,
 and the dashed orange line is a similar result with the second time constant
 $
\backslash

\backslash
tau_2$ increased from 0.447 to 0.6 s to illustrate sensitivity to this parameter.'>
>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

dfr <- data.frame(frq=exp(pf2$xc), mrspec=ar, sdr=sdr)
\end_layout

\begin_layout Plain Layout

dfr <- dfr[dfr$frq > 0.01, ]
\end_layout

\begin_layout Plain Layout

dfr <- dfr[dfr$sdr > 0, ]
\end_layout

\begin_layout Plain Layout

dfr <- dfr[dfr$frq < 12, ]
\end_layout

\begin_layout Plain Layout

frq <- exp(pf2$xc[nar > 0])
\end_layout

\begin_layout Plain Layout

# spec1 <- spec1[nspec1 > 0]
\end_layout

\begin_layout Plain Layout

# spec2 <- spec2[nspec1 > 0]
\end_layout

\begin_layout Plain Layout

# rspec <- spec1 / spec2
\end_layout

\begin_layout Plain Layout

# plotWAC(data.frame(frq, mrspec), xlab='frequency [Hz]', ylab='amplitude
 ratio RTRR/Q', type='p', 
\end_layout

\begin_layout Plain Layout

#         col='blue', log='x', pch=20, xlim=c(0.1,15), ylim=c(0,1.2))
\end_layout

\begin_layout Plain Layout

# HR <- LTphase(frq, Param1)
\end_layout

\begin_layout Plain Layout

# P <- Param1
\end_layout

\begin_layout Plain Layout

# P$tau2 <- 0.84
\end_layout

\begin_layout Plain Layout

# HR2 <- LTphase(frq, P)
\end_layout

\begin_layout Plain Layout

# lines(frq, (HR2$Amp)^2, col='forestgreen', lwd=2)
\end_layout

\begin_layout Plain Layout

# lines(frq, (HR$Amp)^2, col='darkorange', lwd=2, lty=2)
\end_layout

\begin_layout Plain Layout

Param5 <- Param1
\end_layout

\begin_layout Plain Layout

Param5$tau2 <- 0.6
\end_layout

\begin_layout Plain Layout

H5 <- LTphase(dfr$frq, Param5)
\end_layout

\begin_layout Plain Layout

cTF5 <- H5$Amp
\end_layout

\begin_layout Plain Layout

phiTF5 <- H5$Phase
\end_layout

\begin_layout Plain Layout

dfr$Amp5 <- cTF5
\end_layout

\begin_layout Plain Layout

g <- ggplot(dfr, aes(x=frq, y=mrspec))+geom_point()
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab ('amplitude ratio')
\end_layout

\begin_layout Plain Layout

g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=4),
\end_layout

\begin_layout Plain Layout

         labels = trans_format("log10", math_format(expr = 10^.x))) + xlab('frequ
ency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = "bt")
\end_layout

\begin_layout Plain Layout

g <- g + geom_errorbar(aes(ymin=mrspec-sdr, ymax=mrspec+sdr), width=0.06)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfAP, aes(x=Time, y=Amp, col='best', lty='best'))
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfr, aes(x=frq, y=Amp5, col='tau2=0.6', lty='tau2=0.6'))
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  g + scale_colour_manual (
\end_layout

\begin_layout Plain Layout

    name = 'fit: ',
\end_layout

\begin_layout Plain Layout

    values = c("best" = "forestgreen", "tau2=0.6" = "darkorange")
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

g <- g + scale_linetype_manual (name = 'fit: ', 
\end_layout

\begin_layout Plain Layout

                                values = c('best' = 1, 'tau2=0.6'=2))
\end_layout

\begin_layout Plain Layout

suppressWarnings(print(g + ylim(0, 1.3) + theme_WAC(1)))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The ratio of the amplitude of the response to that of the dynamic-heating
 signal, used as an estimate of the gain of the transfer function, is shown
 in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:checkAmplitude}
\end_layout

\end_inset

.
 It is useful to consider both the amplitude and phase when determining
 the response parameters because, as shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:LTsolution}
\end_layout

\end_inset

, the amplitude of the transfer function is more sensitive to 
\begin_inset Formula $\tau_{2}$
\end_inset

 than the phase but 
\begin_inset Formula $\tau_{1}$
\end_inset

 is a very sensitive predictor of the phase at high frequency.
 For the set of favored parameters, Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:checkAmplitude}
\end_layout

\end_inset

 shows the standard prediction and another with 
\begin_inset Formula $\tau_{2}$
\end_inset

 set to 0.6
\begin_inset space ~
\end_inset

s instead, to show the sensitivity of this result to that parameter.
 The best prediction based on the measured phases consistently underestimates
 the ratio of spectra for frequencies below about 0.1
\begin_inset space ~
\end_inset

Hz and above about 3
\begin_inset space ~
\end_inset

Hz but is reasonably consistent with the observed ratio between 0.1
\begin_inset space ~
\end_inset

Hz and 3
\begin_inset space ~
\end_inset

Hz.
 Below 0.1
\begin_inset space ~
\end_inset

Hz it appears likely that the sensor is responding to real fluctuations
 in temperature not attributable to dynamic heating, as would be expected
 at these low frequencies.
 Above 3
\begin_inset space ~
\end_inset

Hz the prediction is much too low, probably because there is noise or other
 spurious variance in 
\begin_inset Formula $T_{m}(t)$
\end_inset

 not caused by dynamic heating.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
The orange dashed line, showing the result when 
\begin_inset Formula $\tau_{2}$
\end_inset

 is decreased to 0.4
\begin_inset space ~
\end_inset

s, is a much better fit.
 This suggests that the second time constant determined from the fit to
 the phase is overestimated, so this revised value for 
\begin_inset Formula $\tau_{2}$
\end_inset

 will be interpreted as the best value.
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
However, the previous standard parameters as represented by the green line
 will continue to be used as the best estimate because the spectral ratio
 is more easily confounded, especially by departures of the data toward
 higher values, by extraneous sources of variance in 
\begin_inset Formula $T_{m}(t)$
\end_inset

 not produced by 
\begin_inset Formula $Q$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<fitCoefs, include=TRUE, echo=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Param2 <- Param1
\end_layout

\begin_layout Plain Layout

## Restrict dfr frequencies:
\end_layout

\begin_layout Plain Layout

dfr <- dfr[dfr$frq > 0.1 & dfr$frq < 3, ]
\end_layout

\begin_layout Plain Layout

minFn <- function(V) {
\end_layout

\begin_layout Plain Layout

  Param2$a <<- V[1]
\end_layout

\begin_layout Plain Layout

  Param2$tau1 <<- V[2]
\end_layout

\begin_layout Plain Layout

  Param2$tau2 <<- V[3]
\end_layout

\begin_layout Plain Layout

  Chisq <- 0
\end_layout

\begin_layout Plain Layout

  for (i in 1:nrow(df)) {
\end_layout

\begin_layout Plain Layout

    Chisq <- Chisq + (df$mphase[i] - LTphase(df$frq[i], Param2)$Phase)^2
 / df$sdp[i]^2
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  for (i in 1:nrow(dfr)) {
\end_layout

\begin_layout Plain Layout

    Chisq <- Chisq + (dfr$mrspec[i] - LTphase(dfr$frq[i], Param2)$Amp)^2
 / dfr$sdr[i]^2
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return (Chisq)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

A <- optim (c(Param2$a, Param2$tau1, Param2$tau2), minFn, hessian=TRUE)
\end_layout

\begin_layout Plain Layout

best <- A$par
\end_layout

\begin_layout Plain Layout

Herror <- solve(A$hessian / 4)  # factor of 4 because 2-sigma errors were
 used?
\end_layout

\begin_layout Plain Layout

uncLimits <- sqrt(diag(Herror))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The fit procedure used 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:responseAmp"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:responsePhase"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to find the theoretical value of the amplitude ratio and phase at each
 frequency represented in the observations.
 For assumed values of the three parameters 
\begin_inset Formula $a$
\end_inset

, 
\begin_inset Formula $\tau_{1}$
\end_inset

 and 
\begin_inset Formula $\tau_{2}$
\end_inset

, a chi-square was calculated from the differences between these theoretical
 values and the observed values.
 The frequencies used for the fit were 0.01 to 12
\begin_inset space ~
\end_inset

Hz for the measurements of phase and 0.1 to 3
\begin_inset space ~
\end_inset

Hz for the measurements of amplitude ratio, to avoid regions where effects
 other than dynamic heating appear to bias the measurements.
 Then a search procedure varied these parameters to seek the minimum value
 of the chi-square.
\begin_inset Foot
status open

\begin_layout Plain Layout
The code can be found in the 
\begin_inset Quotes eld
\end_inset

Rnw
\begin_inset Quotes erd
\end_inset

 document that generates the present document.
 It used the 
\begin_inset Quotes eld
\end_inset

optim()
\begin_inset Quotes erd
\end_inset

 function from the R 
\begin_inset Quotes eld
\end_inset

stats
\begin_inset Quotes erd
\end_inset

 package produced by the 
\begin_inset CommandInset citation
LatexCommand citet
key "Rlanguage"
literal "false"

\end_inset

.
\end_layout

\end_inset

 The resulting values were 
\begin_inset Formula $a=$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(best[1], 2)}
\end_layout

\end_inset

, 
\begin_inset Formula $\tau_{1}=$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(best[2], 3)}
\end_layout

\end_inset

 and 
\begin_inset Formula $\tau_{2}=$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(best[3], 2)}
\end_layout

\end_inset

.
 The chi-square for the fit is about 18 times larger than expected if the
 fit represents the measurements to measurement uncertainty, so it is difficult
 to assign uncertainty limits to this result on the basis of this fit because
 of this not-understood excess chi-square, but the fit minimum distinguished
 nearby values to about three significant digits in all three parameters.
 The Hessian from the fit implies that the results with standard uncertainties
 are 
\begin_inset Formula $a=$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(best[1], 3)}
\end_layout

\end_inset


\begin_inset Formula $\pm$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(uncLimits[1], 3)}
\end_layout

\end_inset

, 
\begin_inset Formula $\tau_{1}=$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(best[2], 4)}
\end_layout

\end_inset


\begin_inset Formula $\pm$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(uncLimits[2], 4)}
\end_layout

\end_inset

 and 
\begin_inset Formula $\tau_{2}=$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(best[3], 2)}
\end_layout

\end_inset


\begin_inset Formula $\pm$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(uncLimits[3], 2)}
\end_layout

\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
As shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:LTsolution}
\end_layout

\end_inset

, the phase of the response at high frequency is very sensitive to 
\begin_inset Formula $\tau_{1}$
\end_inset

 while the amplitude of the response near 0.3
\begin_inset space ~
\end_inset

Hz is sensitive to 
\begin_inset Formula $\tau_{2}$
\end_inset

.
 The fit is therefore better constrained by combining the two parts of the
 response function.
 These parameters led to the transfer function shown earlier in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:LTsolution}
\end_layout

\end_inset

 and used as the reference values for the unheated Rosemount 102E4AL in
 this study.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<correctRT, include=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Integrate to find the support temperature Ts:
\end_layout

\begin_layout Plain Layout

a <- Param1$a
\end_layout

\begin_layout Plain Layout

tau1 <- Param1$tau1
\end_layout

\begin_layout Plain Layout

tau2 <- Param1$tau2
\end_layout

\begin_layout Plain Layout

## RT is the working solution; Ts is the support temperature
\end_layout

\begin_layout Plain Layout

DT$Ts <- DT$RT
\end_layout

\begin_layout Plain Layout

Rate <- attr (DT, 'Rate')
\end_layout

\begin_layout Plain Layout

DT$DTMDT <- c(0, diff(DT$TTRR, 2), 0) * Rate / 2
\end_layout

\begin_layout Plain Layout

# DT$DTMDT <- (DT$DTMDT + c(0, DT$DTMDT[1:(nrow(DT)-1)])) / 2
\end_layout

\begin_layout Plain Layout

# DT$DTMDT <- as.vector (signal::filter(signal::sgolay(1, 3, m=1), DT$TTRR))
 * Rate
\end_layout

\begin_layout Plain Layout

fS <- function(y, i) {  # Eq.
 Ts3
\end_layout

\begin_layout Plain Layout

  ((1/a) * (tau1 * DT$DTMDT[i] + DT$TTRR[i] - (1-a) * y) - y) / (Rate *
 tau2)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DT$Ts <- rk4.integrate (fS, DT$Ts[1], 1:nrow(DT))
\end_layout

\begin_layout Plain Layout

DT$RT <- (1/a) * (tau1 * DT$DTMDT + DT$TTRR - (1-a) * DT$Ts)
\end_layout

\begin_layout Plain Layout

DT %>% select(Time, TTRR, RT, Ts) %>% 
\end_layout

\begin_layout Plain Layout

       selectTime(114500, 114505) %>% 
\end_layout

\begin_layout Plain Layout

       plotWAC()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To complete the iteration discussed earlier, the measured recovery temperature
 was then corrected via method 1 from Appendix
\begin_inset space ~
\end_inset

A, using the parameters from this first fit, to find a prediction for the
 actual recovery temperature 
\begin_inset Formula $T_{r}(t)$
\end_inset

.
 After recalculating 
\begin_inset Formula $Q$
\end_inset

 using 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:DHterm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 with that estimate of 
\begin_inset Formula $T_{r}(t)$
\end_inset

 in place of 
\begin_inset Formula $T_{m}(t)$
\end_inset

, the calculation of phase and amplitude was repeated and the results were
 fitted again by adjusting the fit parameters.
 Only very minor changes arose from this procedure even after one iteration,
 but the iterated result is the one used here to represent the unheated
 Rosemount 102E4AL sensor.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<GVcheck>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## This chunk checks GV measurements for consistency with the previous results
 from the C-130,
\end_layout

\begin_layout Plain Layout

## with results reasonably consistent with those results.
 Decided that they don't merit a
\end_layout

\begin_layout Plain Layout

## separate result for the GV.
\end_layout

\begin_layout Plain Layout

DSX <- getNetCDF(file.path(DataDirectory(), 'SOCRATES/rf15h.nc'),
\end_layout

\begin_layout Plain Layout

                 standardVariables(c('ATF1', 'ATH1', 'ATH2')), 55200, 62000)
\end_layout

\begin_layout Plain Layout

DCX <- getNetCDF(file.path(DataDirectory(), 'CSET/rf05h.nc'),
\end_layout

\begin_layout Plain Layout

                 standardVariables(c('ATF1', 'ATH1', 'ATH2')), 175000, 205000)
\end_layout

\begin_layout Plain Layout

rf.txt <- attr(DSX$ATF1, 'RecoveryFactor')
\end_layout

\begin_layout Plain Layout

rf <- gsub('mach', 'MACHX', rf.txt)
\end_layout

\begin_layout Plain Layout

rf <- gsub(' log', ' * log', rf)
\end_layout

\begin_layout Plain Layout

rf <- gsub(' 
\backslash

\backslash
(', ' * 
\backslash

\backslash
(', rf)
\end_layout

\begin_layout Plain Layout

rf <- with(DSX, eval(parse(text=rf)))
\end_layout

\begin_layout Plain Layout

rf2.txt <- attr(DSX$ATH1, 'RecoveryFactor')
\end_layout

\begin_layout Plain Layout

rf2 <- gsub('mach', 'MACHX', rf2.txt)
\end_layout

\begin_layout Plain Layout

rf2 <- gsub(' log', ' * log', rf2)
\end_layout

\begin_layout Plain Layout

rf2 <- gsub(' 
\backslash

\backslash
(', ' * 
\backslash

\backslash
(', rf2)
\end_layout

\begin_layout Plain Layout

rf2 <- with(DSX, eval(parse(text=rf2)))
\end_layout

\begin_layout Plain Layout

DSX$RTF1 <- DSX$ATF1 + rf * DSX$TASX^2 / 2010
\end_layout

\begin_layout Plain Layout

DSX$RTF1 <- SmoothInterp(DSX$RTF1, .Length=0)
\end_layout

\begin_layout Plain Layout

DSX$RTH1 <- DSX$ATH1 + rf2 * DSX$TASX^2 / 2010
\end_layout

\begin_layout Plain Layout

DSX$RTH1 <- SmoothInterp(DSX$RTH1, .Length=0)
\end_layout

\begin_layout Plain Layout

XXA <- rf * DSX$MACHX^2 / 5
\end_layout

\begin_layout Plain Layout

DSX$Q <- (DSX$RTF1 + 273.15) * XXA / (1 + XXA)
\end_layout

\begin_layout Plain Layout

DSX$Q <- SmoothInterp(DSX$Q, .Length=0)
\end_layout

\begin_layout Plain Layout

DSX$Q <- ShiftInTime(DSX$Q, .rate=25, .shift=-10)
\end_layout

\begin_layout Plain Layout

rf.txt <- attr(DCX$ATF1, 'RecoveryFactor')
\end_layout

\begin_layout Plain Layout

rf <- gsub('mach', 'MACHX', rf.txt)
\end_layout

\begin_layout Plain Layout

rf <- gsub(' log', ' * log', rf)
\end_layout

\begin_layout Plain Layout

rf <- gsub(' 
\backslash

\backslash
(', ' * 
\backslash

\backslash
(', rf)
\end_layout

\begin_layout Plain Layout

rf <- with(DCX, eval(parse(text=rf)))
\end_layout

\begin_layout Plain Layout

rf2.txt <- attr(DCX$ATH1, 'RecoveryFactor')
\end_layout

\begin_layout Plain Layout

rf2 <- gsub('mach', 'MACHX', rf2.txt)
\end_layout

\begin_layout Plain Layout

rf2 <- gsub(' log', ' * log', rf2)
\end_layout

\begin_layout Plain Layout

rf2 <- gsub(' 
\backslash

\backslash
(', ' * 
\backslash

\backslash
(', rf2)
\end_layout

\begin_layout Plain Layout

rf2 <- with(DCX, eval(parse(text=rf2)))
\end_layout

\begin_layout Plain Layout

DCX$RTF1 <- DCX$ATF1 + rf * DCX$TASX^2 / 2010
\end_layout

\begin_layout Plain Layout

DCX$RTF1 <- SmoothInterp(DCX$RTF1, .Length=0)
\end_layout

\begin_layout Plain Layout

DCX$RTH1 <- DCX$ATH1 + rf2 * DCX$TASX^2 / 2010
\end_layout

\begin_layout Plain Layout

DCX$RTH1 <- SmoothInterp(DCX$RTH1, .Length=0)
\end_layout

\begin_layout Plain Layout

XXA <- rf * DCX$MACHX^2 / 5
\end_layout

\begin_layout Plain Layout

DCX$Q <- (DCX$RTF1 + 273.15) * XXA / (1 + XXA)
\end_layout

\begin_layout Plain Layout

DCX$Q <- SmoothInterp(DCX$Q, .Length=0)
\end_layout

\begin_layout Plain Layout

DCX$Q <- ShiftInTime(DCX$Q, .rate=25, .shift=-10)
\end_layout

\begin_layout Plain Layout

## May need to revise this with corrected RT in second iteration
\end_layout

\begin_layout Plain Layout

# RX <- CohPhase(DSA, 'RTF1', 'Q', plotType='Ranadu')
\end_layout

\begin_layout Plain Layout

SB <- 100
\end_layout

\begin_layout Plain Layout

DSX$RT <- DSX$RTF1
\end_layout

\begin_layout Plain Layout

DCX$RT <- DCX$RTF1
\end_layout

\begin_layout Plain Layout

## Next is for Z adjustment later
\end_layout

\begin_layout Plain Layout

DZ <- rbind(DSX %>% selectTime(55200, 60200),
\end_layout

\begin_layout Plain Layout

            DSX %>% selectTime(60500, 61500),
\end_layout

\begin_layout Plain Layout

            DCX %>% selectTime(175200, 180200),
\end_layout

\begin_layout Plain Layout

            DCX %>% selectTime(194530, 195530),
\end_layout

\begin_layout Plain Layout

            DCX %>% selectTime(203717, 204717))
\end_layout

\begin_layout Plain Layout

DSA <- DSX %>% selectTime(55200, 60200)
\end_layout

\begin_layout Plain Layout

RXA <- DSX %>% selectTime(55200, 60200) %>% CohP('RT', 'Q', plotType='Ranadu',
 smoothBins=SB)
\end_layout

\begin_layout Plain Layout

RXB <- DSX %>% selectTime(60500, 61500) %>% CohP('RT', 'Q', plotType='Ranadu',
 smoothBins=SB)
\end_layout

\begin_layout Plain Layout

RXC <- DCX %>% selectTime(175200, 180200) %>% CohP('RT', 'Q', plotType='Ranadu',
 smoothBins=SB)
\end_layout

\begin_layout Plain Layout

RXD <- DCX %>% selectTime(194530, 195530) %>% CohP('RT', 'Q', plotType='Ranadu',
 smoothBins=SB)
\end_layout

\begin_layout Plain Layout

RXE <- DCX %>% selectTime(203717, 204717) %>% CohP('RT', 'Q', plotType='Ranadu',
 smoothBins=SB)
\end_layout

\begin_layout Plain Layout

## May need to revise this with corrected RT in second iteration
\end_layout

\begin_layout Plain Layout

Z <- capture.output (Vr <- SmoothInterp(detrend (DSA[, c('Time', 'RT')]),
 .Length=0))
\end_layout

\begin_layout Plain Layout

Z <- capture.output (VrC <- SmoothInterp(detrend (DSA[, c('Time', 'Q')]),
 .Length=0))
\end_layout

\begin_layout Plain Layout

Rate <- attr(DSA, 'Rate')
\end_layout

\begin_layout Plain Layout

vcv <- cbind(ts(Vr, frequency=Rate), ts(VrC, frequency=Rate))
\end_layout

\begin_layout Plain Layout

P <- spec.pgram(vcv, detrend=FALSE, fast=TRUE, plot=FALSE, spans=25)
\end_layout

\begin_layout Plain Layout

df1SF <- data.frame(P$coh, log(P$freq))
\end_layout

\begin_layout Plain Layout

df2SF <- data.frame (P$phase, log(P$freq))
\end_layout

\begin_layout Plain Layout

pf1SF <- binStats (df1SF, bins=SB)
\end_layout

\begin_layout Plain Layout

pf2SF <- binStats (df2SF, bins=SB)
\end_layout

\begin_layout Plain Layout

phaseSF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

nphaseSF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

phase2SF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

arSF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

ar2SF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

narSF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

for (RX in list(RXA, RXB, RXC, RXD, RXE)) {
\end_layout

\begin_layout Plain Layout

  for (i in 2:nrow(RX)) {
\end_layout

\begin_layout Plain Layout

    phaseSF[RX$BIN.1[i]] <- phaseSF[RX$BIN.1[i]] + RX$P.phase[i]
\end_layout

\begin_layout Plain Layout

    nphaseSF[RX$BIN.1[i]] <- nphaseSF[RX$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

    phase2SF[RX$BIN.1[i]] <- phase2SF[RX$BIN.1[i]] + RX$P.phase[i]^2
\end_layout

\begin_layout Plain Layout

    arSF[RX$BIN.1[i]] <- arSF[RX$BIN.1[i]] + sqrt(RX$P.spec...1.[i] / RX$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

    ar2SF[RX$BIN.1[i]] <- ar2SF[RX$BIN.1[i]] + (RX$P.spec...1.[i] / RX$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

    narSF[RX$BIN.1[i]] <- narSF[RX$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

nphaseSF[nphaseSF == 0] <- 1
\end_layout

\begin_layout Plain Layout

narSF[narSF == 0] <- 1
\end_layout

\begin_layout Plain Layout

mphaseSF <- phaseSF/nphaseSF
\end_layout

\begin_layout Plain Layout

mphase2SF <- phase2SF/nphaseSF
\end_layout

\begin_layout Plain Layout

sdpSF <- sqrt(mphase2SF - mphaseSF^2)
\end_layout

\begin_layout Plain Layout

mphaseSF <- mphaseSF * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpSF <- sdpSF * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpSF <- sdpSF * 2 / sqrt(nphaseSF)
\end_layout

\begin_layout Plain Layout

arSF <- arSF / narSF
\end_layout

\begin_layout Plain Layout

ar2SF <- ar2SF / narSF
\end_layout

\begin_layout Plain Layout

b <- ar2SF - arSF^2
\end_layout

\begin_layout Plain Layout

b[near(b, 0)] <- 0
\end_layout

\begin_layout Plain Layout

sdrSF <- sqrt(b)
\end_layout

\begin_layout Plain Layout

sdrSF <- sdrSF * 2 / sqrt(narSF)
\end_layout

\begin_layout Plain Layout

dfSF <- data.frame(frq=exp(pf2SF$xc), mphase=mphaseSF, sdp=sdpSF)
\end_layout

\begin_layout Plain Layout

dfSF <- dfSF[dfSF$frq > 0.05, ]
\end_layout

\begin_layout Plain Layout

dfSF <- dfSF[dfSF$sdp > 0, ]
\end_layout

\begin_layout Plain Layout

dfSF <- dfSF[dfSF$frq < 8, ]
\end_layout

\begin_layout Plain Layout

dfrSF <- data.frame(frq=exp(pf2SF$xc), mrspec=arSF, sdr=sdrSF)
\end_layout

\begin_layout Plain Layout

dfrSF <- dfrSF[dfrSF$frq > 0.05, ]
\end_layout

\begin_layout Plain Layout

dfrSF <- dfrSF[dfrSF$sdr > 0, ]
\end_layout

\begin_layout Plain Layout

dfrSF <- dfrSF[dfrSF$frq < 8, ]
\end_layout

\begin_layout Plain Layout

frq <- exp(pf2SF$xc)
\end_layout

\begin_layout Plain Layout

Parm <- Param1
\end_layout

\begin_layout Plain Layout

minFn <- function(V) {
\end_layout

\begin_layout Plain Layout

  Parm$a <<- V[1]
\end_layout

\begin_layout Plain Layout

  Parm$tau1 <<- V[2]
\end_layout

\begin_layout Plain Layout

  Parm$tau2 <<- V[3]
\end_layout

\begin_layout Plain Layout

  Chisq <- 0
\end_layout

\begin_layout Plain Layout

  for (i in 1:nrow(dfSF)) {
\end_layout

\begin_layout Plain Layout

    Chisq <- Chisq + (dfSF$mphase[i] - LTphase(dfSF$frq[i], Parm)$Phase)^2
 / dfSF$sdp[i]^2
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  for (i in 1:nrow(dfrSF)) {
\end_layout

\begin_layout Plain Layout

    Chisq <- Chisq + (dfrSF$mrspec[i] - LTphase(dfrSF$frq[i], Parm)$Amp)^2
 / dfrSF$sdr[i]^2
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return (Chisq)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

ASF <- optim (c(Parm$a, Parm$tau1, Parm$tau2), minFn, hessian=TRUE)
\end_layout

\begin_layout Plain Layout

bestSF <- ASF$par
\end_layout

\begin_layout Plain Layout

HerrorSF <- solve(ASF$hessian / 4)  # factor of 4 because 2-sigma errors
 were used?
\end_layout

\begin_layout Plain Layout

uncLimitsSF <- sqrt(diag(HerrorSF))
\end_layout

\begin_layout Plain Layout

print(bestSF)
\end_layout

\begin_layout Plain Layout

HSF <- LTphase(dfrSF$frq, Parm)
\end_layout

\begin_layout Plain Layout

dfrSF$Amp <- HSF$Amp
\end_layout

\begin_layout Plain Layout

dfrSF$Phase <- HSF$Phase
\end_layout

\begin_layout Plain Layout

ParamSF <- Param2
\end_layout

\begin_layout Plain Layout

ParGV <- Parm
\end_layout

\begin_layout Plain Layout

rhozero <- 1013.25 * 100 / (287.05 * 288.15)
\end_layout

\begin_layout Plain Layout

MRHO <- MachNumber(DZ$PSXC, DZ$QCXC) * DZ$PSXC * 100 / 
\end_layout

\begin_layout Plain Layout

        (287.05 * (273.15 + DZ$ATX)) / rhozero
\end_layout

\begin_layout Plain Layout

ParGV$tau1 <- ParGV$tau1 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ 0.6
\end_layout

\begin_layout Plain Layout

ParGV$tau2 <- ParGV$tau2 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ 0.6
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

g <- ggplot(dfSF, aes(x=frq, y=mphase))+geom_point()
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab ('phase RTF1 x Q [degrees]')
\end_layout

\begin_layout Plain Layout

g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=4),
\end_layout

\begin_layout Plain Layout

                       labels = trans_format("log10", math_format(expr =
 10^.x))) + xlab('frequency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = "bt")
\end_layout

\begin_layout Plain Layout

g <- g + geom_errorbar(aes(ymin=mphase-sdp, ymax=mphase+sdp), width=0.06)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfrSF, aes(x=frq, y=Phase), col='forestgreen')
\end_layout

\begin_layout Plain Layout

# g <- g + geom_path(data=dfAPSF, aes(x=Time, y=Phase), col='darkorange')
\end_layout

\begin_layout Plain Layout

g + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

frq <- exp(pf2SF$xc[narSF > 0])
\end_layout

\begin_layout Plain Layout

# spec1 <- spec1[nspec1 > 0]
\end_layout

\begin_layout Plain Layout

# spec2 <- spec2[nspec1 > 0]
\end_layout

\begin_layout Plain Layout

# rspec <- spec1 / spec2
\end_layout

\begin_layout Plain Layout

# plotWAC(data.frame(frq, mrspec), xlab='frequency [Hz]', ylab='amplitude
 ratio RTRR/Q', type='p', 
\end_layout

\begin_layout Plain Layout

#         col='blue', log='x', pch=20, xlim=c(0.1,15), ylim=c(0,1.2))
\end_layout

\begin_layout Plain Layout

# HR <- LTphase(frq, Param1)
\end_layout

\begin_layout Plain Layout

# P <- Param1
\end_layout

\begin_layout Plain Layout

# P$tau2 <- 0.84
\end_layout

\begin_layout Plain Layout

# HR2 <- LTphase(frq, P)
\end_layout

\begin_layout Plain Layout

# lines(frq, (HR2$Amp)^2, col='forestgreen', lwd=2)
\end_layout

\begin_layout Plain Layout

# lines(frq, (HR$Amp)^2, col='darkorange', lwd=2, lty=2)
\end_layout

\begin_layout Plain Layout

g <- ggplot(dfrSF, aes(x=frq, y=mrspec))+geom_point()
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab ('amplitude ratio RTF1 / Q')
\end_layout

\begin_layout Plain Layout

g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=2),
\end_layout

\begin_layout Plain Layout

                       labels = trans_format("log10", math_format(expr =
 10^.x))) + xlab('frequency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = "bt")
\end_layout

\begin_layout Plain Layout

g <- g + geom_errorbar(aes(ymin=mrspec-sdr, ymax=mrspec+sdr), width=0.06)
\end_layout

\begin_layout Plain Layout

# g <- g + geom_path(data=dfAPSF, aes(x=Time, y=Amp), col='darkorange')
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfrSF, aes(x=frq, y=Amp), col='forestgreen')
\end_layout

\begin_layout Plain Layout

suppressWarnings(print(g + ylim(0, 1.3) + theme_WAC(1)))
\end_layout

\begin_layout Plain Layout

CohPhase(DSA, 'RTF1', 'Q')
\end_layout

\begin_layout Plain Layout

DSA %>% select(Time, TASX, RTF1, Q, ATF1) %>% VSpec()
\end_layout

\begin_layout Plain Layout

print(bestSF)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<S11a>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DS11 <- getNetCDF(file.path(DataDirectory(), 'SOCRATES/SOCRATESrf11h.nc'),
 
\end_layout

\begin_layout Plain Layout

                  standardVariables(c('ATF1', 'ATH1')), 34850, 35900)
\end_layout

\begin_layout Plain Layout

# DS11 <- DS11 %>% selectTime(44300, 44800)
\end_layout

\begin_layout Plain Layout

dfAPSF <- dfAP[dfAP$Time > 0.5 & dfAP$Time < 8, ]
\end_layout

\begin_layout Plain Layout

## Revise the calculation of dynamic heating to avoid dependence on AT:
\end_layout

\begin_layout Plain Layout

rf.txt <- attr(DS11$ATF1, 'RecoveryFactor')
\end_layout

\begin_layout Plain Layout

rf <- gsub('mach', 'MACHX', rf.txt)
\end_layout

\begin_layout Plain Layout

rf <- gsub(' log', ' * log', rf)
\end_layout

\begin_layout Plain Layout

rf <- gsub(' 
\backslash

\backslash
(', ' * 
\backslash

\backslash
(', rf)
\end_layout

\begin_layout Plain Layout

rf <- with(DS11, eval(parse(text=rf)))
\end_layout

\begin_layout Plain Layout

## RTF1 is not in the netCDF file so recalculate it:
\end_layout

\begin_layout Plain Layout

DS11$RTF1 <- DS11$ATF1 + rf * DS11$TASX^2 / 2010
\end_layout

\begin_layout Plain Layout

DS11$RTF1 <- SmoothInterp(DS11$RTF1, .Length=0)
\end_layout

\begin_layout Plain Layout

## Now correct it using standard parameters:
\end_layout

\begin_layout Plain Layout

## Integrate to find the support temperature Ts:
\end_layout

\begin_layout Plain Layout

CorrectT <- FALSE
\end_layout

\begin_layout Plain Layout

# CorrectT <- TRUE
\end_layout

\begin_layout Plain Layout

if (CorrectT) {
\end_layout

\begin_layout Plain Layout

  a <- Param1$a
\end_layout

\begin_layout Plain Layout

  tau1 <- Param1$tau1
\end_layout

\begin_layout Plain Layout

  tau2 <- Param1$tau2
\end_layout

\begin_layout Plain Layout

  ## RT is the working solution; Ts is the support temperature
\end_layout

\begin_layout Plain Layout

  DS11$Ts <- DS11$RTF1
\end_layout

\begin_layout Plain Layout

  Rate <- attr (DS11, 'Rate')
\end_layout

\begin_layout Plain Layout

  DS11$DTMDT <- c(0, diff(DS11$RTF1, 2), 0) * Rate / 2
\end_layout

\begin_layout Plain Layout

  # DT$DTMDT <- (DT$DTMDT + c(0, DT$DTMDT[1:(nrow(DT)-1)])) / 2
\end_layout

\begin_layout Plain Layout

  # DT$DTMDT <- as.vector (signal::filter(signal::sgolay(1, 3, m=1), DT$TTRR))
 * Rate
\end_layout

\begin_layout Plain Layout

  fS <- function(y, i) {  # Eq.
 Ts3
\end_layout

\begin_layout Plain Layout

    ((1/a) * (tau1 * DS11$DTMDT[i] + DS11$RTF1[i] - (1-a) * y) - y) / (Rate
 * tau2)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  DS11$Ts <- rk4.integrate (fS, DS11$Ts[1], 1:nrow(DS11))
\end_layout

\begin_layout Plain Layout

  DS11$RT <- (1/a) * (tau1 * DS11$DTMDT + DS11$RTF1 - (1-a) * DS11$Ts)
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  DS11$RT <- DS11$RTF1
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

XXA <- rf * DS11$MACHX^2 / 5
\end_layout

\begin_layout Plain Layout

DS11$Q <- (DS11$RT + 273.15) * XXA / (1 + XXA)
\end_layout

\begin_layout Plain Layout

DS11$Q <- SmoothInterp(DS11$Q, .Length=0)
\end_layout

\begin_layout Plain Layout

## May need to revise this with corrected RT in second iteration
\end_layout

\begin_layout Plain Layout

RX <- CohPhase(DS11, 'RT', 'Q', plotType='Ranadu')
\end_layout

\begin_layout Plain Layout

SB <- 90
\end_layout

\begin_layout Plain Layout

Z <- capture.output (Vr <- SmoothInterp(detrend (DS11[, c('Time', 'RT')]),
 .Length=0))
\end_layout

\begin_layout Plain Layout

Z <- capture.output (VrC <- SmoothInterp(detrend (DS11[, c('Time', 'Q')]),
 .Length=0))
\end_layout

\begin_layout Plain Layout

Rate <- attr(DS11, 'Rate')
\end_layout

\begin_layout Plain Layout

vcv <- cbind(ts(Vr, frequency=Rate), ts(VrC, frequency=Rate))
\end_layout

\begin_layout Plain Layout

P <- spec.pgram(vcv, detrend=FALSE, fast=TRUE, plot=FALSE, spans=25)
\end_layout

\begin_layout Plain Layout

df1SF <- data.frame(P$coh, log(P$freq))
\end_layout

\begin_layout Plain Layout

df2SF <- data.frame (P$phase, log(P$freq))
\end_layout

\begin_layout Plain Layout

pf1SF <- binStats (df1SF, bins=SB)
\end_layout

\begin_layout Plain Layout

pf2SF <- binStats (df2SF, bins=SB)
\end_layout

\begin_layout Plain Layout

## Use DH2 to get the time-response-corrected-RT Q
\end_layout

\begin_layout Plain Layout

RX1 <- CohP(DS11, 'RT', 'Q', plotType='Ranadu', smoothBins=SB)
\end_layout

\begin_layout Plain Layout

phaseSF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

nphaseSF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

phase2SF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

arSF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

ar2SF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

narSF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

for (RX in list(RX1)) {
\end_layout

\begin_layout Plain Layout

  for (i in 2:nrow(RX)) {
\end_layout

\begin_layout Plain Layout

    phaseSF[RX$BIN.1[i]] <- phaseSF[RX$BIN.1[i]] + RX$P.phase[i]
\end_layout

\begin_layout Plain Layout

    nphaseSF[RX$BIN.1[i]] <- nphaseSF[RX$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

    phase2SF[RX$BIN.1[i]] <- phase2SF[RX$BIN.1[i]] + RX$P.phase[i]^2 
\end_layout

\begin_layout Plain Layout

    arSF[RX$BIN.1[i]] <- arSF[RX$BIN.1[i]] + sqrt(RX$P.spec...1.[i] / RX$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

    ar2SF[RX$BIN.1[i]] <- ar2SF[RX$BIN.1[i]] + (RX$P.spec...1.[i] / RX$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

    narSF[RX$BIN.1[i]] <- narSF[RX$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

nphaseSF[nphaseSF == 0] <- 1
\end_layout

\begin_layout Plain Layout

narSF[narSF == 0] <- 1
\end_layout

\begin_layout Plain Layout

mphaseSF <- phaseSF/nphaseSF
\end_layout

\begin_layout Plain Layout

mphase2SF <- phase2SF/nphaseSF
\end_layout

\begin_layout Plain Layout

sdpSF <- sqrt(mphase2SF - mphaseSF^2)
\end_layout

\begin_layout Plain Layout

mphaseSF <- mphaseSF * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpSF <- sdpSF * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpSF <- sdpSF * 2 / sqrt(nphaseSF)
\end_layout

\begin_layout Plain Layout

arSF <- arSF / narSF
\end_layout

\begin_layout Plain Layout

ar2SF <- ar2SF / narSF
\end_layout

\begin_layout Plain Layout

b <- ar2SF - arSF^2
\end_layout

\begin_layout Plain Layout

b[near(b, 0)] <- 0
\end_layout

\begin_layout Plain Layout

sdrSF <- sqrt(b)
\end_layout

\begin_layout Plain Layout

sdrSF <- sdrSF * 2 / sqrt(narSF)
\end_layout

\begin_layout Plain Layout

dfSF <- data.frame(frq=exp(pf2SF$xc), mphase=mphaseSF, sdp=sdpSF)
\end_layout

\begin_layout Plain Layout

dfSF <- dfSF[dfSF$frq > 0.5, ]
\end_layout

\begin_layout Plain Layout

dfSF <- dfSF[dfSF$sdp > 0, ]
\end_layout

\begin_layout Plain Layout

dfSF <- dfSF[dfSF$frq < 8, ]
\end_layout

\begin_layout Plain Layout

dfrSF <- data.frame(frq=exp(pf2SF$xc), mrspec=arSF, sdr=sdrSF)
\end_layout

\begin_layout Plain Layout

dfrSF <- dfrSF[dfrSF$frq > 0.5, ]
\end_layout

\begin_layout Plain Layout

dfrSF <- dfrSF[dfrSF$sdr > 0, ]
\end_layout

\begin_layout Plain Layout

dfrSF <- dfrSF[dfrSF$frq < 8, ]
\end_layout

\begin_layout Plain Layout

frq <- exp(pf2SF$xc)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Param2 <- Param1
\end_layout

\begin_layout Plain Layout

minFn <- function(V) {
\end_layout

\begin_layout Plain Layout

  Param2$a <<- V[1]
\end_layout

\begin_layout Plain Layout

  Param2$tau1 <<- V[2]
\end_layout

\begin_layout Plain Layout

  Param2$tau2 <<- V[3]
\end_layout

\begin_layout Plain Layout

  Chisq <- 0
\end_layout

\begin_layout Plain Layout

  for (i in 1:nrow(dfSF)) {
\end_layout

\begin_layout Plain Layout

    Chisq <- Chisq + (dfSF$mphase[i] - LTphase(dfSF$frq[i], Param2)$Phase)^2
 / dfSF$sdp[i]^2
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  for (i in 1:nrow(dfrSF)) {
\end_layout

\begin_layout Plain Layout

    Chisq <- Chisq + (dfrSF$mrspec[i] - LTphase(dfrSF$frq[i], Param2)$Amp)^2
 / dfrSF$sdr[i]^2
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return (Chisq)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

ASF <- optim (c(Param2$a, Param2$tau1, Param2$tau2), minFn, method='L-BFGS-B',
 lower=0, upper=1, hessian=TRUE)
\end_layout

\begin_layout Plain Layout

bestSF <- ASF$par
\end_layout

\begin_layout Plain Layout

HerrorSF <- solve(ASF$hessian / 4)  # factor of 4 because 2-sigma errors
 were used?
\end_layout

\begin_layout Plain Layout

uncLimitsSF <- sqrt(diag(HerrorSF))
\end_layout

\begin_layout Plain Layout

HSF <- LTphase(dfSF$frq, Param2)
\end_layout

\begin_layout Plain Layout

dfSF$Amp <- HSF$Amp
\end_layout

\begin_layout Plain Layout

dfSF$Phase <- HSF$Phase
\end_layout

\begin_layout Plain Layout

ParamSF <- Param2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

g <- ggplot(dfSF, aes(x=frq, y=mphase))+geom_point()
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab ('phase RTF1 x Q [degrees]')
\end_layout

\begin_layout Plain Layout

g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=4),
\end_layout

\begin_layout Plain Layout

                       labels = trans_format("log10", math_format(expr =
 10^.x))) + xlab('frequency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = "bt")
\end_layout

\begin_layout Plain Layout

g <- g + geom_errorbar(aes(ymin=mphase-sdp, ymax=mphase+sdp), width=0.06)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfSF, aes(x=frq, y=Phase), col='forestgreen')
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfAPSF, aes(x=Time, y=Phase), col='darkorange')
\end_layout

\begin_layout Plain Layout

g + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

frq <- exp(pf2SF$xc[narSF > 0])
\end_layout

\begin_layout Plain Layout

# spec1 <- spec1[nspec1 > 0]
\end_layout

\begin_layout Plain Layout

# spec2 <- spec2[nspec1 > 0]
\end_layout

\begin_layout Plain Layout

# rspec <- spec1 / spec2
\end_layout

\begin_layout Plain Layout

# plotWAC(data.frame(frq, mrspec), xlab='frequency [Hz]', ylab='amplitude
 ratio RTRR/Q', type='p', 
\end_layout

\begin_layout Plain Layout

#         col='blue', log='x', pch=20, xlim=c(0.1,15), ylim=c(0,1.2))
\end_layout

\begin_layout Plain Layout

# HR <- LTphase(frq, Param1)
\end_layout

\begin_layout Plain Layout

# P <- Param1
\end_layout

\begin_layout Plain Layout

# P$tau2 <- 0.84
\end_layout

\begin_layout Plain Layout

# HR2 <- LTphase(frq, P)
\end_layout

\begin_layout Plain Layout

# lines(frq, (HR2$Amp)^2, col='forestgreen', lwd=2)
\end_layout

\begin_layout Plain Layout

# lines(frq, (HR$Amp)^2, col='darkorange', lwd=2, lty=2)
\end_layout

\begin_layout Plain Layout

g <- ggplot(dfrSF, aes(x=frq, y=mrspec))+geom_point()
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab ('amplitude ratio RTF1 / Q')
\end_layout

\begin_layout Plain Layout

g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=2),
\end_layout

\begin_layout Plain Layout

                       labels = trans_format("log10", math_format(expr =
 10^.x))) + xlab('frequency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = "bt")
\end_layout

\begin_layout Plain Layout

g <- g + geom_errorbar(aes(ymin=mrspec-sdr, ymax=mrspec+sdr), width=0.06)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfAPSF, aes(x=Time, y=Amp), col='darkorange')
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfSF, aes(x=frq, y=Amp), col='forestgreen')
\end_layout

\begin_layout Plain Layout

suppressWarnings(print(g + ylim(0, 1.3) + theme_WAC(1)))
\end_layout

\begin_layout Plain Layout

print(bestSF)
\end_layout

\begin_layout Plain Layout

rhozero <- 1013.25*100/(287.05*288.15)
\end_layout

\begin_layout Plain Layout

MRHOGV <- MachNumber(DS11$PSXC, DS11$QCXC) * DS11$PSXC * 100 / (287.05 *
 
\end_layout

\begin_layout Plain Layout

                   (273.15 + DS11$ATX)) / rhozero
\end_layout

\begin_layout Plain Layout

ParamSF$tau1 <- ParamSF$tau1 * (mean(MRHOGV, na.rm=TRUE) / 0.3)^0.6
\end_layout

\begin_layout Plain Layout

ParamSF$tau2 <- ParamSF$tau2 * (mean(MRHOGV, na.rm=TRUE) / 0.3)^0.6
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The airflow and typical flow angles approaching a sensor can affect its
 response, so the results might change when installed on a different location
 or a different aircraft.
 Therefore a similar evaluation examined the response of this same sensor
 when flown on the NSF/NCAR GV, which flies significantly faster than the
 C-130.
 The results of a study using a combined low-level dataset from the SOCRATES
 (
\begin_inset CommandInset citation
LatexCommand citet
key "mcfarquhar2014southern"
literal "false"

\end_inset

) and CSET (
\begin_inset CommandInset citation
LatexCommand citet
key "albrecht2019cloud"
literal "false"

\end_inset

) experiments, which were flown over the Pacific Ocean, were similar to
 but slightly different from the coefficients determined on the C-130, with
 both time constants a little smaller than found for the C-130 (
\begin_inset Formula $\tau_{1}=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(ParGV$tau1, 3)}
\end_layout

\end_inset

 and 
\begin_inset Formula $\tau_{2}=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(ParGV$tau2, 2)}
\end_layout

\end_inset

).
 This might be expected at greater airspeed, as discussed in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Expected-dependence-on"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The preceding results characterize the measurement on the NSF/NCAR C-130
 research aircraft.
 The airflow at the sensor may vary depending on its location on the aircraft
 or on which aircraft is used, so it is useful to consider another case
 where the sensor is installed on the GV.
 The case selected was a low-level flight segment from the SOCRATES research
 project, flight 3, 3:48:50 to 3:59:00 UTC\SpecialChar endofsentence
 The preceding analysis was repeated,
 with the result that the best-fit parameters were 
\begin_inset Formula $a=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestSF[1], 2)}
\end_layout

\end_inset

, 
\begin_inset Formula $\tau_{1}=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestSF[2], 3)}
\end_layout

\end_inset

 and 
\begin_inset Formula $\tau_{2}$
\end_inset

=
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestSF[3], 3)}
\end_layout

\end_inset

.
 The second time constant is significantly greater that that found previously
 for the C-130, but otherwise these are reasonably consistent with the previous
 results.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Heated sensors
\begin_inset CommandInset label
LatexCommand label
name "subsec:Heated-sensors"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<SOCrf08, include=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DS <- getNetCDF('/Data/SOCRATES/SOCRATESrf08h.nc', 
\end_layout

\begin_layout Plain Layout

        standardVariables(c('ATF1', 'ATH1', 'ATH2', 'RTF1', 'RTH1', 'RTH2')),
\end_layout

\begin_layout Plain Layout

        45600, 50100)
\end_layout

\begin_layout Plain Layout

DS$TASX <- SmoothInterp(DS$TASX, .Length=0)
\end_layout

\begin_layout Plain Layout

DS$Q <- DS$TASX^2 / 2010
\end_layout

\begin_layout Plain Layout

DS$ATX <- DS$ATF1
\end_layout

\begin_layout Plain Layout

DS$AT <- reviseDH(DS, ParamSF, 0.985)
\end_layout

\begin_layout Plain Layout

DS$AT <- SmoothInterp(DS$AT, .Length=0)
\end_layout

\begin_layout Plain Layout

## Small time adjustment seems useful?
\end_layout

\begin_layout Plain Layout

# DS$Q <- ShiftInTime(DS$Q, .shift=-25, .rate=25)
\end_layout

\begin_layout Plain Layout

DS <- DS %>% selectTime(45600, 50100)
\end_layout

\begin_layout Plain Layout

DS$RHOCP <- 100 * DS$PSXC / (287.05 * 278) * 1005
\end_layout

\begin_layout Plain Layout

DS$RHOCP <- SmoothInterp(DS$RHOCP, .Length=0)
\end_layout

\begin_layout Plain Layout

SB <- 50
\end_layout

\begin_layout Plain Layout

Z <- capture.output (Vr <- SmoothInterp(detrend (DS[, c('Time', 'RTH1')]),
 .Length=0))
\end_layout

\begin_layout Plain Layout

Z <- capture.output (VrB <- SmoothInterp(detrend (DS[, c('Time', 'RTH2')]),
 .Length=0))
\end_layout

\begin_layout Plain Layout

Z <- capture.output (VrF <- SmoothInterp(detrend (DS[, c('Time', 'RTF1')]),
 .Length=0))
\end_layout

\begin_layout Plain Layout

Z <- capture.output (VrC <- SmoothInterp(detrend (DS[, c('Time', 'Q')]),
 .Length=0))
\end_layout

\begin_layout Plain Layout

Rate <- attr(DS, 'Rate')
\end_layout

\begin_layout Plain Layout

vcv <- cbind(ts(Vr, frequency=Rate), ts(VrC, frequency=Rate))
\end_layout

\begin_layout Plain Layout

P <- spec.pgram(vcv, detrend=FALSE, fast=TRUE, plot=FALSE, spans=25)
\end_layout

\begin_layout Plain Layout

vcv <- cbind(ts(VrB, frequency=Rate), ts(VrC, frequency=Rate))
\end_layout

\begin_layout Plain Layout

PB <- spec.pgram(vcv, detrend=FALSE, fast=TRUE, plot=FALSE, spans=25)
\end_layout

\begin_layout Plain Layout

vcv <- cbind(ts(VrF, frequency=Rate), ts(VrC, frequency=Rate))
\end_layout

\begin_layout Plain Layout

PF <- spec.pgram(vcv, detrend=FALSE, fast=TRUE, plot=FALSE, spans=25)
\end_layout

\begin_layout Plain Layout

dfHS <- data.frame(P$coh, log(P$freq))
\end_layout

\begin_layout Plain Layout

dfHSB <- data.frame(PB$coh, log(PB$freq))
\end_layout

\begin_layout Plain Layout

dfHSF <- data.frame(PF$coh, log(PF$freq))
\end_layout

\begin_layout Plain Layout

pfHS <- binStats (dfHS, bins=SB)
\end_layout

\begin_layout Plain Layout

RXHS <- CohP(DS, 'RTH1', 'Q', plotType='Ranadu', smoothBins=SB)
\end_layout

\begin_layout Plain Layout

pfHSB <- binStats (dfHSB, bins=SB)
\end_layout

\begin_layout Plain Layout

RXHSB <- CohP(DS, 'RTH2', 'Q', plotType='Ranadu', smoothBins=SB)
\end_layout

\begin_layout Plain Layout

pfHSF <- binStats (dfHSF, bins=SB)
\end_layout

\begin_layout Plain Layout

RXHSF <- CohP(DS, 'RTF1', 'Q', plotType='Ranadu', smoothBins=SB)
\end_layout

\begin_layout Plain Layout

phaseHS <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

nphaseHS <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

phase2HS <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

arHS <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

ar2HS <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

narHS <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

RXHS$P.spec...1.[RXHS$P.spec...1.
 < 0] <- 0
\end_layout

\begin_layout Plain Layout

phaseHSB <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

nphaseHSB <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

phase2HSB <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

arHSB <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

ar2HSB <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

narHSB <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

RXHSB$P.spec...1.[RXHSB$P.spec...1.
 < 0] <- 0
\end_layout

\begin_layout Plain Layout

phaseHSF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

nphaseHSF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

phase2HSF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

arHSF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

ar2HSF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

narHSF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

RXHSF$P.spec...1.[RXHSF$P.spec...1.
 < 0] <- 0
\end_layout

\begin_layout Plain Layout

for (i in 2:nrow(RXHS)) {
\end_layout

\begin_layout Plain Layout

  phaseHS[RXHS$BIN.1[i]] <- phaseHS[RXHS$BIN.1[i]]+RXHS$P.phase[i]
\end_layout

\begin_layout Plain Layout

  nphaseHS[RXHS$BIN.1[i]] <- nphaseHS[RXHS$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

  phase2HS[RXHS$BIN.1[i]] <- phase2HS[RXHS$BIN.1[i]]+RXHS$P.phase[i]^2 
\end_layout

\begin_layout Plain Layout

  arHS[RXHS$BIN.1[i]] <- arHS[RXHS$BIN.1[i]] + 
\end_layout

\begin_layout Plain Layout

             sqrt(RXHS$P.spec...1.[i] / RXHS$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

  ar2HS[RXHS$BIN.1[i]] <- ar2HS[RXHS$BIN.1[i]] + 
\end_layout

\begin_layout Plain Layout

             (RXHS$P.spec...1.[i] / RXHS$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

  narHS[RXHS$BIN.1[i]] <- narHS[RXHS$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

  phaseHSB[RXHSB$BIN.1[i]] <- phaseHSB[RXHSB$BIN.1[i]]+RXHSB$P.phase[i]
\end_layout

\begin_layout Plain Layout

  nphaseHSB[RXHSB$BIN.1[i]] <- nphaseHSB[RXHSB$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

  phase2HSB[RXHSB$BIN.1[i]] <- phase2HSB[RXHSB$BIN.1[i]]+RXHSB$P.phase[i]^2
 
\end_layout

\begin_layout Plain Layout

  arHSB[RXHSB$BIN.1[i]] <- arHSB[RXHSB$BIN.1[i]] + 
\end_layout

\begin_layout Plain Layout

             sqrt(RXHSB$P.spec...1.[i] / RXHSB$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

  ar2HSB[RXHSB$BIN.1[i]] <- ar2HSB[RXHSB$BIN.1[i]] + 
\end_layout

\begin_layout Plain Layout

             (RXHSB$P.spec...1.[i] / RXHSB$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

  narHSB[RXHSB$BIN.1[i]] <- narHSB[RXHSB$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

  phaseHSF[RXHSF$BIN.1[i]] <- phaseHSF[RXHSF$BIN.1[i]]+RXHSF$P.phase[i]
\end_layout

\begin_layout Plain Layout

  nphaseHSF[RXHSF$BIN.1[i]] <- nphaseHSF[RXHSF$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

  phase2HSF[RXHSF$BIN.1[i]] <- phase2HSF[RXHSF$BIN.1[i]]+RXHSF$P.phase[i]^2
 
\end_layout

\begin_layout Plain Layout

  arHSF[RXHSF$BIN.1[i]] <- arHSF[RXHSF$BIN.1[i]] + 
\end_layout

\begin_layout Plain Layout

             sqrt(RXHSF$P.spec...1.[i] / RXHSF$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

  ar2HSF[RXHSF$BIN.1[i]] <- ar2HSF[RXHSF$BIN.1[i]] + 
\end_layout

\begin_layout Plain Layout

             (RXHSF$P.spec...1.[i] / RXHSF$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

  narHSF[RXHSF$BIN.1[i]] <- narHSF[RXHSF$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

narHS[narHS <= 0] <- 1
\end_layout

\begin_layout Plain Layout

nphaseHS[nphaseHS == 0] <- 1
\end_layout

\begin_layout Plain Layout

mphaseHS <- phaseHS/nphaseHS
\end_layout

\begin_layout Plain Layout

mphase2HS <- phase2HS/nphaseHS
\end_layout

\begin_layout Plain Layout

sdpHS <- sqrt(mphase2HS - mphaseHS^2)
\end_layout

\begin_layout Plain Layout

mphaseHS <- mphaseHS * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpHS <- sdpHS * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpHS <- sdpHS * 2 / sqrt(nphaseHS)
\end_layout

\begin_layout Plain Layout

arHS <- arHS / narHS
\end_layout

\begin_layout Plain Layout

ar2HS <- ar2HS / narHS
\end_layout

\begin_layout Plain Layout

b <- ar2HS - arHS^2
\end_layout

\begin_layout Plain Layout

b[near(b, 0)] <- 0
\end_layout

\begin_layout Plain Layout

sdrHS <- sqrt(b)
\end_layout

\begin_layout Plain Layout

sdrHS <- sdrHS * 2 / sqrt(narHS)
\end_layout

\begin_layout Plain Layout

narHSB[narHSB <= 0] <- 1
\end_layout

\begin_layout Plain Layout

nphaseHSB[nphaseHSB == 0] <- 1
\end_layout

\begin_layout Plain Layout

mphaseHSB <- phaseHSB/nphaseHSB
\end_layout

\begin_layout Plain Layout

mphase2HSB <- phase2HSB/nphaseHSB
\end_layout

\begin_layout Plain Layout

sdpHSB <- sqrt(mphase2HSB - mphaseHSB^2)
\end_layout

\begin_layout Plain Layout

mphaseHSB <- mphaseHSB * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpHSB <- sdpHSB * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpHSB <- sdpHSB * 2 / sqrt(nphaseHSB)
\end_layout

\begin_layout Plain Layout

arHSB <- arHSB / narHSB
\end_layout

\begin_layout Plain Layout

ar2HSB <- ar2HSB / narHSB
\end_layout

\begin_layout Plain Layout

b <- ar2HSB - arHSB^2
\end_layout

\begin_layout Plain Layout

b[near(b, 0)] <- 0
\end_layout

\begin_layout Plain Layout

sdrHSB <- sqrt(b)
\end_layout

\begin_layout Plain Layout

sdrHSB <- sdrHSB * 2 / sqrt(narHSB)
\end_layout

\begin_layout Plain Layout

narHSF[narHSF <= 0] <- 1
\end_layout

\begin_layout Plain Layout

nphaseHSF[nphaseHSF == 0] <- 1
\end_layout

\begin_layout Plain Layout

mphaseHSF <- phaseHSF/nphaseHSF
\end_layout

\begin_layout Plain Layout

mphase2HSF <- phase2HSF/nphaseHSF
\end_layout

\begin_layout Plain Layout

sdpHSF <- sqrt(mphase2HSF - mphaseHSF^2)
\end_layout

\begin_layout Plain Layout

mphaseHSF <- mphaseHSF * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpHSF <- sdpHSF * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpHSF <- sdpHSF * 2 / sqrt(nphaseHSF)
\end_layout

\begin_layout Plain Layout

arHSF <- arHSF / narHSF
\end_layout

\begin_layout Plain Layout

ar2HSF <- ar2HSF / narHSF
\end_layout

\begin_layout Plain Layout

b <- ar2HSF - arHSF^2
\end_layout

\begin_layout Plain Layout

b[near(b, 0)] <- 0
\end_layout

\begin_layout Plain Layout

sdrHSF <- sqrt(b)
\end_layout

\begin_layout Plain Layout

sdrHSF <- sdrHSF * 2 / sqrt(narHSF)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Measurements from two slower sensors, a heated Goodrich/Rosemount 102 sensor
 and a similar 
\begin_inset CommandInset href
LatexCommand href
name "“Harco Model 100009-1 Deiced TAT”"
target "https://www.eol.ucar.edu/instruments/heated-ambient-temperature-sensor"
literal "false"

\end_inset

 (HARCO) sensor, have also been evaluated, but only the latter is included
 here because they have similar response.
 The spectral variance for both these measurements has apparent rapid attenuatio
n beginning at about 0.1
\begin_inset space ~
\end_inset

Hz, as shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:HARCOSpec}
\end_layout

\end_inset

, and the response is attenuated seriously above about 1
\begin_inset space ~
\end_inset

Hz.
\end_layout

\begin_layout Standard
Attempts to use the same three-parameter representation of the transfer
 function relative to dynamic heating led to unsatisfactory fits, so a different
 approach is used here.
 Because the evaluation in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-unheated-Rosemount"
plural "false"
caps "false"
noprefix "false"

\end_inset

 provides a good representation of the unheated Rosemount 102E4AL sensor,
 the measurements from that sensor, corrected as will be described in Appendix
 A, were used as the reference for the assumed-correct recovery temperature.
 Then the phase and amplitude ratio were found for the transfer function
 required to produce the heated-probe measurements from the unheated-probe
 measurements.
 This did not require any assumptions about equations or parameters determining
 the transfer function.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<extraUHR, include=FALSE, echo=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# SB <- 30
\end_layout

\begin_layout Plain Layout

Z <- capture.output (Vr <- SmoothInterp(detrend (DT1[, c('Time', 'TTWH')]),
 .Length=0))
\end_layout

\begin_layout Plain Layout

Z <- capture.output (VrC <- SmoothInterp(detrend (DT1[, c('Time', 'DH')]),
 .Length=0))
\end_layout

\begin_layout Plain Layout

Rate <- attr(DT1, 'Rate')
\end_layout

\begin_layout Plain Layout

vcv <- cbind(ts(Vr, frequency=Rate), ts(VrC, frequency=Rate))
\end_layout

\begin_layout Plain Layout

P <- spec.pgram(vcv, detrend=FALSE, fast=TRUE, plot=FALSE, spans=25)
\end_layout

\begin_layout Plain Layout

df1W <- data.frame(P$coh, log(P$freq))
\end_layout

\begin_layout Plain Layout

pf1W <- binStats (df1W, bins=SB)
\end_layout

\begin_layout Plain Layout

RX1W <- CohP(DT1, 'TTWH', 'RT', plotType='Ranadu', smoothBins=SB)
\end_layout

\begin_layout Plain Layout

RX2W <- CohP(DT2, 'TTWH', 'RT', plotType='Ranadu', smoothBins=SB)
\end_layout

\begin_layout Plain Layout

RX3W <- CohP(DT3, 'TTWH', 'RT', plotType='Ranadu', smoothBins=SB)
\end_layout

\begin_layout Plain Layout

RX4W <- CohP(DT4, 'TTWH', 'RT', plotType='Ranadu', smoothBins=SB)
\end_layout

\begin_layout Plain Layout

RX5W <- CohP(DT5, 'TTWH', 'RT', plotType='Ranadu', smoothBins=SB)
\end_layout

\begin_layout Plain Layout

# RX6W <- CohP(DT6, 'TTWH', 'DH', plotType='Ranadu', smoothBins=SB)
\end_layout

\begin_layout Plain Layout

phaseW <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

nphaseW <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

phase2W <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

arW <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

ar2W <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

narW <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

for (RX in list(RX1W, RX2W, RX3W, RX4W, RX5W)) {
\end_layout

\begin_layout Plain Layout

  for (i in 2:nrow(RX)) {
\end_layout

\begin_layout Plain Layout

    phaseW[RX$BIN.1[i]] <- phaseW[RX$BIN.1[i]]+RX$P.phase[i]
\end_layout

\begin_layout Plain Layout

    nphaseW[RX$BIN.1[i]] <- nphaseW[RX$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

    phase2W[RX$BIN.1[i]] <- phase2W[RX$BIN.1[i]]+RX$P.phase[i]^2 
\end_layout

\begin_layout Plain Layout

    arW[RX$BIN.1[i]] <- arW[RX$BIN.1[i]] + sqrt(RX$P.spec...1.[i] / RX$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

    ar2W[RX$BIN.1[i]] <- ar2W[RX$BIN.1[i]] + (RX$P.spec...1.[i] / RX$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

    narW[RX$BIN.1[i]] <- narW[RX$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

nphaseW[nphaseW == 0] <- 1
\end_layout

\begin_layout Plain Layout

mphaseW <- phaseW/nphaseW
\end_layout

\begin_layout Plain Layout

mphase2W <- phase2W/nphaseW
\end_layout

\begin_layout Plain Layout

sdpW <- sqrt(mphase2W - mphaseW^2)
\end_layout

\begin_layout Plain Layout

mphaseW <- mphaseW * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpW <- sdpW * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpW <- sdpW * 2 / sqrt(nphaseW)
\end_layout

\begin_layout Plain Layout

arW <- arW / narW
\end_layout

\begin_layout Plain Layout

ar2W <- ar2W / narW
\end_layout

\begin_layout Plain Layout

sdrW <- sqrt(ar2W - arW^2)
\end_layout

\begin_layout Plain Layout

sdrW <- sdrW * 2 / sqrt(narW)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The standard HARCO sensor was not flown on the same flight used to study
 the Rosemount sensor in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-unheated-Rosemount"
plural "false"
caps "false"
noprefix "false"

\end_inset

, so a different research flight will be used from the SOCRATES experiment.
 This flight segment was in modest turbulence (with eddy dissipation rate
 of approximately 
\begin_inset Formula $10^{-3}\mathrm{m}^{2}\mathrm{s^{-3}}$
\end_inset

) at low level and with an airspeed variance spectrum reasonably consistent
 with expectations for an inertial sub-range.
 Two sensors producing the measurements RTH1 and RTH1 are enclosed in the
 same housing.
 The characteristics are very similar so both will be evaluated here.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<RTH1Spec, include=FALSE, echo=FALSE, fig.pos='t', fig.height=4, fig.cap='Spectral
 variance $P(
\backslash

\backslash
nu)$ weighted by frequency ($
\backslash

\backslash
nu$) for the recovery temperature measured by a heated  and by an unheated
 Rosemount sensor.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# g <- VSpec(DT, 'TTWH', spans=99, ylim=c(1.e-6, 1))
\end_layout

\begin_layout Plain Layout

# suppressWarnings(print(VSpec(DT, 'TTRR', add=g, spans=99) + theme_WAC(1)))
\end_layout

\begin_layout Plain Layout

DT$temperature <- DT$TTWH
\end_layout

\begin_layout Plain Layout

DT %>% select(Time, TASX, temperature, TTRR) %>% 
\end_layout

\begin_layout Plain Layout

       VSpec(spans=199, VLabel=c('heated', 'unheated'), 
\end_layout

\begin_layout Plain Layout

             xlim=c(0.03, 12), ylim=c(4.e-7, 0.01), 
\end_layout

\begin_layout Plain Layout

             method='MEM', poles=100, smoothBins=200) + 
\end_layout

\begin_layout Plain Layout

  theme_WAC(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<tfHR, include=FALSE, eval=FALSE, fig.height=3.6, fig.pos='p', fig.cap='Transfer
 function for the heated Rosemount 102 sensor, based on measurements from
 the NSF/NCAR C-130 in the VOCALS project.
 Because the results showed high variability and inconsistency for frequencies
 above 1 Hz, only results for frequencies below that limit are shown.
 See the text for the fitted equations producing these curves.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

frq <- seq(0.01, 1.1, by=0.01)
\end_layout

\begin_layout Plain Layout

dfAPW <- data.frame('Time' = frq)
\end_layout

\begin_layout Plain Layout

dfAPW$Amp <- cfr[1]+cfr[2]*log(frq)+cfr[3]*log(frq)^3+cfr[4]*log(frq)^5
\end_layout

\begin_layout Plain Layout

dfAPW$Amp[dfAPW$Time < 0.09] <- 1 
\end_layout

\begin_layout Plain Layout

APW <- LTphase(dfAPW$Time, Param2)
\end_layout

\begin_layout Plain Layout

dfAPW$Amp2 <- APW$Amp
\end_layout

\begin_layout Plain Layout

dfAPW$Phase <- cf[1]+cf[2]*log(frq)+cf[3]*log(frq)^2+cf[4]*atan(frq)
\end_layout

\begin_layout Plain Layout

dfAPW$Phase2 <- APW$Phase
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  ggplotWAC(
\end_layout

\begin_layout Plain Layout

    dfAPW,
\end_layout

\begin_layout Plain Layout

    panels = 2,
\end_layout

\begin_layout Plain Layout

    labelP = c('    Amplitude', 'Phase [degrees]'),
\end_layout

\begin_layout Plain Layout

    labelL = c('lfit', '3-par')
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab(bquote('transfer function H(' * nu
 ~ ')'))
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  g + scale_x_log10(
\end_layout

\begin_layout Plain Layout

    breaks = trans_breaks("log10", function(x)
\end_layout

\begin_layout Plain Layout

      10 ^ x, n = 3),
\end_layout

\begin_layout Plain Layout

    labels = trans_format("log10", math_format(expr = 10 ^ .x))
\end_layout

\begin_layout Plain Layout

  ) + xlab('frequency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = 'tb')
\end_layout

\begin_layout Plain Layout

g <- g + theme_WAC(1) + theme(legend.position = c(0.3, 0.65))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<checkH, include=TRUE, fig.cap='The ratio of the spectral amplitude for
 the measurement of recovery temperature ($T_m(t)$) from the heated HARCO
 sensor to that for dynamic heating ($Q$), shown as the plotted data points.
 The green line is the prediction from the transfer function determined
 from the best-fit values matching the phase lag and amplitude ratio between
 these variables.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

g <- ggplot(dfrH, aes(x=frq, y=mrspec))+geom_point()
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab ('amplitude ratio RTH1 / Q')
\end_layout

\begin_layout Plain Layout

g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=1),
\end_layout

\begin_layout Plain Layout

         labels = trans_format("log10", math_format(expr = 10^.x))) + xlab('frequ
ency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = "bt")
\end_layout

\begin_layout Plain Layout

g <- g + geom_errorbar(aes(ymin=mrspec-sdr, ymax=mrspec+sdr), width=0.02)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=HH, aes(x=frq, y=Amp), col='forestgreen')
\end_layout

\begin_layout Plain Layout

suppressWarnings(print(g + ylim(0, 1.05) + theme_WAC(1)))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<HARCOSpec, include = TRUE, fig.height=3, fig.pos='t', fig.cap='Spectral variance
 $P(
\backslash

\backslash
nu)$ weighted by frequency ($
\backslash

\backslash
nu$) for the recovery temperature measured by a heated  HARCO and an unheated
 Rosemount sensor.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DCX$temperature <- DCX$RT
\end_layout

\begin_layout Plain Layout

DCX %>% selectTime(175200, 180200) %>% select(Time, TASX, temperature, RTH1)
 %>%
\end_layout

\begin_layout Plain Layout

        VSpec(VLabel=c('unheated', 'HARCO'), ylim=c(1.e-6, 0.1)) +
\end_layout

\begin_layout Plain Layout

        ylab(bquote('spectral variance ' ~ nu * 'P(' * nu * ')')) +    
\end_layout

\begin_layout Plain Layout

        theme_WAC(1) + theme(legend.position=c(0.7, 0.9))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Extra
inverted 0
status open

\begin_layout Standard
Measurements from the first five flight segments listed in Table
\begin_inset space ~
\end_inset

1 were used for characterization of the heated Rosemount 102 sensor.
 (The last segment was excluded because some of the measurements from the
 heated sensor were missing.) The spectral variance for the recovery-temperature
 measurement from the heated sensor has apparent rapid attenuation beginning
 at about 0.2
\begin_inset space ~
\end_inset

Hz, as shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:RTH1Spec}
\end_layout

\end_inset

, and the response is attenuated seriously above about 1
\begin_inset space ~
\end_inset

Hz.
 The measured phase lag of the measurement behind the measurement from the
 unheated Rosemount 102E4AL sensor is shown in the bottom panel of Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:phaseG}
\end_layout

\end_inset

 and the corresponding estimate of the gain is shown in the top panel.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<phaseG, include = FALSE, fig.show = 'asis', fig.height = 6, fig.cap = 'The
 gain (top) and phase (bottom) of the transfer function determined for the
 heated Rosemount 102 sensor (variable TTWH) and the recovery temperature
 obtained by applying transfer-function corrections to the measurments from
 the unheated Rosemount 102E4AL sensor (variable RT).
 Error bars are two-standard-deviation estimates of the uncertainty in the
 mean values shown by plotted circles.
 Because the results showed high variability and inconsistency for frequencies
 above 1 Hz, only results for frequencies below that limit are shown.
 The fits are described in the text.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

dfW <- data.frame(frq=exp(pf1W$xc), mphase=mphaseW, sdp=sdpW)
\end_layout

\begin_layout Plain Layout

dfrW <- data.frame(frq=exp(pf1W$xc), mrspec=arW, sdr=sdrW)
\end_layout

\begin_layout Plain Layout

dfW <- dfW[dfW$frq > 0.01 & dfW$frq <= 1, ]
\end_layout

\begin_layout Plain Layout

dfrW <- dfrW[dfrW$frq > 0.01 & dfrW$frq <= 1, ]
\end_layout

\begin_layout Plain Layout

Param2 <- Param1
\end_layout

\begin_layout Plain Layout

Param2$tau1 <- 0.5
\end_layout

\begin_layout Plain Layout

Param2$tau2 <- 0.8
\end_layout

\begin_layout Plain Layout

minFn <- function(V) {
\end_layout

\begin_layout Plain Layout

  Param2$a <<- V[1]
\end_layout

\begin_layout Plain Layout

  Param2$tau1 <<- V[2]
\end_layout

\begin_layout Plain Layout

  Param2$tau2 <<- V[3]
\end_layout

\begin_layout Plain Layout

  Chisq <- 0
\end_layout

\begin_layout Plain Layout

  for (i in 1:nrow(dfW)) {
\end_layout

\begin_layout Plain Layout

    Chisq <- Chisq + (dfW$mphase[i] - LTphase(dfW$frq[i], Param2)$Phase)^2
 / dfW$sdp[i]^2
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  for (i in 1:nrow(dfrW)) {
\end_layout

\begin_layout Plain Layout

    Chisq <- Chisq + (dfrW$mrspec[i] - LTphase(dfrW$frq[i], Param2)$Amp)^2
 / dfrW$sdr[i]^2
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return (Chisq)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

AW <- optim (c(Param2$a, Param2$tau1, Param2$tau2), minFn, hessian=TRUE)
\end_layout

\begin_layout Plain Layout

bestW <- AW$par
\end_layout

\begin_layout Plain Layout

HerrorW <- solve(AW$hessian / 4)  # factor of 4 because 2-sigma errors were
 used?
\end_layout

\begin_layout Plain Layout

uncLimitsW <- sqrt(diag(HerrorW))
\end_layout

\begin_layout Plain Layout

g <- ggplot(dfW, aes(x=frq, y=mphase))+geom_point()
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab (bquote('phase [' ~ degree * ']'))
\end_layout

\begin_layout Plain Layout

g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=2),
\end_layout

\begin_layout Plain Layout

                       labels = trans_format("log10", math_format(expr =
 10^.x))) + xlab('frequency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = "bt")
\end_layout

\begin_layout Plain Layout

g <- g + geom_errorbar(aes(ymin=mphase-sdp, ymax=mphase+sdp), width=0.05)
\end_layout

\begin_layout Plain Layout

# g <- g + geom_path(data=dfW, aes(x=frq, y=mphase), col='forestgreen')
\end_layout

\begin_layout Plain Layout

cf <- coef(lm(data=dfW, mphase ~ log(frq)+I(log(frq)^2)+I(atan(frq))))
\end_layout

\begin_layout Plain Layout

dfW$Ph <- cf[1]+cf[2]*log(dfW$frq)+cf[3]*log(dfW$frq)^2+cf[4]*atan(dfW$frq)
\end_layout

\begin_layout Plain Layout

dfW$PhLT <- LTphase(dfW$frq, Param2)$Phase
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfW, aes(x=frq, y=Ph, col='lfit', lty='lfit'))
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfW, aes(x=frq, y=PhLT, col='3-par', lty='3-par'))
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  g + scale_colour_manual (
\end_layout

\begin_layout Plain Layout

    name = 'fit: ',
\end_layout

\begin_layout Plain Layout

    values = c("lfit" = "forestgreen", "3-par" = "blue")
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

g <- g + scale_linetype_manual (name = 'fit: ', 
\end_layout

\begin_layout Plain Layout

                                values = c('lfit' = 4, '3-par'=1))
\end_layout

\begin_layout Plain Layout

g1 <- g + theme_WAC(1) + theme(legend.position = c(0.75, 0.9))
\end_layout

\begin_layout Plain Layout

g <- ggplot(dfrW, aes(x=frq, y=mrspec))+geom_point()
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab ('amplitude ratio TTWH / RT')
\end_layout

\begin_layout Plain Layout

g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=2),
\end_layout

\begin_layout Plain Layout

         labels = trans_format("log10", math_format(expr = 10^.x))) + xlab('frequ
ency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = "bt")
\end_layout

\begin_layout Plain Layout

g <- g + geom_errorbar(aes(ymin=mrspec-sdr, ymax=mrspec+sdr), width=0.05)
\end_layout

\begin_layout Plain Layout

# g <- g + geom_path(data=dfAP, aes(x=Time, y=Amp), col='forestgreen')
\end_layout

\begin_layout Plain Layout

# g <- g + geom_path(data=dfr, aes(x=frq, y=Amp5), col='darkorange', lty=2)
\end_layout

\begin_layout Plain Layout

cfr <- coef(lm(data=dfrW[dfrW$frq > 0.07, ], mrspec ~ log(frq) + I(log(frq)^3)
 + 
\end_layout

\begin_layout Plain Layout

               I(log(frq)^5)))
\end_layout

\begin_layout Plain Layout

dfrW$G <- cfr[1]+cfr[2]*log(dfrW$frq)+cfr[3]*log(dfrW$frq)^3+cfr[4]*log(dfrW$frq
)^5
\end_layout

\begin_layout Plain Layout

dfrW$G[dfrW$frq < 0.08] <- 1
\end_layout

\begin_layout Plain Layout

dfrW$GLT <- LTphase(dfrW$frq, Param2)$Amp
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfrW, aes(x=frq, y=G, col='lfit', lty='lfit'))
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfrW, aes(x=frq, y=GLT, col='3-par', lty='3-par'))
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  g + scale_colour_manual (
\end_layout

\begin_layout Plain Layout

    name = 'fit: ',
\end_layout

\begin_layout Plain Layout

    values = c("lfit" = "forestgreen", "3-par" = "blue")
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

g <- g + scale_linetype_manual (name = 'fit: ', 
\end_layout

\begin_layout Plain Layout

                                values = c('lfit' = 4, '3-par'=1))
\end_layout

\begin_layout Plain Layout

g2 <- g + ylim(0, 1.2) + theme_WAC(1) + theme(legend.position = c(0.75, 0.9))
\end_layout

\begin_layout Plain Layout

# suppressWarnings(print(g + ylim(0, 1.2) + theme_WAC(1) + 
\end_layout

\begin_layout Plain Layout

#                        theme(legend.position = c(0.75, 0.9))))
\end_layout

\begin_layout Plain Layout

g2 <- g2 + theme(plot.margin=unit(c(0.5,0.3,1.1,1.8),"lines"))  ## small adjustment
 for alignment
\end_layout

\begin_layout Plain Layout

grid.newpage()
\end_layout

\begin_layout Plain Layout

vp2 <- viewport(y=unit(0.61, 'npc'), height=unit(0.5, 'npc'),layout.pos.row=2)
\end_layout

\begin_layout Plain Layout

vp1 <- viewport(y=unit(0.25, 'npc'), height=unit(0.5, 'npc'),layout.pos.row=1)
\end_layout

\begin_layout Plain Layout

print(g2, vp=vp2)
\end_layout

\begin_layout Plain Layout

print(g1, vp=vp1)
\end_layout

\begin_layout Plain Layout

grid.newpage()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Extra
inverted 0
status open

\begin_layout Standard
No combination of the three fit parameters {
\begin_inset Formula $a,\,\tau_{1},\,\tau_{2}$
\end_inset

} entering the transfer-function equations 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:responseAmp"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:responsePhase"
plural "false"
caps "false"
noprefix "false"

\end_inset

 provides a satisfactory representation of the measurements in those two
 plots, although the best fit (shown as the 
\begin_inset Quotes eld
\end_inset

3-par
\begin_inset Quotes erd
\end_inset

 line) for the values {
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestW[1], 2)}
\end_layout

\end_inset

,
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestW[2], 2)}
\end_layout

\end_inset

,
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestW[3], 2)}
\end_layout

\end_inset

} provides a fair approximation.
 Those figures show that the fit is inadequate (chisquare of over 16,000
 for 40 degrees of freedom) so it appears that for this sensor heat transfer
 is still more complicated than can be represented by the differential equations
 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

, perhaps because there are other paths by which heat can be transferred
 to or from the sensing wire.
 The small value for the parameter 
\begin_inset Formula $a$
\end_inset

 suggests that most of the heat transferred to or from the wire is through
 routes other than direct conduction from the air.
\end_layout

\begin_layout Standard
Rather than seeking a more complicated representation of the transfer function,
 it can be represented instead by the lines in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:phaseG}
\end_layout

\end_inset

 labeled 
\begin_inset Quotes eld
\end_inset

lfit
\begin_inset Quotes erd
\end_inset

, fits to the measurements in terms of 
\begin_inset Formula $x=\log_{e}(\nu/\nu_{0})$
\end_inset

 where 
\begin_inset Formula $\nu=\omega/(2\pi)$
\end_inset

 is the frequency and 
\begin_inset Formula $\nu_{0}=1\,\mathrm{Hz}$
\end_inset

:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\mathrm{for}\,\nu>0.08\,\mathrm{Hz,\,\,}H(\omega)=(h_{0}+h_{1}x+h_{2}x^{3}+h_{3}x^{5}+h_{3}\arctan(\nu/\nu_{0}))e^{i\phi(\omega)}\label{eq:lfitR}
\end{equation}

\end_inset


\begin_inset Formula 
\[
\mathrm{for\:\nu\leq0.08\,\mathrm{Hz},\quad}H(\omega)=1
\]

\end_inset


\begin_inset Formula 
\[
\phi(\omega)=p_{0}+p_{1}x+p_{2}x^{2}+p_{3}\arctan(\nu/\nu_{0})
\]

\end_inset

The coefficients obtained by fitting to the observations are 
\begin_inset Formula $h_{0-3}=$
\end_inset

{
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{round(cfr[1], 3)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{round(cfr[2], 3)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{round(cfr[3], 4)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{round(cfr[4], 5)}$
\end_layout

\end_inset

} and 
\begin_inset Formula $p_{0-3}=$
\end_inset

{
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{round(cf[1], 1)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{format(cf[2], digits=1, nsmall=1)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{format(cf[3], digits=2, nsmall=2)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{round(cf[4], 1)}$
\end_layout

\end_inset

}.
 These equations are the basis for the 
\begin_inset Quotes eld
\end_inset

lfit
\begin_inset Quotes erd
\end_inset

 lines plotted in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:phaseG}
\end_layout

\end_inset

.
 For negative frequencies, the values of 
\begin_inset Formula $H(\omega)$
\end_inset

 are the complex conjugate of the values listed above.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Extra
inverted 0
status open

\begin_layout Standard
The reason that the three-parameter fit is unacceptable is that there is
 conflict between the constraints imposed by the amplitude ratio and the
 phase, such that either could be represented reasonably but not both.
 The actual transfer function has some complex features, including frequencies
 where the phase shift reaches values below 
\begin_inset Formula $-90^{\circ}$
\end_inset

 (not possible for a simple exponential time response) and values of the
 phase shift of about 
\begin_inset Formula $-36^{\circ}$
\end_inset

 at 0.1
\begin_inset space ~
\end_inset

Hz where the amplitude ratio remains near unity.
 The amplitude decreases to 
\begin_inset Formula $e^{-1}$
\end_inset

 at about 0.4
\begin_inset space ~
\end_inset

Hz, as would be the case for a first-order time constant of about 1
\begin_inset space ~
\end_inset

s, so this could be considered another measure of the response.
 However, that value does not extrapolate well to other frequencies and
 the phase shift at 0.4
\begin_inset space ~
\end_inset

Hz is approximately 
\begin_inset Formula $-90^{\circ}$
\end_inset

, which would indicate that the measurement of a real contribution to sensible-h
eat flux at this frequency would be zero.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To characterize the response of the heated HARCO sensor, boundary-layer
 flight segments from the SOCRATES and CSET projects (referenced earlier
 in connection with the unheated probe) were compiled into one data set
 from the flight periods shown in Table
\begin_inset space ~
\end_inset

2.
 An unheated Rosemount 102E4AL sensor was also available, so corrected measureme
nts from that sensor were used as the reference against which to determine
 the gain and phase of the transfer function.
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Project / Flight
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
start [UTC]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
end [UTC]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CSET / 5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2015-07-14 17:52:00
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
18:02:00
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CSET / 5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2015-07-14 19:45:30
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
19:55:30
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CSET / 5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2015-07-14 20:37:17
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20:47:17
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SOCRATES / 15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2018-02-24 5:52:00
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6:02:00
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SOCRATES / 15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2018-02-24 6:05:00
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6:15:00
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Flight segments used to determine the response characteristics of a heated
 HARCO sensor.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<GVHARCO, include = TRUE, fig.height = 6, fig.show='asis', fig.cap = 'The
 gain (top) and phase (bottom) for the transfer function characterizing
 a heated HARCO temperature sensor.
 The measurements are indicated by error bars that show two-standard-deviation
 limits from the mean value).
 Two fits to the measurements, one based on the three-parameter representation
 (
\begin_inset Quotes eld
\end_inset

3-par
\begin_inset Quotes erd
\end_inset

) and one on a polynomial fit (
\begin_inset Quotes eld
\end_inset

lfit
\begin_inset Quotes erd
\end_inset

), are described in the text.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SB <- 50
\end_layout

\begin_layout Plain Layout

RXA <- DSX %>% selectTime(55200, 60200) %>% CohP('RTH1', 'RT', plotType='Ranadu'
, smoothBins=SB)
\end_layout

\begin_layout Plain Layout

RXB <- DSX %>% selectTime(60500, 61500) %>% CohP('RTH1', 'RT', plotType='Ranadu'
, smoothBins=SB)
\end_layout

\begin_layout Plain Layout

RXC <- DCX %>% selectTime(175200, 180200) %>% CohP('RTH1', 'RT', plotType='Ranad
u', smoothBins=SB)
\end_layout

\begin_layout Plain Layout

RXD <- DCX %>% selectTime(194530, 195530) %>% CohP('RTH1', 'RT', plotType='Ranad
u', smoothBins=SB)
\end_layout

\begin_layout Plain Layout

RXE <- DCX %>% selectTime(203717, 204717) %>% CohP('RTH1', 'RT', plotType='Ranad
u', smoothBins=SB)
\end_layout

\begin_layout Plain Layout

## May need to revise this with corrected RT in second iteration
\end_layout

\begin_layout Plain Layout

Z <- capture.output (Vr <- SmoothInterp(detrend (DSA[, c('Time', 'RTH1')]),
 .Length=0))
\end_layout

\begin_layout Plain Layout

Z <- capture.output (VrC <- SmoothInterp(detrend (DSA[, c('Time', 'RT')]),
 .Length=0))
\end_layout

\begin_layout Plain Layout

Rate <- attr(DSA, 'Rate')
\end_layout

\begin_layout Plain Layout

vcv <- cbind(ts(Vr, frequency=Rate), ts(VrC, frequency=Rate))
\end_layout

\begin_layout Plain Layout

P <- spec.pgram(vcv, detrend=FALSE, fast=TRUE, plot=FALSE, spans=25)
\end_layout

\begin_layout Plain Layout

df1SH <- data.frame(P$coh, log(P$freq))
\end_layout

\begin_layout Plain Layout

df2SH <- data.frame (P$phase, log(P$freq))
\end_layout

\begin_layout Plain Layout

pf1SH <- binStats (df1SH, bins=SB)
\end_layout

\begin_layout Plain Layout

pf2SH <- binStats (df2SH, bins=SB)
\end_layout

\begin_layout Plain Layout

phaseSH <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

nphaseSH <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

phase2SH <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

arSH <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

ar2SH <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

narSH <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

for (RX in list(RXA, RXB, RXC, RXD, RXE)) {
\end_layout

\begin_layout Plain Layout

  for (i in 2:nrow(RX)) {
\end_layout

\begin_layout Plain Layout

    phaseSH[RX$BIN.1[i]] <- phaseSH[RX$BIN.1[i]] + RX$P.phase[i]
\end_layout

\begin_layout Plain Layout

    nphaseSH[RX$BIN.1[i]] <- nphaseSH[RX$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

    phase2SH[RX$BIN.1[i]] <- phase2SH[RX$BIN.1[i]] + RX$P.phase[i]^2
\end_layout

\begin_layout Plain Layout

    arSH[RX$BIN.1[i]] <- arSH[RX$BIN.1[i]] + sqrt(RX$P.spec...1.[i] / RX$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

    ar2SH[RX$BIN.1[i]] <- ar2SH[RX$BIN.1[i]] + (RX$P.spec...1.[i] / RX$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

    narSH[RX$BIN.1[i]] <- narSH[RX$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

nphaseSH[nphaseSH == 0] <- 1
\end_layout

\begin_layout Plain Layout

narSH[narSH == 0] <- 1
\end_layout

\begin_layout Plain Layout

mphaseSH <- phaseSH/nphaseSH
\end_layout

\begin_layout Plain Layout

mphase2SH <- phase2SH/nphaseSH
\end_layout

\begin_layout Plain Layout

sdpSH <- sqrt(mphase2SH - mphaseSH^2)
\end_layout

\begin_layout Plain Layout

mphaseSH <- mphaseSH * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpSH <- sdpSH * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpSH <- sdpSH * 2 / sqrt(nphaseSH)
\end_layout

\begin_layout Plain Layout

arSH <- arSH / narSH
\end_layout

\begin_layout Plain Layout

ar2SH <- ar2SH / narSH
\end_layout

\begin_layout Plain Layout

b <- ar2SH - arSH^2
\end_layout

\begin_layout Plain Layout

b[near(b, 0)] <- 0
\end_layout

\begin_layout Plain Layout

sdrSH <- sqrt(b)
\end_layout

\begin_layout Plain Layout

sdrSH <- sdrSH * 2 / sqrt(narSH)
\end_layout

\begin_layout Plain Layout

dfSH <- data.frame(frq=exp(pf2SH$xc), mphase=mphaseSH, sdp=sdpSH)
\end_layout

\begin_layout Plain Layout

dfSH <- dfSH[dfSH$frq > 0.01, ]
\end_layout

\begin_layout Plain Layout

dfSH <- dfSH[dfSH$sdp > 0, ]
\end_layout

\begin_layout Plain Layout

dfSH <- dfSH[dfSH$frq < 2, ]
\end_layout

\begin_layout Plain Layout

dfrSH <- data.frame(frq=exp(pf2SH$xc), mrspec=arSH, sdr=sdrSH)
\end_layout

\begin_layout Plain Layout

dfrSH <- dfrSH[dfrSH$frq > 0.01, ]
\end_layout

\begin_layout Plain Layout

dfrSH <- dfrSH[dfrSH$sdr > 0, ]
\end_layout

\begin_layout Plain Layout

dfrSH <- dfrSH[dfrSH$frq < 2, ]
\end_layout

\begin_layout Plain Layout

frq <- exp(pf2SH$xc)
\end_layout

\begin_layout Plain Layout

Parm <- Param1
\end_layout

\begin_layout Plain Layout

Parm$a <- 0.1
\end_layout

\begin_layout Plain Layout

Parm$tau1 <- 0.1
\end_layout

\begin_layout Plain Layout

Parm$tau2 <- 1.5
\end_layout

\begin_layout Plain Layout

minFn <- function(V) {
\end_layout

\begin_layout Plain Layout

  Parm$a <<- V[1]
\end_layout

\begin_layout Plain Layout

  Parm$tau1 <<- V[2]
\end_layout

\begin_layout Plain Layout

  Parm$tau2 <<- V[3]
\end_layout

\begin_layout Plain Layout

  Chisq <- 0
\end_layout

\begin_layout Plain Layout

  for (i in 1:nrow(dfSH)) {
\end_layout

\begin_layout Plain Layout

    Chisq <- Chisq + (dfSH$mphase[i] - LTphase(dfSH$frq[i], Parm)$Phase)^2
 / dfSH$sdp[i]^2
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  for (i in 1:nrow(dfrSH)) {
\end_layout

\begin_layout Plain Layout

    Chisq <- Chisq + (dfrSH$mrspec[i] - LTphase(dfrSH$frq[i], Parm)$Amp)^2
 / dfrSH$sdr[i]^2
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return (Chisq)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

ASH <- optim (c(Parm$a, Parm$tau1, Parm$tau2), minFn, method='L-BFGS-B',
 
\end_layout

\begin_layout Plain Layout

              lower=0, hessian=TRUE)
\end_layout

\begin_layout Plain Layout

bestSH <- ASH$par
\end_layout

\begin_layout Plain Layout

HerrorSH <- solve(ASH$hessian / 4)  # factor of 4 because 2-sigma errors
 were used?
\end_layout

\begin_layout Plain Layout

uncLimitsSH <- sqrt(diag(HerrorSH))
\end_layout

\begin_layout Plain Layout

# print(bestSH)
\end_layout

\begin_layout Plain Layout

HSH <- LTphase(dfrSH$frq, Parm)
\end_layout

\begin_layout Plain Layout

dfrSH$Amp <- HSH$Amp
\end_layout

\begin_layout Plain Layout

dfrSH$Phase <- HSH$Phase
\end_layout

\begin_layout Plain Layout

ParamSH <- Param2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

g <- ggplot(dfSH, aes(x=frq, y=mphase))+geom_point()
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab (bquote('phase [' * degree * ']'))
\end_layout

\begin_layout Plain Layout

g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=2),
\end_layout

\begin_layout Plain Layout

                       labels = trans_format("log10", math_format(expr =
 10^.x))) + xlab('frequency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = "bt")
\end_layout

\begin_layout Plain Layout

g <- g + geom_errorbar(aes(ymin=mphase-sdp, ymax=mphase+sdp), width=0.06)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfrSH, aes(x=frq, y=Phase), col='forestgreen')
\end_layout

\begin_layout Plain Layout

cf <- coef(lm(data=dfSH, mphase ~ log(frq)+I(log(frq)^2)+I(atan(frq))))
\end_layout

\begin_layout Plain Layout

dfSH$Ph <- cf[1]+cf[2]*log(dfSH$frq) + cf[3]*log(dfSH$frq)^2 + 
\end_layout

\begin_layout Plain Layout

           cf[4]*atan(dfSH$frq)
\end_layout

\begin_layout Plain Layout

dfSH$PhLT <- LTphase(dfSH$frq, Parm)$Phase
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfSH, aes(x=frq, y=Ph, col='lfit', lty='lfit'))
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfSH, aes(x=frq, y=PhLT, col='3-par', lty='3-par'))
\end_layout

\begin_layout Plain Layout

# g <- g + geom_path(data=dfAPSH, aes(x=Time, y=Phase), col='darkorange')
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  g + scale_colour_manual (
\end_layout

\begin_layout Plain Layout

    name = 'fit: ',
\end_layout

\begin_layout Plain Layout

    values = c("lfit" = "forestgreen", "3-par" = "blue")
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

g <- g + scale_linetype_manual (name = 'fit: ', 
\end_layout

\begin_layout Plain Layout

                                values = c('lfit' = 4, '3-par'=1))
\end_layout

\begin_layout Plain Layout

g1 <- g + theme_WAC(1) + theme(legend.position = c(0.75, 0.9))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

frq <- exp(pf2SH$xc[narSH > 0])
\end_layout

\begin_layout Plain Layout

g <- ggplot(dfrSH, aes(x=frq, y=mrspec))+geom_point()
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab ('amplitude ratio')
\end_layout

\begin_layout Plain Layout

g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=2),
\end_layout

\begin_layout Plain Layout

                       labels = trans_format("log10", math_format(expr =
 10^.x))) + xlab('frequency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = "bt")
\end_layout

\begin_layout Plain Layout

g <- g + geom_errorbar(aes(ymin=mrspec-sdr, ymax=mrspec+sdr), width=0.06)
\end_layout

\begin_layout Plain Layout

# g <- g + geom_path(data=dfAPSH, aes(x=Time, y=Amp), col='darkorange')
\end_layout

\begin_layout Plain Layout

cfr <- coef(lm(data=dfrSH, mrspec ~ log(frq) + I(log(frq)^3) + 
\end_layout

\begin_layout Plain Layout

               I(log(frq)^5)))
\end_layout

\begin_layout Plain Layout

cfr <- coef(lm(data=dfrSH, mrspec ~ log(frq) + I(log(frq)^3) +
\end_layout

\begin_layout Plain Layout

            I(log(frq)^4)+I(log(frq)^5)))
\end_layout

\begin_layout Plain Layout

fr <- log(dfrSH$frq)
\end_layout

\begin_layout Plain Layout

dfrSH$G <- cfr[1] + fr * (cfr[2] + fr * fr * (cfr[3] + fr * (cfr[4] + 
\end_layout

\begin_layout Plain Layout

                     fr * cfr[5])))
\end_layout

\begin_layout Plain Layout

dfrSH$G[dfrSH$frq < 0.024] <- 1
\end_layout

\begin_layout Plain Layout

dfrSH$GLT <- LTphase(dfrSH$frq, Parm)$Amp
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfrSH, aes(x=frq, y=G, col='lfit', lty='lfit'))
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfrSH, aes(x=frq, y=GLT, col='3-par', lty='3-par'))
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  g + scale_colour_manual (
\end_layout

\begin_layout Plain Layout

    name = 'fit: ',
\end_layout

\begin_layout Plain Layout

    values = c("lfit" = "forestgreen", "3-par" = "blue")
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

g <- g + scale_linetype_manual (name = 'fit: ', 
\end_layout

\begin_layout Plain Layout

                                values = c('lfit' = 4, '3-par'=1))
\end_layout

\begin_layout Plain Layout

g2 <- g + ylim(0, 1.3) + theme_WAC(1) + theme(legend.position = c(0.75, 0.9))
\end_layout

\begin_layout Plain Layout

g2 <- g2 + theme(plot.margin=unit(c(0.3,0.3,1.1,2.0),"lines"))  ## small adjustment
 for alignment
\end_layout

\begin_layout Plain Layout

g2 <- g2 + theme(axis.title.y = element_text(vjust=4))
\end_layout

\begin_layout Plain Layout

grid.newpage()
\end_layout

\begin_layout Plain Layout

vp2 <- viewport(y=unit(0.61, 'npc'), height=unit(0.5, 'npc'),layout.pos.row=2)
\end_layout

\begin_layout Plain Layout

vp1 <- viewport(y=unit(0.25, 'npc'), height=unit(0.5, 'npc'),layout.pos.row=1)
\end_layout

\begin_layout Plain Layout

print(g2, vp=vp2)
\end_layout

\begin_layout Plain Layout

print(g1, vp=vp1)
\end_layout

\begin_layout Plain Layout

grid.newpage()
\end_layout

\begin_layout Plain Layout

# suppressWarnings(print(g + ylim(0, 1.3) + theme(legend.position = c(0.75,
 0.9)) + theme_WAC(1)))
\end_layout

\begin_layout Plain Layout

# CohPhase(DSA, 'RTH1', 'RTF1')
\end_layout

\begin_layout Plain Layout

# DSA %>% select(Time, TASX, RTH1, RT, ATH1) %>% VSpec()
\end_layout

\begin_layout Plain Layout

# print(bestSH)
\end_layout

\begin_layout Plain Layout

## Save for later use:
\end_layout

\begin_layout Plain Layout

cfHARCO <- cf
\end_layout

\begin_layout Plain Layout

cfrHARCO <- cfr
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The measured phase and amplitude ratio for this data set are shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:GVHARCO}
\end_layout

\end_inset

.
 The fit for the response function defined by 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:responseAmp"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:responsePhase"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is shown as the blue line labeled 
\begin_inset Quotes eld
\end_inset

3-par
\begin_inset Quotes erd
\end_inset

 in that figure.
 The fitted values for {
\begin_inset Formula $a,\,\tau_{1},\,\tau_{2}$
\end_inset

} were {0, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestSH[2], 2)}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestSH[3], 2)}
\end_layout

\end_inset

}, and to obtain this result the fit had to be constrained to keep 
\begin_inset Formula $a$
\end_inset

 non-negative.
 A value of zero for the parameter 
\begin_inset Formula $a$
\end_inset

 would indicate that no heat is transferred from the sensing wire to the
 air, but instead all is transferred to the support which has a relatively
 slow characteristic response.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
The transfer function and typical variance spectrum for the heated Rosemount
 102 sensor is quite similar to this plot, , and the typical variance spectrum
 shows a decrease with frequency similar to that in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:HARCOSpec}
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The three-parameter fit is not consistent with the measurement errors even
 though it provides an approximate representation of the transfer function.
 The apparent reason is that there is conflict between the constraints imposed
 by the amplitude ratio and the phase, such that either could be represented
 reasonably but not both.
 The actual transfer function has some complex features, including frequencies
 where the phase shift reaches values below 
\begin_inset Formula $-90^{\circ}$
\end_inset

 (not possible for a simple exponential time response) and values of the
 phase shift of about 
\begin_inset Formula $-38^{\circ}$
\end_inset

 at 0.1
\begin_inset space ~
\end_inset

Hz where the amplitude ratio is still high (about 0.75).
 The amplitude decreases to 
\begin_inset Formula $e^{-1}$
\end_inset

 at about 0.34
\begin_inset space ~
\end_inset

Hz, as would be the case for a first-order time constant of about 1.3
\begin_inset space ~
\end_inset

s, so this could be considered another measure of the response.
 However, that value does not extrapolate well to other frequencies and
 the phase shift at 0.34
\begin_inset space ~
\end_inset

Hz is approximately 
\begin_inset Formula $-73^{\circ}$
\end_inset

, which would indicate that the measurement of a real contribution to sensible-h
eat flux at this frequency would be only about 10% of the correct value.
\end_layout

\begin_layout Standard
Because the three-parameter fit distorted the measured result, fits in the
 logarithm of the frequency were used to provide a better representation
 of the measurements, as shown by the dashed green lines labeled 
\begin_inset Quotes eld
\end_inset

lfit
\begin_inset Quotes erd
\end_inset

.
 Those fits are given by these equations and coefficients, with 
\begin_inset Formula $x=\log_{e}(\nu/\nu_{0})$
\end_inset

 where 
\begin_inset Formula $\nu$
\end_inset

 is the frequency, 
\begin_inset Formula $\omega=2\pi\nu$
\end_inset

 and 
\begin_inset Formula $\nu_{0}=1\,\mathrm{Hz}$
\end_inset

:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\mathrm{for}\,\nu>0.024\,\mathrm{Hz,\,\,}H(\omega)=(h_{0}+h_{1}x+h_{2}x^{3}+h_{3}x^{4}+h_{4}x^{5})e^{i\phi(\omega)}\label{eq:lfitH}
\end{equation}

\end_inset


\begin_inset Formula 
\[
\mathrm{for\:\nu\leq0.024\,\mathrm{Hz},\quad}H(\omega)=1
\]

\end_inset


\begin_inset Formula 
\[
\phi(\omega)=p_{0}+p_{1}x+p_{2}x^{2}+p_{3}\arctan(\nu/\nu_{0})
\]

\end_inset

The coefficients obtained by fitting to the observations are 
\begin_inset Formula $h_{0-4}=$
\end_inset

{
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{round(cfr[1], 3)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{round(cfr[2], 3)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{format(cfr[3], digits=3, nsmall=4)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{round(cfr[4], 4)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{round(cfr[5], 5)}$
\end_layout

\end_inset

} and 
\begin_inset Formula $p_{0-3}=$
\end_inset

{
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{round(cf[1], 1)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{round(cf[2], 1)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{round(cf[3], 2)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{round(cf[4], 1)}$
\end_layout

\end_inset

}.
 This fit can be used to represent the transfer function better than the
 three-parameter fit (with negative-frequency values defined as the complex
 conjugate of the values at the corresponding positive frequency), although
 the fit needs to be modified above about 2
\begin_inset space ~
\end_inset

Hz because those values were not constrained by the measurements.
 A suggested modification is to duplicate the value at 2
\begin_inset space ~
\end_inset

Hz to higher frequencies; this appears to be adequate because there is so
 little variance measured by this sensor at these frequencies, but it is
 important to avoid possible zeroes that otherwise arise from extrapolation.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
For the contribution of these measurements to fits to determine the response
 parameters, measurements of phase were used only for frequencies from 0.05
 to 1
\begin_inset space ~
\end_inset

Hz and those of amplitude ratio only for frequencies from 0.13 to 1
\begin_inset space ~
\end_inset

Hz.
 The fit does not appear to be as consistent with the measured values as
 the fit for the unheated Rosemount
\begin_inset Foot
status open

\begin_layout Plain Layout
Chi-square 405 for 36 degrees of freedom.
\end_layout

\end_inset

, especially in regard to the amplitude, perhaps indicating that the two-differe
ntial-equation representation of the response is incomplete in this case.
 The best-fit parameters indicated for this sensor are 
\begin_inset Formula $a=$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestHS[1], 2)}
\end_layout

\end_inset

, 
\begin_inset Formula $\tau_{1}=$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestHS[2], 2)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

s and 
\begin_inset Formula $\tau_{2}=$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestHS[3], 2)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

s for sensor 1 (RTH1) and 
\begin_inset Formula $a=$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestHSB[1], 2)}
\end_layout

\end_inset

, 
\begin_inset Formula $\tau_{1}=$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestHSB[2], 2)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

s and 
\begin_inset Formula $\tau_{2}=$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestHSB[3], 2)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

s for sensor 2 (RTH2).
 The best fit indicates that most heat transfer from or to the wire comes
 from the support and only a smaller fraction is contributed by the air
 itself.
 However, this is still a two-time-constant fit because the support responds
 to the air temperature and the wire separately responds to the support
 temperature.
 This leads to phase shifts more negative than 
\begin_inset Formula $-90^{\circ}$
\end_inset

, which would not be possible for a single-time-constant response.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Expected dependence on flight conditions
\begin_inset CommandInset label
LatexCommand label
name "subsec:Expected-dependence-on"

\end_inset


\end_layout

\begin_layout Standard
Based on measurements in a wind tunnel, 
\begin_inset CommandInset citation
LatexCommand citet
key "GoodrichTR5755"
literal "false"

\end_inset

 indicated that the fast-response characteristic time 
\begin_inset Formula $\tau_{1}$
\end_inset

 for the unheated Rosemount 102E4AL sensor varies approximately as 
\begin_inset Formula $\log(Z^{-0.6})$
\end_inset

 where 
\begin_inset Formula $Z=M\rho_{a}/\rho_{s}$
\end_inset

 with 
\begin_inset Formula $M$
\end_inset

 the Mach number, 
\begin_inset Formula $\rho_{a}$
\end_inset

 the air density and 
\begin_inset Formula $\rho_{0}$
\end_inset

 the air density under standard conditions.
 The mean value of 
\begin_inset Formula $Z$
\end_inset

 for the flight segments used to find the best-fit parameters was 
\begin_inset Formula $Z=0.3$
\end_inset

, so this suggests that the first characteristic time for that sensor is
 best represented by
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\tau_{1}^{\prime}(Z)=\tau_{1}\left(\frac{0.3}{Z}\right)^{0.6}\,\,\,.\label{eq:tau1prime}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
For GV flight conditions, 
\begin_inset Formula $Z$
\end_inset

 can vary from about 0.18 to 0.38, so this suggests a range for 
\begin_inset Formula $\tau_{1}$
\end_inset

 from 0.029 to 0.046
\begin_inset space ~
\end_inset

s.
\end_layout

\end_inset

 There is no similar evidence for 
\begin_inset Formula $\tau_{2}$
\end_inset

, but it might be expected to have similar dependence because this is approximat
ely the Reynolds number dependence and the Nusselt number characterizing
 ventilated heat transfer often is represented by a power-law relationship
 to the Reynolds number.
 If both heat transfer terms scale similarly, it might be expected that
 
\begin_inset Formula $a$
\end_inset

 will be unchanged.
\end_layout

\begin_layout Standard
For these reasons, the time parameters obtained in preceding sections have
 been adjusted to a reference value of 
\begin_inset Formula $Z=0.3$
\end_inset

 in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Parameters"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 For other conditions, it is suggested that the best estimate will be to
 multiply 
\begin_inset Formula $\tau_{1}$
\end_inset

 and 
\begin_inset Formula $\tau_{2}$
\end_inset

 by 
\begin_inset Formula $(0.3/Z)^{0.6}$
\end_inset

.
 (Having these parameters vary is in conflict with the 
\begin_inset Quotes eld
\end_inset

LTI
\begin_inset Quotes erd
\end_inset

 assumption leading to the transfer function, but these variations are minor
 over short times so incorporating this variation should produce reasonable
 results.)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<adjustP, include=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

rhozero <- 1013.25 * 100 / (287.05 * 288.15)
\end_layout

\begin_layout Plain Layout

MRHO <- MachNumber(DZV$PSXC, DZV$QCXC) * DZV$PSXC * 100 / 
\end_layout

\begin_layout Plain Layout

        (287.05 * (273.15 + DZV$ATX)) / rhozero
\end_layout

\begin_layout Plain Layout

Param1$tau1 <- Param1$tau1 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ 0.6
\end_layout

\begin_layout Plain Layout

Param1$tau2 <- Param1$tau2 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ 0.6
\end_layout

\begin_layout Plain Layout

MRHO <- MachNumber(DS$PSXC, DS$QCXC) * DS$PSXC * 100 / 
\end_layout

\begin_layout Plain Layout

        (287.05 * (273.15 + DS$ATX)) / rhozero
\end_layout

\begin_layout Plain Layout

# ParamHS$tau1 <- ParamHS$tau1 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ 0.6
\end_layout

\begin_layout Plain Layout

# ParamHS$tau2 <- ParamHS$tau2 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ 0.6
\end_layout

\begin_layout Plain Layout

# ParamHSB$tau1 <- ParamHSB$tau1 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ 0.6
\end_layout

\begin_layout Plain Layout

# ParamHSB$tau2 <- ParamHSB$tau2 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ 0.6
\end_layout

\begin_layout Plain Layout

bestSH[2] <- bestSH[2] * (mean(MRHO, na.rm = TRUE) / 0.3) ^ 0.6
\end_layout

\begin_layout Plain Layout

bestSH[3] <- bestSH[3] * (mean(MRHO, na.rm = TRUE) / 0.3) ^ 0.6
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
sensor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\begin_inset Formula $a$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\begin_inset Formula $\tau_{1}$
\end_inset


\series default
 [s]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\begin_inset Formula $\tau_{2}$
\end_inset


\series default
 [s]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
unheated Rosemount 102E4ALon C-130
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(Param1$a, 2)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(Param1$tau1, 3)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(Param1$tau2,2)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
unheated Rosemount 102E4AL on GV
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{format(ParGV$a, digits=2, nsmall=2)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(ParGV$tau1, 3)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{format(ParGV$tau2, digits=2, nsmall=2)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
heated HARCO
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{format(bestSH[1], digits=1, nsmall=1)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{format(bestSH[2], digits=2, nsmall=2)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{format(bestSH[3], digits=2, nsmall=2)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Parameters for the time response of available temperature sensors on the
 NSF/NCAR aircraft, adjusted to 
\begin_inset Formula $Z=0.3$
\end_inset

.
 For other conditions, scale as represented for 
\begin_inset Formula $\tau_{1}^{\prime}$
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:tau1prime"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\begin_inset CommandInset label
LatexCommand label
name "tab:Parameters"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\lang english
heated Rosemount 102 on C-130		
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
\lang american

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{format(bestW[1], digits=2, nsmall=2)}
\end_layout

\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\lang english
	
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
\lang american

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{format(bestW[2], digits=2, nsmall=2)}
\end_layout

\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
\lang english

 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
\lang american

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{format(bestW[3], digits=2, nsmall=2)}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
heated Rosemount on C-130
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(ParamW$a, 2)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(ParamW$tau1, 2)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(ParamW$tau2, 2)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Response to a step change
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<VOCALSrf03, include=FALSE, echo=FALSE, fig.height=4, fig.cap='Temperature
 measured during descent through an inversion capping the marine boundary
 layer, from VOCALS flight 3, starting at 8:13:50 UTC.
 The descent rate was approximately 5 m/s.
 The dashed red line shows a dry-adiabatic lapse rate in the marine boundary
 layer, and the dashed blue line is a reference line indicating the location
 of the top of the boundary layer.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Data <-
\end_layout

\begin_layout Plain Layout

  getNetCDF(
\end_layout

\begin_layout Plain Layout

    file.path(DataDirectory(), 'VOCALS/VOCALSrf03h.nc'),
\end_layout

\begin_layout Plain Layout

    c(
\end_layout

\begin_layout Plain Layout

      'PALT',
\end_layout

\begin_layout Plain Layout

      'GGALT_NTL',
\end_layout

\begin_layout Plain Layout

      'ATX',
\end_layout

\begin_layout Plain Layout

      'ATRL',
\end_layout

\begin_layout Plain Layout

      'ATRR',
\end_layout

\begin_layout Plain Layout

      'ATWH',
\end_layout

\begin_layout Plain Layout

      'DPXC',
\end_layout

\begin_layout Plain Layout

      'PSXC',
\end_layout

\begin_layout Plain Layout

      'QCXC',
\end_layout

\begin_layout Plain Layout

      'TTRR'
\end_layout

\begin_layout Plain Layout

    )
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

Data %>% select(Time, PALT, ATRR) %>% 
\end_layout

\begin_layout Plain Layout

  selectTime(81350, 81358) %>%
\end_layout

\begin_layout Plain Layout

  select(ATRR) %>% 
\end_layout

\begin_layout Plain Layout

  plot(
\end_layout

\begin_layout Plain Layout

    type = 'b',
\end_layout

\begin_layout Plain Layout

    pch = 20,
\end_layout

\begin_layout Plain Layout

    ylab = bquote('ATRR [' * degree ~ 'C]'),
\end_layout

\begin_layout Plain Layout

    xlab = 'sample number',
\end_layout

\begin_layout Plain Layout

    col = 'blue'
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

x <- 0:250
\end_layout

\begin_layout Plain Layout

y <- 6.9 - x * 5 / 25 * 10 / 1000
\end_layout

\begin_layout Plain Layout

lines(x, y, col = 'red', lty = 2)
\end_layout

\begin_layout Plain Layout

abline(v = 10, col = 'black', lty = 2)
\end_layout

\begin_layout Plain Layout

## Get Z for scaling the time constants:
\end_layout

\begin_layout Plain Layout

rhozero <- 1013.25 * 100 / (287.05 * 288.15)
\end_layout

\begin_layout Plain Layout

Z <- MachNumber(Data$PSXC, Data$QCXC) * 100 * Data$PSXC /
\end_layout

\begin_layout Plain Layout

  (287.05 * (273.15 + Data$ATRR)) / rhozero
\end_layout

\begin_layout Plain Layout

ParamS <- ParamSF
\end_layout

\begin_layout Plain Layout

ParamS$tau1 <- ParamS$tau1 * (mean(Z, na.rm = TRUE) / 0.3) ^ 0.6
\end_layout

\begin_layout Plain Layout

ParamS$tau2 <- ParamS$tau2 * (mean(Z, na.rm = TRUE) / 0.3) ^ 0.6
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<tfit, include=TRUE, echo=FALSE, fig.pos='t', fig.cap='(blue dots): Temperature
 measured at 25 Hz during descent through an inversion capping the marine
 boundary layer, from VOCALS flight 3, starting at 8:13:50 UTC.
 The descent rate was approximately 5 m/s.
 The dashed red line shows a dry-adiabatic lapse rate in the marine boundary
 layer, and the dashed black line is a reference line indicating the location
 of the top of the boundary layer.The  prediction using the parameters listed
 in the text is shown as the magenta line, mostly over the blue dots representin
g the measurements.
 The dashed brown line is the calculated temperature of the support that
 contacts the sensing wire.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Data %>% select(Time, PALT, ATRR) %>% 
\end_layout

\begin_layout Plain Layout

  selectTime(81350, 81358) %>% 
\end_layout

\begin_layout Plain Layout

  select(ATRR) %>% 
\end_layout

\begin_layout Plain Layout

  plot(
\end_layout

\begin_layout Plain Layout

    type = 'b',
\end_layout

\begin_layout Plain Layout

    pch = 20,
\end_layout

\begin_layout Plain Layout

    ylab = bquote('temperature [' * degree ~ 'C]'),
\end_layout

\begin_layout Plain Layout

    xlab = 'sample number @ 25 Hz',
\end_layout

\begin_layout Plain Layout

    col = 'blue'
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

x <- 0:200
\end_layout

\begin_layout Plain Layout

y <- 6.9 - x * 5 / 25 * 10 / 1000
\end_layout

\begin_layout Plain Layout

lines(x[11:200], y[11:200], col = 'red', lty = 2)
\end_layout

\begin_layout Plain Layout

lines(c(10, 10), c(y[11], 14.3), col = 'black', lty = 2)
\end_layout

\begin_layout Plain Layout

xx <- 0:2000
\end_layout

\begin_layout Plain Layout

yy <- 6.9 - xx * 5 / 250 * 10 / 1000
\end_layout

\begin_layout Plain Layout

yy[1:110] <- 14.30
\end_layout

\begin_layout Plain Layout

# calculate the response, given tau:
\end_layout

\begin_layout Plain Layout

tau <- 0.05
\end_layout

\begin_layout Plain Layout

taua <- 0.09
\end_layout

\begin_layout Plain Layout

tau2 <- 0.90
\end_layout

\begin_layout Plain Layout

tau2a <- 1.0
\end_layout

\begin_layout Plain Layout

a <- 0.62
\end_layout

\begin_layout Plain Layout

aa <- 0.65
\end_layout

\begin_layout Plain Layout

tau <- Param1$tau1
\end_layout

\begin_layout Plain Layout

# tau2 <- Param1$tau2
\end_layout

\begin_layout Plain Layout

tau2a <- 1.1
\end_layout

\begin_layout Plain Layout

taua <- 0.05
\end_layout

\begin_layout Plain Layout

a <- Param1$a
\end_layout

\begin_layout Plain Layout

a <- ParamS$a
\end_layout

\begin_layout Plain Layout

tau1 <- ParamS$tau1
\end_layout

\begin_layout Plain Layout

tau2 <- ParamS$tau2
\end_layout

\begin_layout Plain Layout

tau1a <- 0.06
\end_layout

\begin_layout Plain Layout

tau2a <- 1.3
\end_layout

\begin_layout Plain Layout

aa <- a - 0.02
\end_layout

\begin_layout Plain Layout

ym <- yy
\end_layout

\begin_layout Plain Layout

ymf <- ym
\end_layout

\begin_layout Plain Layout

yr <- yy
\end_layout

\begin_layout Plain Layout

yra <- yy
\end_layout

\begin_layout Plain Layout

for (i in 2:2000) {
\end_layout

\begin_layout Plain Layout

  yr[i] <- yr[i - 1] + (yy[i] - yr[i - 1]) * 0.004 / tau2
\end_layout

\begin_layout Plain Layout

  yra[i] <- yra[i - 1] + (yy[i] - yra[i - 1]) * 0.004 / tau2a
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

for (i in 2:2000) {
\end_layout

\begin_layout Plain Layout

  ym[i] <-
\end_layout

\begin_layout Plain Layout

    ym[i - 1] + (a * yy[i] + (1 - a) * yr[i] - ym[i - 1]) * 0.004 / tau1
\end_layout

\begin_layout Plain Layout

  ymf[i] <-
\end_layout

\begin_layout Plain Layout

    ymf[i - 1] + (aa * yy[i] + (1 - aa) * yra[i] - ymf[i - 1]) * 0.004 /
 tau1a
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

lines(xx / 10, ym, col = 'magenta', lwd = 3.5, lty=1)
\end_layout

\begin_layout Plain Layout

# lines(xx / 10, ymf, col = 'darkorange', lwd = 2)
\end_layout

\begin_layout Plain Layout

lines(xx / 10,
\end_layout

\begin_layout Plain Layout

      yr,
\end_layout

\begin_layout Plain Layout

      col = 'brown',
\end_layout

\begin_layout Plain Layout

      lwd = 2,
\end_layout

\begin_layout Plain Layout

      lty = 2)
\end_layout

\begin_layout Plain Layout

legend('topright', legend=c('measured','predicted', 'support'),
\end_layout

\begin_layout Plain Layout

       lwd=c(2, 3.5, 2), lty=c(1, 1, 2),
\end_layout

\begin_layout Plain Layout

       col=c('blue', 'magenta', 'brown'))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The preceding subsection developed estimates of the sensor response with
 low uncertainty compared to previous estimates, so that will be the primary
 constraint on these parameters.
 It is nevertheless useful to check if other measurements that are sensitive
 to the time response are consistent with the characterization developed
 in the preceding subsections.
 Previous studies have mostly used sharp temperature changes in the atmosphere,
 for example from climbs through the inversion at the top of a boundary
 layer, to study the time response.
 A search of representative VOCALS climbs and descents through inversions
 capping the marine boundary layer found many with unusable structure but
 one near-ideal example, from VOCALS research flight 3, with a descent through
 the inversion at 8:13:50 UTC.
 Figure 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:tfit}
\end_layout

\end_inset

 shows the time history of the measured temperature for 8
\begin_inset space ~
\end_inset

s during this descent, which was at a rate of approximately 1000
\begin_inset space ~
\end_inset

ft/min (around 5
\begin_inset space ~
\end_inset

m/s).
 The temperature structure in this case was remarkably consistent with a
 near-constant temperature above the inversion and a near-adiabatic temperature
 structure below the inversion.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<VOCALSrf03, include=TRUE, echo=FALSE, fig.height=4, fig.cap='Temperature
 measured during descent through an inversion capping the marine boundary
 layer, from VOCALS flight 3, starting at 8:13:50 UTC.
 The descent rate was approximately 5 m/s.
 The dashed red line shows a dry-adiabatic lapse rate in the marine boundary
 layer, and the dashed blue line is a reference line indicating the location
 of the top of the boundary layer.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Data <- getNetCDF(file.path(DataDirectory(), 'VOCALS/VOCALSrf03h.nc'), c('PALT',
 'GGALT_NTL', 'ATX', 'ATRL', 'ATRR', 'ATWH', 'DPXC', 'PSXC', 'QCXC', 'TTRR'))
\end_layout

\begin_layout Plain Layout

# Data %>% select(Time, PALT, ATX) %>% selectTime(81349, 81351) %>% select(Time,
 ATX) %>% plot()
\end_layout

\begin_layout Plain Layout

# Data %>% select(Time, PALT, ATX) %>% selectTime(81349, 81351) %>% select(Time,
 ATX) %>% plot(type='b', pch=20)
\end_layout

\begin_layout Plain Layout

# Data %>% select(Time, PALT, ATX) %>% selectTime(81350, 81351) %>% select(Time,
 ATX) %>% plot(type='b', pch=20)
\end_layout

\begin_layout Plain Layout

# Data %>% select(Time, PALT, ATRR) %>% selectTime(81350, 81351) %>% select(Time
, ATRR) %>% plot(type='b', pch=20) 
\end_layout

\begin_layout Plain Layout

Data %>% select(Time, PALT, ATRR) %>% selectTime(81350, 81358) %>% select(ATRR)
 %>% plot(type='b', pch=20, ylab='ATRR', xlab='sample number', col='blue')
\end_layout

\begin_layout Plain Layout

x <- 0:250
\end_layout

\begin_layout Plain Layout

y <- 6.9-x*5/25*10/1000 
\end_layout

\begin_layout Plain Layout

lines(x, y, col='red', lty=2) 
\end_layout

\begin_layout Plain Layout

abline(v=10, col='black', lty=2) 
\end_layout

\begin_layout Plain Layout

## Get Z for scaling the time constants: 
\end_layout

\begin_layout Plain Layout

rhozero <- 1013.25*100/(287.05*288.15) 
\end_layout

\begin_layout Plain Layout

Z <- MachNumber(Data$PSXC, Data$QCXC) * 100 * Data$PSXC / 
\end_layout

\begin_layout Plain Layout

     (287.05 * (273.15 + Data$ATRR)) / rhozero 
\end_layout

\begin_layout Plain Layout

ParamS <- Param1 
\end_layout

\begin_layout Plain Layout

ParamS$tau1 <- ParamS$tau1 * (mean(Z, na.rm=TRUE) / 0.3)^0.6 
\end_layout

\begin_layout Plain Layout

ParamS$tau2 <- ParamS$tau2 * (mean(Z, na.rm=TRUE) / 0.3)^0.6
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<<tfit, include=TRUE, echo=FALSE, fig.height=4, fig.cap='The 25 Hz measurements
 from the previous figure (blue dots) and the predictions using the parameters
 listed in the text (green line).
 The dashed brown line is the calculated temperature of the support that
 contacts the sensing wire.
 Also shown as the orange line is the result if the parameters are changed
 to $a=0.713$, $
\backslash

\backslash
tau_1$=0.06 s and $
\backslash

\backslash
tau_2$=1.3 s.'>>=
\end_layout

\begin_layout Plain Layout

Data %>% select(Time, PALT, ATRR) %>% selectTime(81350, 81358) %>% select(ATRR)
 %>% plot(type='b', pch=20, ylab='ATRR', xlab='sample number', col='blue')
 x <- 0:200 y <- 6.9-x*5/25*10/1000 lines(x[11:200], y[11:200], col='red',
 lty=2) lines(c(10,10), c(y[11], 14.3), col='black', lty=2) xx <- 0:2000
 yy <- 6.9 - xx * 5 / 250 * 10 / 1000 yy[1:110] <- 14.30 # calculate the response,
 given tau: tau <- 0.05 taua <- 0.09 tau2 <- 0.90 tau2a <- 1.0 a <- 0.62 aa <-
 0.65 tau <- Param1$tau1 # tau2 <- Param1$tau2 tau2a <- 1.1 taua <- 0.05 a
 <- Param1$a a <- ParamS$a tau1 <- ParamS$tau1 tau2 <- ParamS$tau2 tau1a
 <- 0.06 tau2a <- 1.3 aa <- a - 0.02 ym <- yy ymf <- ym yr <- yy yra <- yy
 for (i in 2:2000) {   yr[i] <- yr[i-1] + (yy[i] - yr[i-1]) * 0.004 / tau2
   yra[i] <- yra[i-1] + (yy[i] - yra[i-1]) * 0.004 / tau2a } for (i in 2:2000)
 {   ym[i] <- ym[i-1] + (a * yy[i] + (1-a) * yr[i] - ym[i-1]) * 0.004 / tau1
    ymf[i] <- ymf[i-1] + (aa * yy[i] + (1-aa) * yra[i] - ymf[i-1]) * 0.004
 / tau1a  } lines(xx/10, ym, col='forestgreen', lwd=2) lines(xx/10, ymf,
 col='darkorange', lwd=2) lines(xx/10, yr, col='brown', lwd=2, lty=2)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

The suggested measurand history, if the discontinuity at the inversion is
 discrete, is that shown by the dashed black and dashed red lines, x(t)=
\backslash
{14.3, 6.878, 6.876, 6.874, 6.872, 6.870, 6.868, 6.866, 6.864, 6.862, 6.860, ...
\backslash
} for t=
\backslash
{10, 11, 12, ...
\backslash
}.
 The predicted time response from 
\backslash
eqref{eq:Tm} for assumed time constants as given in Table 1 for the unheated
 Rosemount 102E4AL sensor adjusted for air density and flight speed ($a=0.733$,
 $
\backslash
tau_{1}=0.030$~s and $
\backslash
tau_{2}=0.43$~s) is shown as the green line in Fig.~
\backslash
ref{fig:tfit}.
 The predicted response is significantly faster than that of the observations,
 and the fit to observations can be improved by adjusting the time constants
 as listed in the figure caption.
 The adjusted values needed to match the observations are so far outside
 estimated uncertainty limits for the parameters that it seems likely that
 the actual temperature at the top of the boundary layer is not as sharply
 discontinuous as assumed but is smoothed by some mixing.
 The rapid initial change does supports a small value of $
\backslash
tau_{1}$, and the results may suggest a longer time constant for the support
 structure, but this evidence is weak in comparison to that arising from
 the phase and amplitude ratio obtained for dynamic heating.
 
\end_layout

\begin_layout Plain Layout


\backslash
subsection{Application to a speed run}
\end_layout

\begin_layout Plain Layout

Because the assumed response of the support is characterized by a simple
 time constant, during the speed run the support will lag in temperature
 by $
\backslash
tau_{2}$.
 Then, from 
\backslash
eqref{eq:Tm}, $T_{m}(t)$ will lag by $
\backslash
tau_{1}$ behind the temperature to which the sensor responds, which is $aT(t)+(1
-a)T(t-
\backslash
tau_{2})$.
 For a ramp input such that $T(t)=T_{0}+kt$, the solution to 
\backslash
eqref{eq:Tm} is that the measured temperature $T_{m}(t)$ lags $T(t)$ by
 $
\backslash
psi$, so that $T_{m}(t)=T_{0}+k(t-
\backslash
psi)$.
 Then
\backslash

\backslash
 
\backslash
[ k
\backslash
tau_{1}=a(T_{0}+kt)+(1-a)(T_{0}+k(t-
\backslash
tau_{2})-T_{0}-kt+k
\backslash
psi 
\backslash
]
\end_layout

\begin_layout Plain Layout

which requires the recovery-temperature lag to be
\backslash

\backslash
 
\backslash
begin{equation} 
\backslash
psi=
\backslash
tau_{1}+(1-a)
\backslash
tau_{2}
\backslash
label{eq:delta} 
\backslash
end{equation}
\end_layout

\begin_layout Plain Layout

<<SRDW, include=TRUE, fig.height=4.2, fig.cap='History of the airspeed during
 a segment of flight 15 from the DEEPWAVE project.'>>=
\end_layout

\begin_layout Plain Layout

Project <- 'DEEPWAVE' Flight <- 'rf15h' startTime <- 32300 endTime <- 32815
 fname <- file.path(DataDirectory(), Project, '/', Project,   Flight,'.nc',
 fsep='') FI <- DataFileInfo(fname, LLrange=FALSE) iv <- which(grepl('^RT',
 FI$Variables)) ProjDir <- Project VL <- c('TASX', 'EWX', 'PSXC', 'RTX',
 'RTH1', 'RTH2', 'RTF1', 'ATX',   'GGALT', 'PITCH', 'ADIFR', 'QCF', 'AKRD',
 'WIC', 'QCXC') VL <- c(VL, FI$Variables[iv]) VL <- unique(VL) DSR <- getNetCDF
 (sprintf ('%s%s/%s%s.nc', DataDirectory (),   ProjDir, Project, Flight),
 VL,    Start=startTime, End=endTime) DSR %>% select(Time, TASX) %>% selectTime(
32310, 32700) %>% plotWAC() ## Find the average Z: (but there is significant
 Mach number variation...) Z <- MachNumber(DSR$PSXC, DSR$QCXC) * 100 * DSR$PSXC
 / (287.05 * (273.15 + DSR$ATX)) / rhozero ParamS <- Param1 ParamS$tau1 <-
 ParamS$tau1 * (mean(Z, na.rm=TRUE) / 0.3)^0.6 ParamS$tau2 <- ParamS$tau2 *
 (mean(Z, na.rm=TRUE) / 0.3)^0.6 ParamWZ <- ParamW ParamHZ <- ParamHS ParamWZ$tau1
 <- ParamW$tau1 * (mean(Z, na.rm=TRUE) / 0.3)^0.6 ParamHZ$tau1 <- ParamHZ$tau1
 * (mean(Z, na.rm=TRUE) / 0.3)^0.6 ParamWZ$tau2 <- ParamW$tau2 * (mean(Z, na.rm=TRUE
) / 0.3)^0.6 ParamHZ$tau2 <- ParamHZ$tau2 * (mean(Z, na.rm=TRUE) / 0.3)^0.6
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

For the Rosemount 102E4AL, the fitted values from the previous subsection
 would then cause a lag
\end_layout

\begin_layout Plain Layout

y <- 6.9-x*5/25*10/1000
\end_layout

\begin_layout Plain Layout

lines(x, y, col='red', lty=2)
\end_layout

\begin_layout Plain Layout

abline(v=10, col='black', lty=2)
\end_layout

\begin_layout Plain Layout

## Get Z for scaling the time constants:
\end_layout

\begin_layout Plain Layout

rhozero <- 1013.25*100/(287.05*288.15)
\end_layout

\begin_layout Plain Layout

Z <- MachNumber(Data$PSXC, Data$QCXC) * 100 * Data$PSXC / (287.05 * (273.15
 + Data$ATRR)) / rhozero
\end_layout

\begin_layout Plain Layout

ParamS <- Param1
\end_layout

\begin_layout Plain Layout

ParamS$tau1 <- ParamS$tau1 * (mean(Z, na.rm=TRUE) / 0.3)^0.6
\end_layout

\begin_layout Plain Layout

ParamS$tau2 <- ParamS$tau2 * (mean(Z, na.rm=TRUE) / 0.3)^0.6
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Also shown as the orange line is the result if the parameters are changed
 to $a=0.713$, $
\backslash

\backslash
tau_1$=0.06 s and $
\backslash

\backslash
tau_2$=1.3 s.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The suggested measurand history, if the discontinuity at the inversion is
 discrete, is that shown by the dashed black and dashed red lines.
\begin_inset Note Note
status open

\begin_layout Plain Layout
, x(t)={14.3, 6.878, 6.876, 6.874, 6.872, 6.870, 6.868, 6.866, 6.864, 6.862, 6.860,
 ...} for t={10, 11, 12, ...}
\end_layout

\end_inset

.
 The predicted time response from 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for assumed time constants for the unheated Rosemount 102E4AL sensor adjusted
 for air density and flight speed is shown as the magenta line in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:tfit}
\end_layout

\end_inset

.
 The predicted response is consistent with the observations and supports
 the approximate validity of the parameters determined from fits to the
 response to dynamic heating.
\end_layout

\begin_layout Subsection
Application to a 
\begin_inset Quotes eld
\end_inset

speed run
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
Another situation where a temperature lag can be observed is when the airspeed
 changes during level flight and causes a change in dynamic heating.
 An example is shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:SRDW}
\end_layout

\end_inset

, where the airspeed was increased steadily in level flight from near the
 lower limit of the flight envelope to near the upper limit and then was
 decreased back to the starting value.
 A plot of recovery temperature should also increase and decrease as the
 dynamic heating changes, but with a lag caused by the sensor response.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The assumed model provided by 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 leads to a prediction of the time lag.
 Because the assumed response of the support is characterized by a simple
 time constant, during the speed run the support will lag in temperature
 by 
\begin_inset Formula $\tau_{2}$
\end_inset

.
 Then, from 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

, 
\begin_inset Formula $T_{m}(t)$
\end_inset

 will lag by 
\begin_inset Formula $\tau_{1}$
\end_inset

 behind the temperature to which the sensor responds, which is 
\begin_inset Formula $aT(t)+(1-a)T(t-\tau_{2})$
\end_inset

.
 For a ramp input such that 
\begin_inset Formula $T(t)=T_{0}+kt$
\end_inset

, the solution to 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is that the measured temperature 
\begin_inset Formula $T_{m}(t)$
\end_inset

 lags 
\begin_inset Formula $T(t)$
\end_inset

 by 
\begin_inset Formula $\psi$
\end_inset

, so that 
\begin_inset Formula $T_{m}(t)=T_{0}+k(t-\psi)$
\end_inset

.
 Then
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
k\tau_{1}=a(T_{0}+kt)+(1-a)(T_{0}+k(t-\tau_{2})-T_{0}-kt+k\psi
\]

\end_inset


\end_layout

\begin_layout Plain Layout
which requires the recovery-temperature lag to be
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\psi=\tau_{1}+(1-a)\tau_{2}\label{eq:delta}
\end{equation}

\end_inset


\end_layout

\end_inset

 This lag will produce hysteresis in the measured temperature during the
 speed run.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<SRDW, include=TRUE, fig.pos='t', fig.height=3.2, fig.cap='History of the airspeed
 during a  
\begin_inset Quotes eld
\end_inset

speed-run
\begin_inset Quotes erd
\end_inset

 maneuver where the airspeed varied during level flight over the available
 speed range of the aircraft.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Project <- 'DEEPWAVE'
\end_layout

\begin_layout Plain Layout

Flight <- 'rf15h'
\end_layout

\begin_layout Plain Layout

startTime <- 32300
\end_layout

\begin_layout Plain Layout

endTime <- 32815
\end_layout

\begin_layout Plain Layout

fname <- file.path(DataDirectory(), Project, '/', Project,
\end_layout

\begin_layout Plain Layout

                   Flight, '.nc', fsep = '')
\end_layout

\begin_layout Plain Layout

FI <- DataFileInfo(fname, LLrange = FALSE)
\end_layout

\begin_layout Plain Layout

iv <- which(grepl(
\begin_inset Quotes eld
\end_inset

^RT
\begin_inset Quotes erd
\end_inset

, FI$Variables))
\end_layout

\begin_layout Plain Layout

ProjDir <- Project
\end_layout

\begin_layout Plain Layout

VL <- c(
\end_layout

\begin_layout Plain Layout

  'TASX',
\end_layout

\begin_layout Plain Layout

  'EWX',
\end_layout

\begin_layout Plain Layout

  'PSXC',
\end_layout

\begin_layout Plain Layout

  'RTX',
\end_layout

\begin_layout Plain Layout

  'RTH1',
\end_layout

\begin_layout Plain Layout

  'RTH2',
\end_layout

\begin_layout Plain Layout

  'RTF1',
\end_layout

\begin_layout Plain Layout

  'ATX',
\end_layout

\begin_layout Plain Layout

  'GGALT',
\end_layout

\begin_layout Plain Layout

  'PITCH',
\end_layout

\begin_layout Plain Layout

  'ADIFR',
\end_layout

\begin_layout Plain Layout

  'QCF',
\end_layout

\begin_layout Plain Layout

  'AKRD',
\end_layout

\begin_layout Plain Layout

  'WIC',
\end_layout

\begin_layout Plain Layout

  'QCXC'
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

VL <- c(VL, FI$Variables[iv])
\end_layout

\begin_layout Plain Layout

VL <- unique(VL)
\end_layout

\begin_layout Plain Layout

DSR <- getNetCDF (
\end_layout

\begin_layout Plain Layout

  sprintf ('%s%s/%s%s.nc', DataDirectory (),
\end_layout

\begin_layout Plain Layout

           ProjDir, Project, Flight),
\end_layout

\begin_layout Plain Layout

  VL,
\end_layout

\begin_layout Plain Layout

  Start = startTime,
\end_layout

\begin_layout Plain Layout

  End = endTime
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

DSR %>% select(Time, TASX) %>% 
\end_layout

\begin_layout Plain Layout

  selectTime(32310, 32700) %>% 
\end_layout

\begin_layout Plain Layout

  plotWAC()
\end_layout

\begin_layout Plain Layout

## Find the average Z: (but there is significant Mach number variation...)
\end_layout

\begin_layout Plain Layout

Z <- MachNumber(DSR$PSXC, DSR$QCXC) * 100 * DSR$PSXC / 
\end_layout

\begin_layout Plain Layout

     (287.05 * (273.15 + DSR$ATX)) / rhozero
\end_layout

\begin_layout Plain Layout

ParamS <- Param1
\end_layout

\begin_layout Plain Layout

ParamS$tau1 <- ParamS$tau1 * (mean(Z, na.rm = TRUE) / 0.3) ^ -0.6
\end_layout

\begin_layout Plain Layout

ParamS$tau2 <- ParamS$tau2 * (mean(Z, na.rm = TRUE) / 0.3) ^ -0.6
\end_layout

\begin_layout Plain Layout

ParamHZ <- Param1
\end_layout

\begin_layout Plain Layout

ParamHZ$tau1 <- ParamHZ$tau1 * (mean(Z, na.rm = TRUE) / 0.3) ^ -0.6
\end_layout

\begin_layout Plain Layout

ParamHZ$tau2 <- ParamHZ$tau2 * (mean(Z, na.rm = TRUE) / 0.3) ^ -0.6
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Extra
inverted 0
status open

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<XTR>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

ParamWZ <- ParamW
\end_layout

\begin_layout Plain Layout

ParamWZ$tau1 <- ParamW$tau1 * (mean(Z, na.rm = TRUE) / 0.3) ^ -0.6
\end_layout

\begin_layout Plain Layout

ParamWZ$tau2 <- ParamW$tau2 * (mean(Z, na.rm = TRUE) / 0.3) ^ -0.6
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
For the Rosemount 102E4AL, the fitted values from Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-unheated-Rosemount"
plural "false"
caps "false"
noprefix "false"

\end_inset

 would then cause a lag of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(Param1$tau1+(1-Param1$a)*Param1$tau2, 2)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

s, which is hard to detect.
\begin_inset Branch Extra
inverted 0
status open

\begin_layout Standard
For the heated Rosemount the expected lag is about 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestW[2]+(1-bestW[1])*bestW[3], 2)}
\end_layout

\end_inset

.
\end_layout

\end_inset

For the heated HARCO sensor the predicted lag would be 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestSH[2]+(1-bestSH[1])*bestSH[3], 2)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

s, which is easily observed.
\end_layout

\end_inset

Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:SRRTH1delay}
\end_layout

\end_inset

a shows this hysteresis, which appears as the difference between the segment
 with increasing speed and that with decreasing speed.
\begin_inset Note Note
status open

\begin_layout Plain Layout
The delay can be estimated by shifting the measurements later in time and
 repeating the fit to search for the smallest standard deviation about the
 fitted line.
 The smallest standard deviation occurs for a shift of 2.225
\begin_inset space ~
\end_inset

s, larger than the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(ParamHZ$tau1+(1-ParamHZ$a)*ParamHZ$tau2, 2)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

s expected from the phase-lag analysis.
\end_layout

\end_inset

 A correction based on simply shifting the measurements in time works reasonably
 but doesn't take into account that the Mach number and hence the time parameter
s vary significantly during the speed run.
 A better test of the time-response parameters is to apply the first correction
 scheme outlined in Appendix
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-resulting-transfer"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to the measurements, with varying response parameters dependent on the
 Mach number.
 The specific correction equation used is 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:HARCOsoln"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:srRTH1delay}
\end_layout

\end_inset

b shows that the delay is mostly removed by this procedure.
 The residual standard deviation about the regression fit for recovery temperatu
re as a function of 
\begin_inset Formula $V^{2}/(2C_{p})$
\end_inset

 is reduced from 
\begin_inset Formula $0.26^{\circ}$
\end_inset

C before correction to 
\begin_inset Formula $0.10^{\circ}$
\end_inset

C after correction.
 The minimum standard deviation results from increasing the time constants
 an additional 10%, so measurements from this speed-run maneuver are consistent
 with the predicted time response as found in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Heated-sensors"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to within about this uncertainty.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<SRnodelay, include=FALSE, fig.cap='The recovery temperature measured by
 a heated HARCO sensor during the speed-run maneuver shown in the previous
 figure.
 The abscissa is the dynamic-heating term without the recovery factor, where
 $V$ is the airspeed and $Cp$ is the specific heat at constant pressure.
 The measurements while the airspeed was increasing are shown by the green
 line and those for decreasing airspeed by the red line.
 The dashed orange line indicates the regression fit, with standard deviation
 about the fit of 0.26$^{
\backslash

\backslash
circ}$C.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Cp <- SpecificHeats (DSR$EWX / DSR$PSXC)[, 1]
\end_layout

\begin_layout Plain Layout

DSR$X <- DSR$TASX ^ 2 / (2 * Cp)
\end_layout

\begin_layout Plain Layout

Rate <- 1
\end_layout

\begin_layout Plain Layout

if (grepl('h', Flight)) {
\end_layout

\begin_layout Plain Layout

  Rate <- 25
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

DSR$RT <- DSR$RTH1
\end_layout

\begin_layout Plain Layout

DSS <- DSR
\end_layout

\begin_layout Plain Layout

DSR <- DSR %>% selectTime(32310, 32700)
\end_layout

\begin_layout Plain Layout

DSR <- transferAttributes(DSS, DSR)
\end_layout

\begin_layout Plain Layout

cf <- coef(fm <- lm (RT ~ X, data = DSR))
\end_layout

\begin_layout Plain Layout

rms <- summary(fm)$sigma
\end_layout

\begin_layout Plain Layout

RTSEL <- 'RTH1'
\end_layout

\begin_layout Plain Layout

xp <- c(min(DSR$X, na.rm = TRUE), max(DSR$X, na.rm = TRUE))
\end_layout

\begin_layout Plain Layout

yp <- cf[1] + cf[2] * xp
\end_layout

\begin_layout Plain Layout

d <- data.frame(xp = xp, yp = yp)
\end_layout

\begin_layout Plain Layout

Xlab <- expression(paste(V ^ 2, '/(2', C[p], ')', sep = ''))
\end_layout

\begin_layout Plain Layout

dX <- c(0, diff(DSR$X))
\end_layout

\begin_layout Plain Layout

dXS <- SmoothInterp(dX)
\end_layout

\begin_layout Plain Layout

DSR$RT2 <- DSR$RT
\end_layout

\begin_layout Plain Layout

DSR$RT1 <- DSR$RT
\end_layout

\begin_layout Plain Layout

DSR$RT2[dXS <= 0] <- NA  # Don't plot decreasing-speed as green
\end_layout

\begin_layout Plain Layout

DSR$RT1[dXS >= 0] <- NA
\end_layout

\begin_layout Plain Layout

delay <- 0
\end_layout

\begin_layout Plain Layout

g <- ggplot (data = DSR, aes(x = X, y = RT))
\end_layout

\begin_layout Plain Layout

if (Rate == 1) {
\end_layout

\begin_layout Plain Layout

  g <- g + geom_point(colour = 'blue')
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(aes(y = RT1, colour = 'decreasing'),
\end_layout

\begin_layout Plain Layout

                   na.rm = TRUE,
\end_layout

\begin_layout Plain Layout

                   lwd = 1.1)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(aes(y = RT2, colour = 'increasing'),
\end_layout

\begin_layout Plain Layout

                   lwd = 1.1,
\end_layout

\begin_layout Plain Layout

                   na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(
\end_layout

\begin_layout Plain Layout

  data = d,
\end_layout

\begin_layout Plain Layout

  aes(x = xp, y = yp),
\end_layout

\begin_layout Plain Layout

  colour = 'darkorange',
\end_layout

\begin_layout Plain Layout

  lwd = 1.5,
\end_layout

\begin_layout Plain Layout

  lty = 2
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

# g <-
\end_layout

\begin_layout Plain Layout

#  g + ggtitle(sprintf(
\end_layout

\begin_layout Plain Layout

#    'sensor is %s; fit coefficients %.1f %.2f rms %.3f; no delay',
\end_layout

\begin_layout Plain Layout

#    RTSEL,
\end_layout

\begin_layout Plain Layout

#    cf[1],
\end_layout

\begin_layout Plain Layout

#    cf[2],
\end_layout

\begin_layout Plain Layout

#    rms
\end_layout

\begin_layout Plain Layout

#  ))
\end_layout

\begin_layout Plain Layout

g <- g + scale_colour_manual (
\end_layout

\begin_layout Plain Layout

  name = 'airspeed: ',
\end_layout

\begin_layout Plain Layout

  values = c("increasing" = "forestgreen", "decreasing" = "blue")
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

# print (sprintf('RTX is %s; fit coefficients %.3f %.3f rms %.2f; delay %d
 ms',
\end_layout

\begin_layout Plain Layout

#   RTSEL, cf[1], cf[2], rms, input$sliderSR))
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  g + ylab(expression(paste('Recovery Temperature [', degree, 'C]'))) +
 
\end_layout

\begin_layout Plain Layout

  xlab(Xlab) + 
\end_layout

\begin_layout Plain Layout

  theme_WAC(1)
\end_layout

\begin_layout Plain Layout

g1 <- g + theme(plot.title = element_text(size = 12))
\end_layout

\begin_layout Plain Layout

DXX <- DSR  ## save for the next chunk
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<srRTH1delay, include=TRUE, fig.height=3.3, fig.width=6.5, fig.cap='The recovery
 temperature as measured by a heated HARCO sensor during the speed-run maneuver
 shown in the previous figure (a) and the same measurement after correction
 (b).
 The abscissa is the dynamic-heating term without the recovery factor, where
 $V$ is the airspeed and $Cp$ is the specific heat at constant pressure.
 The measurements while the airspeed was increasing are shown by the green
 lines and those for decreasing airspeed by the blue lines.
 The dashed orange lines indicate the regression fits, with standard deviation
 about the fit of 0.26$^{
\backslash

\backslash
circ}$C (uncorrected) and 0.10$^{
\backslash

\backslash
circ}$C (after correction).'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

delay <- -2200
\end_layout

\begin_layout Plain Layout

DSR <- DSS
\end_layout

\begin_layout Plain Layout

MRHO <- MachNumber(DSR$PSXC, DSR$QCXC) * DSR$PSXC * 100 / 
\end_layout

\begin_layout Plain Layout

        (287.05 * (273.15 + DSR$ATX)) / rhozero
\end_layout

\begin_layout Plain Layout

a <- bestSH[1]
\end_layout

\begin_layout Plain Layout

tau1 <- bestSH[2] * (0.3 / MRHO) ^ 0.6  ## Note that these are variable
\end_layout

\begin_layout Plain Layout

tau2 <- bestSH[3] * (0.3 / MRHO) ^ 0.6
\end_layout

\begin_layout Plain Layout

## RT is the working solution
\end_layout

\begin_layout Plain Layout

Rate <- attr (DSR, 'Rate')
\end_layout

\begin_layout Plain Layout

DSR$DTMDT <- c(0, diff(DSR$RTH1, 2), 0) * Rate / 2
\end_layout

\begin_layout Plain Layout

DSR$DTM2DT2 <- (c(diff(DSR$RTH1), 0) - c(0, diff(DSR$RTH1))) * Rate^2
\end_layout

\begin_layout Plain Layout

DSR$RT <- (tau1 + tau2) * DSR$DTMDT + DSR$RTH1 + tau1 * tau2 * DSR$DTM2DT2
\end_layout

\begin_layout Plain Layout

# DSR$RT <- ShiftInTime(DSR[, RTSEL], .rate=Rate, .shift = delay)
\end_layout

\begin_layout Plain Layout

DSR <- DSR %>% selectTime(32310, 32700)
\end_layout

\begin_layout Plain Layout

DSR <- transferAttributes(DSS, DSR)
\end_layout

\begin_layout Plain Layout

N <- 2^13  ## encompasses the speed run
\end_layout

\begin_layout Plain Layout

Nby2 <- N / 2
\end_layout

\begin_layout Plain Layout

N1 <- (N - nrow(DSR)) %/% 2
\end_layout

\begin_layout Plain Layout

N2 <- N - nrow(DSR) - N1
\end_layout

\begin_layout Plain Layout

RTH1 <- c(rep(DSR$RTH1[1], N1), DSR$RTH1, rep(DSR$RTH1[nrow(DSR)], N2))
\end_layout

\begin_layout Plain Layout

ff1 <- fft(RTH1)
\end_layout

\begin_layout Plain Layout

RTH <- Re(fft(ff1, inverse=TRUE)) / N
\end_layout

\begin_layout Plain Layout

df <- Rate / N
\end_layout

\begin_layout Plain Layout

frq <- c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
\end_layout

\begin_layout Plain Layout

fr <- log(frq[1:(Nby2+1)])
\end_layout

\begin_layout Plain Layout

## Get the transfer function from the fitted parameterized form:
\end_layout

\begin_layout Plain Layout

Ph <- cfHARCO[1] + cfHARCO[2] * fr + 
\end_layout

\begin_layout Plain Layout

           cfHARCO[3] * fr^2 + cfHARCO[4] * atan(frq[1:(Nby2+1)])
\end_layout

\begin_layout Plain Layout

Ph[1] <- 0
\end_layout

\begin_layout Plain Layout

G <- cfrHARCO[1] + fr * (cfrHARCO[2] + fr * fr * (cfrHARCO[3] + 
\end_layout

\begin_layout Plain Layout

           fr * (cfrHARCO[4] + fr * cfrHARCO[5])))
\end_layout

\begin_layout Plain Layout

G[frq[1:length(fr)] < 0.024] <- 1
\end_layout

\begin_layout Plain Layout

G[frq[1:length(fr)] > 2] <- G[which.min(abs(frq-2))]
\end_layout

\begin_layout Plain Layout

H <- rep(complex(modulus=0), N)
\end_layout

\begin_layout Plain Layout

H[1:(Nby2+1)] <- complex(modulus=G, argument=Ph * pi / 180)
\end_layout

\begin_layout Plain Layout

H[(Nby2+2):N] <- rev(Conj(H[2:Nby2]))
\end_layout

\begin_layout Plain Layout

RTC <- Re(fft(ff1 / H, inverse = TRUE)) / N
\end_layout

\begin_layout Plain Layout

DSR$RTC <- RTC[(N1+1):(N-N2)]
\end_layout

\begin_layout Plain Layout

cf <- coef(fm <- lm (RT ~ X, data = DSR))
\end_layout

\begin_layout Plain Layout

xp <- c(min(DSR$X, na.rm = TRUE), max(DSR$X, na.rm = TRUE))
\end_layout

\begin_layout Plain Layout

yp <- cf[1] + cf[2] * xp
\end_layout

\begin_layout Plain Layout

d <- data.frame(xp = xp, yp = yp)
\end_layout

\begin_layout Plain Layout

rms <- summary(fm)$sigma
\end_layout

\begin_layout Plain Layout

DSR$RT2C <- DSR$RT
\end_layout

\begin_layout Plain Layout

DSR$RT1C <- DSR$RT
\end_layout

\begin_layout Plain Layout

DSR$RT2C[dXS <= 0] <- NA  # Don't plot decreasing-speed as green
\end_layout

\begin_layout Plain Layout

DSR$RT1C[dXS >= 0] <- NA
\end_layout

\begin_layout Plain Layout

# DXX$RT1C <- DSR$RT1C
\end_layout

\begin_layout Plain Layout

# DXX$RT2C <- DSR$RT2C
\end_layout

\begin_layout Plain Layout

# DXX$Time <- DXX$X
\end_layout

\begin_layout Plain Layout

# g <- DXX %>% select(Time, RT1, RT2, RT1C, RT2C) %>%
\end_layout

\begin_layout Plain Layout

#              ggplotWAC(panels=2, labelP=c)'      uncorrected', 
\end_layout

\begin_layout Plain Layout

#              '      corrected'), labelL=c('decreasing', 'increasing'))
 + 
\end_layout

\begin_layout Plain Layout

#        xlab(Xlab) 
\end_layout

\begin_layout Plain Layout

g <- ggplot (data = DSR, aes(x = X, y = RT))
\end_layout

\begin_layout Plain Layout

if (Rate == 1) {
\end_layout

\begin_layout Plain Layout

  g <- g + geom_point(colour = 'blue')
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(aes(y = RT1C, colour = 'decreasing'),
\end_layout

\begin_layout Plain Layout

                   na.rm = TRUE,
\end_layout

\begin_layout Plain Layout

                   lwd = 1.2)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(aes(y = RT2C, colour = 'increasing'),
\end_layout

\begin_layout Plain Layout

                   lwd = 1.2,
\end_layout

\begin_layout Plain Layout

                   na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(
\end_layout

\begin_layout Plain Layout

  data = d,
\end_layout

\begin_layout Plain Layout

  aes(x = xp, y = yp),
\end_layout

\begin_layout Plain Layout

  colour = 'darkorange',
\end_layout

\begin_layout Plain Layout

  lwd = 1.5,
\end_layout

\begin_layout Plain Layout

  lty = 2
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  g + scale_colour_manual (
\end_layout

\begin_layout Plain Layout

    name = 'airspeed: ',
\end_layout

\begin_layout Plain Layout

    values = c("increasing" = "forestgreen", "decreasing" = "blue")
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

# print (sprintf('RTX is %s; fit coefficients %.3f %.3f rms %.2f; delay %d
 ms',
\end_layout

\begin_layout Plain Layout

#   RTSEL, cf[1], cf[2], rms, input$sliderSR))
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  g + ylab(expression(paste('Recovery Temperature [', degree, 'C]'))) +
 xlab(Xlab) + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

g2 <- g + theme(plot.title = element_text(size = 12))
\end_layout

\begin_layout Plain Layout

g1 <- g1 + theme(legend.position=c(0.99, 0.92))
\end_layout

\begin_layout Plain Layout

g2 <- g2 + theme(legend.position = 'none')
\end_layout

\begin_layout Plain Layout

g1 <- g1 + ylim(c(-11, 4.5))
\end_layout

\begin_layout Plain Layout

g2 <- g2 + ylim(c(-11, 4.5))
\end_layout

\begin_layout Plain Layout

g2 <- g2 + ylab('')
\end_layout

\begin_layout Plain Layout

g1 <- g1 + annotate('text', x=8, y=3, label='(a)', size=5)
\end_layout

\begin_layout Plain Layout

g2 <- g2 + annotate('text', x=17, y=3, label='(b)', size=5)
\end_layout

\begin_layout Plain Layout

grid.newpage()
\end_layout

\begin_layout Plain Layout

vp1 <- viewport(width=0.57, height=0.9, x=0.25, y=0.45)
\end_layout

\begin_layout Plain Layout

vp2 <- viewport(width=0.57, height=0.9, x=0.68, y=0.45)
\end_layout

\begin_layout Plain Layout

# grid.rect(0.5, 0.5, width = unit(5, "npc"), name = 'a', vp = vp1)
\end_layout

\begin_layout Plain Layout

# grid.rect(0.5, 0.5, width = unit(5, "npc"), name = 'b', vp = vp2)
\end_layout

\begin_layout Plain Layout

plot(g2, vp=vp2)
\end_layout

\begin_layout Plain Layout

plot(g1, vp=vp1)
\end_layout

\begin_layout Plain Layout

# grid.newpage()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Extra
inverted 0
status open

\begin_layout Subsection
The measured temperature in an inertial sub-range
\end_layout

\begin_layout Standard
One further check of the time-constant parameters can be obtained by comparing
 the slope of the spectral variance of the recovery temperature to the expected
 slope in an inertial sub-range.
 Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:VCLS2}
\end_layout

\end_inset

 shows an example of the measured variance spectrum for the recovery temperature
 measured during a low-level flight segment similar to those used to determine
 the phase lag in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-unheated-Rosemount"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The turbulent air motions in this region are consistent with expectations
 for an inertial sub-range, so it might be expected that the slope would
 conform to the expected 
\begin_inset Formula $-5/3$
\end_inset

 slope (or 
\begin_inset Formula $-2/3$
\end_inset

 in this spectrum that is weighted by the frequency).
 The measured spectrum (for TTRR) decreases a little more rapidly with frequency
 than expected but does not appear to be as far from the expected slope
 as would be expected from the transfer function, for example on the basis
 of Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:LTsolution}
\end_layout

\end_inset

.
 If the spectrum is corrected according to the transfer function, the result,
 shown as the variable 
\begin_inset Quotes eld
\end_inset

TTRRC,
\begin_inset Quotes erd
\end_inset

 has significant excess variance above about 2
\begin_inset space ~
\end_inset

Hz.
 The spectral variance as measured and as corrected both appear to be too
 high.
 This is not understood but appears to indicate that there is some spurious
 contribution to the variance at 2
\begin_inset space ~
\end_inset

Hz and above.
 This was also evident in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:checkAmplitude}
\end_layout

\end_inset

, where some source of variance other than dynamic heating appears to contribute
 to the amplitude fluctuations above 3
\begin_inset space ~
\end_inset

Hz.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<VCLS2, include=TRUE, echo=FALSE, fig.cap='The variance spectrum for the
 recovery temperature measured by a Rosemount 102E4AL sensor during a flight
 segment from VOCALS C-130 flight 3, 11:39:00 -- 11:52:00 UTC.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

D <- getNetCDF(
\end_layout

\begin_layout Plain Layout

  file.path(DataDirectory(), 'VOCALS/VOCALSrf03h.nc'),
\end_layout

\begin_layout Plain Layout

  c('TASX', 'PALT', 'TTRR', 'ATRR'),
\end_layout

\begin_layout Plain Layout

  113800,
\end_layout

\begin_layout Plain Layout

  115300
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

D$DH <- D$TASX ^ 2 / 2010
\end_layout

\begin_layout Plain Layout

DT <- D %>% selectTime(113900, 115200)
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  VSpecC(
\end_layout

\begin_layout Plain Layout

    DT,
\end_layout

\begin_layout Plain Layout

    'TTRR',
\end_layout

\begin_layout Plain Layout

    spans = 99,
\end_layout

\begin_layout Plain Layout

    xlim = c(0.01, 15),
\end_layout

\begin_layout Plain Layout

    ylim = c(1.e-5, 1.e-1)
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

DT$TTRRC <- DT$TTRR
\end_layout

\begin_layout Plain Layout

VSpecC(DT,
\end_layout

\begin_layout Plain Layout

       'TTRRC',
\end_layout

\begin_layout Plain Layout

       add = g,
\end_layout

\begin_layout Plain Layout

       corrected = TRUE,
\end_layout

\begin_layout Plain Layout

       Par = Param1) + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

# g <- VSpec(DT, 'ATRR', spans=99, add=g)
\end_layout

\begin_layout Plain Layout

# VSpec(DT, 'DH', spans=99, add=g) + theme_WAC()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

<<specialVSpec>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#' @title VSpec ## SPECIAL FOR SHOWING TRANSFER-FUNCTION MOD
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

VSpecC <-
\end_layout

\begin_layout Plain Layout

  function (.data,
\end_layout

\begin_layout Plain Layout

            .Variable = NA,
\end_layout

\begin_layout Plain Layout

            VLabel = NA,
\end_layout

\begin_layout Plain Layout

            col = NA,
\end_layout

\begin_layout Plain Layout

            type = 'spectrum',
\end_layout

\begin_layout Plain Layout

            corrected = FALSE,
\end_layout

\begin_layout Plain Layout

            method = NA,
\end_layout

\begin_layout Plain Layout

            xlim = NA,
\end_layout

\begin_layout Plain Layout

            ylim = NA,
\end_layout

\begin_layout Plain Layout

            Par = NA,
\end_layout

\begin_layout Plain Layout

            # c(0.001, 15), ylim=c(0.0001,1),
\end_layout

\begin_layout Plain Layout

            spans = 49,
\end_layout

\begin_layout Plain Layout

            ae = 0.2,
\end_layout

\begin_layout Plain Layout

            smoothBins = 0,
\end_layout

\begin_layout Plain Layout

            segLength = 512,
\end_layout

\begin_layout Plain Layout

            poles = 50,
\end_layout

\begin_layout Plain Layout

            resolution = 0.0001,
\end_layout

\begin_layout Plain Layout

            showErrors = 0,
\end_layout

\begin_layout Plain Layout

            WavelengthScale = TRUE,
\end_layout

\begin_layout Plain Layout

            ADD = NA,
\end_layout

\begin_layout Plain Layout

            add = NA,
\end_layout

\begin_layout Plain Layout

            EDR = FALSE,
\end_layout

\begin_layout Plain Layout

            WACtheme = NA) {
\end_layout

\begin_layout Plain Layout

    if (!is.data.frame(.data)) {
\end_layout

\begin_layout Plain Layout

      # See if the first argument can be split into a data.frame and a variable:
\end_layout

\begin_layout Plain Layout

      X <- substitute(.data)
\end_layout

\begin_layout Plain Layout

      if (is.call(X)) {
\end_layout

\begin_layout Plain Layout

        V <- try(eval(X), silent = TRUE)
\end_layout

\begin_layout Plain Layout

        if (grepl('Error', V[[1]])) {
\end_layout

\begin_layout Plain Layout

          V <- eval(plyr::as.quoted(X))  # eval(X) for names()
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        if (is.character(V[1])) {
\end_layout

\begin_layout Plain Layout

          
\end_layout

\begin_layout Plain Layout

        } else {
\end_layout

\begin_layout Plain Layout

          V <- plyr::as.quoted(X)
\end_layout

\begin_layout Plain Layout

          if (is.symbol(V[[1]])) {
\end_layout

\begin_layout Plain Layout

            V <- vapply(V, deparse, 'character')
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        V <- plyr::as.quoted(X)
\end_layout

\begin_layout Plain Layout

        if (is.symbol(V[[1]])) {
\end_layout

\begin_layout Plain Layout

          V <- vapply(V, deparse, 'character')
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      # print (c('first argument evaluates to', V))
\end_layout

\begin_layout Plain Layout

      # Extract data.frame:
\end_layout

\begin_layout Plain Layout

      .data <- get(V[[1]])
\end_layout

\begin_layout Plain Layout

      .Variable <- V[[2]]
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    # print(str(.data))
\end_layout

\begin_layout Plain Layout

    if (is.data.frame(.data)) {
\end_layout

\begin_layout Plain Layout

      ## must be true, or exit.
 Needs to contain Time and TASX
\end_layout

\begin_layout Plain Layout

      ## in addition to .Variable
\end_layout

\begin_layout Plain Layout

      nm <- names(.data)
\end_layout

\begin_layout Plain Layout

      V <- try(is.na(.Variable), silent = TRUE)
\end_layout

\begin_layout Plain Layout

      if (grepl('Error', V[[1]])) {
\end_layout

\begin_layout Plain Layout

        X <- substitute(.Variable)
\end_layout

\begin_layout Plain Layout

        if (is.call(X)) {
\end_layout

\begin_layout Plain Layout

          V <- try(eval(X), silent = TRUE)
\end_layout

\begin_layout Plain Layout

          if (grepl('Error', V[[1]])) {
\end_layout

\begin_layout Plain Layout

            V <- eval(plyr::as.quoted(X))  # eval(X) for names()
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          if (is.character(V[1])) {
\end_layout

\begin_layout Plain Layout

            
\end_layout

\begin_layout Plain Layout

          } else {
\end_layout

\begin_layout Plain Layout

            V <- plyr::as.quoted(X)
\end_layout

\begin_layout Plain Layout

            if (is.symbol(V[[1]])) {
\end_layout

\begin_layout Plain Layout

              V <- vapply(V, deparse, 'character')
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        } else {
\end_layout

\begin_layout Plain Layout

          V <- plyr::as.quoted(X)
\end_layout

\begin_layout Plain Layout

          if (is.symbol(V[[1]])) {
\end_layout

\begin_layout Plain Layout

            V <- vapply(V, deparse, 'character')
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        .Variable <- V
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      if (is.na(.Variable[1])) {
\end_layout

\begin_layout Plain Layout

        nm <- nm[-which('Time' == nm)]
\end_layout

\begin_layout Plain Layout

        nm <- nm[-which('TASX' == nm)]
\end_layout

\begin_layout Plain Layout

        .Variable <- nm
\end_layout

\begin_layout Plain Layout

        if (length(.Variable) > 3) {
\end_layout

\begin_layout Plain Layout

          .Variable <- .Variable[1:3]
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      print('VSpec ERROR: first argument is not a data.frame.')
\end_layout

\begin_layout Plain Layout

      return (NA)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if (is.null(attr(.data, 'Rate'))) {
\end_layout

\begin_layout Plain Layout

      print ('VSpec warning: Rate attribute missing from data.frame, so using
 Rate=1')
\end_layout

\begin_layout Plain Layout

      Rate <- 1
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      Rate <- attr(.data, 'Rate')
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if (is.na(xlim[1])) {
\end_layout

\begin_layout Plain Layout

      if (Rate == 1) {
\end_layout

\begin_layout Plain Layout

        xlim <- c(0.001, 1)
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        xlim <- c(0.001, 15)
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if (is.na(ylim[1])) {
\end_layout

\begin_layout Plain Layout

      ylim <- c(1.e-4, 1.)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if (!is.na(method)) {
\end_layout

\begin_layout Plain Layout

      type <- method
\end_layout

\begin_layout Plain Layout

    }  ## method over-rides if present
\end_layout

\begin_layout Plain Layout

    for (.V in .Variable) {
\end_layout

\begin_layout Plain Layout

      if (.V %in% names(.data)) {
\end_layout

\begin_layout Plain Layout

        NV <- which(.V == .Variable)
\end_layout

\begin_layout Plain Layout

        Z <- capture.output (v <- detrend (.data[, c('Time', .V)]))
\end_layout

\begin_layout Plain Layout

        if (!is.na(VLabel[1]) &&
\end_layout

\begin_layout Plain Layout

            length(VLabel) >= NV) {
\end_layout

\begin_layout Plain Layout

          ## use this alternate name in legend
\end_layout

\begin_layout Plain Layout

          V <- VLabel[NV]
\end_layout

\begin_layout Plain Layout

        } else {
\end_layout

\begin_layout Plain Layout

          V <- .V
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        print(sprintf(
\end_layout

\begin_layout Plain Layout

          'VSpec ERROR: Variable %s is not in the supplied data.frame',
\end_layout

\begin_layout Plain Layout

          .V
\end_layout

\begin_layout Plain Layout

        ))
\end_layout

\begin_layout Plain Layout

        return (NA)
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      if (type != 'spectrum' &&
\end_layout

\begin_layout Plain Layout

          type != 'Welch' && type != 'MEM' && type != 'mem') {
\end_layout

\begin_layout Plain Layout

        print (sprintf ('type %s is unavailable; using type=spectrum', type))
\end_layout

\begin_layout Plain Layout

        type <- 'spectrum'
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      siglim <- 1  ## 1-sigma error limits
\end_layout

\begin_layout Plain Layout

      if (type == 'spectrum') {
\end_layout

\begin_layout Plain Layout

        if (!is.null(spans[1])) {
\end_layout

\begin_layout Plain Layout

          if (!(spans[1] %% 2)) {
\end_layout

\begin_layout Plain Layout

            spans[1] <- spans[1] + 1
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          if (spans[1] <= 5) {
\end_layout

\begin_layout Plain Layout

            spans <- NULL
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        S <-
\end_layout

\begin_layout Plain Layout

          spectrum (ts(
\end_layout

\begin_layout Plain Layout

            SmoothInterp(v, .maxGap = 1000 * Rate, .Length = 0),
\end_layout

\begin_layout Plain Layout

            frequency = Rate
\end_layout

\begin_layout Plain Layout

          ),
\end_layout

\begin_layout Plain Layout

          span = spans,
\end_layout

\begin_layout Plain Layout

          plot = FALSE)
\end_layout

\begin_layout Plain Layout

        freq <- S$freq
\end_layout

\begin_layout Plain Layout

        if (corrected) {
\end_layout

\begin_layout Plain Layout

          ARX <- LTphase(freq, Par)
\end_layout

\begin_layout Plain Layout

          S$spec <- S$spec / ARX$Amp ^ 2
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        fpf <- 2 * S$spec * freq
\end_layout

\begin_layout Plain Layout

      } else if (type == 'Welch') {
\end_layout

\begin_layout Plain Layout

        ## bspec section
\end_layout

\begin_layout Plain Layout

        ## force segLength to a power of 2
\end_layout

\begin_layout Plain Layout

        segl <- segLength
\end_layout

\begin_layout Plain Layout

        rsl <- log(segl) / log(2)
\end_layout

\begin_layout Plain Layout

        ns <- round (rsl)
\end_layout

\begin_layout Plain Layout

        if (2 ^ ns != segl) {
\end_layout

\begin_layout Plain Layout

          if (2 ^ ns > segl) {
\end_layout

\begin_layout Plain Layout

            segl <- 2 ^ (ns - 1)
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          else {
\end_layout

\begin_layout Plain Layout

            segl <- 2 ^ (ns + 1)
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          segLength <- segl
\end_layout

\begin_layout Plain Layout

          print (sprintf ('reset segLength to %d', segLength))
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        S2 <-
\end_layout

\begin_layout Plain Layout

          bspec::welchPSD (
\end_layout

\begin_layout Plain Layout

            ts(SmoothInterp(v, .Length = 0), frequency = Rate),
\end_layout

\begin_layout Plain Layout

            seglength = segLength,
\end_layout

\begin_layout Plain Layout

            windowfun = bspec::hammingwindow
\end_layout

\begin_layout Plain Layout

          )
\end_layout

\begin_layout Plain Layout

        # ci <- quantile.bspec(BSP, probs = c(0.025, 0.975),
\end_layout

\begin_layout Plain Layout

        #   two.sided = FALSE)
\end_layout

\begin_layout Plain Layout

        coverage <- 0.683
\end_layout

\begin_layout Plain Layout

        tail <- 1 - coverage
\end_layout

\begin_layout Plain Layout

        df <- 2 * 9 * S2$segments / 11 ##1.768849
\end_layout

\begin_layout Plain Layout

        upper.quantile <-
\end_layout

\begin_layout Plain Layout

          1 - tail * pchisq(df, df, lower.tail = FALSE)
\end_layout

\begin_layout Plain Layout

        lower.quantile <- tail * pchisq(df, df)
\end_layout

\begin_layout Plain Layout

        ci <- 1 / (qchisq(c(upper.quantile, lower.quantile), df) / df)
\end_layout

\begin_layout Plain Layout

        df <- 1.46 * (S2$segments + 1)
\end_layout

\begin_layout Plain Layout

        lower.limit <- qchisq (pnorm(-siglim), df) / df
\end_layout

\begin_layout Plain Layout

        upper.limit <- qchisq (pnorm(siglim), df) / df
\end_layout

\begin_layout Plain Layout

        # ci <- 0.5 + (ci-0.5) / sqrt(9 * S2$segments / 11)
\end_layout

\begin_layout Plain Layout

        # print (sprintf ('ci2=%.3f -- %.3f segments %d', ci[1], ci[2], S2$segment
s))
\end_layout

\begin_layout Plain Layout

        freq <- S2$frequency[-1]
\end_layout

\begin_layout Plain Layout

        fpf <- S2$power[-1] * freq
\end_layout

\begin_layout Plain Layout

      } else if (type == 'MEM' || type == 'mem') {
\end_layout

\begin_layout Plain Layout

        ## MEM section
\end_layout

\begin_layout Plain Layout

        A <- memCoef (v, poles)
\end_layout

\begin_layout Plain Layout

        ld <- nrow(.data)
\end_layout

\begin_layout Plain Layout

        fmin <- log (Rate / ld)
\end_layout

\begin_layout Plain Layout

        fmax <- log (0.5 * Rate)
\end_layout

\begin_layout Plain Layout

        bins <- as.integer (1 / resolution)
\end_layout

\begin_layout Plain Layout

        df <- (fmax - fmin) / bins
\end_layout

\begin_layout Plain Layout

        fdtl <- fmin + df * (0:bins)
\end_layout

\begin_layout Plain Layout

        freq <- exp (fdtl)
\end_layout

\begin_layout Plain Layout

        psComplex <- memEstimate (freq / Rate, A) / Rate
\end_layout

\begin_layout Plain Layout

        ps <- 2 * Rate * Mod (psComplex) ^ 2
\end_layout

\begin_layout Plain Layout

        fpf <- freq * ps
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      tasAverage <- mean(.data$TASX, na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

      if (EDR) {
\end_layout

\begin_layout Plain Layout

        ps <- fpf / freq
\end_layout

\begin_layout Plain Layout

        fpf <- (2 * pi / tasAverage) * (1.5 * ps) ^ 1.5 * freq ^ 2.5
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      if (smoothBins > 9) {
\end_layout

\begin_layout Plain Layout

        bs1 <- binStats(data.frame(fpf, log(freq)), bins = smoothBins)
\end_layout

\begin_layout Plain Layout

        bs1 <-
\end_layout

\begin_layout Plain Layout

          rbind (bs1,
\end_layout

\begin_layout Plain Layout

                 data.frame(
\end_layout

\begin_layout Plain Layout

                   xc = bs1$xc[nrow(bs1)],
\end_layout

\begin_layout Plain Layout

                   ybar = bs1$ybar[nrow(bs1)],
\end_layout

\begin_layout Plain Layout

                   sigma = bs1$sigma[nrow(bs1)],
\end_layout

\begin_layout Plain Layout

                   nb = 1
\end_layout

\begin_layout Plain Layout

                 ))
\end_layout

\begin_layout Plain Layout

        bs1 <- bs1[!is.na(bs1$ybar), ]
\end_layout

\begin_layout Plain Layout

        freq <- exp(bs1$xc)
\end_layout

\begin_layout Plain Layout

        fpf <- bs1$ybar
\end_layout

\begin_layout Plain Layout

        bs1$sigma <- ifelse (bs1$nb > 2, bs1$sigma / sqrt(bs1$nb), NA)
\end_layout

\begin_layout Plain Layout

        rna <- is.na(bs1$sigma)
\end_layout

\begin_layout Plain Layout

        bs1$sigma[rna] <- bs1$ybar[rna] / 2
\end_layout

\begin_layout Plain Layout

        # bs1 <<- bs1
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      if (.V == .Variable[1]) {
\end_layout

\begin_layout Plain Layout

        DF <- data.frame(freq, fpf)
\end_layout

\begin_layout Plain Layout

      } else if (.V == .Variable[2]) {
\end_layout

\begin_layout Plain Layout

        DF$fpf2 <- fpf
\end_layout

\begin_layout Plain Layout

      } else if (.V == .Variable[3]) {
\end_layout

\begin_layout Plain Layout

        DF$fpf3 <- fpf
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    VL <- .Variable
\end_layout

\begin_layout Plain Layout

    if (!is.na(VLabel[1])) {
\end_layout

\begin_layout Plain Layout

      VL <- VLabel
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if (is.na(col[1])) {
\end_layout

\begin_layout Plain Layout

      col = c("blue", "forestgreen", "black", "darkorange")
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if (!is.na(add[1])) {
\end_layout

\begin_layout Plain Layout

      ADD <- add
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    for (.V in .Variable) {
\end_layout

\begin_layout Plain Layout

      NV <- which(.V == .Variable)
\end_layout

\begin_layout Plain Layout

      if (is.na(ADD[1])) {
\end_layout

\begin_layout Plain Layout

        if (NV == 1) {
\end_layout

\begin_layout Plain Layout

          ## first call: redefine VSpecDF
\end_layout

\begin_layout Plain Layout

          try(rm(list = names(VSpecEnv), envir = VSpecEnv), silent = TRUE)
\end_layout

\begin_layout Plain Layout

          VSpecEnv$Variable <- .Variable
\end_layout

\begin_layout Plain Layout

          assign('VSpecDF1', DF, envir = VSpecEnv)
\end_layout

\begin_layout Plain Layout

          labx <- 'frequency [Hz]'
\end_layout

\begin_layout Plain Layout

          if (EDR) {
\end_layout

\begin_layout Plain Layout

            # laby <- sprintf('eddy dissipation rate for %s', .V)
\end_layout

\begin_layout Plain Layout

            laby <-
\end_layout

\begin_layout Plain Layout

              expression(paste("eddy dissipation rate [m" ^ "2", "s" ^ "-3",
 "]"))
\end_layout

\begin_layout Plain Layout

          } else {
\end_layout

\begin_layout Plain Layout

            laby <- sprintf('variance spectrum fP(f) for %s', .V)
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          g <- ggplot(data = DF)
\end_layout

\begin_layout Plain Layout

          g <-
\end_layout

\begin_layout Plain Layout

            g + geom_path (aes(
\end_layout

\begin_layout Plain Layout

              x = freq,
\end_layout

\begin_layout Plain Layout

              y = fpf,
\end_layout

\begin_layout Plain Layout

              colour = VL[1]
\end_layout

\begin_layout Plain Layout

            ),
\end_layout

\begin_layout Plain Layout

            data = DF,
\end_layout

\begin_layout Plain Layout

            na.rm = TRUE) +
\end_layout

\begin_layout Plain Layout

            xlab(labx) + ylab (laby)
\end_layout

\begin_layout Plain Layout

          .clinesVSpec <- col[1]
\end_layout

\begin_layout Plain Layout

          names(.clinesVSpec) <- VL[1]
\end_layout

\begin_layout Plain Layout

          VSpecEnv$clinesVSpec <- .clinesVSpec
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        if (NV == 2) {
\end_layout

\begin_layout Plain Layout

          g <-
\end_layout

\begin_layout Plain Layout

            g + geom_path (aes(
\end_layout

\begin_layout Plain Layout

              x = freq,
\end_layout

\begin_layout Plain Layout

              y = fpf2,
\end_layout

\begin_layout Plain Layout

              colour = VL[2]
\end_layout

\begin_layout Plain Layout

            ),
\end_layout

\begin_layout Plain Layout

            data = DF,
\end_layout

\begin_layout Plain Layout

            na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

          cl2 <- ifelse (length(col) >= 2, col[2], 'forestgreen')
\end_layout

\begin_layout Plain Layout

          names(cl2) <- VL[2]
\end_layout

\begin_layout Plain Layout

          .clinesVSpec <- c(VSpecEnv$clinesVSpec, cl2)
\end_layout

\begin_layout Plain Layout

          VSpecEnv$clinesVSpec <- .clinesVSpec
\end_layout

\begin_layout Plain Layout

        } else if (NV == 3) {
\end_layout

\begin_layout Plain Layout

          g <-
\end_layout

\begin_layout Plain Layout

            g + geom_path (aes(
\end_layout

\begin_layout Plain Layout

              x = freq,
\end_layout

\begin_layout Plain Layout

              y = fpf3,
\end_layout

\begin_layout Plain Layout

              colour = VL[3]
\end_layout

\begin_layout Plain Layout

            ),
\end_layout

\begin_layout Plain Layout

            data = DF,
\end_layout

\begin_layout Plain Layout

            na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

          cl3 <- ifelse (length(col) >= 3, col[3], 'black')
\end_layout

\begin_layout Plain Layout

          names(cl3) <- VL[3]
\end_layout

\begin_layout Plain Layout

          .clinesVSpec <- c(VSpecEnv$clinesVSpec, cl3)
\end_layout

\begin_layout Plain Layout

          VSpecEnv$clinesVSpec <- .clinesVSpec
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        ## assign name based on elements in clinesVSpec
\end_layout

\begin_layout Plain Layout

        N <- length(VSpecEnv$clinesVSpec) + 1
\end_layout

\begin_layout Plain Layout

        nc <- names(VSpecEnv$clinesVSpec)
\end_layout

\begin_layout Plain Layout

        .clinesVSpec <- c(VSpecEnv$clinesVSpec, col[N])
\end_layout

\begin_layout Plain Layout

        names(.clinesVSpec) <- c(nc, V)
\end_layout

\begin_layout Plain Layout

        VSpecEnv$clinesVSpec <- .clinesVSpec
\end_layout

\begin_layout Plain Layout

        VName <- sprintf('VSpecDF%d', N)
\end_layout

\begin_layout Plain Layout

        assign(VName, DF, pos = VSpecEnv)
\end_layout

\begin_layout Plain Layout

        if (N == 2) {
\end_layout

\begin_layout Plain Layout

          VSpecEnv$VSpecVar2 <- V
\end_layout

\begin_layout Plain Layout

          g <-
\end_layout

\begin_layout Plain Layout

            ADD + geom_path (
\end_layout

\begin_layout Plain Layout

              aes(
\end_layout

\begin_layout Plain Layout

                x = freq,
\end_layout

\begin_layout Plain Layout

                y = fpf,
\end_layout

\begin_layout Plain Layout

                colour = VSpecEnv$VSpecVar2
\end_layout

\begin_layout Plain Layout

              ),
\end_layout

\begin_layout Plain Layout

              data = get(VName, envir = VSpecEnv),
\end_layout

\begin_layout Plain Layout

              na.rm = TRUE
\end_layout

\begin_layout Plain Layout

            )
\end_layout

\begin_layout Plain Layout

        } else if (N == 3) {
\end_layout

\begin_layout Plain Layout

          VSpecEnv$VSpecVar3 <- V
\end_layout

\begin_layout Plain Layout

          g <-
\end_layout

\begin_layout Plain Layout

            ADD + geom_path (
\end_layout

\begin_layout Plain Layout

              aes(
\end_layout

\begin_layout Plain Layout

                x = freq,
\end_layout

\begin_layout Plain Layout

                y = fpf,
\end_layout

\begin_layout Plain Layout

                colour = VSpecEnv$VSpecVar3
\end_layout

\begin_layout Plain Layout

              ),
\end_layout

\begin_layout Plain Layout

              data = get(VName, envir = VSpecEnv),
\end_layout

\begin_layout Plain Layout

              na.rm = TRUE
\end_layout

\begin_layout Plain Layout

            )
\end_layout

\begin_layout Plain Layout

        } else if (N == 4) {
\end_layout

\begin_layout Plain Layout

          VSpecEnv$VSpecVar4 <- V
\end_layout

\begin_layout Plain Layout

          g <-
\end_layout

\begin_layout Plain Layout

            ADD + geom_path (
\end_layout

\begin_layout Plain Layout

              aes(
\end_layout

\begin_layout Plain Layout

                x = freq,
\end_layout

\begin_layout Plain Layout

                y = fpf,
\end_layout

\begin_layout Plain Layout

                colour = VSpecEnv$VSpecVar4
\end_layout

\begin_layout Plain Layout

              ),
\end_layout

\begin_layout Plain Layout

              data = get(VName, envir = VSpecEnv),
\end_layout

\begin_layout Plain Layout

              na.rm = TRUE
\end_layout

\begin_layout Plain Layout

            )
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    g <-
\end_layout

\begin_layout Plain Layout

      suppressMessages(g + scale_colour_manual (name = '', values = .clinesVSpec)
)
\end_layout

\begin_layout Plain Layout

    # print (.clinesVSpec)
\end_layout

\begin_layout Plain Layout

    if (showErrors > 0) {
\end_layout

\begin_layout Plain Layout

      if (smoothBins > 9) {
\end_layout

\begin_layout Plain Layout

        bse <-
\end_layout

\begin_layout Plain Layout

          data.frame(
\end_layout

\begin_layout Plain Layout

            x = exp(bs1$xc),
\end_layout

\begin_layout Plain Layout

            ymin = bs1$ybar - showErrors * bs1$sigma,
\end_layout

\begin_layout Plain Layout

            ymax = bs1$ybar + showErrors * bs1$sigma
\end_layout

\begin_layout Plain Layout

          )
\end_layout

\begin_layout Plain Layout

        bse$ymin[bse$ymin < ylim[1]] <- ylim[1]
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        coverage <-
\end_layout

\begin_layout Plain Layout

          pnorm(showErrors) - pnorm(-showErrors)  ## 1-sigma, 0.68269
\end_layout

\begin_layout Plain Layout

        tail <- 1 - coverage
\end_layout

\begin_layout Plain Layout

        if (type == 'spectrum') {
\end_layout

\begin_layout Plain Layout

          df <- S$df
\end_layout

\begin_layout Plain Layout

        } else if (type == 'Welch') {
\end_layout

\begin_layout Plain Layout

          df <- 1.46 * (S2$segments + 1)
\end_layout

\begin_layout Plain Layout

        } else if (type == 'MEM') {
\end_layout

\begin_layout Plain Layout

          df <- length(v) / poles
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        uq <- 1 - tail * pchisq(df, df, lower.tail = FALSE)
\end_layout

\begin_layout Plain Layout

        lq <- tail * pchisq(df, df, lower.tail = TRUE)
\end_layout

\begin_layout Plain Layout

        ci <- 1 / (qchisq(c(uq, lq), df) / df)
\end_layout

\begin_layout Plain Layout

        lower.limit <- qchisq (pnorm(-showErrors), df) / df
\end_layout

\begin_layout Plain Layout

        upper.limit <- qchisq (pnorm(showErrors), df) / df
\end_layout

\begin_layout Plain Layout

        bse <-
\end_layout

\begin_layout Plain Layout

          data.frame(x = freq,
\end_layout

\begin_layout Plain Layout

                     ymin = lower.limit * fpf,
\end_layout

\begin_layout Plain Layout

                     ymax = upper.limit * fpf)
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      # g <- g + geom_ribbon(data=bs1, aes(x=exp(xc), ymin=max(ylim[1],
 ybar-showErrors*sigma), ymax=ybar+showErrors*sigma),
\end_layout

\begin_layout Plain Layout

      #   fill='cyan', alpha=0.25, show.legend=FALSE, inherit.aes=FALSE, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

      g <- g + geom_ribbon(
\end_layout

\begin_layout Plain Layout

        data = bse,
\end_layout

\begin_layout Plain Layout

        aes(x = x, ymin = ymin, ymax = ymax),
\end_layout

\begin_layout Plain Layout

        fill = 'gray50',
\end_layout

\begin_layout Plain Layout

        alpha = 0.5,
\end_layout

\begin_layout Plain Layout

        show.legend = FALSE,
\end_layout

\begin_layout Plain Layout

        inherit.aes = FALSE,
\end_layout

\begin_layout Plain Layout

        na.rm = TRUE
\end_layout

\begin_layout Plain Layout

      )
\end_layout

\begin_layout Plain Layout

      # bs1$xc <- exp(bs1$xc)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if (is.na(ADD[1])) {
\end_layout

\begin_layout Plain Layout

      g <-
\end_layout

\begin_layout Plain Layout

        g + scale_x_log10(
\end_layout

\begin_layout Plain Layout

          breaks = trans_breaks("log10", function(x)
\end_layout

\begin_layout Plain Layout

            10 ^ x, n = 4),
\end_layout

\begin_layout Plain Layout

          #limits = xlim,
\end_layout

\begin_layout Plain Layout

          labels = trans_format("log10", math_format(10 ^ .x))
\end_layout

\begin_layout Plain Layout

        ) +
\end_layout

\begin_layout Plain Layout

        scale_y_log10(
\end_layout

\begin_layout Plain Layout

          breaks = trans_breaks("log10", function(x)
\end_layout

\begin_layout Plain Layout

            10 ^ x, n = 4),
\end_layout

\begin_layout Plain Layout

          #limits = ylim,
\end_layout

\begin_layout Plain Layout

          labels = trans_format("log10", math_format(10 ^ .x))
\end_layout

\begin_layout Plain Layout

        ) +
\end_layout

\begin_layout Plain Layout

        annotation_logticks(sides = 'trbl') +
\end_layout

\begin_layout Plain Layout

        coord_cartesian(xlim = xlim, ylim = ylim)
\end_layout

\begin_layout Plain Layout

      # g <- g + theme(panel.grid.minor = element_line(colour = "black"))
\end_layout

\begin_layout Plain Layout

      if (EDR) {
\end_layout

\begin_layout Plain Layout

        ## add line showing highest-decade average EDR
\end_layout

\begin_layout Plain Layout

        imx <- length(freq)
\end_layout

\begin_layout Plain Layout

        imn <- which (freq > freq[imx] / 20)[1]
\end_layout

\begin_layout Plain Layout

        aveEDR <- mean(fpf[imn:imx], na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

        ttl <- sprintf ('EDR=%.2e', aveEDR)
\end_layout

\begin_layout Plain Layout

        DFL <- data.frame(x = c(freq[imn], freq[imx]), y = rep(aveEDR, 2))
\end_layout

\begin_layout Plain Layout

        g <-
\end_layout

\begin_layout Plain Layout

          g + geom_path(data = DFL,
\end_layout

\begin_layout Plain Layout

                        aes(x = x, y = y),
\end_layout

\begin_layout Plain Layout

                        lwd = 1.5,
\end_layout

\begin_layout Plain Layout

                        colour = 'red')
\end_layout

\begin_layout Plain Layout

        g <- g + ggtitle (bquote(.(ttl) ~ ' m' ^ 2 ~ 's' ^ -3))
\end_layout

\begin_layout Plain Layout

        # g <- g + ggtitle(sprintf(' mean eddy dissipation rate %.2e m^2/s^3',
 aveEDR))
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        for (i in (-8:0)) {
\end_layout

\begin_layout Plain Layout

          a = ae * 10.
 ^ (i * (2 / 3)) * tasAverage ^ (2 / 3)
\end_layout

\begin_layout Plain Layout

          lw = ifelse(i == -4, 1.2, 0.5)
\end_layout

\begin_layout Plain Layout

          DFL <-
\end_layout

\begin_layout Plain Layout

            data.frame(x = xlim, y = c(a / xlim[1] ^ (2 / 3), a / xlim[2]
 ^ (2 / 3)))
\end_layout

\begin_layout Plain Layout

          # print(DFL)
\end_layout

\begin_layout Plain Layout

          g <-
\end_layout

\begin_layout Plain Layout

            g + geom_path (
\end_layout

\begin_layout Plain Layout

              data = DFL,
\end_layout

\begin_layout Plain Layout

              aes(x = x, y = y),
\end_layout

\begin_layout Plain Layout

              colour = 'darkorange',
\end_layout

\begin_layout Plain Layout

              lwd = lw,
\end_layout

\begin_layout Plain Layout

              lty = 3
\end_layout

\begin_layout Plain Layout

            )
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      if (WavelengthScale) {
\end_layout

\begin_layout Plain Layout

        yl <- c(ylim[1] * 1.2, ylim[1] * 1.5)
\end_layout

\begin_layout Plain Layout

        lclr <- 'slategrey'
\end_layout

\begin_layout Plain Layout

        for (j1 in c(10, 100, 1000, 10000, 100000)) {
\end_layout

\begin_layout Plain Layout

          DFL2 <- data.frame(x = rep(tasAverage / j1, 2), y = yl)
\end_layout

\begin_layout Plain Layout

          g <-
\end_layout

\begin_layout Plain Layout

            g + geom_path(
\end_layout

\begin_layout Plain Layout

              data = DFL2,
\end_layout

\begin_layout Plain Layout

              aes(x = x, y = y),
\end_layout

\begin_layout Plain Layout

              colour = lclr,
\end_layout

\begin_layout Plain Layout

              lwd = 1.0
\end_layout

\begin_layout Plain Layout

            )
\end_layout

\begin_layout Plain Layout

          if (j1 != 100000) {
\end_layout

\begin_layout Plain Layout

            for (j2 in 2:9) {
\end_layout

\begin_layout Plain Layout

              DFL2 <- data.frame(x = rep(tasAverage / (j1 * j2), 2), y =
 yl)
\end_layout

\begin_layout Plain Layout

              g <-
\end_layout

\begin_layout Plain Layout

                g + geom_path(
\end_layout

\begin_layout Plain Layout

                  data = DFL2,
\end_layout

\begin_layout Plain Layout

                  aes(x = x, y = y),
\end_layout

\begin_layout Plain Layout

                  colour = lclr,
\end_layout

\begin_layout Plain Layout

                  lwd = 0.6
\end_layout

\begin_layout Plain Layout

                )
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        DFL2 <-
\end_layout

\begin_layout Plain Layout

          data.frame (x = tasAverage * c(1 / 10, 1 / 100000), y = rep(yl[1],
 2))
\end_layout

\begin_layout Plain Layout

        g <-
\end_layout

\begin_layout Plain Layout

          g + geom_path(data = DFL2,
\end_layout

\begin_layout Plain Layout

                        aes(x = x, y = y),
\end_layout

\begin_layout Plain Layout

                        colour = lclr,
\end_layout

\begin_layout Plain Layout

                        lwd = 1.0)
\end_layout

\begin_layout Plain Layout

        g <- g + annotate(
\end_layout

\begin_layout Plain Layout

          "text",
\end_layout

\begin_layout Plain Layout

          x = tasAverage * c(1 / 100000, 1 / 10000, 1 / 1000, 1 / 100, 1
 /
\end_layout

\begin_layout Plain Layout

                               10),
\end_layout

\begin_layout Plain Layout

          y = rep(yl[2] * 1.5, 5),
\end_layout

\begin_layout Plain Layout

          label = c("100 km", "10 km", "1 km", "0.1 km", " "),
\end_layout

\begin_layout Plain Layout

          colour = lclr
\end_layout

\begin_layout Plain Layout

        )
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      # g <- g + theme_WAC()
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if (!is.na(WACtheme)) {
\end_layout

\begin_layout Plain Layout

      g <- g + theme_WAC()
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return(g)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Section
Uses of the Transfer Functions
\end_layout

\begin_layout Standard
The transfer functions determined in the preceding section have two potential
 uses: (i) to predict how airborne thermometers will respond; and (ii) to
 correct measurements to compensate for the time response of the sensors.
 The two papers that follow, Part 2 and Part 3, are examples of these two
 uses.
 In Part 2, the transfer functions are used to assess how sensors respond
 to dynamic heating and to develop appropriate correction schemes.
 Part 3 applies the transfer functions to improve measurements of the flux
 of sensible heat.
\end_layout

\begin_layout Standard
It is also possible to make corrections to the measurements for other purposes.
 Once the transfer functions are determined, the correction procedures use
 standard techniques, as discussed in Appendix A.
 These are suited to standard measurements made from most research aircraft
 and so can have general community utility.
\end_layout

\begin_layout Section
Summary and Conclusions
\end_layout

\begin_layout Standard
Findings and conclusions of this investigation include these items:
\end_layout

\begin_layout Enumerate
The differential equations 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

, with appropriate parameters, provide an analytical representation of the
 transfer function for the recovery temperature measured by an unheated
 Rosemount 102E4AL sensor.
 That transfer function was shown to be consistent with measurements of
 the phase and amplitude ratio of the response to dynamic-heating fluctuations.
 This is good evidence that the equations provide a good representation
 of the time response for that sensor.
 The predictions of the equations are less satisfactory when applied to
 a heated HARCO sensor or a heated Rosemount sensor, possibly indicating
 that the heat transfer is not represented adequately by those equations.
\end_layout

\begin_layout Enumerate
For the Rosemount 102E4AL sensor, the three parameters in those equations
 9characterizing the two time constants and the fraction of heat transfer
 to the air vs.
\begin_inset space ~
\end_inset

that to the structure supporting the sensing wire) can be determined with
 small uncertainty by fitting the transfer function to observations of dynamic
 heating.
 These parameters are thus constrained well and can be relied upon to make
 corrections to the measurements and otherwise to characterize the effects
 of time response of that sensor.
\end_layout

\begin_layout Enumerate
Some additional evidence supports the general magnitude of the parameters
 determined by reference to dynamic heating.
 The supplemental observations come from a sharp feature in the atmosphere
 and from the lag observed during flight while the airspeed varies at constant
 altitude.
\end_layout

\begin_layout Enumerate
Once the transfer function for the unheated Rosemount sensor has been determined
, it can be used to estimate the true recovery temperature, and then transfer
 functions for other sensors can be determined by comparison to that estimate
 of the measurand to which they are responding.
 This approach has been used here for the slower heated sensors and should
 provide a means of correcting other sensors slower than the unheated sensor.
 Appendix A uses these results with standard methods to correct the measurements
 from airborne temperature sensors for their time response.
\end_layout

\begin_layout Section
\start_of_appendix
Correcting the Temperature
\begin_inset CommandInset label
LatexCommand label
name "sec:Correcting-the-Temperature"

\end_inset


\end_layout

\begin_layout Standard
The true recovery temperature 
\begin_inset Formula $T_{r}$
\end_inset

 can be retrieved from the measured temperature 
\begin_inset Formula $T_{m}$
\end_inset

 in two ways, either from the differential equations or by Fourier transformatio
n.
 These methods are illustrated here.
\end_layout

\begin_layout Standard
The differential equations 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 provide a basis for correcting the measured temperature to account for
 the time response of the sensor.
 They should be applied to the recovery temperature 
\begin_inset Formula $T_{r}(t)$
\end_inset

, which is the measurand.
 The actual measurement is 
\begin_inset Formula $T_{m}(t)$
\end_inset

 and the temperature of the support is 
\begin_inset Formula $T_{s}(t)$
\end_inset

, so those equations, rearranged, are:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\frac{dT_{s}(t)}{dt}=\frac{T_{r}(t)-T_{s}(t)}{\tau_{2}}\label{eq:Ts2}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
T_{r}(t)=\frac{1}{a}\left\{ \tau_{1}\frac{dT_{m}(t)}{dt}+T_{m}(T)-(1-a)T_{s}(t)\right\} \label{eq:Tm2}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
There are two unknowns (
\begin_inset Formula $T_{r}(t)$
\end_inset

, the actual recovery temperature, and 
\begin_inset Formula $T_{s}(t)$
\end_inset

).
 Those unknowns are specified by the two preceding equations because all
 other terms are known, including 
\begin_inset Formula $dT_{m}/dt$
\end_inset

 which can be represented using the numerical derivative of the measurements
 
\begin_inset Formula $T_{m}(t)$
\end_inset

.
 The second equation can be used to eliminate 
\begin_inset Formula $T_{r}$
\end_inset

 from the first:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\frac{dT_{s}(t)}{dt}=\frac{\frac{1}{a}\left\{ \tau_{1}\frac{dT_{m}(t)}{dt}+T_{m}(T)-(1-a)T_{s}(t)\right\} -T_{s}(t)}{\tau_{2}}\label{eq:Ts3}
\end{equation}

\end_inset

From an initial value 
\begin_inset Formula $T_{s}(0)$
\end_inset

, assumed to be 
\begin_inset Formula $T_{m}(0)$
\end_inset

, this equation can be integrated to find the temperature of the support,
 
\begin_inset Formula $T_{s}(t)$
\end_inset

.
 Once that is known, 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 specifies the estimate of the true recovery temperature 
\begin_inset Formula $T_{r}(t)$
\end_inset

 without further integration.
 The only choices needed are the numerical method used to find the derivative
 
\begin_inset Formula $dT_{m}/dt$
\end_inset

 (e.g., here centered fourth-order) and the integration method applied to
 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts3"
plural "false"
caps "false"
noprefix "false"

\end_inset

, here fourth-order Runge-Kutta integration with Cash-Karp (
\begin_inset CommandInset citation
LatexCommand citet
key "cash1990variable"
literal "false"

\end_inset

) adjustment of the step size.
 If a centered second-order finite-difference expression is used for 
\begin_inset Formula $dT_{m}(t)/dt$
\end_inset

 and an Euler integration is used to integrate 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts3"
plural "false"
caps "false"
noprefix "false"

\end_inset

, this correction can be shown to be equivalent to that developed by 
\begin_inset CommandInset citation
LatexCommand citet
key "InverarityJTech2000"
literal "false"

\end_inset

; cf.
\begin_inset space ~
\end_inset

his Eqn.
\begin_inset space ~
\end_inset

(12).
\end_layout

\begin_layout Standard
\begin_inset Branch Extra
inverted 0
status open

\begin_layout Standard
The heated Rosemount sensor presents a special case because the best-fit
 parameters included 
\begin_inset Formula $a=0$
\end_inset

 so it isn't possible to substitute 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 into 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 as for the other sensors.
 Instead, 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 can be solved to find the support temperature 
\begin_inset Formula $T_{s}(t)$
\end_inset

:
\begin_inset Formula 
\begin{equation}
T_{s}(t)=\tau_{1}\frac{dT_{m}(t)}{dt}+T_{m}(t)\label{eq:Ts4}
\end{equation}

\end_inset

which can be solved for 
\begin_inset Formula $T_{s}(t)$
\end_inset

 because both 
\begin_inset Formula $T_{m}(t)$
\end_inset

 and 
\begin_inset Formula $dT_{m}(t)/dt$
\end_inset

 are measured.
 With this solution and the resulting derivative 
\begin_inset Formula $dT_{s}(t)/dt$
\end_inset

 of this solution, 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 leads to 
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
T_{r}(t)=T_{s}(t)+\tau_{2}\frac{dT_{s}(t)}{dt}\label{eq:Tm4}
\end{equation}

\end_inset

which gives the solution directly (without integration) because all terms
 on the right side are known.
 The result could also be written by combining 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm4"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts4"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to give
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
T_{r}(t)=(\tau_{1}+\tau_{2})\frac{dT_{m}(t)}{dt}+T_{m}(t)+\tau_{2}\tau_{1}\frac{d^{2}T_{m}(t)}{dt^{2}}\label{eq:Tm5}
\end{equation}

\end_inset

which, without the second-derivative term, would represent a first-order
 response with time constant 
\begin_inset Formula $\tau=\tau_{1}+\tau_{2}$
\end_inset

.
 The transfer function for the HARCO (Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:rfHARCO}
\end_layout

\end_inset

 shows that, contrary to first-order response, the phase lag can be negative
 for some frequencies, so the second-derivative term plays an important
 role.
 The second derivative in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:HARCOsoln"
plural "false"
caps "false"
noprefix "false"

\end_inset

 can be represented, for example, by
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\frac{d^{2}T_{m}(t)}{dt^{2}}=\frac{T_{m}(t-\delta t)-2T_{m}(t)+T_{m}(t+\delta t)}{(\delta t)^{2}}\label{eq:deriv2nd}
\end{equation}

\end_inset

where all quantities on the right side are known from the measurement sequence.
 Equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm5"
plural "false"
caps "false"
noprefix "false"

\end_inset

 thus provides the corrected recovery temperature 
\begin_inset Formula $T_{r}(t)$
\end_inset

 without any need to calculate the temperature of the support.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<method1, include=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

a <- Param1$a
\end_layout

\begin_layout Plain Layout

tau1 <- Param1$tau1
\end_layout

\begin_layout Plain Layout

tau2 <- Param1$tau2
\end_layout

\begin_layout Plain Layout

## RT is the working solution; Ts is the support temperature
\end_layout

\begin_layout Plain Layout

DT$Ts <- DT$RT
\end_layout

\begin_layout Plain Layout

Rate <- attr (DT, 'Rate')
\end_layout

\begin_layout Plain Layout

DT$DTMDT <- c(0, diff(DT$TTRR, 2), 0) * Rate / 2
\end_layout

\begin_layout Plain Layout

DT$DTMDT <-  (c(0, 8*diff(DT$TTRR, 2), 0) - 
\end_layout

\begin_layout Plain Layout

              c(0, 0, diff(DT$TTRR, 4), 0, 0)) * Rate / 12
\end_layout

\begin_layout Plain Layout

# DT$DTMDT <- (DT$DTMDT + c(0, DT$DTMDT[1:(nrow(DT)-1)])) / 2
\end_layout

\begin_layout Plain Layout

# DT$DTMDT <- as.vector (signal::filter(signal::sgolay(1, 3, m=1), DT$TTRR))
 * Rate
\end_layout

\begin_layout Plain Layout

fS <- function(y, i) {
\end_layout

\begin_layout Plain Layout

  # Eq.
 Ts3
\end_layout

\begin_layout Plain Layout

  ((tau1 * DT$DTMDT[i] + DT$TTRR[i] - (1 - a) * y)/a - y) / (Rate * tau2)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DT$Ts <- rk4.integrate (fS, DT$Ts[1], 1:nrow(DT))
\end_layout

\begin_layout Plain Layout

DT$RT <- (1 / a) * (tau1 * DT$DTMDT + DT$TTRR - (1 - a) * DT$Ts)
\end_layout

\begin_layout Plain Layout

DT %>% select(Time, TTRR, RT, Ts) %>% 
\end_layout

\begin_layout Plain Layout

  selectTime(114500, 114505) %>% 
\end_layout

\begin_layout Plain Layout

  plotWAC()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<meth1Example, include=FALSE, fig.height=4, fig.cap=c('Examples of the changes
 produced by the correction procedures.
 The original measurement of recovery temperature is Tm and the revised
 value using is RT.
 The estimated temperature of the support (Ts) is also shown.
 The plotted time is seconds after 11:45:00 UTC for VOCALS flight 3.', 'Variance
 spectra for the original measurement of recovery temperature (TTRR) and
 for the corrected value (RT).')>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DT %>% select(Time, TTRR, RT, Ts) %>% 
\end_layout

\begin_layout Plain Layout

  selectTime(114500, 114505) %>% 
\end_layout

\begin_layout Plain Layout

  plotWAC(legend.position = 'topright')
\end_layout

\begin_layout Plain Layout

g <- VSpec(DT, 'TTRR', ylim = c(1.e-5, 0.1))
\end_layout

\begin_layout Plain Layout

VSpec(DT, 'RT', add = g) + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
An example of the corrected recovery temperature will be shown in the next
 subsection, where the two approaches to correction can be compared.
\end_layout

\begin_layout Standard
An alternate approach is to use Fourier transforms:
\end_layout

\begin_layout Enumerate
Calculate the Fourier transform of the measured time series: 
\begin_inset Formula $\hat{T}_{m}(\omega)=\mathcal{F}\left(T_{m}(t)\right)$
\end_inset

 where 
\begin_inset Formula $\omega$
\end_inset

 is the angular frequency and 
\begin_inset Formula $\mathcal{F}$
\end_inset

 denotes the Fourier transform.
\end_layout

\begin_layout Enumerate
Divide the result by the complex representation of the transfer function:
 
\begin_inset Formula $\hat{T}_{r}(\omega)=\hat{T}_{m}(\omega)/H(\omega)$
\end_inset

.
\end_layout

\begin_layout Enumerate
Use the inverse Fourier transform to find a retrieved estimate of the true
 recovery temperature: 
\begin_inset Formula $T_{r}(t)=\mathrm{Re}\left(\mathcal{F}^{-1}\left(\hat{T}_{r}(\omega)\right)\right)$
\end_inset

 where Re denotes the real part of the complex result.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<setUpFFT, include=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

N <- length(DT$TTRR)
\end_layout

\begin_layout Plain Layout

if (N %% 2 == 1) {
\end_layout

\begin_layout Plain Layout

  N <- N - 1
\end_layout

\begin_layout Plain Layout

  DT  <- DT[-nrow(DT), ]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

f <- fft (DT$TTRR)
\end_layout

\begin_layout Plain Layout

N <- length(f)
\end_layout

\begin_layout Plain Layout

df <- Rate / N
\end_layout

\begin_layout Plain Layout

frq <- c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
\end_layout

\begin_layout Plain Layout

N2 <- N %/% 2
\end_layout

\begin_layout Plain Layout

fmax <- 2
\end_layout

\begin_layout Plain Layout

nlim <- which(frq > fmax)[1]
\end_layout

\begin_layout Plain Layout

# f[nlim:N2] <- f[nlim:N2] * (fmax / frq[nlim:(N2-1)])
\end_layout

\begin_layout Plain Layout

# f[(N2+1):(N-nlim)] <- Conj(rev(f[nlim:N2]))
\end_layout

\begin_layout Plain Layout

## Modify the spectrum by the inverse of the response function:
\end_layout

\begin_layout Plain Layout

AFFT <- LTphase(frq, Param1)
\end_layout

\begin_layout Plain Layout

AFFT$frq <- frq
\end_layout

\begin_layout Plain Layout

AFFT$Phase <- AFFT$Phase * pi / 180
\end_layout

\begin_layout Plain Layout

H <- complex (modulus = AFFT$Amp, argument = AFFT$Phase)
\end_layout

\begin_layout Plain Layout

xn <- Re(fft(f / H, inverse = TRUE)) / N
\end_layout

\begin_layout Plain Layout

DT$FFT <- xn
\end_layout

\begin_layout Plain Layout

# g <- VSpec(DT, 'TTRR', ylim=c(1.e-5, 0.1))
\end_layout

\begin_layout Plain Layout

# g <- VSpec(DT, 'FFT', add=g)
\end_layout

\begin_layout Plain Layout

# VSpec(DT, 'RT', add=g) + theme_WAC()
\end_layout

\begin_layout Plain Layout

# DT %>% select(Time, TTRR, FFT) %>% selectTime(114500, 114505) %>% plotWAC()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<sampleFFT, include=TRUE, fig.height=4, fig.cap=c('Example of the changes
 produced by the correction procedures.
 The original measurement of recovery temperature is Tm, produced by an
 unheated Rosemount sensor, and the revised values are RT (from integration)
 and FFT (from Fourier transforms).
 The dashed green line labeled 
\begin_inset Quotes eld
\end_inset

Ts
\begin_inset Quotes erd
\end_inset

 is the temperature of the support as calculated using (17).
 Measurements from VOCALS flight 3.', 'Variance spectra for the original
 measurement of recovery temperature (Tm) produced by an unheated Rosemount
 sensor and for the corrected values (RT and FFT) produced respectively
 by (16) and the Fourier-transform algorithm.')>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DT$Tm <- DT$TTRR
\end_layout

\begin_layout Plain Layout

DT %>% select(Time, Tm, FFT, RT, Ts) %>% 
\end_layout

\begin_layout Plain Layout

  selectTime(114500, 114505) %>% 
\end_layout

\begin_layout Plain Layout

  plotWAC(col=c('blue', 'black', 'darkorange', 'forestgreen'), 
\end_layout

\begin_layout Plain Layout

          lty=c(1,1,2,2), lwd=c(2,2,2,1.5), legend.position='bottom')
\end_layout

\begin_layout Plain Layout

# g <- VSpec(DT, 'TTRR', ylim = c(1.e-5, 0.1))
\end_layout

\begin_layout Plain Layout

# VSpec(DT, 'FFT', add = g) + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

DT %>% select(Time, TASX, Tm, RT, FFT) %>% 
\end_layout

\begin_layout Plain Layout

       VSpec(method='MEM', ylim=c(1.e-5, 0.1)) +
\end_layout

\begin_layout Plain Layout

       theme_WAC(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Sample results of these correction procedures are shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:sampleFFT1}
\end_layout

\end_inset

.
 The agreement between the two correction methods is very good, and both
 show evidence of faster and higher-amplitude response to fluctuations.
 The resulting variance spectrum for the Fourier-transform method (Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:sampleFFT2}
\end_layout

\end_inset

) has high variance above about 5
\begin_inset space ~
\end_inset

Hz that is above the variance for the corrected variable obtained from 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm2"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The increasing variance for the Fourier-transform method is is likely the
 fault of the measurement itself: The spectral variance for the original
 measurement (Tm) does not decrease at high frequency as expected from the
 transfer function, and the correction procedure amplifies this excess noise.
 The lower variance for the variable obtained from 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 at high frequency arises from the finite-difference representation of the
 term 
\begin_inset Formula $dT_{m}(t)/dt$
\end_inset

, which results in some smoothing.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Taking the Fourier transform of an entire 25-Hz measurement for a flight
 of several hours becomes impractical.
 However, it is possible to segment the time series, calculate Fourier transform
s for the segments, and then combine the results to represent the entire
 flight.
 Tests have shown that, for example, dividing into 
\begin_inset Formula $2^{16}$
\end_inset

-sample overlapping segments, using fast Fourier transforms, and combining
 the middle halves of each segment is feasible with many-hour flights and
 25-Hz data.
\end_layout

\end_inset

Because the heated HARCO sensor is much slower than the unheated Rosemount
 102E4AL sensor, the measurements from that slower sensor can't be corrected
 to the extent possible for the unheated sensor, but it is still useful
 to evaluate to what extent the measurements can be improved.
 The HARCO presents a special case because the best-fit value is 
\begin_inset Formula $a=0$
\end_inset

 so 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 can't be used.
 However, in this case the differential equations can still be combined
 to give
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
T_{r}(t)=(\tau_{1}+\tau_{2})\frac{dT_{m}(t)}{dt}+T_{m}(t)+\tau_{2}\tau_{1}\frac{d^{2}T_{m}(t)}{dt^{2}}\label{eq:HARCOsoln}
\end{equation}

\end_inset

a form that can be used directly without integration because finite-difference
 expressions can be used for the derivatives of the measured 
\begin_inset Formula $T_{m}(t)$
\end_inset

.
 The solution from 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:HARCOsoln"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is very noisy if finite-difference estimates of the derivatives are used,
 so smoothing of the result was applied.
 Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:HARCOcorrection1}
\end_layout

\end_inset

 shows the result (as 
\begin_inset Quotes eld
\end_inset

RTH
\begin_inset Quotes erd
\end_inset

) after a Butterworth low-pass filter with cutoff frequency of 2
\begin_inset space ~
\end_inset

Hz smoothed the corrected measurements.
 This filtering is reasonable because the variance spectrum for this sensor
 shows very little real signal at frequencies above 2
\begin_inset space ~
\end_inset

Hz.
 In comparison to the original measurement (labeled 
\begin_inset Quotes eld
\end_inset

Tm
\begin_inset Quotes erd
\end_inset

), the response of the sensor is greatly improved by this correction procedure.
 It even provides a reasonable representation of the corrected unheated
 Rosemount measurement (labeled 
\begin_inset Quotes eld
\end_inset

RT
\begin_inset Quotes erd
\end_inset

) for the same period.
\end_layout

\begin_layout Standard
This is not as good a representation of the transfer function as is possible
 with the fitted representation shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:GVHARCO}
\end_layout

\end_inset

 and given by 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:lfitH"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 That fit can be used with the Fourier-transform approach to correction.
 The result is shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:HARCOcorrection1}
\end_layout

\end_inset

 as the black line labeled 
\begin_inset Quotes eld
\end_inset

FFT
\begin_inset Quotes erd
\end_inset

.
 This is also a significant improvement over the original and reproduces
 many of the features of the best measurement (
\begin_inset Quotes eld
\end_inset

RT
\begin_inset Quotes erd
\end_inset

).
 To obtain this result, it was necessary to attenuate frequencies above
 1.8
\begin_inset space ~
\end_inset

Hz in the Fourier transform solution because there is a zero in the transfer
 function as represented by 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:lfitH"
plural "false"
caps "false"
noprefix "false"

\end_inset

 that otherwise invalidates the inversion.
 This attenuation was accomplished by multiplying the transfer function
 by 
\begin_inset Formula $e^{5\nu}$
\end_inset

above 1.8
\begin_inset space ~
\end_inset

Hz.
 This arbitrarily chosen attenuation gave reasonable results, although it
 is likely that better choices could be made with further exploration.
 One more general measure of the improvement, beyond the anecdotal evidence
 in the preceding figures, is that either correction procedure reduced the
 standard deviation of the difference between the measured value (Tm) and
 the estimated best value (RT) from 
\begin_inset Formula $0.06^{\circ}$
\end_inset

C before correction to 
\begin_inset Formula $0.03^{\circ}$
\end_inset

C after correction.
\end_layout

\begin_layout Standard
The plot of variance spectra (Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:HARCOcorrection2}
\end_layout

\end_inset

) shows that the original spectrum (blue line labeled 
\begin_inset Quotes eld
\end_inset

Tm
\begin_inset Quotes erd
\end_inset

) is seriously attenuated at high frequencies relative to the reference
 measurement (
\begin_inset Quotes eld
\end_inset

RT
\begin_inset Quotes erd
\end_inset

) and that both correction procedures restore significant parts of the missing
 spectral variance.
 Despite its inferior representation of the transfer function, it appears
 that application of 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:HARCOsoln"
plural "false"
caps "false"
noprefix "false"

\end_inset

 provides a better match to the reference measurements.
 It does not appear possible to restore the missing high-frequency fluctuations
 (above about 1 or 2
\begin_inset space ~
\end_inset

Hz) because the original measurement is so severely attenuated at these
 frequencies.
 This sensor and the similar heated Rosemount sensor are therefore unable
 to detect contributions to sensible-heat flux from this frequency range,
 even after corrections.
 It nevertheless appears useful to apply one of these correction approaches
 routinely to improve the quality of this measurement.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<HARCOcorrection, include=TRUE, fig.height=3.5, fig.cap=c('Corrected recovery
 temperature as measured by a heated HARCO sensor (
\begin_inset Quotes eld
\end_inset

RTH
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

FFT
\begin_inset Quotes erd
\end_inset

), the uncorrected measurement (
\begin_inset Quotes eld
\end_inset

Tm
\begin_inset Quotes erd
\end_inset

), and the best estimate of the true recovery temperature (
\begin_inset Quotes eld
\end_inset

RT
\begin_inset Quotes erd
\end_inset

) based on an unheated Rosemount sensor after correction.
 The time is seconds after 2018-02-24 5:59:00 UTC, SOCRATES flight 15.
 
\begin_inset Quotes eld
\end_inset

RTH
\begin_inset Quotes erd
\end_inset

 is based on the approximate formula (20), while 
\begin_inset Quotes eld
\end_inset

FFT
\begin_inset Quotes erd
\end_inset

 results from Fourier transformation after correction using the transfer
 function determined from (13).
 Mean values have been subtracted from all to facilitate comparisons.', 'Variance
 spectra for some measurements of recovery temperature: 
\begin_inset Quotes eld
\end_inset

RT
\begin_inset Quotes erd
\end_inset

 (the best estimate resulting from correction of the measurements from the
 unheated Rosemount 102E4AL); 
\begin_inset Quotes eld
\end_inset

Tm
\begin_inset Quotes erd
\end_inset

 (the uncorrected measurement from the heated HARCO); 
\begin_inset Quotes eld
\end_inset

FFT
\begin_inset Quotes erd
\end_inset

 (the corrected HARCO measurement based on Fourier transforms); and 
\begin_inset Quotes eld
\end_inset

RTH
\begin_inset Quotes erd
\end_inset

 (the corrected HARCO measurement based on the correction formula (17)).')>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

a <- Param1$a
\end_layout

\begin_layout Plain Layout

tau1 <- Param1$tau1
\end_layout

\begin_layout Plain Layout

tau2 <- Param1$tau2
\end_layout

\begin_layout Plain Layout

## RT is the working solution; Ts is the support temperature
\end_layout

\begin_layout Plain Layout

DSX$Ts <- DSX$RTF1
\end_layout

\begin_layout Plain Layout

Rate <- attr (DSX, 'Rate')
\end_layout

\begin_layout Plain Layout

DSX$DTMDT <- c(0, diff(DSX$RTF1, 2), 0) * Rate / 2
\end_layout

\begin_layout Plain Layout

DSX$DTMDT <-  (c(0, 8*diff(DSX$RTF1, 2), 0) - 
\end_layout

\begin_layout Plain Layout

              c(0, 0, diff(DSX$RTF1, 4), 0, 0)) * Rate / 12
\end_layout

\begin_layout Plain Layout

# DT$DTMDT <- (DT$DTMDT + c(0, DT$DTMDT[1:(nrow(DT)-1)])) / 2
\end_layout

\begin_layout Plain Layout

# DT$DTMDT <- as.vector (signal::filter(signal::sgolay(1, 3, m=1),
\end_layout

\begin_layout Plain Layout

#             DT$TTRR)) * Rate
\end_layout

\begin_layout Plain Layout

fS <- function(y, i) {  # Eq.
 Ts3
\end_layout

\begin_layout Plain Layout

  ((1/a) * (tau1 * DSX$DTMDT[i] + DSX$RTF1[i] - (1-a) * y) - y) / (Rate
 * tau2)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DSX$Ts <- rk4.integrate (fS, DSX$Ts[1], 1:nrow(DSX))
\end_layout

\begin_layout Plain Layout

DSX$RT <- (1/a) * (tau1 * DSX$DTMDT + DSX$RTF1 - (1-a) * DSX$Ts)
\end_layout

\begin_layout Plain Layout

MRHO <- MachNumber(DSX$PSXC, DSX$QCXC) * DSX$PSXC * 100 /
\end_layout

\begin_layout Plain Layout

                  (287.05 * (273.15 + DSX$ATX)) / rhozero
\end_layout

\begin_layout Plain Layout

a <- bestSH[1]
\end_layout

\begin_layout Plain Layout

tau1 <- bestSH[2] * (MRHO / 0.3) ^ 0.6  ## Note that these are variable
\end_layout

\begin_layout Plain Layout

tau2 <- bestSH[3] * (MRHO / 0.3) ^ 0.6
\end_layout

\begin_layout Plain Layout

Rate <- attr (DSX, 'Rate')
\end_layout

\begin_layout Plain Layout

DSX$DTMDT <- c(0, diff(DSX$RTH1, 2), 0) * Rate / 2
\end_layout

\begin_layout Plain Layout

DSX$DTM2DT2 <- (c(diff(DSX$RTH1), 0) - c(0, diff(DSX$RTH1))) * Rate^2
\end_layout

\begin_layout Plain Layout

DSX$RTHC <- (tau1 + tau2) * DSX$DTMDT + DSX$RTH1 + tau1 * tau2 * DSX$DTM2DT2
\end_layout

\begin_layout Plain Layout

DSX$RTHC <- zoo::na.approx (as.vector(DSX$RTHC), maxgap=1000*Rate,
\end_layout

\begin_layout Plain Layout

      na.rm = FALSE, rule = 2)
\end_layout

\begin_layout Plain Layout

CutoffPeriod <- 12.5
\end_layout

\begin_layout Plain Layout

DSX$RTHC <- signal::filtfilt (signal::butter (3,
\end_layout

\begin_layout Plain Layout

      2/CutoffPeriod), DSX$RTHC)
\end_layout

\begin_layout Plain Layout

# DSX$RTHC <- SmoothInterp(DSX$RTHC, .Length=25)
\end_layout

\begin_layout Plain Layout

DSAP <- DSX
\end_layout

\begin_layout Plain Layout

DSAP$RTH1 <- DSAP$RTH1 - mean(DSAP$RTH1[setRange(DSAP, 55700, 60000)], na.rm=TRUE
)
\end_layout

\begin_layout Plain Layout

DSAP$RTF1P <- DSAP$RTF1 - mean(DSAP$RTF1[setRange(DSAP, 55700, 60000)],
 na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

DSAP$RTHC <- DSAP$RTHC - mean(DSAP$RTHC[setRange(DSAP, 55700, 60000)], na.rm=TRUE
)
\end_layout

\begin_layout Plain Layout

DSAP$RT <- DSAP$RT - mean(DSAP$RT[setRange(DSAP, 55700, 60000)], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

# DSAP %>% selectTime(55920, 55950) %>% 
\end_layout

\begin_layout Plain Layout

#          select(Time, RT, RTH1, RTHC) %>% 
\end_layout

\begin_layout Plain Layout

#         ggplotWAC(col=c('blue', 'forestgreen', 'black'), lty=c(1,4,1),
\end_layout

\begin_layout Plain Layout

#                   ylab=bquote('recovery temperature [' ~ degree * 'C]'),
 
\end_layout

\begin_layout Plain Layout

#                   lwd=c(0.8,1,1)) + xlab('time [s]') +
\end_layout

\begin_layout Plain Layout

#         theme_WAC(1) + theme(legend.position=c(0.75, 0.9))
\end_layout

\begin_layout Plain Layout

DSAX <- DSX %>% selectTime(55700, 60300)
\end_layout

\begin_layout Plain Layout

DSAX <- DSAX[1:2^13, ]
\end_layout

\begin_layout Plain Layout

ft <- fft(DSAX$RTH1)
\end_layout

\begin_layout Plain Layout

N <- length(ft)
\end_layout

\begin_layout Plain Layout

Rate <- attr(DSX, 'Rate')
\end_layout

\begin_layout Plain Layout

df <- Rate / N
\end_layout

\begin_layout Plain Layout

frq <- c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
\end_layout

\begin_layout Plain Layout

fr <- log(abs(frq))
\end_layout

\begin_layout Plain Layout

Gain  <- cfrHARCO[1] + fr * (cfrHARCO[2] + fr * fr * (cfrHARCO[3] + 
\end_layout

\begin_layout Plain Layout

         fr * (cfrHARCO[4] + fr * cfrHARCO[5])))
\end_layout

\begin_layout Plain Layout

Gain[abs(frq) < 0.024] <- 1
\end_layout

\begin_layout Plain Layout

Phase <- cfHARCO[1] + cfHARCO[2] * fr + cfHARCO[3] * fr^2 +
\end_layout

\begin_layout Plain Layout

         cfHARCO[4] * atan(frq)
\end_layout

\begin_layout Plain Layout

Phase[frq < 0] <- -Phase[frq < 0]
\end_layout

\begin_layout Plain Layout

Phase[1] <- 0
\end_layout

\begin_layout Plain Layout

Phase <- Phase * pi / 180
\end_layout

\begin_layout Plain Layout

TF <- complex(modulus=Gain, argument=Phase)
\end_layout

\begin_layout Plain Layout

tlmt <- 1.8
\end_layout

\begin_layout Plain Layout

TF[abs(frq) > tlmt] <- TF[abs(frq) > tlmt] * exp(5*abs(frq[abs(frq) > tlmt])
 / tlmt)
\end_layout

\begin_layout Plain Layout

ftx <- ft / TF
\end_layout

\begin_layout Plain Layout

DSAX$RTFFT <- Re(fft(ftx, inverse = TRUE) / N)
\end_layout

\begin_layout Plain Layout

N <- 2^13 
\end_layout

\begin_layout Plain Layout

Nby2 <- N / 2
\end_layout

\begin_layout Plain Layout

RTH1 <- DSAX$RTH1
\end_layout

\begin_layout Plain Layout

ff1 <- fft(RTH1)
\end_layout

\begin_layout Plain Layout

RTH <- Re(fft(ff1, inverse=TRUE)) / N
\end_layout

\begin_layout Plain Layout

df <- Rate / N
\end_layout

\begin_layout Plain Layout

frq <- c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
\end_layout

\begin_layout Plain Layout

fr <- log(frq[1:(Nby2+1)])
\end_layout

\begin_layout Plain Layout

## Get the transfer function from the fitted parameterized form:
\end_layout

\begin_layout Plain Layout

Ph <- cfHARCO[1] + cfHARCO[2] * fr + 
\end_layout

\begin_layout Plain Layout

           cfHARCO[3] * fr^2 + cfHARCO[4] * atan(frq[1:(Nby2+1)])
\end_layout

\begin_layout Plain Layout

Ph[1] <- 0
\end_layout

\begin_layout Plain Layout

G <- cfrHARCO[1] + fr * (cfrHARCO[2] + fr * fr * (cfrHARCO[3] + 
\end_layout

\begin_layout Plain Layout

           fr * (cfrHARCO[4] + fr * cfrHARCO[5])))
\end_layout

\begin_layout Plain Layout

G[frq[1:length(fr)] < 0.024] <- 1
\end_layout

\begin_layout Plain Layout

G[frq[1:length(fr)] > 2] <- G[which.min(abs(frq-2))]
\end_layout

\begin_layout Plain Layout

H <- rep(complex(modulus=0), N)
\end_layout

\begin_layout Plain Layout

H[1:(Nby2+1)] <- complex(modulus=G, argument=Ph * pi / 180)
\end_layout

\begin_layout Plain Layout

H[(Nby2+2):N] <- rev(Conj(H[2:Nby2]))
\end_layout

\begin_layout Plain Layout

RTC <- Re(fft(ff1 / H, inverse = TRUE)) / N
\end_layout

\begin_layout Plain Layout

DSAX$RTC <- RTC
\end_layout

\begin_layout Plain Layout

dfTF <- data.frame(
\end_layout

\begin_layout Plain Layout

  'Time' = frq,
\end_layout

\begin_layout Plain Layout

  'Amp' = Gain,
\end_layout

\begin_layout Plain Layout

  'Phase' = Phase
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  ggplotWAC(
\end_layout

\begin_layout Plain Layout

    dfTF,
\end_layout

\begin_layout Plain Layout

    panels = 2,
\end_layout

\begin_layout Plain Layout

    labelP = c('    Amplitude', 'Phase [degrees]')
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab(bquote('transfer function H(' * nu
 ~ ')'))
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  g + scale_x_log10(
\end_layout

\begin_layout Plain Layout

    breaks = trans_breaks("log10", function(x)
\end_layout

\begin_layout Plain Layout

      10 ^ x, n = 4),
\end_layout

\begin_layout Plain Layout

    labels = trans_format("log10", math_format(expr = 10 ^ .x))
\end_layout

\begin_layout Plain Layout

  ) + xlab('frequency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = 'tb')
\end_layout

\begin_layout Plain Layout

# g + theme_WAC(1) + theme(legend.position = c(0.3, 0.65))
\end_layout

\begin_layout Plain Layout

DSAP <- DSAX
\end_layout

\begin_layout Plain Layout

DSAP$RTH1 <- DSAP$RTH1 - mean(DSAP$RTH1[setRange(DSAP, 55700, 60000)], na.rm=TRUE
)
\end_layout

\begin_layout Plain Layout

DSAP$RTF1P <- DSAP$RTF1 - mean(DSAP$RTF1[setRange(DSAP, 55700, 60000)],
 na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

DSAP$RTH <- DSAP$RTHC - mean(DSAP$RTHC[setRange(DSAP, 55700, 60000)], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

DSAP$RT <- DSAP$RT - mean(DSAP$RT[setRange(DSAP, 55700, 60000)], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

DSAP$FFT <- DSAP$RTFFT - mean(DSAP$RTFFT[setRange(DSAP, 55700, 60000)],
\end_layout

\begin_layout Plain Layout

                                na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

DSAP$Tm <- DSAP$RTH1
\end_layout

\begin_layout Plain Layout

DSAP %>% selectTime(55920, 55950) %>% 
\end_layout

\begin_layout Plain Layout

         select(Time, RT, Tm, FFT, RTH) %>% 
\end_layout

\begin_layout Plain Layout

         ggplotWAC(c('blue', 'forestgreen', 'black', 'darkorange'),
\end_layout

\begin_layout Plain Layout

                   ylab=bquote('recovery temperature [' ~ degree * 'C]'),
\end_layout

\begin_layout Plain Layout

                   lty=c(1,2,1,1), lwd=c(0.8,1.2,1,0.8)) + xlab('time [s]')
 +
\end_layout

\begin_layout Plain Layout

         theme_WAC(1) + 
\end_layout

\begin_layout Plain Layout

         theme(legend.position=c(0.715, 0.93))
\end_layout

\begin_layout Plain Layout

g <- DSAP %>% select(Time, TASX, Tm, RTH, RT) %>% 
\end_layout

\begin_layout Plain Layout

        VSpec(xlim=c(5.e-3, 15), ylim=c(2.e-6, 1.e-2), 
\end_layout

\begin_layout Plain Layout

        smoothBins = 100, method='MEM')
\end_layout

\begin_layout Plain Layout

VSpec(DSAP, 'FFT', add=g, type='MEM') + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Section
Reproducibility
\end_layout

\begin_layout Standard
\begin_inset Index idx
status open

\begin_layout Plain Layout
reproducibility
\end_layout

\end_inset

This document is constructed in ways that support duplication of the study.
 The code that generates the plots and implements the correction procedure
 is incorporated into the same 
\begin_inset Index idx
status open

\begin_layout Plain Layout
program!file
\end_layout

\end_inset

file that generated this document via 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
LaTeX
\end_layout

\end_inset

, using principles and techniques described by 
\begin_inset CommandInset citation
LatexCommand citet
key "Xie2014a"
literal "true"

\end_inset

 as implemented in the R 
\begin_inset Index idx
status open

\begin_layout Plain Layout
R language!package!knitr
\end_layout

\end_inset

package
\begin_inset Index idx
status open

\begin_layout Plain Layout
knitr
\end_layout

\end_inset

 'knitr' (
\begin_inset CommandInset citation
LatexCommand citet
key "Xie2014b"
literal "true"

\end_inset

).
 The program, 'Paper1.Rnw', is archived on 'GitHub' 
\begin_inset Index idx
status open

\begin_layout Plain Layout
GitHub repository
\end_layout

\end_inset

in the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
repository!github
\end_layout

\end_inset

directory
\begin_inset Index idx
status open

\begin_layout Plain Layout
archive!for this document
\end_layout

\end_inset

 at 
\begin_inset CommandInset href
LatexCommand href
name "this URL"
target "https://github.com/WilliamCooper/KalmanFilter.git"
literal "false"

\end_inset

.
 There is some 
\begin_inset Index idx
status open

\begin_layout Plain Layout
supplemental material
\end_layout

\end_inset

supplemental material in that directory, including a workflow document
\begin_inset Index idx
status open

\begin_layout Plain Layout
workflow document
\end_layout

\end_inset

 for all the papers, the bibliography and some code segments saved in the
 
\begin_inset Quotes eld
\end_inset

chunks
\begin_inset Quotes erd
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
R language!program chunks
\end_layout

\end_inset

 subdirectory, so the full directory should be downloaded in order to run
 the program.
 The calculations use the programming 
\begin_inset Index idx
status open

\begin_layout Plain Layout
R language
\end_layout

\end_inset

language 
\begin_inset Index idx
status open

\begin_layout Plain Layout
R language!program
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
RStudio
\end_layout

\end_inset

R (
\begin_inset CommandInset citation
LatexCommand citet
key "Rlanguage"
literal "true"

\end_inset

) and were run within 
\begin_inset Index idx
status open

\begin_layout Plain Layout
RStudio
\end_layout

\end_inset

RStudio (
\begin_inset CommandInset citation
LatexCommand citet
key "RStudio2012"
literal "true"

\end_inset

), so this is the most straightforward way to replicate the calculations
 and the generation of this 
\begin_inset Index idx
status open

\begin_layout Plain Layout
program!generating this document
\end_layout

\end_inset

document.
\end_layout

\begin_layout Standard
A 
\begin_inset Index idx
status open

\begin_layout Plain Layout
R language!package!Ranadu
\end_layout

\end_inset

package named Ranadu,
\begin_inset Index idx
status open

\begin_layout Plain Layout
R language!package!Ranadu
\end_layout

\end_inset

 containing auxillary 
\begin_inset Index idx
status open

\begin_layout Plain Layout
function!Ranadu
\end_layout

\end_inset

functions, is used extensively in the R code.
 It is available on GitHub
\begin_inset Index idx
status open

\begin_layout Plain Layout
GitHub repository
\end_layout

\end_inset

 as 
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/WilliamCooper/Ranadu.git"
literal "false"

\end_inset

.
 The version used for calculations in this technical note is included in
 the 'zip' archive listed below.
\end_layout

\begin_layout Standard
The 
\begin_inset Index idx
status open

\begin_layout Plain Layout
file!data
\end_layout

\end_inset

data files used are also preserved in the NCAR/EOL Data Archives and can
 be obtained via a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
data!requesting
\end_layout

\end_inset

request to 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

mailto:raf-dm@eol.ucar.edu
\end_layout

\end_inset

 or via the 
\begin_inset Quotes eld
\end_inset

Data Access
\begin_inset Quotes erd
\end_inset

 links at 
\begin_inset CommandInset href
LatexCommand href
name "this web site"
target "https://www.eol.ucar.edu/all-field-projects-and-deployments"
literal "false"

\end_inset

.
 The original files containing the data as produced by the NCAR Earth Observing
 Laboratory, Research Aviation Facility, were in 
\begin_inset Index idx
status open

\begin_layout Plain Layout
netCDF format
\end_layout

\end_inset

netCDF format (cf.
\begin_inset space ~
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "this URL"
target "http://www.unidata.ucar.edu/software/netcdf/"
literal "false"

\end_inset

), but in many cases data archives were reprocessed and the files may change
 after reprocessing so a separate archive
\begin_inset Index idx
status open

\begin_layout Plain Layout
archive!for this document!data
\end_layout

\end_inset

 is maintained for this document.
 The data files
\begin_inset Index idx
status open

\begin_layout Plain Layout
file!data!archive
\end_layout

\end_inset

 in this archive contain 
\begin_inset Index idx
status open

\begin_layout Plain Layout
R language!data.frames
\end_layout

\end_inset

R data.frames and are preserved as binary-format 'Rdata' files via R 'save'
 commands.
 The code in the GitHub archive has appropriate 'load' commands to read
 these data files from a subdirectory named 'Data' (/Data or ~/Data or /home/Dat
a) but this is not part of the GitHub repository because it is too large
 to be appropriate there.
 To reproduce this research, those data files have to be transferred separately
 from {??where??}
\end_layout

\begin_layout Standard
Extensive use has been made of 
\begin_inset Index idx
status open

\begin_layout Plain Layout
attributes!data.frame
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
attributes!variable
\end_layout

\end_inset

attributes assigned to the data.frames and the variables in those data.frames.
 All the attributes from the original netCDF 
\begin_inset Index idx
status open

\begin_layout Plain Layout
file!netCDF
\end_layout

\end_inset

files have been transferred to the data.frames, so there is a record of how
 the original data were processed, for example with 
\begin_inset Index idx
status open

\begin_layout Plain Layout
calibration!coefficients!used in processing
\end_layout

\end_inset

calibration coefficients and processing dependence for the variables.
 Key information like the processing date, the program version that produced
 the archive, and the selection of primary variables for various measurements
 thus is preserved.
\end_layout

\begin_layout Standard
(See the related list of project components on the next page that are preserved
 to enhance reproducibility.)
\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Project:
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SensibleHeatFlux
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Archive package:
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "SensibleHeatFluxPaper1.zip"
target "https://github.com/WilliamCooper/SensibleHeatFlux/blob/master/SensibleHeatFluxPaper1.zip"
literal "false"

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Contains:
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
attachment list below
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Program:
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "Paper1.Rnw"
target "https://github.com/WilliamCooper/SensibleHeatFlux/blob/master/Paper1.Rnw"
literal "false"

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Original Data:
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset CommandInset citation
LatexCommand citet
key "VOCALS2011"
literal "false"

\end_inset

, 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset CommandInset citation
LatexCommand citet
key "CSET2017"
literal "false"

\end_inset

,
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
,
\begin_inset CommandInset citation
LatexCommand citet
key "SOCRATES2019"
literal "false"

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Special Data Files:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SensibleHeatFluxTechNote.Rdata, SensibleHeatFluxTechNote2.Rdata
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Workflow Document:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "WorkflowSensibleHeatFlux.pdf"
target "https://github.com/WilliamCooper/SensibleHeatFlux/blob/master/WorkflowSensibleHeatFlux.pdf"
literal "false"

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Git:
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Index idx
status open

\begin_layout Plain Layout
GitHub repository
\end_layout

\end_inset


\begin_inset CommandInset href
LatexCommand href
name "https://github.com/WilliamCooper/SensibleHeatFlux.git"
target "https://github.com/WilliamCooper/SensibleHeatFlux.git"
literal "false"

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
attachm{
\end_layout

\end_inset

Paper1.Rnw
\begin_inset Newline newline
\end_inset

Paper1.pdf
\begin_inset Newline newline
\end_inset

WorkflowSensibleHeatFlux.pdf
\begin_inset Newline newline
\end_inset

WAC.bib
\begin_inset Newline newline
\end_inset

chunks/*
\begin_inset Newline newline
\end_inset

SessionInfo
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\begin_layout Plain Layout


\backslash
phantomsection 
\backslash
addcontentsline{toc}{section}{List of Symbols}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset index_print
LatexCommand printindex
type "lis"
name "List of Symbols"
literal "true"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\begin_layout Plain Layout


\backslash
phantomsection 
\backslash
addcontentsline{toc}{section}{Variable Names and Acronyms}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset index_print
LatexCommand printindex
type "var"
name "Variable Names and Acronyms"
literal "true"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Variable Names
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\begin_layout Plain Layout


\backslash
phantomsection 
\backslash
addcontentsline{toc}{section}{Index}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
** indicates that many similar entries are omitted.
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset index_print
LatexCommand printindex
type "idx"
name "Index"
literal "true"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\begin_layout Plain Layout

%
\backslash
phantomsection 
\backslash
addcontentsline{toc}{section}{References}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:bibliography"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "/home/cooperw/RStudio/WAC"
options "bibtotoc,plainnat"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% 
\backslash
centerline{-- Blank Page, End of this Technical Report --}
\end_layout

\begin_layout Plain Layout

% 
\backslash
vfill
\backslash
eject
\end_layout

\begin_layout Plain Layout

% 
\backslash
clearpage
\end_layout

\begin_layout Plain Layout

%
\backslash
addcontentsline{toc}{section}{End}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<make-zip-archive, INCLUDE=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

system (sprintf("zip KalmanFilterTechNote.zip KalmanFilterTechNote.Rnw KalmanFilte
rTechNote.pdf WorkflowKalmanFilter.pdf WAC.bib ./chunks/* SessionInfo"))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@ 
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
