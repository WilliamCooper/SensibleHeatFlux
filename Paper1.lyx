#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\definecolor{fgcolor}{rgb}{0.345, 0.345, 0.345}\definecolor{messagecolor}{rgb}{0, 0, 0}\definecolor{warningcolor}{rgb}{1, 0, 1}\definecolor{errorcolor}{rgb}{1, 0, 0}\setlength{\headheight}{14.5pt}\usepackage{babel}


\definecolor{fgcolor}{rgb}{0.345, 0.345, 0.345}\definecolor{messagecolor}{rgb}{0, 0, 0}\definecolor{warningcolor}{rgb}{1, 0, 1}\definecolor{errorcolor}{rgb}{1, 0, 0}\usepackage{babel}
% macro for italic page numbers in the index
\newcommand{\IndexDef}[1]{\textit{#1}}
\newcommand{\IndexPrimary}[1]{\textbf{#1}}
% force a page break at the start of sections
\let\stdsection\section
\renewcommand{\section}{\newpage\stdsection}


% workaround for a makeindex bug,
% see sec. "Index Entry Order"
% only uncomment this when you are using makindex
%\let\OrgIndex\index 
%\renewcommand*{\index}[1]{\OrgIndex{#1}}
%\usepackage{splitidx}

% workaround for a makeindex bug,
% see sec. "Index Entry Order"
% only uncomment this when you are using makindex
\let\OrgIndex\index 
\renewcommand*{\index}[1]{\OrgIndex{#1}}
\usepackage{splitidx}
%\indexsetup{noclearpage}
\AtBeginDocument{
  \def\labelitemii{\(\circ\)}
  \def\labelitemiii{\(\triangleright\)}
}
\usepackage[font={normal,sl}]{caption}% set captions slanted

\IfFileExists{upquote.sty}{\usepackage{upquote}}{}

\newenvironment{lylist}[1]{\begin{list}{}
{\settowidth{\labelwidth}{#1}
\setlength{\leftmargin}{\labelwidth}
\addtolength{\leftmargin}{\labelsep}
\renewcommand{\makelabel}[1]{##1\hfil}}}{\end{list}}
\newcommand{\datetoday}{\number\day\space
     \ifcase\month\or January\or February\or March\or April\or May\or
     June\or July\or August\or September\or October\or November\or
     December\fi
     \space\number\year}
\newcommand{\EOLmemo}{\null \vskip-1.5truein
{\raggedright \textsf{\textsc{\large \textcolor{blue}{Earth Observing Laboratory}}}}\par
{\raggedright \textsf{\textsl{\textcolor{blue}{Memorandum:}}}} \par \vskip6pt
{\color{blue}{\hrule}}\par
\vskip0.3truein \leftline{\hskip \longindent \datetoday} \vskip0.2truein
\thispagestyle{empty}}
\newcommand{\attachm}[1]{\begin{lylist}{Attachments:00}
\item [Attachments:] {#1}
\end{lylist}}
\newcommand{\cc}[1]{\begin{lylist}{Attachments:00}
\item [cc:] {#1}
\end{lylist}}
\newcommand{\attach}[1]{\begin{lylist}{Attachments:00}
\item [Attachment:] {#1}
\end{lylist}}

\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\pagenumbering{gobble}
\end_preamble
\options 12pt,twoside,american
\use_default_options false
\begin_modules
knitr
hanging
\end_modules
\maintain_unincluded_children false
\language american
\language_package babel
\inputencoding default
\fontencoding global
\font_roman "times" "default"
\font_sans "helvet" "default"
\font_typewriter "lmtt" "default"
\font_math "auto" "auto"
\font_default_family rmdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format pdf2
\output_sync 0
\bibtex_command bibtex
\index_command makeindex
\paperfontsize 11
\spacing single
\use_hyperref true
\pdf_title "Technical Note: Measuring Sensible-Heat Flux"
\pdf_author "William A. Cooper"
\pdf_subject "Assessment of Measurements of Sensible-Heat Flux"
\pdf_keywords "sensible heat flux, temperature, time response of sensors, NCAR Research Aviation Facility, research aircraft, NCAR/EOL/RAF"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref section
\pdf_pdfusetitle false
\pdf_quoted_options " linkcolor=blue, citecolor={blue}"
\papersize letterpaper
\use_geometry true
\use_package amsmath 2
\use_package amssymb 0
\use_package cancel 0
\use_package esint 2
\use_package mathdots 0
\use_package mathtools 0
\use_package mhchem 0
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine natbib
\cite_engine_type authoryear
\biblio_style plainnat
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 0
\use_minted 0
\backgroundcolor #ffffff
\boxbgcolor #f7f7f7
\branch Extra
\selected 0
\filename_suffix 0
\color #faf0e6
\end_branch
\index Index
\shortcut idx
\color #008000
\end_index
\index Variable Names and Acronyms
\shortcut var
\color #00aaff
\end_index
\index List of Symbols
\shortcut lis
\color #ff0000
\end_index
\leftmargin 1.2in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 2
\paragraph_separation skip
\defskip medskip
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\tracking_changes true
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\author 1311305628 "William Cooper"
\end_header

\begin_body

\begin_layout Title
The Delayed Response of Airborne Thermometers:
\begin_inset Newline newline
\end_inset

Part 1: Determining the Characteristic Response 
\end_layout

\begin_layout Author
William A.
 Cooper and others...
\end_layout

\begin_layout Date

\color red
DRAFT
\color inherit
 March 2020
\end_layout

\begin_layout Standard
National Center for Atmospheric Research
\begin_inset Newline newline
\end_inset

Earth Observing Laboratory
\begin_inset Newline newline
\end_inset

Research Aviation Facility
\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\begin_inset Newpage cleardoublepage
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{roman}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
contentsname}{Table of Contents} 
\end_layout

\end_inset


\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset

 
\begin_inset VSpace vfill
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
eject
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%% LyX 2.2.2 created this file.
  For more info, see http://www.lyx.org/.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\backslash
phantomsection 
\backslash
addcontentsline{toc}{section}{List of Figures}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
clearpage %
\backslash
phantomsection 
\backslash
addcontentsline{toc}{section}{List of Tables}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList table

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
abstractname}{Preface and Abstract}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{plain}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{abstract}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\change_inserted 1311305628 1585866180
This is Part 1 of a three-part series addressing errors that are present
 in most archived measurements of temperature made from research aircraft.
 In this first part, 
\change_deleted 1311305628 1585866182
T
\change_inserted 1311305628 1585866182
t
\change_unchanged
he time response of
\change_deleted 1311305628 1585857826
 some
\change_unchanged
 standard airborne thermometers is 
\change_deleted 1311305628 1585865846
determined
\change_inserted 1311305628 1585865848
quantified
\change_unchanged
 by 
\change_inserted 1311305628 1585865854
determining
\change_deleted 1311305628 1585865859
observing
\change_unchanged
 the transfer function where the known input is turbulent dynamic heating.
 Differential equations for the response are proposed, and it is verified
 that the solutions to those differential equations provide good representations
 of the response characteristics in terms of fitted empirical coefficients.
 Those solutions then can be used to correct the measurements to compensate
 in part for the response characteristics of the sensors.
 
\change_inserted 1311305628 1585866473
Part 2 will use these results to demonstrate that standard data processing
 used by most operators of research aircraft introduces errors that arise
 from incorrect adjustment for dynamic heating.
 Part 3 will use the results from the first two papers to assess how these
 errors affect measurements of the flux of sensible heat and will propose
 and evaluate a method for correcting those measurements that removes a
 significant error in that measured flux.
\change_unchanged

\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{abstract}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Section*
Acknowledgements
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:acknowledgements"

\end_inset


\end_layout

\begin_layout Standard
This material is based upon work supported by the National Center for Atmospheri
c Research, which is a major facility sponsored by the National Science
 Foundation under Cooperative Agreement No.
 1852977.
 Any opinions, findings and conclusions or recom-mendations expressed in
 this publication are those of the author(s) and do not necessarily reflect
 the views of the National Science Foundation.
 The data used in the examples presented are from the VOCALS (VAMOS Ocean-Cloud-
Atmosphere-Land Study), SOCRATES (Southern Ocean Clouds, Radiation, Aerosol
 Transport Experimental Study) and the CSET (Cloud Systems Evolution in
 the Trades) experiment
\change_inserted 1311305628 1586123187
s
\change_unchanged
, 
\begin_inset Note Note
status open

\begin_layout Plain Layout
WE-CAN (Western wildfire Experiment for Cloud chemistry, Aerosol absorption
 and Nitrogen) projects, 
\end_layout

\end_inset

each described at 
\begin_inset CommandInset href
LatexCommand href
name "this URL"
target "https://www.eol.ucar.edu/field_projects/"
literal "false"

\end_inset

.
 Citations for the data sets are included in the references.
 Measurements (
\begin_inset CommandInset citation
LatexCommand citet
key "VOCALS2011"
literal "false"

\end_inset

, 
\begin_inset CommandInset citation
LatexCommand citet
key "SOCRATES2019"
literal "false"

\end_inset

, 
\begin_inset CommandInset citation
LatexCommand citet
key "WECAN2018"
literal "false"

\end_inset

) were collected by the project experiment teams, and flight operations
 and data acquisition and processing were performed by the Research Aviation
 Facility, Earth Observing Laboratory, National Center for Atmospheric Research
 (NCAR).
 The analyses reported here were mostly performed using R (
\begin_inset CommandInset citation
LatexCommand citet
key "Rlanguage"
literal "true"

\end_inset

), with 
\begin_inset Index idx
status open

\begin_layout Plain Layout
RStudio
\end_layout

\end_inset

RStudio (
\begin_inset CommandInset citation
LatexCommand citet
key "RStudio2012"
literal "true"

\end_inset

) and 
\begin_inset Index idx
status open

\begin_layout Plain Layout
knitr
\end_layout

\end_inset

knitr (
\begin_inset CommandInset citation
LatexCommand citet
key "Xie2014a,Xie2014b"
literal "true"

\end_inset

).
 Data files in netCDF format have been read and written using the R 
\begin_inset Index idx
status open

\begin_layout Plain Layout
R language!package!ncdf4
\end_layout

\end_inset

package 
\begin_inset Quotes eld
\end_inset

ncdf4
\begin_inset Quotes erd
\end_inset

; cf.
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citet
key "ncdf4"
literal "true"

\end_inset

.
 Substantial use also was made of the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
ggplot2
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
R language!package!ggplot2
\end_layout

\end_inset


\begin_inset Quotes eld
\end_inset

ggplot2
\begin_inset Quotes erd
\end_inset

 package (
\begin_inset CommandInset citation
LatexCommand citet
key "wickham2009"
literal "true"

\end_inset

) for R, and some fits relied on the 
\begin_inset Quotes eld
\end_inset

nleqslv
\begin_inset Quotes erd
\end_inset

 package for R 
\begin_inset CommandInset citation
LatexCommand citet
key "hasselman-nleqslv"
literal "false"

\end_inset

.
 Extensive use was made of the 
\begin_inset Quotes eld
\end_inset

stats
\begin_inset Quotes erd
\end_inset

 package, part of Core R\SpecialChar endofsentence
 Some of the numerical integrations used the Runge-Kutta
 function from the 
\begin_inset Quotes eld
\end_inset

rmutil
\begin_inset Quotes erd
\end_inset

 package (
\begin_inset CommandInset citation
LatexCommand citet
key "runge.kutta"
literal "false"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{plain}
\end_layout

\end_inset


\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{arabic}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction
\change_deleted 1311305628 1585923272

\end_layout

\begin_layout Subsection

\change_deleted 1311305628 1585923267
Overview
\end_layout

\begin_layout Standard

\change_inserted 1311305628 1585867327
Temperature is a routine measurement on research aircraft, but the standard
 sensors in widespread use do not respond fast enough to meet many scientific
 needs.
 In particular, measurements of the flux of sensible heat need faster response
 than is typically available, as do measurements of near-discontinuous changes
 such as those at the top of boundary layers or at cloud boundaries.
 The measurement of sensible-heat flux requires, for the standard eddy-correlati
on measurement, that temperature be measured with sufficient response to
 resolve the spectrum of contributions to the flux.
 
\change_unchanged
Various recent reviews of priorities for research in atmospheric science
 have called attention to the important roles that fluxes of various quantities
 play in climate science and have advocated increased focus on those fluxes;
 e.g., 
\begin_inset CommandInset citation
LatexCommand citet
key "NAP6021"
literal "false"

\end_inset

.
 
\change_deleted 1311305628 1585867313
Among the fluxes that should be measurable using research aircraft is the
 flux of sensible heat.
 That requires, for the standard eddy-correlation measurement, that temperature
 be measured with sufficient response to resolve the spectrum of contributions
 to the flux.
 Temperature is a routine measurement on research aircraft, but most sensors
 do not have adequate response for this measurement.

\change_unchanged
 
\change_inserted 1311305628 1585867465

\end_layout

\begin_layout Standard

\change_inserted 1311305628 1585867526
The basis for this measurement of the flux of sensible heat (
\begin_inset Formula $F_{s})$
\end_inset

 is this equation:
\end_layout

\begin_layout Standard

\change_inserted 1311305628 1585867665
\begin_inset Formula 
\begin{equation}
F_{s}=\rho_{a}\thinspace C_{p}\left\langle w^{\prime}T^{\prime}\right\rangle \label{eq:heatFlux}
\end{equation}

\end_inset

where 
\begin_inset Formula $\rho_{a}$
\end_inset

 is the density of air, 
\begin_inset Formula $C_{p}$
\end_inset

 the specific heat of air at constant pressure, 
\begin_inset Formula $w$
\end_inset

 the vertical wind, and 
\begin_inset Formula $T$
\end_inset

 the temperature.
 Primes in this equation denote fluctuations from the mean and angle brackets
 denote an ensemble average.
 The measurement thus depends on having a temperature sensor that can respond
 to the range of fluctuations making significant contributions to the heat
 flux.
 
\begin_inset CommandInset citation
LatexCommand citet
key "FrieheKhelif1992"
literal "false"

\end_inset

 suggest, without demonstration, that 4–5
\begin_inset space ~
\end_inset

Hz is 
\begin_inset Quotes eld
\end_inset

just adequate
\begin_inset Quotes erd
\end_inset

 (for flight at around 125
\begin_inset space ~
\end_inset

m/s) and that 25
\begin_inset space ~
\end_inset

Hz would be desirable to resolve some interesting aspects of the temperature
 structure.
 If the response of the temperature sensor is reduced or shifted in phase
 at a particular frequency, an error will be introduced into the measurement
 of sensible-heat flux.
 
\begin_inset CommandInset citation
LatexCommand citet
key "LawsonRodi1992"
literal "false"

\end_inset

 argued that sensible-heat flux measured by some of the fastest sensors
 then in common use produced measurements of sensible heat flux about 21%
 too low compared to the measurements from their faster thermocouple-based
 sensor.
 It therefore is essential, for this measurement, to characterize the time
 response of the temperature sensor used and, where necessary, to apply
 corrections to compensate for that response.
\end_layout

\begin_layout Standard

\change_inserted 1311305628 1585922308
The present investigation uses measurements from the NSF/NCAR (National
 Science Foundation / National Center for Atmospheric Research) research
 aircraft, but the temperature sensors producing the measurements are in
 widespread use so these results should have community applicability.
 Measurements were made in several field projects that used the NSF/NCAR
 Gulfstream V (hereafter, GV) or C-130 aircraft.
 Some aspects of the uncertainty limits associated with temperature are
 included in an NCAR Technical Note (
\begin_inset CommandInset citation
LatexCommand citet
key "Cooper2016ncartn"
literal "true"

\end_inset

), which focused on the measurements of wind from the GV\SpecialChar endofsentence
 That document included
 an estimate that the standard uncertainty in measurements of temperature
 from the GV is about 
\begin_inset Formula $0.3^{\circ}\mathrm{C}$
\end_inset

 and referenced 
\begin_inset CommandInset citation
LatexCommand citet
key "CooperEtAl2014"
literal "false"

\end_inset

 for supporting evidence.
 This limit applies when the temperature being measured is varying slowly
 but does not apply when the temperature changes rapidly.
 It is well known, however, that temperature sensors in common use on research
 aircraft have time-response characteristics that can affect the measurements.
 
\begin_inset CommandInset citation
LatexCommand citet
key "FrieheKhelif1992"
literal "false"

\end_inset

 and 
\begin_inset CommandInset citation
LatexCommand citet
key "LawsonRodi1992"
literal "false"

\end_inset

, among many others, provide reviews of the evidence for delayed response
 of the standard sensors.
 In particular, the unheated Rosemount 102E4AL sensor has been used widely
 as a fast-responding sensor, so it will be a focus of this three-part study.
\end_layout

\begin_layout Standard

\change_deleted 1311305628 1585921478
This set of three papers argues that application of a correction procedure
 developed in the third paper improves this measurement sufficiently to
 make it reliable despite the response-characteristics of airborne thermometers.
 That paper relies on information from the first two.
 
\end_layout

\begin_layout Standard
In this first paper, the time response of some standard airborne temperature
 sensors is characterized in terms of a transfer function that relates the
 measurand (the temperature) to the measurement (the sensor output) in ways
 that are invertible.
 Two coupled differential equations are used as the basis for this characterizat
ion, but the transfer function is determined independent of those equations.
 Because the equations predict a transfer function matching the observations,
 they provide a useful generalization 
\change_deleted 1311305628 1585922192
of that transfer function
\change_inserted 1311305628 1585922205
 when the measurements are fitted to a three-parameter equation consistent
 with those equations
\change_unchanged
.
\end_layout

\begin_layout Standard

\change_deleted 1311305628 1585867657
Some aspects of the uncertainty limits associated with temperature as measured
 from research aircraft are included in an NCAR Technical Note (
\begin_inset CommandInset citation
LatexCommand citet
key "Cooper2016ncartn"
literal "true"

\end_inset

), which was focused on the measurements of wind from the NSF/NCAR Gulfstream
 V
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
aircraft!NSF/NCAR GV
\end_layout

\end_inset


\begin_inset Index var
status open

\begin_layout Plain Layout
GV=NSF/NCAR Gulfstream V
\end_layout

\end_inset

 research aircraft, hereafter called the GV.
\begin_inset Index idx
status open

\begin_layout Plain Layout
GV|see 
\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset

aircraft!NSF/NCAR GV
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
NSF/NCAR GV|see 
\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset

aircraft!NSF/NCAR GV
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_inset

 That aircraft and a C-130 are owned by the 
\begin_inset Index var
status open

\begin_layout Plain Layout
NSF=National Science Foundation
\end_layout

\end_inset

National Science Foundation (NSF) and operated by the Research Aviation
 Facility
\begin_inset Index var
status open

\begin_layout Plain Layout
RAF=Research Aviation Facility
\end_layout

\end_inset

 (RAF), Earth Observing Laboratory (EOL), National Center for Atmospheric
 Research
\begin_inset Index var
status open

\begin_layout Plain Layout
NCAR=National Center for Atmospheric Research
\end_layout

\end_inset

 (NCAR).
 
\begin_inset Index idx
status open

\begin_layout Plain Layout
aircraft!NSF/NCAR GV
\end_layout

\end_inset

 The NCAR Technical Note included an estimate that the standard uncertainty
 in measurements of temperature from the GV is about 
\begin_inset Formula $0.3^{\circ}\mathrm{C}$
\end_inset

 and referenced 
\begin_inset CommandInset citation
LatexCommand citet
key "CooperEtAl2014"
literal "false"

\end_inset

 for supporting evidence.
 This limit applies when the temperature being measured is varying slowly
 and does not consider apply when the temperature changes rapidly.
 It is well known, however, that temperature sensors in common use on research
 aircraft have time-response characteristics that can affect the measurements.
 
\begin_inset CommandInset citation
LatexCommand citet
key "FrieheKhelif1992"
literal "false"

\end_inset

 and 
\begin_inset CommandInset citation
LatexCommand citet
key "LawsonRodi1992"
literal "false"

\end_inset

, among many others, provide reviews of the evidence for delayed response
 of the standard sensors.
 In particular, the unheated Rosemount 102E4AL sensor has been used widely
 as a fast-responding sensor, but its response characteristics are inadequate
 for many applications on a fast-moving aircraft like the NSF/NCAR GV.
\change_unchanged

\end_layout

\begin_layout Standard

\change_deleted 1311305628 1585867449
The time response of temperature sensors becomes particularly important
 when it is desired to measure the flux of sensible heat (
\begin_inset Formula $F_{s}$
\end_inset

) by the eddy-correlation method.
 The basis for this measurement is this equation:
\end_layout

\begin_layout Standard

\change_deleted 1311305628 1585867449
\begin_inset Formula 
\begin{equation}
F_{s}=\rho_{a}\thinspace C_{p}\left\langle w^{\prime}T^{\prime}\right\rangle \label{eq:heatFlux}
\end{equation}

\end_inset

where 
\begin_inset Formula $\rho_{a}$
\end_inset

 is the density of air, 
\begin_inset Formula $C_{p}$
\end_inset

 the specific heat of air at constant pressure, 
\begin_inset Formula $w$
\end_inset

 the vertical wind, and 
\begin_inset Formula $T$
\end_inset

 the temperature.
 Primes in this equation denote fluctuations from the mean and angle brackets
 denote an ensemble average.
 The measurement thus depends on having a temperature sensor that can respond
 to the range of fluctuations making significant contributions to the heat
 flux.
 
\begin_inset CommandInset citation
LatexCommand citet
key "FrieheKhelif1992"
literal "false"

\end_inset

 suggest, without demonstration, that 4–5
\begin_inset space ~
\end_inset

Hz is 
\begin_inset Quotes eld
\end_inset

just adequate
\begin_inset Quotes erd
\end_inset

 (for flight at around 125
\begin_inset space ~
\end_inset

m/s) and that 25
\begin_inset space ~
\end_inset

Hz would be desirable to resolve some interesting aspects of the temperature
 structure.
 If the response of the temperature sensor is reduced or shifted in phase
 at a particular frequency, an error will be introduced into the measurement
 of sensible-heat flux.
 
\begin_inset CommandInset citation
LatexCommand citet
key "LawsonRodi1992"
literal "false"

\end_inset

 argued that sensible-heat flux measured by some of the fastest sensors
 in common use produced measurements of sensible heat flux about 21% too
 low compared to the measurements from their faster thermocouple-based sensor.
 It therefore is essential, for this measurement, to characterize the time
 response of the temperature sensor used and, where necessary, to apply
 corrections to compensate for that response.
\change_unchanged

\end_layout

\begin_layout Standard

\change_deleted 1311305628 1585923435
This paper develops a new method for evaluating of the time response of
 a temperature sensor and applies that method to some temperature sensors
 now used on research aircraft.
 One significant difference in comparison to previous studies by, e.g., 
\begin_inset CommandInset citation
LatexCommand citet
key "mccarthy1973method"
literal "false"

\end_inset

 and 
\begin_inset CommandInset citation
LatexCommand citet
key "InverarityJTech2000"
literal "false"

\end_inset

, is that the correction is applied to the measurement from the sensor,
 which corresponds to the 
\begin_inset Quotes eld
\end_inset

recovery temperature
\begin_inset Quotes erd
\end_inset

, rather than the final temperature after correction for dynamic heating.
 The latter reference addresses this but removes the dynamic-heating correction
 prior to applying a correction scheme.
 Because the sensor cannot respond to rapid fluctuations in dynamic heating,
 the standard correction for dynamic heating introduces errors into the
 sensed temperature that are then amplified by a correction procedure.
 This will be addressed in Part II.
\end_layout

\begin_layout Standard

\change_deleted 1311305628 1585923435
\begin_inset CommandInset citation
LatexCommand citet
key "PayneEtAl1994"
literal "false"

\end_inset

 provided a particularly illuminating analysis of the expected response
 of a temperature sensor and developed their results in terms of a transfer
 function.
 They represent the response of the sensor in terms of two coupled differential
 equations, one representing the temperature of the sensing wire and a second
 representing the temperature of the structure that supports that wire.
 Their analysis in terms of fundamental representation of the heat transport
 leads to reasonable consistency with previous two-time-constant models
 like that of 
\begin_inset CommandInset citation
LatexCommand citet
key "mccarthy1973method"
literal "false"

\end_inset

 but poor agreement with the empirical evidence regarding the time-response
 parameters in those models.
 They note, however, that the empirical evidence is not as consistent or
 convincing as would be desirable.
 One goal of the present work, therefore, is to develop a different and
 readily available method of determining those parameters.
 The over-arching goal is to be able to assess errors that might be present
 in measurements of the flux of sensible heat and to apply corrections for
 those errors.
 The transfer function, constrained by new data regarding the parameters,
 makes this possible and also supports a new scheme by which the temperature
 measurements can be corrected for the time response of the sensor.
 This will be the subject of Part III.
\change_unchanged

\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<initialization, echo=FALSE,include=FALSE>>=
\end_layout

\begin_layout Plain Layout

## This chunk loads some needed R packages and defines a function
\end_layout

\begin_layout Plain Layout

## used for the Laplace-transform solution of the governing
\end_layout

\begin_layout Plain Layout

## differential equations.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

library(knitr)
\end_layout

\begin_layout Plain Layout

opts_chunk$set(echo = FALSE,
\end_layout

\begin_layout Plain Layout

               include = FALSE,
\end_layout

\begin_layout Plain Layout

               fig.lp = "fig:")
\end_layout

\begin_layout Plain Layout

# note that fig.pos="center" gave errors, changed to fig.align
\end_layout

\begin_layout Plain Layout

opts_chunk$set(
\end_layout

\begin_layout Plain Layout

  fig.width = 6,
\end_layout

\begin_layout Plain Layout

  fig.height = 3.5,
\end_layout

\begin_layout Plain Layout

  fig.align = "center",
\end_layout

\begin_layout Plain Layout

  digits = 4
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

thisFileName <- "SensibleHeatFluxTechNote"
\end_layout

\begin_layout Plain Layout

library(Ranadu, quietly = TRUE, warn.conflicts = FALSE)
\end_layout

\begin_layout Plain Layout

library(scales)
\end_layout

\begin_layout Plain Layout

require(numDeriv)    ## is this used?
\end_layout

\begin_layout Plain Layout

library(signal)      ## used for filtering
\end_layout

\begin_layout Plain Layout

library(reshape2)    ## used with ggplot facet plots
\end_layout

\begin_layout Plain Layout

library(grid)
\end_layout

\begin_layout Plain Layout

library(magrittr)    ## used for pipes (%>%)
\end_layout

\begin_layout Plain Layout

library(dplyr)
\end_layout

\begin_layout Plain Layout

library(nleqslv)
\end_layout

\begin_layout Plain Layout

library(rmutil)      ## provides the runge-kutta integration function
\end_layout

\begin_layout Plain Layout

options(stringsAsFactors = FALSE)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

CACHE <- FALSE
\end_layout

\begin_layout Plain Layout

setwd ('~/RStudio/SensibleHeatFlux') 
\end_layout

\begin_layout Plain Layout

Directory <- DataDirectory ()
\end_layout

\begin_layout Plain Layout

## standard values:
\end_layout

\begin_layout Plain Layout

frq <- seq(0.01, 25, by = 0.01)
\end_layout

\begin_layout Plain Layout

Phi <- rep(0, length(frq))
\end_layout

\begin_layout Plain Layout

H <- rep(0, length(frq))
\end_layout

\begin_layout Plain Layout

a <- 0.733 # 0.713
\end_layout

\begin_layout Plain Layout

tau1 <- 0.0308  # 0.0335
\end_layout

\begin_layout Plain Layout

tau2 <- 0.447
\end_layout

\begin_layout Plain Layout

# The Laplace-transform solution:
\end_layout

\begin_layout Plain Layout

LTphase <- function(f, P) {
\end_layout

\begin_layout Plain Layout

  ## f=frequency; P=Param
\end_layout

\begin_layout Plain Layout

  tau1 <- P$tau1
\end_layout

\begin_layout Plain Layout

  tau2 <- P$tau2
\end_layout

\begin_layout Plain Layout

  a <- P$a
\end_layout

\begin_layout Plain Layout

  b <- sqrt(1 / (1 + (2 * pi * f * tau2) ^ 2))
\end_layout

\begin_layout Plain Layout

  zeta <- -atan(2 * pi * f * tau2)
\end_layout

\begin_layout Plain Layout

  C1 <- 1 / (1 + 4 * pi ^ 2 * f ^ 2 * tau1 ^ 2) *
\end_layout

\begin_layout Plain Layout

    (-(a + (1 - a) * b * cos(zeta)) * 2 * pi * f * tau1 +
\end_layout

\begin_layout Plain Layout

       (1 - a) * b * sin(zeta))
\end_layout

\begin_layout Plain Layout

  C2 <- 1 / (1 + 4 * pi ^ 2 * f ^ 2 * tau1 ^ 2) *
\end_layout

\begin_layout Plain Layout

    ((a + (1 - a) * b * cos(zeta)) +
\end_layout

\begin_layout Plain Layout

       (1 - a) * b * sin(zeta) * 2 * pi * f * tau1)
\end_layout

\begin_layout Plain Layout

  cTF <- sqrt(C1 ^ 2 + C2 ^ 2)
\end_layout

\begin_layout Plain Layout

  phiTF <- atan2(C1, C2) * 180 / pi
\end_layout

\begin_layout Plain Layout

  return(list('Amp' = cTF, 'Phase' = phiTF))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<rk4Integration, include = FALSE, echo = FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## rk4.integrate
\end_layout

\begin_layout Plain Layout

## [Do entire integration in one call instead, as for runge.kutta]
\end_layout

\begin_layout Plain Layout

## [i.e., function (ya, dydt, tv, tol=0.005) and return entire vector]
\end_layout

\begin_layout Plain Layout

rk4.integrate <- function (dydt, ystart, tv, tol = 0.005) {
\end_layout

\begin_layout Plain Layout

  ## Try the full step and accept if error estimate is < tol;
\end_layout

\begin_layout Plain Layout

  ## otherwise calculate the number of steps that will give the desired
\end_layout

\begin_layout Plain Layout

  ## tolerance and divide the step into that number of smaller steps.
\end_layout

\begin_layout Plain Layout

  L <- length(tv)
\end_layout

\begin_layout Plain Layout

  yr <- rep(ystart, L)
\end_layout

\begin_layout Plain Layout

  y <- ystart
\end_layout

\begin_layout Plain Layout

  dt <- 1
\end_layout

\begin_layout Plain Layout

  for (it in 2:L) {
\end_layout

\begin_layout Plain Layout

    dt <- tv[it] - tv[it - 1]
\end_layout

\begin_layout Plain Layout

    t <- tv[it - 1]
\end_layout

\begin_layout Plain Layout

    RK4 <- rk4.step(y, t, dt, dydt)
\end_layout

\begin_layout Plain Layout

    # print (sprintf ('rk4 return for y=%.2f and t=%.1f is %.2f with error
 estimate %.3f',
\end_layout

\begin_layout Plain Layout

    #                 y1, t, RK4[[1]], RK4[[2]]))
\end_layout

\begin_layout Plain Layout

    if (abs(RK4[[2]]) <= tol) {
\end_layout

\begin_layout Plain Layout

      yr[it] <- y <- RK4[[1]]
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      N <- as.integer (1.1 * (abs(RK4[[2]]) / tol) ^ 0.3 + 1)
\end_layout

\begin_layout Plain Layout

      # print (sprintf ('error estimate is %.3f so using %d steps', RK4[[2]],
 N))
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

      for (n in 1:N) {
\end_layout

\begin_layout Plain Layout

        A <- rk4.step(y, t, dt / N, dydt)
\end_layout

\begin_layout Plain Layout

        y <- A[[1]]
\end_layout

\begin_layout Plain Layout

        if (abs(A[[2]]) > tol) {
\end_layout

\begin_layout Plain Layout

          # print (sprintf ('Warning: error estimate still too large, t=%.2f,
 y=%.2f, err=%.2f', t, y, A[[2]]))
\end_layout

\begin_layout Plain Layout

          # Try further reduced step size
\end_layout

\begin_layout Plain Layout

          M <- as.integer (1.1 * (abs(A[[2]]) / tol) ^ 0.3 + 1)
\end_layout

\begin_layout Plain Layout

          for (m in 1:M) {
\end_layout

\begin_layout Plain Layout

            y <- rk4.step(y, t, dt / (N * M), dydt)[[1]]
\end_layout

\begin_layout Plain Layout

            t <- t + dt / (N * M)
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        } else {
\end_layout

\begin_layout Plain Layout

          t <- t + dt / N
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      yr[it] <- y
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return(yr)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

## These are the coefficients used by the Runge-Kutta Cash-Karp integration:
\end_layout

\begin_layout Plain Layout

RKD <- data.frame(
\end_layout

\begin_layout Plain Layout

  a2 = 0.2,
\end_layout

\begin_layout Plain Layout

  a3 = 0.3,
\end_layout

\begin_layout Plain Layout

  a4 = 0.6,
\end_layout

\begin_layout Plain Layout

  a5 = 1,
\end_layout

\begin_layout Plain Layout

  a6 = 0.875,
\end_layout

\begin_layout Plain Layout

  b21 = 0.2,
\end_layout

\begin_layout Plain Layout

  b31 = 3 / 40,
\end_layout

\begin_layout Plain Layout

  b32 = 9 / 40,
\end_layout

\begin_layout Plain Layout

  b41 = 0.3,
\end_layout

\begin_layout Plain Layout

  b42 = -0.9,
\end_layout

\begin_layout Plain Layout

  b43 = 1.2,
\end_layout

\begin_layout Plain Layout

  b51 = -11 / 54,
\end_layout

\begin_layout Plain Layout

  b52 = 2.5,
\end_layout

\begin_layout Plain Layout

  b53 = -70 / 27,
\end_layout

\begin_layout Plain Layout

  b54 = 35 / 27,
\end_layout

\begin_layout Plain Layout

  b61 = 1631 / 55296,
\end_layout

\begin_layout Plain Layout

  b62 = 175 / 512,
\end_layout

\begin_layout Plain Layout

  b63 = 575 / 13824,
\end_layout

\begin_layout Plain Layout

  b64 = 44275 / 110592,
\end_layout

\begin_layout Plain Layout

  b65 = 253 / 4096,
\end_layout

\begin_layout Plain Layout

  c1 = 37 / 378,
\end_layout

\begin_layout Plain Layout

  c3 = 250 / 621,
\end_layout

\begin_layout Plain Layout

  c4 = 125 / 594,
\end_layout

\begin_layout Plain Layout

  c6 = 512 / 1771
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

RKD <-
\end_layout

\begin_layout Plain Layout

  cbind(
\end_layout

\begin_layout Plain Layout

    RKD,
\end_layout

\begin_layout Plain Layout

    data.frame(
\end_layout

\begin_layout Plain Layout

      dc1 = RKD$c1 - 2825 / 27648,
\end_layout

\begin_layout Plain Layout

      dc3 = RKD$c3 - 18575 / 48384,
\end_layout

\begin_layout Plain Layout

      dc4 = RKD$c4 - 13525 / 55296,
\end_layout

\begin_layout Plain Layout

      dc5 = -277 / 14336,
\end_layout

\begin_layout Plain Layout

      dc6 = RKD$c6 - 0.25
\end_layout

\begin_layout Plain Layout

    )
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

## Save this in a special environment that rk4.step() can access:
\end_layout

\begin_layout Plain Layout

if (!exists('RKCKEnv', envir = emptyenv())) {
\end_layout

\begin_layout Plain Layout

  # define if absent
\end_layout

\begin_layout Plain Layout

  assign('RKCKEnv', new.env(parent = emptyenv()), envir = globalenv())
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

RKCKEnv$RKD <- RKD
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

rk4.step <- function (y1, t, dt, dydt) {
\end_layout

\begin_layout Plain Layout

  RKD <- RKCKEnv$RKD
\end_layout

\begin_layout Plain Layout

  dydt1 <- dydt(y1, t)
\end_layout

\begin_layout Plain Layout

  trial2 <- dydt(y1 + dt * RKD$b21 * dydt1, t + RKD$a2 * dt)
\end_layout

\begin_layout Plain Layout

  trial3 <- dydt(y1 + dt *
\end_layout

\begin_layout Plain Layout

                   (RKD$b31 * dydt1 + RKD$b32 * trial2), t + RKD$a3 * dt)
\end_layout

\begin_layout Plain Layout

  trial4 <- dydt(y1 + dt *
\end_layout

\begin_layout Plain Layout

                   (RKD$b41 * dydt1 + RKD$b42 * trial2 + RKD$b43 * trial3),
\end_layout

\begin_layout Plain Layout

                 t + RKD$a4 * dt)
\end_layout

\begin_layout Plain Layout

  trial5 <- dydt(
\end_layout

\begin_layout Plain Layout

    y1 + dt *
\end_layout

\begin_layout Plain Layout

      (
\end_layout

\begin_layout Plain Layout

        RKD$b51 * dydt1 + RKD$b52 * trial2 + RKD$b53 * trial3 +
\end_layout

\begin_layout Plain Layout

          RKD$b54 * trial4
\end_layout

\begin_layout Plain Layout

      ),
\end_layout

\begin_layout Plain Layout

    t + RKD$a5 * dt
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

  trial6 <- dydt(
\end_layout

\begin_layout Plain Layout

    y1 + dt *
\end_layout

\begin_layout Plain Layout

      (
\end_layout

\begin_layout Plain Layout

        RKD$b61 * dydt1 + RKD$b62 * trial2 + RKD$b63 * trial3 +
\end_layout

\begin_layout Plain Layout

          RKD$b64 * trial4 + RKD$b65 * trial5
\end_layout

\begin_layout Plain Layout

      ),
\end_layout

\begin_layout Plain Layout

    t + RKD$a6 * dt
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

  yn <- y1 + dt *
\end_layout

\begin_layout Plain Layout

    (RKD$c1 * dydt1 + RKD$c3 * trial3 + RKD$c4 * trial4 + RKD$c6 * trial6)
\end_layout

\begin_layout Plain Layout

  err <-
\end_layout

\begin_layout Plain Layout

    dt * (RKD$dc1 * dydt1 + RKD$dc3 * trial3 + RKD$dc4 * trial4 +
\end_layout

\begin_layout Plain Layout

            RKD$dc5 * trial5 + RKD$dc6 * trial6)
\end_layout

\begin_layout Plain Layout

  # print (sprintf ('rkck.integrate return is %.5f for input y=%.5f and t=%.2f',
 yn, y, t))
\end_layout

\begin_layout Plain Layout

  return(list(yn, err))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Section

\change_deleted 1311305628 1585923348
Basis for the Assessment
\change_inserted 1311305628 1585925950
Theory
\change_unchanged

\end_layout

\begin_layout Standard

\change_deleted 1311305628 1585945518
The evaluation of the time response that follows uses several methods, but
 the key one is based on the dynamic heating produced by airspeed fluctuations.
 In steady conditions a temperature sensor exposed to the air stream will
 measure the recovery temperature, defined as the ambient temperature increased
 by the effect of dynamic heating.
 Dynamic heating fluctuates as the airspeed fluctuates, so in a turbulent
 wind field fluctuations with a measurable frequency spectrum are imposed
 on the sensor.
 These fluctuations are often significantly larger than real fluctuations
 in the ambient temperature.
 If the fluctuations are higher in frequency than those to which the sensor
 can respond, corresponding fluctuations will not appear in the measured
 spectrum.
 Furthermore, the phase of the measured response relative to the imposed
 signal will vary, from near 
\begin_inset Formula $0^{\circ}$
\end_inset

 for fluctuations slow compared to sensor response to near 
\begin_inset Formula $90^{\circ}$
\end_inset

 or even more
\begin_inset Foot
status open

\begin_layout Plain Layout
A sensor with a first-order time constant cannot produce a phase lag of
 more than 
\begin_inset Formula $90^{\circ}$
\end_inset

, but larger lags are possible for systems characterized by two time constants,
 as developed below.
\end_layout

\end_inset

 for fluctuations fast compared to that response.
 The amplitude and especially the phase of the recovery temperature relative
 to that of the dynamic heating therefore can be used as sensitive indicators
 of the response characteristics of the sensor.
 
\end_layout

\begin_layout Standard

\change_deleted 1311305628 1585945518
The evaluation in terms of the amplitude ratio and phase shift of the recovery
 temperature as forced by the dynamic-heating term will therefore be the
 central approach in this study.
 Two other sources of information also provide supporting evidence.
 Those are: (i) the observed time delay during 
\begin_inset Quotes eld
\end_inset

speed-run
\begin_inset Quotes erd
\end_inset

 maneuvers, during which the flight speed is changed between minimum and
 maximum values; and (ii) passage through a near-discontinuous change in
 temperature at the top of a marine boundary layer.
 On the basis of this evidence, it will be argued that current standard
 temperature sensors do not meet the requirement even of 4–5
\begin_inset space ~
\end_inset

Hz response.
 Measurements of sensible heat flux will underestimate the contributions
 from fluctuations even as slow as 0.05
\begin_inset space ~
\end_inset

Hz, and the measured fluctuations lead to measurements of the contribution
 from 10-Hz fluctuations that are smaller than 10% of the correct values.
 Knowledge of the limitations of these sensors is therefore essential to
 any application to measurements of sensible heat flux that uses these sensors,
 and the correction schemes developed in Part III can lead to defensible
 measurements of sensible-heat flux that otherwise will have serious errors.
\change_inserted 1311305628 1585923532

\end_layout

\begin_layout Standard

\change_inserted 1311305628 1586025441
The errors considered here are those applicable to the measurement from
 the sensor, which corresponds to the 
\begin_inset Quotes eld
\end_inset

recovery temperature
\begin_inset Quotes erd
\end_inset

, rather than those in the final temperature after correction for dynamic
 heating.
 Because the sensor cannot respond to rapid fluctuations in dynamic heating,
 the standard correction for dynamic heating introduces errors into the
 sensed temperature that are then amplified by a correction procedure.
 This will be addressed in Part 2, but for this reason the present paper
 will discuss only the recovery temperature.
\end_layout

\begin_layout Standard

\change_inserted 1311305628 1585926814
\begin_inset CommandInset citation
LatexCommand citet
key "PayneEtAl1994"
literal "false"

\end_inset

 provided a particularly illuminating analysis of the expected response
 of a temperature sensor and developed their results in terms of a transfer
 function.
 They represent the response of the sensor in terms of two coupled differential
 equations, one representing the temperature of the sensing wire and a second
 representing the temperature of the structure that supports that wire.
 Their analysis in terms of fundamental representation of the heat transport
 leads to reasonable consistency with previous two-time-constant models
 like that of 
\begin_inset CommandInset citation
LatexCommand citet
key "mccarthy1973method"
literal "false"

\end_inset

 but poor agreement with the empirical evidence regarding the time-response
 parameters in those models.
 They note, however, that the empirical evidence is not as consistent or
 convincing as would be desirable.
 One goal of the present work, therefore, is to develop a different and
 readily available method of determining those parameters.
 The over-arching goal is to be able to assess errors that might be present
 in measurements of the flux of sensible heat and to apply corrections for
 those errors.
 The transfer function, constrained by new data regarding the parameters,
 makes this possible and also supports a new scheme by which the temperature
 measurements can be corrected for the time response of the sensor.
 This will be the subject of Part 3.
\change_deleted 1311305628 1585923783

\end_layout

\begin_layout Standard

\change_deleted 1311305628 1585923776
Characterizing the Time Response
\change_unchanged

\end_layout

\begin_layout Subsection
The differential equations and their solution
\end_layout

\begin_layout Standard
Previous studies have demonstrated that a simple first-order 
\change_deleted 1311305628 1586096348
response
\change_inserted 1311305628 1586096357
exponential equation
\change_unchanged
 with one time constant does not represent the 
\change_inserted 1311305628 1586096372
time response 
\change_deleted 1311305628 1586096375
nature 
\change_unchanged
of 
\change_inserted 1311305628 1586096388
airborne temperature
\change_deleted 1311305628 1586096391
existing
\change_unchanged
 sensors.
 The suggested explanation (
\begin_inset CommandInset citation
LatexCommand citet
key "NCAR_OpenSky_TECH-NOTE-000-000-000-064"
literal "false"

\end_inset

 is that heat is transferred to the sensing wire of standard sensors not
 only from the air but also from the support
\change_inserted 1311305628 1586096432
ing structure
\change_unchanged
 that is in contact with the wire.
 Friehe and Khelif (
\begin_inset CommandInset citation
LatexCommand citet
key "FrieheKhelif1992"
literal "false"

\end_inset

), following other prior work including that of
\change_inserted 1311305628 1585927098
 
\begin_inset CommandInset citation
LatexCommand citet
key "rodi1972analysis"
literal "false"

\end_inset

 and
\change_unchanged
 
\begin_inset CommandInset citation
LatexCommand citet
key "mccarthy1973method"
literal "false"

\end_inset

, suggested representing the two-time-constant response via the following
 functional form:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\Theta(t)=A_{1}e^{-t/\tau_{1}}+A_{2}e^{-t/\tau_{2}}\label{eq:FrieheKehlif}
\end{equation}

\end_inset

where 
\begin_inset Formula $\Theta(t)$
\end_inset

 is the normalized history of the measured temperature decaying from an
 initial value of unity to a final value of zero.
 The sum of the coefficients 
\begin_inset Formula $A_{1}$
\end_inset

 and 
\begin_inset Formula $A_{2}$
\end_inset

 must then be 1.
 
\change_deleted 1311305628 1585945799
Suggested
\change_inserted 1311305628 1585945806
The
\change_unchanged
 values for {
\begin_inset Formula $A_{1},\,A_{2},\,\tau_{1},\,\tau_{2}$
\end_inset

}
\change_inserted 1311305628 1585945837
 suggested by 
\begin_inset CommandInset citation
LatexCommand citet
key "FrieheKhelif1992"
literal "false"

\end_inset


\change_unchanged
 were {0.65, 0.35, 0.09
\begin_inset space ~
\end_inset

s, 0.5
\begin_inset space ~
\end_inset

s}.
 
\end_layout

\begin_layout Standard

\change_inserted 1311305628 1585943096
Following the approach of 
\begin_inset CommandInset citation
LatexCommand citet
key "PayneEtAl1994"
literal "false"

\end_inset

, 
\change_deleted 1311305628 1585943127
To consider how a sensor responds to a general input and not just to the
 step-function change described by 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:FrieheKehlif"
plural "false"
caps "false"
noprefix "false"

\end_inset

, an appropriate pair of differential equations is developed and solved
 in this section.
 Following the approach of 
\begin_inset CommandInset citation
LatexCommand citet
key "PayneEtAl1994"
literal "false"

\end_inset

, the following represents 
\change_unchanged
the time response of the sensor 
\change_inserted 1311305628 1585943144
will be represented by 
\change_deleted 1311305628 1585943148
in terms of 
\change_unchanged
two coupled differential equations, one that describes the response of the
 support 
\change_inserted 1311305628 1585925802
on which the sensing wire is wound 
\change_unchanged
to the air temperature and a second that describes the response of the sensing
 wire to two inputs, one from the support and one from the air.
 No attempt is made 
\change_inserted 1311305628 1585927727
here 
\change_unchanged
to determine the parameters from first principles as in 
\change_deleted 1311305628 1585924377
that reference
\change_inserted 1311305628 1585924390

\begin_inset CommandInset citation
LatexCommand citet
key "PayneEtAl1994"
literal "false"

\end_inset


\change_unchanged
, however; instead, parameters entering the equations are determined empirically.
 
\change_deleted 1311305628 1585943229
This approach leads to the following two differential equations describing
 the temperature of the support
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
A heat-transfer term omitted from the first equation is that from the support
 to the wire, which is assumed a negligible effect on the support temperature.
\end_layout

\end_inset

 (
\begin_inset Formula $T_{s}(t)$
\end_inset

) and of the sensing wire (
\begin_inset Formula $T_{m}(t)$
\end_inset

) as they respond to the measurand that is the recovery temperature (
\begin_inset Formula $T_{r}(t)$
\end_inset

):
\change_inserted 1311305628 1585943234
The equations are:
\change_unchanged

\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\frac{dT_{s}(t)}{dt}=\frac{T_{r}(t)-T_{s}(t)}{\tau_{2}}\label{eq:Ts}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{align}
\frac{dT_{m}(t)}{dt} & =\frac{a(T_{r}(t)-T_{m}(t))+(1-a)(T_{s}(t)-T_{m}(t))}{\tau_{1}}\label{eq:Tm}\\
= & \frac{\left\{ aT_{r}(t)+(1-a)T_{s}(t)\right\} -T_{m}(t)}{\tau_{1}}\nonumber 
\end{align}

\end_inset


\change_inserted 1311305628 1586097431
where 
\begin_inset Formula $T_{s}(t)$
\end_inset

 is the temperature of the 
\bar under
s
\bar default
upport, 
\begin_inset Formula $T_{m}(t)$
\end_inset

 the 
\bar under
m
\bar default
easured temperature of the sensing wire, and 
\begin_inset Formula $T_{r}(t)$
\end_inset

 the true 
\bar under
r
\bar default
ecovery temperature that is the measurand.
 
\change_unchanged
For heat transfer to or from the wire, the parameter 
\begin_inset Formula $a$
\end_inset

 then represents the fraction of the heat 
\change_deleted 1311305628 1586097984
conducted
\change_inserted 1311305628 1586097987
transferred
\change_unchanged
 by the air, while 
\change_deleted 1311305628 1586098013
a fraction 
\change_unchanged

\begin_inset Formula $(1-a)$
\end_inset

 is transferred to or from the support.
 The wire responds to the combined transfers of heat with characteristic
 time constant 
\begin_inset Formula $\tau_{1}$
\end_inset

 while the support structure responds to the air temperature more slowly,
 with time constant 
\begin_inset Formula $\tau_{2}$
\end_inset

.
 It is straightforward to apply 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to changing but not necessarily discrete conditions, so a general response
 to a given air-temperature history can be predicted by numerical integration
 of these equations.
 
\change_inserted 1311305628 1585607844
Furthermore, the equations are linear and, for constant values of the parameters
, they are also time-invariant (i.e., 
\begin_inset Quotes eld
\end_inset

LTI
\begin_inset Quotes erd
\end_inset

) descriptions of the response.
 As a result, a particular signal for 
\begin_inset Formula $T_{r}(t)$
\end_inset

 can be decomposed into its sinusoidal Fourier components and each will
 satisfy these equations independently.
 
\change_deleted 1311305628 1586025544

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The step-function response of 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is the sum of two exponentials as in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:FrieheKehlif"
plural "false"
caps "false"
noprefix "false"

\end_inset

, with the same time constants but with the adjustment that 
\begin_inset Formula $A_{1}=(a-\tau_{1}/\tau_{2})/(1-\tau_{1}/\tau_{2})$
\end_inset

 and 
\begin_inset Formula $A_{2}=(1-a)/\left(1-\tau_{1}/\tau_{2}\right)$
\end_inset

.
 Because 
\begin_inset Formula $\tau_{1}$
\end_inset

 is normally small compared to 
\begin_inset Formula $\tau_{2}$
\end_inset

 for the Rosemount 102E4AL sensor, 
\begin_inset Formula $A_{1}\approx a$
\end_inset

.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The solution to 
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\frac{dT_{m}(t)}{dt}=\frac{(1-a)e^{-t/\tau_{2}}-T_{m}(t)}{\tau_{1}}
\]

\end_inset


\begin_inset Formula 
\[
T_{m}(t)=be^{-t/\tau_{a}}+(1-b)e^{-t/\tau_{b}}
\]

\end_inset


\begin_inset Formula 
\[
-b\frac{e^{-t/\tau_{a}}}{\tau_{a}}-(1-b)\frac{e^{-t/\tau_{b}}}{\tau_{b}}=\frac{(1-a)e^{-t/\tau_{2}}-be^{-t/\tau_{a}}-(1-b)e^{-t/\tau_{b}}}{\tau_{1}}
\]

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
e^{-t/\tau_{a}}:\,\,\,\frac{b}{\tau_{a}}=\frac{b}{\tau_{1}}
\]

\end_inset


\begin_inset Formula 
\[
e^{-t/\tau_{b}}:\,\,\,-\frac{1-b}{\tau_{b}}=-\frac{(1-b)}{\tau_{1}}
\]

\end_inset


\begin_inset Formula 
\[
e^{-t/\tau_{2}}:\,\,\,0=\frac{(1-a)}{\tau_{1}}
\]

\end_inset

If 
\begin_inset Formula $\tau_{a}=\tau_{1}$
\end_inset

 and 
\begin_inset Formula $\tau_{b}=\tau_{2}$
\end_inset

, 
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
(1-b)e^{-t/\tau_{b}}\left(\frac{1}{\tau_{1}}-\frac{1}{\tau_{b}}\right)=(1-a)e^{-t/\tau_{2}}\frac{1}{\tau_{1}}
\]

\end_inset


\begin_inset Formula 
\[
1-b=\frac{1-a}{\left(1-\frac{\tau_{1}}{\tau_{2}}\right)}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

 
\change_inserted 1311305628 1586025544

\begin_inset Note Note
status open

\begin_layout Plain Layout

\change_inserted 1311305628 1586025544
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\change_inserted 1311305628 1586025544
The step-function response of 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is the sum of two exponentials as in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:FrieheKehlif"
plural "false"
caps "false"
noprefix "false"

\end_inset

, with the same time constants but with the adjustment that 
\begin_inset Formula $A_{1}=(a-\tau_{1}/\tau_{2})/(1-\tau_{1}/\tau_{2})$
\end_inset

 and 
\begin_inset Formula $A_{2}=(1-a)/\left(1-\tau_{1}/\tau_{2}\right)$
\end_inset

.
 Because 
\begin_inset Formula $\tau_{1}$
\end_inset

 is normally small compared to 
\begin_inset Formula $\tau_{2}$
\end_inset

 for the Rosemount 102E4AL sensor, 
\begin_inset Formula $A_{1}\approx a$
\end_inset

.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\change_inserted 1311305628 1586025544
The solution to 
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\frac{dT_{m}(t)}{dt}=\frac{(1-a)e^{-t/\tau_{2}}-T_{m}(t)}{\tau_{1}}
\]

\end_inset


\begin_inset Formula 
\[
T_{m}(t)=be^{-t/\tau_{a}}+(1-b)e^{-t/\tau_{b}}
\]

\end_inset


\begin_inset Formula 
\[
-b\frac{e^{-t/\tau_{a}}}{\tau_{a}}-(1-b)\frac{e^{-t/\tau_{b}}}{\tau_{b}}=\frac{(1-a)e^{-t/\tau_{2}}-be^{-t/\tau_{a}}-(1-b)e^{-t/\tau_{b}}}{\tau_{1}}
\]

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
e^{-t/\tau_{a}}:\,\,\,\frac{b}{\tau_{a}}=\frac{b}{\tau_{1}}
\]

\end_inset


\begin_inset Formula 
\[
e^{-t/\tau_{b}}:\,\,\,-\frac{1-b}{\tau_{b}}=-\frac{(1-b)}{\tau_{1}}
\]

\end_inset


\begin_inset Formula 
\[
e^{-t/\tau_{2}}:\,\,\,0=\frac{(1-a)}{\tau_{1}}
\]

\end_inset

If 
\begin_inset Formula $\tau_{a}=\tau_{1}$
\end_inset

 and 
\begin_inset Formula $\tau_{b}=\tau_{2}$
\end_inset

, 
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
(1-b)e^{-t/\tau_{b}}\left(\frac{1}{\tau_{1}}-\frac{1}{\tau_{b}}\right)=(1-a)e^{-t/\tau_{2}}\frac{1}{\tau_{1}}
\]

\end_inset


\begin_inset Formula 
\[
1-b=\frac{1-a}{\left(1-\frac{\tau_{1}}{\tau_{2}}\right)}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

 
\change_unchanged

\end_layout

\end_inset


\change_unchanged
The first equation does not involve the measurement, so for a particular
 history of recovery temperature 
\begin_inset Formula $T_{r}(t)$
\end_inset

 the support temperature can be determined solely by integration of 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Then, with 
\begin_inset Formula $T_{s}(t)$
\end_inset

 determined, 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 can be integrated to find the expected measurement 
\begin_inset Formula $T_{m}(t)$
\end_inset

 for a specified 
\change_inserted 1311305628 1585943431
measurand 
\change_unchanged
history 
\begin_inset Formula $T_{r}(t)$
\end_inset

.
 The inverse process, finding 
\begin_inset Formula $T_{r}(t)$
\end_inset

 from the measurements 
\begin_inset Formula $T_{m}(t)$
\end_inset

, is also straightforward and only slightly more complicated, as discussed
 in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Correcting-the-Temperature"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
For a 
\change_deleted 1311305628 1586098098
sine-wave
\change_inserted 1311305628 1586098101
sinusoidal
\change_unchanged
 input
\change_deleted 1311305628 1586098107
,
\change_unchanged
 these equations have analytic solutions after any transient response from
 initial conditions has decayed.
 If the actual recovery temperature is 
\begin_inset Formula $T_{r}(t)=\sin\omega t$
\end_inset

 where 
\begin_inset Formula $\omega$
\end_inset

 is the angular frequency, then the solutions for 
\begin_inset Formula $T_{s}(t)$
\end_inset

 and 
\begin_inset Formula $T_{m}(t)$
\end_inset

 are given by the following equations:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
T_{s}(t)=b\sin(\omega t+\zeta)\label{eq:TsSolved}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
T_{m}(t)=c\sin(\omega t+\phi)=C_{1}\cos\omega t+C_{2}\sin\omega t\label{eq:TmSolved}
\end{equation}

\end_inset


\begin_inset Newline newline
\end_inset

where
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
b=\frac{1}{\sqrt{1+\omega^{2}\tau_{2}^{2}}}
\]

\end_inset


\begin_inset Formula 
\[
\zeta=-\arctan(\omega\tau_{2})
\]

\end_inset


\begin_inset Formula 
\begin{align*}
C_{1} & =\left(\frac{1}{1+\omega^{2}\tau_{1}^{2}}\right)\left(-\omega\tau_{1}\left(a+(1-a)b\cos\zeta\right)+(1-a)b\sin\zeta\right)\\
= & \frac{-\omega}{(1+\omega^{2}\tau_{1}^{2})}\left(\tau_{1}a+\frac{(1-a)(\tau_{1}+\tau_{2})}{(1+\omega^{2}\tau_{2}^{2})}\right)
\end{align*}

\end_inset


\begin_inset Formula 
\begin{align*}
C_{2} & =\left(\frac{1}{1+\omega^{2}\tau_{1}^{2}}\right)\left(a+(1-a)b\cos\zeta+\omega\tau_{1}(1-a)b\sin\zeta\right)\\
= & \left(\frac{1}{1+\omega^{2}\tau_{1}^{2}}\right)\left(a+\frac{(1-a)(1-\omega^{2}\tau_{1}\tau_{2})}{(1+\omega^{2}\tau_{2}^{2})}\right)
\end{align*}

\end_inset


\begin_inset Formula 
\begin{equation}
c=\sqrt{C_{1}^{2}+C_{2}^{2}}\label{eq:responseAmp}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
\phi=\arctan(C_{1}/C_{2})\label{eq:responsePhase}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard

\change_deleted 1311305628 1585926064
The transfer function 
\begin_inset Formula $H(\omega)=c(\omega)e^{i\phi(\omega)}$
\end_inset

 then describes how the sensor will respond to a unit-amplitude sine wave
 with angular frequency 
\begin_inset Formula $\omega=2\pi\nu$
\end_inset

 where 
\begin_inset Formula $\nu$
\end_inset

 is the frequency.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The workflow document that 
\change_deleted 1311305628 1585688837
accompanies
\change_inserted 1311305628 1585688839
complements
\change_unchanged
 this 
\change_deleted 1311305628 1585688849
technical report
\change_inserted 1311305628 1585688850
paper
\change_unchanged
 develops and checks these solutions using Laplace transforms, but they
 have also been verified by substitution into the differential equations.

\change_inserted 1311305628 1585688866
 An alternate derivation that leads to the same transfer function is to
 differentiate (2) to obtain the impulse response function, then calculate
 the Fourier transform of that impulse response function to obtain 
\begin_inset Formula $H(\omega)$
\end_inset

.
 The workflow document also verifies that the result is the same as given
 above.
 The expressions are somewhat more concise:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
C_{1}=\omega\left(\frac{A_{1}\tau_{1}}{1+\omega^{2}\tau_{1}^{2}}+\frac{A_{2}\tau_{2}}{1+\omega^{2}\tau_{2}^{2}}\right)
\]

\end_inset


\begin_inset Formula 
\[
C_{2}=\left(\frac{A_{1}}{1+\omega^{2}\tau_{1}^{2}}+\frac{A_{2}}{1+\omega^{2}\tau_{2}^{2}}\right)
\]

\end_inset


\change_unchanged

\end_layout

\end_inset


\change_inserted 1311305628 1586003926

\end_layout

\begin_layout Standard

\change_inserted 1311305628 1586186745
\begin_inset CommandInset citation
LatexCommand citet
key "mccarthy1973method"
literal "false"

\end_inset

 used the derivative of the step-function response to find the impulse response
 function and, from its Fourier transform, the sensor response function.
 That leads to the following alternate expressions for 
\begin_inset Formula $C_{1}$
\end_inset

 and 
\begin_inset Formula $C_{2}$
\end_inset

:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
C_{1}=-\omega\left(\frac{A_{1}\tau_{1}}{1+\omega^{2}\tau_{1}^{2}}+\frac{A_{2}\tau_{2}}{1+\omega^{2}\tau_{2}^{2}}\right)
\]

\end_inset


\begin_inset Formula 
\[
C_{2}=\left(\frac{A_{1}}{1+\omega^{2}\tau_{1}^{2}}+\frac{A_{2}}{1+\omega^{2}\tau_{2}^{2}}\right)
\]

\end_inset

With 
\begin_inset Formula $A_{2}=(1-a)/(1-\tau_{1}/\tau_{2})$
\end_inset

 and 
\begin_inset Formula $A_{1}=1-A_{2},$
\end_inset

these are equivalent to the expressions for the same coefficients given
 above 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:responseAmp"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 This demonstrates that the equations 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 are a representation of the response equivalent to 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:FrieheKehlif"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and the equations used by 
\begin_inset CommandInset citation
LatexCommand citet
key "mccarthy1973method"
literal "false"

\end_inset

 and 
\begin_inset CommandInset citation
LatexCommand citet
key "InverarityJTech2000"
literal "false"

\end_inset

, among others.
\change_unchanged

\end_layout

\begin_layout Subsection
The transfer function
\begin_inset CommandInset label
LatexCommand label
name "subsec:The-resulting-transfer"

\end_inset

 
\end_layout

\begin_layout Standard

\change_inserted 1311305628 1585926165
The transfer function 
\begin_inset Formula $H(\omega)=c(\omega)e^{i\phi(\omega)}$
\end_inset

 then characterizes how the sensor will respond to a unit-amplitude sine
 wave with angular frequency 
\begin_inset Formula $\omega=2\pi\nu$
\end_inset

 where 
\begin_inset Formula $\nu$
\end_inset

 is the frequency.
 
\change_deleted 1311305628 1585926227
Equations 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:responseAmp"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:responsePhase"
plural "false"
caps "false"
noprefix "false"

\end_inset

 provide the gain and phase for the time-response transfer function of the
 sensor.

\change_unchanged
 For a particular set of parameters (
\begin_inset Formula $a=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(a, 3)}
\end_layout

\end_inset

, 
\begin_inset Formula $\tau_{1}=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(tau1, 4)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

s, 
\begin_inset Formula $\tau_{2}=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(tau2, 3)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

s),
\change_inserted 1311305628 1586098383

\begin_inset Foot
status open

\begin_layout Plain Layout

\change_inserted 1311305628 1586098385
These parameters are approximately representative of an unheated Rosemount
 102E4AL sensor used on the NSF/NCAR C-130, as will be demonstrated in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand eqref
reference "subsec:The-unheated-Rosemount"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 
\change_unchanged

\end_layout

\end_inset


\change_unchanged
 the amplitude response and phase delay of the transfer function 
\change_deleted 1311305628 1586098424
obtained in this way 
\change_unchanged
is shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:LTsolution}
\end_layout

\end_inset

.

\change_inserted 1311305628 1586098784
 Similar plots of the amplitude have been shown by 
\begin_inset CommandInset citation
LatexCommand citet
key "mccarthy1973method"
literal "false"

\end_inset

 (Fig.
\begin_inset space ~
\end_inset

2) and 
\begin_inset CommandInset citation
LatexCommand citet
key "nicholls1978measurements"
literal "false"

\end_inset

 (Fig.
 3).

\change_unchanged
 
\change_deleted 1311305628 1586100022
These parameters are approximately representative of an unheated Rosemount
 102E4AL sensor that has been used on the NSF/NCAR C-130, as will be demonstrate
d in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand eqref
reference "subsec:The-unheated-Rosemount"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The sensor in effect acts as a filter with the plotted gain and phase,
 so the frequency-dependent gain and phase can be used with Fourier representati
on of an input signal to characterize the response of the sensor to that
 input.

\change_unchanged
 Modified transfer functions for two small changes to these parameters are
 also shown to illustrate the sensitivity of the solution to these parameters.
 This figure
\change_inserted 1311305628 1586098776
 
\change_deleted 1311305628 1586026248
 
\change_unchanged
illustrates that serious errors will enter estimates of the sensible heat
 flux if 
\change_deleted 1311305628 1586098619
there are significant contributions 
\change_inserted 1311305628 1586098776
temperature fluctuations 
\change_unchanged
at frequencies
\change_deleted 1311305628 1586098634
 even
\change_unchanged
 above 
\change_deleted 1311305628 1586098654
about 
\change_unchanged
1
\begin_inset space ~
\end_inset

Hz
\change_inserted 1311305628 1586098776
 make a significant contribution to the flux
\change_unchanged
.
 
\change_deleted 1311305628 1586100210
Because t
\change_inserted 1311305628 1586100211
T
\change_unchanged
he contribution to the cospectrum of temperature and vertical wind will
 be reduced by the product of the amplitude and the cosine of the phase
\change_inserted 1311305628 1586100225
 
\change_deleted 1311305628 1586100232
 shown in 
\change_inserted 1311305628 1586100234
(
\change_unchanged
Fig.
\begin_inset space ~
\end_inset


\change_deleted 1311305628 1586100275

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:LTsolution}
\end_layout

\end_inset

, the fractional error in the measurement will be as shown in Fig.
\begin_inset space ~
\end_inset


\change_unchanged

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:FE}
\end_layout

\end_inset


\change_inserted 1311305628 1586100286
)
\change_unchanged
.
 Most of the 10-Hz contribution is missed, but even at 1
\begin_inset space ~
\end_inset

Hz the error is about 28%.
 
\change_deleted 1311305628 1586098816
If there are substantial contributions to the sensible-heat flux with fluctuatio
ns at 1
\begin_inset space ~
\end_inset

Hz and above, the fractional error in those contributions will lead to an
 error in the measured flux.
 
\change_unchanged

\begin_inset Note Note
status open

\begin_layout Plain Layout
Characterizing the time response of sensors and correcting for that response
 when calculating fluxes therefore is an essential part of measuring fluxes
 with this sensor.
 The unheated Rosemount 102E4AL sensor is the fastest sensor available on
 the NSF/NCAR aircraft; other sensors will lead to still larger errors.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<LTsolution, include = TRUE, fig.height=3.7, fig.cap = 'The amplitude and
 phase for the 
\change_deleted 1311305628 1585691138
response function
\change_inserted 1311305628 1585691151
frequency domain transfer function
\change_unchanged
 of the Rosemount 102E4AL temperature sensor.
 The parameters representing that sensor, labeled 
\begin_inset Quotes eld
\end_inset

best
\begin_inset Quotes erd
\end_inset

, are $a$=0.733, $
\backslash

\backslash
tau_1=0.0308$ s and $
\backslash

\backslash
tau_2=0.447$ s.
 To illustrate sensitivity,  the curves labeled 
\begin_inset Quotes eld
\end_inset

t1=0.05
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

t2=0.6
\begin_inset Quotes erd
\end_inset

 use instead $
\backslash

\backslash
tau_1=0.05$ s and $
\backslash

\backslash
tau_2=0.6$ s, respectively.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

zeta <- -atan(2 * pi * frq * tau2)
\end_layout

\begin_layout Plain Layout

b <- cos(zeta)
\end_layout

\begin_layout Plain Layout

Param <- list(
\end_layout

\begin_layout Plain Layout

  a = a,
\end_layout

\begin_layout Plain Layout

  tau1 = tau1,
\end_layout

\begin_layout Plain Layout

  tau2 = tau2,
\end_layout

\begin_layout Plain Layout

  b = b,
\end_layout

\begin_layout Plain Layout

  zeta = zeta,
\end_layout

\begin_layout Plain Layout

  frq = frq
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

Param1 <- Param
\end_layout

\begin_layout Plain Layout

Param3 <- Param
\end_layout

\begin_layout Plain Layout

Param4 <- Param
\end_layout

\begin_layout Plain Layout

Param3$tau1 <- 0.05
\end_layout

\begin_layout Plain Layout

Param4$tau2 <- 0.6
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Use the Laplace-transform solution
\end_layout

\begin_layout Plain Layout

H1 <- LTphase(frq, Param1)
\end_layout

\begin_layout Plain Layout

cTF <- H1$Amp
\end_layout

\begin_layout Plain Layout

phiTF <- H1$Phase
\end_layout

\begin_layout Plain Layout

H3 <- LTphase(frq, Param3)
\end_layout

\begin_layout Plain Layout

cTF3 <- H3$Amp
\end_layout

\begin_layout Plain Layout

phiTF3 <- H3$Phase
\end_layout

\begin_layout Plain Layout

H4 <- LTphase(frq, Param4)
\end_layout

\begin_layout Plain Layout

cTF4 <- H4$Amp
\end_layout

\begin_layout Plain Layout

phiTF4 <- H4$Phase
\end_layout

\begin_layout Plain Layout

dfAP <- data.frame(
\end_layout

\begin_layout Plain Layout

  'Time' = frq,
\end_layout

\begin_layout Plain Layout

  'Amp' = cTF,
\end_layout

\begin_layout Plain Layout

  'Amp3' = cTF3,
\end_layout

\begin_layout Plain Layout

  'Amp4' = cTF4,
\end_layout

\begin_layout Plain Layout

  'Phase' = phiTF,
\end_layout

\begin_layout Plain Layout

  'Phase3' = phiTF3,
\end_layout

\begin_layout Plain Layout

  'Phase4' = phiTF4
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  ggplotWAC(
\end_layout

\begin_layout Plain Layout

    dfAP,
\end_layout

\begin_layout Plain Layout

    panels = 2,
\end_layout

\begin_layout Plain Layout

    labelP = c('    Amplitude', 'Phase [degrees]'),
\end_layout

\begin_layout Plain Layout

    labelL = c('best', 't1=0.05', 't2=0.6'),
\end_layout

\begin_layout Plain Layout

    lty = c(1, 1, 2)
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab(bquote('transfer function H(' * nu
 ~ ')'))
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  g + scale_x_log10(
\end_layout

\begin_layout Plain Layout

    breaks = trans_breaks("log10", function(x)
\end_layout

\begin_layout Plain Layout

      10 ^ x, n = 4),
\end_layout

\begin_layout Plain Layout

    labels = trans_format("log10", math_format(expr = 10 ^ .x))
\end_layout

\begin_layout Plain Layout

  ) + xlab('frequency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = 'tb')
\end_layout

\begin_layout Plain Layout

g + theme_WAC(1) + theme(legend.position = c(0.3, 0.65))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<SEQNS, include=TRUE, echo=FALSE, fig.cap='transfer function (amplitude
 and phase) for the Rosemount 102E4AL sensor, based on the parameters a=0.72,
 $
\backslash

\backslash
tau_1$=0.032 s, $
\backslash

\backslash
tau_2$=0.6 s.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

library(nleqslv)
\end_layout

\begin_layout Plain Layout

frq <- seq(0.01, 25, by=0.01)
\end_layout

\begin_layout Plain Layout

Phi <- rep(0, length(frq))
\end_layout

\begin_layout Plain Layout

H <- rep(0, length(frq))
\end_layout

\begin_layout Plain Layout

tau2 <- 0.6
\end_layout

\begin_layout Plain Layout

tau1 <- 0.032
\end_layout

\begin_layout Plain Layout

a <- 0.72
\end_layout

\begin_layout Plain Layout

zeta <- -atan(2*pi*frq*tau2)
\end_layout

\begin_layout Plain Layout

b <- cos(zeta)
\end_layout

\begin_layout Plain Layout

Param <- list(a=a, tau1=tau1, tau2=tau2, b=b, zeta=zeta, frq=frq)
\end_layout

\begin_layout Plain Layout

f2solve <- function (x) { # x[1]=phi, x[2]=cf
\end_layout

\begin_layout Plain Layout

  phi <- x[1]
\end_layout

\begin_layout Plain Layout

  cf <- x[2]
\end_layout

\begin_layout Plain Layout

  v <- x
\end_layout

\begin_layout Plain Layout

  v[1] <- a+(1-a)*bA*cos(zeta)+cf*tau1*2*pi*frqA*sin(phi)-cf*cos(phi)
\end_layout

\begin_layout Plain Layout

  v[2] <- cf*(tau1*2*pi*frqA*cos(phi)+sin(phi))-(1-a)*bA*sin(zeta)
\end_layout

\begin_layout Plain Layout

  return(v)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

for (i in 1:length(frq)) {
\end_layout

\begin_layout Plain Layout

  xg <- c(0.1, 0.5)
\end_layout

\begin_layout Plain Layout

  bA <- b[i]
\end_layout

\begin_layout Plain Layout

  zetaA <- zeta[i]
\end_layout

\begin_layout Plain Layout

  frqA <- frq[i]
\end_layout

\begin_layout Plain Layout

  r <- nleqslv(xg, f2solve)
\end_layout

\begin_layout Plain Layout

  Phi[i] <- r$x[1]
\end_layout

\begin_layout Plain Layout

  H[i] <- r$x[2]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

Phi <- Phi * 180 / pi
\end_layout

\begin_layout Plain Layout

dfAP <- data.frame('Amplitude'=H, 'Phase'=Phi)
\end_layout

\begin_layout Plain Layout

dfAP <- data.frame('Time'=frq, 'Amplitude'=H, 'Phase'=Phi)
\end_layout

\begin_layout Plain Layout

g <- ggplotWAC(dfAP, panels=2, labelP=c('       Amplitude', '    Phase [degrees]
'))
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab('transfer function')
\end_layout

\begin_layout Plain Layout

g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=4),
\end_layout

\begin_layout Plain Layout

     labels = trans_format("log10", math_format(expr = 10^.x))) + xlab('frequency
 [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides='tb')
\end_layout

\begin_layout Plain Layout

g + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

<<FE, include=TRUE, echo=FALSE, fig.height=3.5, fig.cap='
\change_inserted 1311305628 1586101479
Fractional error in the cospectrum of sensible-heat flux caused by the delayed
 response of the temperature sensor.
\change_deleted 1311305628 1586101491
Fractional error in the contribution to sensible heat flux as a function
 of frequency.
\change_unchanged
'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

dfFE <-
\end_layout

\begin_layout Plain Layout

  data.frame('Time' = frq,
\end_layout

\begin_layout Plain Layout

             'FractionalError' = 100 * (1 - dfAP$Amp * cos(dfAP$Phase *
 pi / 180)))
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  ggplotWAC(dfFE) + xlab('frequency [Hz]') + ylab('fractional error [%]')
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  g + scale_x_log10(
\end_layout

\begin_layout Plain Layout

    breaks = trans_breaks("log10", function(x)
\end_layout

\begin_layout Plain Layout

      10 ^ x, n = 4),
\end_layout

\begin_layout Plain Layout

    labels = trans_format("log10", math_format(expr = 10 ^ .x))
\end_layout

\begin_layout Plain Layout

  ) + xlab('frequency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = 'tb')
\end_layout

\begin_layout Plain Layout

g + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
These equations and their solution 
\change_deleted 1311305628 1585945980
also 
\change_unchanged
provide a basis for correcting either the measured temperature or the sensible-h
eat flux calculated from the cospectrum in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:heatFlux"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Corrected values can be obtained by 
\change_inserted 1311305628 1586096963
several methods including 
\change_unchanged
integration of the equations for the derivatives
\change_deleted 1311305628 1586026312
, as by 
\begin_inset CommandInset citation
LatexCommand citet
key "mccarthy1973method"
literal "false"

\end_inset

 or 
\begin_inset CommandInset citation
LatexCommand citet
key "InverarityJTech2000"
literal "false"

\end_inset

,
\change_unchanged
 or by 
\change_inserted 1311305628 1585691545
dividing the Fourier transform of the time series by the transfer function
 and then using inverse Fourier transformation to recover the corrected
 time series.
\change_deleted 1311305628 1585691468
using Fourier transforms and the transfer function.
\change_unchanged

\begin_inset Note Note
status collapsed

\begin_layout Enumerate
Solve 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for 
\begin_inset Formula $T_{r}(t)$
\end_inset

 and substitute that into 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to eliminate that unknown.
 The resulting equation can be solved for 
\begin_inset Formula $T_{s}(t)$
\end_inset

 by numerical integration from an arbitrary starting point.
 The result can then be substituted into 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to solve for 
\begin_inset Formula $T(t)$
\end_inset

, the corrected estimate of the true recovery temperature 
\begin_inset Formula $T_{r}(t)$
\end_inset

.
 Both steps require that the derivative of the measurement, 
\begin_inset Formula $dT_{m}(t)/dt$
\end_inset

, be estimated from finite differences or another higher-order formula.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Because by convention the variables in the data files represent the average
 value at the time corresponding to the midpoint of the time step, finite-differ
ence estimates need to be shifted forward by half the data period, or 0.02
\begin_inset space ~
\end_inset

s in this case of 25\SpecialChar softhyphen
Hz data.
\end_layout

\end_inset

 In practice, a fourth-order Runge-Kutta method is used here for the integration.
 Once 
\begin_inset Formula $T_{s}(t)$
\end_inset

 is known from that integration, 
\begin_inset Formula $T_{r}(t)$
\end_inset

 can be obtained by solution of the second equation without further integration.
\end_layout

\begin_layout Enumerate
Fourier transform the time series 
\begin_inset Formula $T_{m}(t)$
\end_inset

, divide the result by the transfer function, and use the inverse Fourier
 transform to recover the corrected time series.
 This is particularly suited to correction of the flux cospectrum because
 the corrected Fourier transform can be used directly
\end_layout

\end_inset

 
\change_deleted 1311305628 1586301624
Before discussing t
\change_inserted 1311305628 1586301626
T
\change_unchanged
hose correction schemes
\change_inserted 1311305628 1586363988
 are discussed
\change_unchanged
 in
\change_deleted 1311305628 1586301641
 more
\change_unchanged
 detail
\change_inserted 1311305628 1586301650
 in Appendix A
\change_unchanged
, 
\change_deleted 1311305628 1586026357
an analysis is needed to find
\change_inserted 1311305628 1586364014
but first a new method for finding
\change_unchanged
 the three parameters {
\begin_inset Formula $a,\,\tau_{1},\,\tau_{2}$
\end_inset

}
\change_inserted 1311305628 1586026403
 will be developed in the next section and used to characterize standard
 temperature sensors
\change_unchanged
.
 
\change_deleted 1311305628 1586301682
That is the subject of the next section.
 Then correction schemes are discussed further in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Correcting-the-Temperature"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\change_unchanged

\end_layout

\begin_layout Section
Determining the Time Constants
\change_inserted 1311305628 1585945540

\end_layout

\begin_layout Standard

\change_inserted 1311305628 1586364530
The evaluation of the time response that follows is based on the dynamic
 heating produced by airspeed fluctuations.
 In steady conditions a temperature sensor exposed to the air stream will
 measure the recovery temperature, defined as the ambient temperature increased
 by the effect of dynamic heating.
 Dynamic heating fluctuates as the airspeed fluctuates, so in a turbulent
 wind field fluctuations with a measurable frequency spectrum are imposed
 on the sensor.
 These fluctuations are often significantly larger than real fluctuations
 in the ambient temperature.
 Dynamic heating of temperature sensors is discussed for example by 
\begin_inset CommandInset citation
LatexCommand citet
key "BangeEtAl2013.ch2"
literal "false"

\end_inset

 (cf.
\begin_inset space ~
\end_inset

their Eq.
\begin_inset space ~
\end_inset

2.23), who expresses dynamic heating 
\begin_inset Formula $Q$
\end_inset

 as
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
Q=\alpha_{r}\frac{V^{2}}{2C_{p}}=T_{r}\left(\frac{\alpha_{r}M^{2}R_{a}/(2C_{v})}{1+\alpha_{r}M^{2}R_{a}/(2C_{v})}\right)\label{eq:DHterm}
\end{equation}

\end_inset

where 
\begin_inset Formula $\alpha_{r}$
\end_inset

 is the 
\begin_inset Quotes eld
\end_inset

recovery factor
\begin_inset Quotes erd
\end_inset

 characterizing the extent to which the air is brought to rest relative
 to the sensor, 
\begin_inset Formula $V$
\end_inset

 is the airspeed, 
\begin_inset Formula $C_{p}$
\end_inset

 and 
\begin_inset Formula $C_{v}$
\end_inset

 are respectively the specific heat of air at constant pressure and constant
 volume, 
\begin_inset Formula $T_{r}$
\end_inset

 is the (true) recovery temperature expressed in absolute units, 
\begin_inset Formula $M$
\end_inset

 the Mach number, and 
\begin_inset Formula $R_{a}$
\end_inset

 the gas constant for air.
 The ambient air temperature 
\begin_inset Formula $T_{a}$
\end_inset

 is related to the recovery temperature and the dynamic heating via
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
T_{r}=T_{a}+Q\,\,\,.\label{eq:recoveryTemperature}
\end{equation}

\end_inset

Because dynamic heating can exceed 
\begin_inset Formula $20^{\circ}\mathrm{C}$
\end_inset

 at jet-aircraft flight speeds, it is often the dominant cause of fluctuations
 in the recovery temperature.
 If the fluctuations in dynamic heating are higher in frequency than those
 to which the sensor can respond, corresponding fluctuations will be attenuated
 in the measured spectrum and the phase of the measured response relative
 to the imposed signal will vary, from near 
\begin_inset Formula $0^{\circ}$
\end_inset

 for fluctuations slow compared to sensor response to near 
\begin_inset Formula $90^{\circ}$
\end_inset

 or even more
\begin_inset Foot
status open

\begin_layout Plain Layout

\change_inserted 1311305628 1586104499
A sensor with a first-order time constant cannot produce a phase lag of
 more than 
\begin_inset Formula $90^{\circ}$
\end_inset

, but larger lags are possible for systems characterized by two time constants,
 as developed below.
\end_layout

\end_inset

 for fluctuations fast compared to that response.
 The amplitude and especially the phase of the recovery temperature relative
 to that of the dynamic heating therefore can be used as sensitive indicators
 of the response characteristics of the sensor and can be used to determine
 appropriate values of characteristic parameters like 
\begin_inset Formula $a$
\end_inset

, 
\begin_inset Formula $\tau_{1}$
\end_inset

 and 
\begin_inset Formula $\tau_{2}$
\end_inset

 that fit the predictions to the observations.
 The evaluation in terms of the amplitude ratio and phase shift of the recovery
 temperature as forced by the dynamic-heating term will therefore be the
 method used to characterize the transfer function and to determine if it
 is represented adequately by the parameterized form given by 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:responseAmp"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:responsePhase"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Standard

\change_deleted 1311305628 1586104646

\end_layout

\begin_layout Subsection
The response to dynamic heating
\change_deleted 1311305628 1586103466

\end_layout

\begin_layout Standard

\change_deleted 1311305628 1586103376
The unheated Rosemount 102E4AL sensor
\begin_inset CommandInset label
LatexCommand label
name "subsec:The-unheated-Rosemount"

\end_inset


\change_unchanged

\end_layout

\begin_layout Standard

\change_deleted 1311305628 1586104164
Dynamic heating provides an opportunity to evaluate the sensor response
 because that dynamic heating is a measured signal and its magnitude often
 is large compared to real temperature fluctuations.
 Dynamic heating of temperature sensors is discussed for example by 
\begin_inset CommandInset citation
LatexCommand citet
key "BangeEtAl2013.ch2"
literal "false"

\end_inset

 (cf.
\begin_inset space ~
\end_inset

their Eq.
\begin_inset space ~
\end_inset

2.23) and also in the working document describing processing algorithms in
 use at the Research Aviation Facility, NCAR: 
\begin_inset Quotes eld
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "RAF Technical Report: Processing Algorithms"
target "https://github.com/NCAR/aircraft_ProcessingAlgorithms/blob/master/ProcessingAlgorithms.pdf"
literal "false"

\end_inset


\begin_inset Quotes erd
\end_inset

.
 These sources express dynamic heating 
\begin_inset Formula $Q$
\end_inset

 as
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
Q=\alpha_{r}\frac{V^{2}}{2C_{p}}=T_{r}\left(\frac{\alpha_{r}M^{2}R_{a}/(2C_{v})}{1+\alpha_{r}M^{2}R_{a}/(2C_{v})}\right)\label{eq:DHterm}
\end{equation}

\end_inset

where 
\begin_inset Formula $\alpha_{r}$
\end_inset

 is the 
\begin_inset Quotes eld
\end_inset

recovery factor
\begin_inset Quotes erd
\end_inset

 characterizing the extent to which the air is brought to rest relative
 to the sensor, 
\begin_inset Formula $V$
\end_inset

 is the airspeed, 
\begin_inset Formula $C_{p}$
\end_inset

 and 
\begin_inset Formula $C_{v}$
\end_inset

 are respectively the specific heat of air at constant pressure and constant
 volume, 
\begin_inset Formula $T_{r}$
\end_inset

 is the (true) recovery temperature expressed in absolute units, 
\begin_inset Formula $M$
\end_inset

 the Mach number, and 
\begin_inset Formula $R_{a}$
\end_inset

 the gas constant for air.
 The ambient air temperature 
\begin_inset Formula $T_{a}$
\end_inset

 is related to the recovery temperature and the dynamic heating via
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
T_{r}=T_{a}+Q\,\,\,.\label{eq:recoveryTemperature}
\end{equation}

\end_inset

Dynamic heating can exceed 
\begin_inset Formula $20^{\circ}\mathrm{C}$
\end_inset

 at jet-aircraft flight speeds, so the large correction is often the dominant
 cause of fluctuations in the recovery temperature.
 The observed phase and amplitude of the measured response to that forcing
 should conform to the predictions of the transfer function.
 When fluctuations in the dynamic-heating term are the dominant cause of
 fluctuations in the recovery temperature, theoretical predictions like
 that shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:LTsolution}
\end_layout

\end_inset

 can be used to determine appropriate values of characteristic parameters
 like 
\begin_inset Formula $a$
\end_inset

 , 
\begin_inset Formula $\tau_{1}$
\end_inset

 and 
\begin_inset Formula $\tau_{2}$
\end_inset

 that fit the predictions to the observations.
\change_unchanged

\end_layout

\begin_layout Standard
Because the airspeed 
\begin_inset Formula $V$
\end_inset

 is itself conventionally determined using the processed air temperature
 
\begin_inset Formula $T_{a}$
\end_inset

, via 
\begin_inset Formula $V=M\sqrt{\gamma R_{a}T_{a}}$
\end_inset

 where 
\begin_inset Formula $\gamma=C_{p}/C_{v}$
\end_inset

, the second expression in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:DHterm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 provides the advantage that it does not rely on prior calculation of the
 air temperature 
\begin_inset Formula $T_{a}$
\end_inset

 but can be calculated from only the recovery temperature 
\begin_inset Formula $T_{r}$
\end_inset

 and the Mach number.
 The Mach number in turn depends only on measurements of the dynamic and
 ambient pressures, with a small adjustment for the water vapor pressure.
 
\change_deleted 1311305628 1586106266
The goal here is to use the phase of the response to the dynamic-heating
 term to determine the response characteristics of the temperature sensor,
 so it is preferable to remain as close to the original measurements as
 possible.

\change_inserted 1311305628 1586106274
 
\change_deleted 1311305628 1586106266
 
\end_layout

\begin_layout Standard

\change_inserted 1311305628 1586106293
However, 
\change_deleted 1311305628 1586106290
T
\change_inserted 1311305628 1586106296
t
\change_unchanged
he available measurement is not the true recovery temperature 
\begin_inset Formula $T_{r}$
\end_inset


\change_deleted 1311305628 1586106306
, however,
\change_unchanged
 but instead the measured temperature 
\begin_inset Formula $T_{m}$
\end_inset

 which may not include high-frequency fluctuations in 
\begin_inset Formula $T_{r}$
\end_inset

.
 This in turn affects the estimated fluctuations determined from 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:DHterm"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 To minimize this problem, regions were sought where the fluctuations in
 dynamic heating were the dominant cause of fluctuations in recovery temperature.
 Temporarily consider these approximations: 
\begin_inset Formula $\alpha_{r}\approx1$
\end_inset

, 
\begin_inset Formula $R_{a}/(2C_{v})\approx1/5$
\end_inset

, and 
\begin_inset Formula $M$
\end_inset

 small enough that the denominator of the right side of 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:DHterm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 can be assumed equal to unity.
 Dynamic heating then is approximately 
\begin_inset Formula $Q\approx T_{r}M^{2}/5$
\end_inset

 and fluctuations in 
\begin_inset Formula $Q$
\end_inset

 are related to those in 
\begin_inset Formula $T_{r}$
\end_inset

 and 
\begin_inset Formula $M$
\end_inset

 according to
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\frac{\delta Q}{Q}\approx\frac{\delta T_{r}}{T_{r}}+\frac{2}{5}\frac{\delta M}{M}\label{eq:QprimeOverQ}
\end{equation}

\end_inset


\change_deleted 1311305628 1586106476
T
\change_inserted 1311305628 1586106481
Because t
\change_unchanged
he measured recovery temperature 
\begin_inset Formula $T_{m}$
\end_inset

 may not include true high-frequency fluctuations in 
\begin_inset Formula $T_{r}$
\end_inset

, 
\change_deleted 1311305628 1586106488
so 
\change_unchanged
the measured phase and amplitude of the response to the dynamic-heating
 term may be distorted from the correct value at frequencies where 
\begin_inset Formula $\delta T_{m}/T_{m}$
\end_inset

 differs from 
\begin_inset Formula $\delta T_{r}/T_{r}$
\end_inset

.
 In regions where the last term in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:QprimeOverQ"
plural "false"
caps "false"
noprefix "false"

\end_inset

 dominates, underestimation of the fluctuations in the recovery temperature
 arising from sensor response will cause less significant errors in the
 measured fluctuations in dynamic heating 
\begin_inset Formula $Q$
\end_inset

, 
\change_inserted 1311305628 1586107047
and those errors can be addressed by correction procedures.
\change_deleted 1311305628 1586106979
but these errors still must be addressed.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Consider the cross-spectrum for measurements of 
\begin_inset Formula $Q_{m}$
\end_inset

 and 
\begin_inset Formula $T_{m}$
\end_inset

:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\delta Q_{m}\times\delta T_{m}=\frac{Q_{m}}{T_{m}}\delta T_{m}\times\delta T_{m}+\frac{2Q_{m}}{5M}\delta M\times\delta T_{m}
\]

\end_inset

The factor 
\begin_inset Formula $\delta T_{m}\times\delta T_{m}$
\end_inset

 in the first term on the right side of this equation is the variance spectrum
 which, in the absence of other variations, would lead to zero phase shift
 in the cross-spectrum of 
\begin_inset Formula $Q_{m}\times T_{m}$
\end_inset

.
 The cross-spectrum of 
\begin_inset Formula $M\times T_{m}$
\end_inset

, however, is not affected by the first term and still would impose a 
\end_layout

\end_inset

For this reason, once a set of parameters is determined, 
\begin_inset Formula $T_{r}(t)$
\end_inset

 can be estimated from the correction procedure outlined in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Correcting-the-Temperature"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\begin_inset Foot
status open

\begin_layout Plain Layout
See also section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Correcting-the-Temperature"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\end_inset

 Iteration using this estimate of 
\begin_inset Formula $T_{r}(t)$
\end_inset

 in place of 
\begin_inset Formula $T_{m}(t)$
\end_inset

 can then improve the estimate of the parameters.
 In practice, the estimate became stable after only one or two iterations.
\change_unchanged

\end_layout

\begin_layout Standard

\change_deleted 1311305628 1586115439
To illustrate this process, consider a low-level flight segment from the
 VOCALS project where modest turbulent fluctuations were encountered.
 The primary temperature sensor for this project was an unheated Rosemount
 102E4AL sensor.
 Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:TASX}
\end_layout

\end_inset

 shows the variance spectrum for measurements of airspeed in this region.
 While the shape is not ideal for an inertial sub-range, it is close with
 an indicated eddy dissipation rate of about 
\begin_inset Formula $3\times10^{-4}\,\mathrm{m}^{2}\mathrm{s}^{-3}$
\end_inset

.

\change_unchanged
 Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:Qprime}
\end_layout

\end_inset

 shows the contributions to the dynamic-heating term from the two terms
 on the right side of 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:QprimeOverQ"
plural "false"
caps "false"
noprefix "false"

\end_inset

, except that 
\begin_inset Formula $T_{m}$
\end_inset

 is used instead of the unknown 
\begin_inset Formula $T_{r}$
\end_inset

.
 
\change_inserted 1311305628 1586115412
This is based on a low-level flight segment with moderate turbulence where
 the airspeed fluctuations were approximately consistent with an eddy dissipatio
n rate of 
\begin_inset Formula $3\times10^{-4}\,\mathrm{m}^{2}\mathrm{s}^{-3}$
\end_inset

.
 
\change_unchanged
The variance of the second term is more than 100 times that of the first,
 indicating that the fluctuations in the first term are less than 10% of
 those in the second term.
 Therefore the right side of 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:DHterm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 with 
\begin_inset Formula $T_{m}$
\end_inset

 in place of 
\begin_inset Formula $T_{r}$
\end_inset

 was used initially to represent dynamic heating
\change_deleted 1311305628 1586107904
 and determine the transfer function representing the response to the imposed
 dynamic heating
\change_unchanged
.
 
\change_inserted 1311305628 1586364824
Once a set of parameters was determined, 
\begin_inset Formula $T_{r}(t)$
\end_inset

 was calculated using the first correction procedure discussed in Appendix
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Correcting-the-Temperature"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 Iteration using this estimate of 
\begin_inset Formula $T_{r}(t)$
\end_inset

 in place of 
\begin_inset Formula $T_{m}(t)$
\end_inset

 led to a small change in the fitted values of the parameters, and the estimate
 became stable after only one iteration.
\change_unchanged

\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<TASX, include = 
\change_deleted 1311305628 1586115218
TRUE
\change_inserted 1311305628 1586115220
FALSE
\change_unchanged
, fig.height = 3.4, fig.cap = '
\change_inserted 1311305628 1586108100
Spectral variance
\change_deleted 1311305628 1586108094
Variance spectra
\change_unchanged
 
\change_inserted 1311305628 1586115174
$P(
\backslash

\backslash
nu)$ 
\change_unchanged
for airspeed 
\change_inserted 1311305628 1586108129
($V$) as a function of frequency $
\backslash

\backslash
nu$ 
\change_unchanged
from a segment from VOCALS C-130 flight 3, 11:39:00 -- 11:52:00 UTC.
 The dotted orange lines show the spectral variance for various values of
 the eddy dissipation rate, with the heavy-dotted line representing $10^{-4}$
 m$^2$ s$^{-3}$.

\change_inserted 1311305628 1586107297
 The wavelength scale shows the correspondence between frequency and wavelength
 at the average airspeed.
\change_unchanged
'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

reviseDH <-
\end_layout

\begin_layout Plain Layout

  function (.data, P, alphaR) {
\end_layout

\begin_layout Plain Layout

    # P is Param1, e.g.; alphaR is recovery factor
\end_layout

\begin_layout Plain Layout

    .data$Q <- .data$TASX ^ 2 / 2010
\end_layout

\begin_layout Plain Layout

    aV <- P$a
\end_layout

\begin_layout Plain Layout

    tau1V <- P$tau1
\end_layout

\begin_layout Plain Layout

    tau2V <- P$tau2
\end_layout

\begin_layout Plain Layout

    Rate <- attr (.data, 'Rate')
\end_layout

\begin_layout Plain Layout

    fS <- function(y, i) {
\end_layout

\begin_layout Plain Layout

      (.data$Q[i] - y) / (tau2V * Rate)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    fM <- function (y, i) {
\end_layout

\begin_layout Plain Layout

      (aV * .data$Q[i] + (1 - aV) * TsQ[i] - y) / (Rate * tau1V)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    TsQ <- rk4.integrate (fS, .data$Q[1], 1:nrow(.data))
\end_layout

\begin_layout Plain Layout

    Qp <- rk4.integrate (fM, .data$Q[1], 1:nrow(.data))
\end_layout

\begin_layout Plain Layout

    return (.data$ATX + alphaR * (.data$Q - Qp))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

if (file.exists ('./DVOCALS.Rdata')) {
\end_layout

\begin_layout Plain Layout

  load (file = './DVOCALS.Rdata')
\end_layout

\begin_layout Plain Layout

  DVOCALS <- D
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  D <- getNetCDF(
\end_layout

\begin_layout Plain Layout

    file.path(DataDirectory(), 'VOCALS/VOCALSrf03h.nc'),
\end_layout

\begin_layout Plain Layout

    c(
\end_layout

\begin_layout Plain Layout

      'TASX',
\end_layout

\begin_layout Plain Layout

      'PALT',
\end_layout

\begin_layout Plain Layout

      'TTRR',
\end_layout

\begin_layout Plain Layout

      'ATRR',
\end_layout

\begin_layout Plain Layout

      'TTWH',
\end_layout

\begin_layout Plain Layout

      'WIC',
\end_layout

\begin_layout Plain Layout

      'ATX',
\end_layout

\begin_layout Plain Layout

      'PSXC',
\end_layout

\begin_layout Plain Layout

      'QCXC'
\end_layout

\begin_layout Plain Layout

    )
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

  D$DH <- D$TASX ^ 2 / 2010
\end_layout

\begin_layout Plain Layout

  ## For use later, "filter" the dynamic-heating term and revise the temperature
:
\end_layout

\begin_layout Plain Layout

  alphaR <- attr(D[, 'ATRR'], 'RecoveryFactor')
\end_layout

\begin_layout Plain Layout

  D$AT <- reviseDH(D, Param1, alphaR)
\end_layout

\begin_layout Plain Layout

  ## Find a corrected recovery temperature to use in the estimate of dynamic
 heating:
\end_layout

\begin_layout Plain Layout

  a <- Param1$a
\end_layout

\begin_layout Plain Layout

  tau1 <- Param1$tau1
\end_layout

\begin_layout Plain Layout

  tau2 <- Param1$tau2
\end_layout

\begin_layout Plain Layout

  ## RT is the working solution; Ts is the support temperature
\end_layout

\begin_layout Plain Layout

  D$Ts <- D$TTRR
\end_layout

\begin_layout Plain Layout

  Rate <- attr (D, 'Rate')
\end_layout

\begin_layout Plain Layout

  D$DTMDT <-
\end_layout

\begin_layout Plain Layout

    c(0, diff(D$TTRR, 2), 0) * Rate / 2  ## Average this and one-sample-advanced
\end_layout

\begin_layout Plain Layout

  # D$DTMDT <- (D$DTMDT + c(0, D$DTMDT[1:(nrow(D)-1)])) / 2
\end_layout

\begin_layout Plain Layout

  # DT$DTMDT <- as.vector (signal::filter(signal::sgolay(1, 3, m=1), DT$TTRR))
 * Rate
\end_layout

\begin_layout Plain Layout

  fS <- function(y, i) {
\end_layout

\begin_layout Plain Layout

    # Eq.
 Ts3
\end_layout

\begin_layout Plain Layout

    ((1 / a) * (tau1 * D$DTMDT[i] + D$TTRR[i] - (1 - a) * y) - y) / (Rate
 * tau2)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  D$Ts <- rk4.integrate (fS, D$Ts[1], 1:nrow(D))
\end_layout

\begin_layout Plain Layout

  D$RT <- (1 / a) * (tau1 * D$DTMDT + D$TTRR - (1 - a) * D$Ts)
\end_layout

\begin_layout Plain Layout

  # D %>% select(Time, TTRR, RT, Ts) %>% selectTime(114500, 114505) %>%
 plotWAC()
\end_layout

\begin_layout Plain Layout

  save(D, file = './DVOCALS.Rdata')
\end_layout

\begin_layout Plain Layout

  DVOCALS <- D
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

## Revise the calculation of dynamic heating to avoid dependence on AT:
\end_layout

\begin_layout Plain Layout

D$MACH <- MachNumber(D$PSXC, D$QCXC)
\end_layout

\begin_layout Plain Layout

XXA <- attr(D[, 'ATRR'], 'RecoveryFactor') * D$MACH ^ 2 / 5
\end_layout

\begin_layout Plain Layout

D$DH <- (D$TTRR + 273.15) * XXA / (1 + XXA)
\end_layout

\begin_layout Plain Layout

D$DH2 <- (D$RT + 273.15) * XXA / (1 + XXA)
\end_layout

\begin_layout Plain Layout

## temporary: shift D$AT later in time
\end_layout

\begin_layout Plain Layout

# D$AT <- ShiftInTime (D$AT, .rate=25, .shift=40)
\end_layout

\begin_layout Plain Layout

Tasm <- mean(D$TASX, na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

DT <- D %>% selectTime(113900, 115200)
\change_inserted 1311305628 1586183130

\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586183142

## Save it for use in the workflow document:
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586183164

save(DT, file='DT.Rdata')
\change_unchanged

\end_layout

\begin_layout Plain Layout

# select six boundary-layer segments of 10 min each:
\end_layout

\begin_layout Plain Layout

DT1 <- D %>% selectTime(65000, 70000)
\end_layout

\begin_layout Plain Layout

DT2 <- D %>% selectTime(73300, 74300)
\end_layout

\begin_layout Plain Layout

DT3 <- D %>% selectTime(104600, 105600)
\end_layout

\begin_layout Plain Layout

DT4 <- D %>% selectTime(114200, 115200)  ## 113900, 115200
\end_layout

\begin_layout Plain Layout

DT5 <- D %>% selectTime(124300, 125300)
\end_layout

\begin_layout Plain Layout

DT6 <- D %>% selectTime(133000, 134000)
\end_layout

\begin_layout Plain Layout

DZV <- rbind(DT1, DT2, DT3, DT4, DT5, DT6)
\end_layout

\begin_layout Plain Layout

rhozero <- 1013.25 * 100 / (287.05 * 288.15)
\end_layout

\begin_layout Plain Layout

# omitting 832-841, 920-951, 955-1005 -- look problematic
\end_layout

\begin_layout Plain Layout

# g <- VSpec(DT, 'TTRR', spans=99, xlim=c(0.01,15), ylim=c(1.e-5, 1.e-1))
\end_layout

\begin_layout Plain Layout

# g <- VSpec(DT, 'ATRR', spans=99, add=g)
\end_layout

\begin_layout Plain Layout

# VSpec(DT, 'DH', spans=99, add=g) + theme_WAC()
\change_inserted 1311305628 1586107602

\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586107616

DT$V <- DT$TASX
\change_unchanged

\end_layout

\begin_layout Plain Layout

VSpec(DT, '
\change_deleted 1311305628 1586107625
TASX
\change_inserted 1311305628 1586107629
V
\change_unchanged
', 
\change_inserted 1311305628 1586107591
VLabel='V=airspeed', 
\change_unchanged
spans = 99, ylim=c(1.e-3, 10)) + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<Qprime, include=TRUE, fig.height=3.4, fig.cap='
\change_inserted 1311305628 1586115549
Frequency-weighted 
\change_deleted 1311305628 1586115540
S
\change_inserted 1311305628 1586115553
s
\change_unchanged
pectral variance for $
\backslash

\backslash
delta T_m/T_m$ and 0.4$
\backslash

\backslash
delta M/M$
\change_inserted 1311305628 1586115608
 as functions of frequency ($
\backslash

\backslash
nu$)
\change_unchanged
 for 
\change_inserted 1311305628 1586116329
a low-level flight segment from VOCALS flight 3, 21 Oct 2008 11:39:00 --
 11:52:00 UTC.
 The wavelength scale shows the correspondence between frequency and wavelength
 at the average airspeed.
\change_deleted 1311305628 1586116390
the same flight segment shown in the previous figure.

\change_unchanged
 The two terms are labeled 
\begin_inset Quotes eld
\end_inset

Tm
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

Mach
\begin_inset Quotes erd
\end_inset

 in the legend.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DT$Mach <- (DT$MACH - mean(DT$MACH, na.rm = TRUE)) / 
\end_layout

\begin_layout Plain Layout

            mean(DT$MACH, na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

DT$Tm <- (DT$TTRR - mean(DT$TTRR, na.rm = TRUE)) / 
\end_layout

\begin_layout Plain Layout

          (273.15 + mean(DT$TTRR, na.rm = TRUE))
\end_layout

\begin_layout Plain Layout

DT$Mach <- DT$Mach * 0.4
\end_layout

\begin_layout Plain Layout

g <- VSpec(DT, 'Mach', ylim = c(1.e-10, 1.e-4))
\end_layout

\begin_layout Plain Layout

VSpec(DT, 'Tm', add = g) + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<extra2, include=FALSE, echo=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## This is a special version with features not in the standard Ranadu version
\end_layout

\begin_layout Plain Layout

CohP <-
\end_layout

\begin_layout Plain Layout

  function (.data,
\end_layout

\begin_layout Plain Layout

            .Var1,
\end_layout

\begin_layout Plain Layout

            .Var2,
\end_layout

\begin_layout Plain Layout

            col = 'blue',
\end_layout

\begin_layout Plain Layout

            spans = 25,
\end_layout

\begin_layout Plain Layout

            smoothBins = 50,
\end_layout

\begin_layout Plain Layout

            plotType = 'ggplot',
\end_layout

\begin_layout Plain Layout

            showErrors = 0,
\end_layout

\begin_layout Plain Layout

            returnCospectrum = FALSE) {
\end_layout

\begin_layout Plain Layout

    if (is.data.frame(.data)) {
\end_layout

\begin_layout Plain Layout

      if (.Var1 %in% names(.data)) {
\end_layout

\begin_layout Plain Layout

        Z <-
\end_layout

\begin_layout Plain Layout

          capture.output (Vr <-
\end_layout

\begin_layout Plain Layout

                            SmoothInterp(detrend (.data[, c('Time', .Var1)]),
 .Length = 0))
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        print(sprintf(
\end_layout

\begin_layout Plain Layout

          'CohPhase ERROR: Variable %s is not in the supplied data.frame',
\end_layout

\begin_layout Plain Layout

          .Var1
\end_layout

\begin_layout Plain Layout

        ))
\end_layout

\begin_layout Plain Layout

        return (NA)
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      if (.Var2 %in% names(.data)) {
\end_layout

\begin_layout Plain Layout

        Z <-
\end_layout

\begin_layout Plain Layout

          capture.output (VrC <-
\end_layout

\begin_layout Plain Layout

                            SmoothInterp(detrend (.data[, c('Time', .Var2)]),
 .Length = 0))
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        print(sprintf(
\end_layout

\begin_layout Plain Layout

          'CohPhase ERROR: Variable %s is not in the supplied data.frame',
\end_layout

\begin_layout Plain Layout

          .Var2
\end_layout

\begin_layout Plain Layout

        ))
\end_layout

\begin_layout Plain Layout

        return (NA)
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      print('CohPhase ERROR: first argument is not a data.frame.')
\end_layout

\begin_layout Plain Layout

      return (NA)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if (is.null(attr(.data, 'Rate'))) {
\end_layout

\begin_layout Plain Layout

      print ('CohPhase warning: Rate attribute missing from data.frame, so
 using Rate=1')
\end_layout

\begin_layout Plain Layout

      Rate <- 1
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      Rate <- attr(.data, 'Rate')
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    vcv <- cbind(ts(Vr, frequency = Rate), ts(VrC, frequency = Rate))
\end_layout

\begin_layout Plain Layout

    P <-
\end_layout

\begin_layout Plain Layout

      spec.pgram(
\end_layout

\begin_layout Plain Layout

        vcv,
\end_layout

\begin_layout Plain Layout

        detrend = FALSE,
\end_layout

\begin_layout Plain Layout

        fast = TRUE,
\end_layout

\begin_layout Plain Layout

        plot = FALSE,
\end_layout

\begin_layout Plain Layout

        spans = spans
\end_layout

\begin_layout Plain Layout

      )
\end_layout

\begin_layout Plain Layout

    df1 <- data.frame(P$coh, log(P$freq))
\end_layout

\begin_layout Plain Layout

    df2 <- data.frame (P$phase, log(P$freq))
\end_layout

\begin_layout Plain Layout

    df3 <- data.frame (P$spec[, 1], log(P$freq))
\end_layout

\begin_layout Plain Layout

    df4 <- data.frame (P$spec[, 2], log(P$freq))
\end_layout

\begin_layout Plain Layout

    pf1 <- binStats (df1, bins = smoothBins)
\end_layout

\begin_layout Plain Layout

    pf2 <- binStats (df2, bins = smoothBins)
\end_layout

\begin_layout Plain Layout

    pf3 <- binStats (df3, bins = smoothBins)
\end_layout

\begin_layout Plain Layout

    pf4 <- binStats (df4, bins = smoothBins)
\end_layout

\begin_layout Plain Layout

    pf1 <- pf1[!is.na (pf1$ybar),]
\end_layout

\begin_layout Plain Layout

    pf2 <- pf2[!is.na (pf2$ybar),]
\end_layout

\begin_layout Plain Layout

    pf3 <- pf3[!is.na (pf3$ybar),]
\end_layout

\begin_layout Plain Layout

    pf4 <- pf4[!is.na (pf4$ybar),]
\end_layout

\begin_layout Plain Layout

    # pf1$sigma[pf1$nb > 1] <- pf1$sigma[pf1$nb > 1] / sqrt(pf1$nb[pf1$nb
 > 2])
\end_layout

\begin_layout Plain Layout

    pf1$sigma[pf1$nb <= 1] <- NA # pf1$ybar[pf1$nb <= 1] * 0.5
\end_layout

\begin_layout Plain Layout

    # pf2$sigma[pf2$nb > 1] <- pf2$sigma[pf2$nb > 1] / sqrt(pf2$nb[pf2$nb
 > 2])
\end_layout

\begin_layout Plain Layout

    pf2$sigma[pf2$nb <= 1] <- NA # pf2$ybar[pf2$nb <= 1] * 0.5is
\end_layout

\begin_layout Plain Layout

    if (plotType != 'ggplot') {
\end_layout

\begin_layout Plain Layout

      pf1 <- binStats (df1, bins = smoothBins, addBin = TRUE)
\end_layout

\begin_layout Plain Layout

      pf2 <- binStats (df2, bins = smoothBins, addBin = TRUE)
\end_layout

\begin_layout Plain Layout

      pf3 <- binStats (df3, bins = smoothBins, addBin = TRUE)
\end_layout

\begin_layout Plain Layout

      pf4 <- binStats (df4, bins = smoothBins, addBin = TRUE)
\end_layout

\begin_layout Plain Layout

      return(cbind(pf1, pf2, pf3, pf4)[, c(2, 1, 3, 4, 6, 7, 10)])
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      d2 <-
\end_layout

\begin_layout Plain Layout

        data.frame(
\end_layout

\begin_layout Plain Layout

          Time = exp(pf1$xc),
\end_layout

\begin_layout Plain Layout

          coherence = pf1$ybar,
\end_layout

\begin_layout Plain Layout

          phase = pf2$ybar * 180 / pi,
\end_layout

\begin_layout Plain Layout

          clo = (pf1$ybar - showErrors * pf1$sigma),
\end_layout

\begin_layout Plain Layout

          chi = pf1$ybar + showErrors * pf1$sigma,
\end_layout

\begin_layout Plain Layout

          plo = (pf2$ybar - showErrors * pf2$sigma) * 180 / pi,
\end_layout

\begin_layout Plain Layout

          phi = (pf2$ybar + showErrors * pf2$sigma) * 180 / pi
\end_layout

\begin_layout Plain Layout

        )
\end_layout

\begin_layout Plain Layout

      d2$clo[!is.na(d2$clo) & (d2$clo < 0)] <- 0
\end_layout

\begin_layout Plain Layout

      labelP <- c('coherence', 'phase [degrees]')
\end_layout

\begin_layout Plain Layout

      g <- ggplotWAC(
\end_layout

\begin_layout Plain Layout

        d2[, c(1, 2, 3)],
\end_layout

\begin_layout Plain Layout

        panels = 2,
\end_layout

\begin_layout Plain Layout

        labelP = labelP,
\end_layout

\begin_layout Plain Layout

        col = col,
\end_layout

\begin_layout Plain Layout

        lwd = c(1.0),
\end_layout

\begin_layout Plain Layout

        lty = c(1),
\end_layout

\begin_layout Plain Layout

        xlab = 'freq'
\end_layout

\begin_layout Plain Layout

      )
\end_layout

\begin_layout Plain Layout

      g <-
\end_layout

\begin_layout Plain Layout

        g + xlab('frequency [Hz]') + ylab (sprintf ('%s x %s', .Var1, .Var2))
\end_layout

\begin_layout Plain Layout

      g <-
\end_layout

\begin_layout Plain Layout

        g + scale_x_log10(
\end_layout

\begin_layout Plain Layout

          breaks = trans_breaks("log10", function(x)
\end_layout

\begin_layout Plain Layout

            10 ^ x, n = 4),
\end_layout

\begin_layout Plain Layout

          labels = trans_format("log10", math_format(expr = 10 ^ .x))
\end_layout

\begin_layout Plain Layout

        ) + xlab('frequency [Hz]')
\end_layout

\begin_layout Plain Layout

      if (showErrors > 0 && smoothBins > 5) {
\end_layout

\begin_layout Plain Layout

        da <- data.frame(d2[, c(1, 4, 5)])
\end_layout

\begin_layout Plain Layout

        db <- data.frame(d2[, c(1, 6, 7)])
\end_layout

\begin_layout Plain Layout

        names(da) <- c('Time', 'ymin', 'ymax')
\end_layout

\begin_layout Plain Layout

        names(db) <- c('Time', 'ymin', 'ymax')
\end_layout

\begin_layout Plain Layout

        da$PanelGroup <- labelP[1]
\end_layout

\begin_layout Plain Layout

        db$PanelGroup <- labelP[2]
\end_layout

\begin_layout Plain Layout

        d <- rbind(db, da)
\end_layout

\begin_layout Plain Layout

        g <-
\end_layout

\begin_layout Plain Layout

          g + geom_ribbon(
\end_layout

\begin_layout Plain Layout

            data = d,
\end_layout

\begin_layout Plain Layout

            aes(
\end_layout

\begin_layout Plain Layout

              x = Time,
\end_layout

\begin_layout Plain Layout

              ymin = ymin,
\end_layout

\begin_layout Plain Layout

              ymax = ymax
\end_layout

\begin_layout Plain Layout

            ),
\end_layout

\begin_layout Plain Layout

            colour = 'grey',
\end_layout

\begin_layout Plain Layout

            alpha = 0.15,
\end_layout

\begin_layout Plain Layout

            inherit.aes = FALSE
\end_layout

\begin_layout Plain Layout

          )
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      g <- g + theme_WAC(1) + theme(legend.position = 'none')
\end_layout

\begin_layout Plain Layout

      if (returnCospectrum) {
\end_layout

\begin_layout Plain Layout

        CS <-
\end_layout

\begin_layout Plain Layout

          sqrt(P$coh[, 1] * P$spec[, 1] * P$spec[, 2] / (1 + tan(P$phase[,
 1]) ^
\end_layout

\begin_layout Plain Layout

                                                           2))
\end_layout

\begin_layout Plain Layout

        v1 <- SmoothInterp(.data[, .Var1], .Length = 0)
\end_layout

\begin_layout Plain Layout

        v2 <- SmoothInterp(.data[, .Var2], .Length = 0)
\end_layout

\begin_layout Plain Layout

        v1 <- detrend(data.frame(Time = .data$Time, v1))
\end_layout

\begin_layout Plain Layout

        v2 <- detrend(data.frame(Time = .data$Time, v2))
\end_layout

\begin_layout Plain Layout

        ff1 <- fft(v1)
\end_layout

\begin_layout Plain Layout

        ff2 <- fft(v2)
\end_layout

\begin_layout Plain Layout

        G <- Re(ff1 * Conj(ff2)) / nrow(.data)
\end_layout

\begin_layout Plain Layout

        GQ <- Im(ff1 * Conj(ff2)) / nrow(.data)
\end_layout

\begin_layout Plain Layout

        N <- nrow(.data) %/% 2
\end_layout

\begin_layout Plain Layout

        S1 <- Re(ff1 * Conj(ff1) / nrow(.data))
\end_layout

\begin_layout Plain Layout

        S2 <- Re(ff2 * Conj(ff2) / nrow(.data))
\end_layout

\begin_layout Plain Layout

        G <- G[2:(N + 1)]
\end_layout

\begin_layout Plain Layout

        GQ <- GQ[2:(N + 1)]
\end_layout

\begin_layout Plain Layout

        S1 <- S1[2:(N + 1)]
\end_layout

\begin_layout Plain Layout

        S2 <- S2[2:(N + 1)]
\end_layout

\begin_layout Plain Layout

        frq <- c(1:N) * Rate / nrow(.data)
\end_layout

\begin_layout Plain Layout

        spec1 <- 2 * S1 / Rate
\end_layout

\begin_layout Plain Layout

        spec2 <- 2 * S2 / Rate
\end_layout

\begin_layout Plain Layout

        cospec <- 2 * G / Rate
\end_layout

\begin_layout Plain Layout

        quad <- 2 * GQ / Rate
\end_layout

\begin_layout Plain Layout

        # cospectrum - i * quadrature = (gain spectrum) * exp(i*(phase spectrum)
)
\end_layout

\begin_layout Plain Layout

        # sqrt(cospectrum^2 + quadrature^2) is the amplitude or gain spectrum
\end_layout

\begin_layout Plain Layout

        return(data.frame(
\end_layout

\begin_layout Plain Layout

          freq = frq,
\end_layout

\begin_layout Plain Layout

          cospec = cospec,
\end_layout

\begin_layout Plain Layout

          quad = quad,
\end_layout

\begin_layout Plain Layout

          spec1 = spec1,
\end_layout

\begin_layout Plain Layout

          spec2 = spec2
\end_layout

\begin_layout Plain Layout

        ))
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        return(g)
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

RX <- CohPhase(DT, 'TTRR', 'DH', plotType = 'Ranadu')
\end_layout

\begin_layout Plain Layout

SB <- 200
\end_layout

\begin_layout Plain Layout

RXX <- CohPhase(DT1, 'TTRR', 'DH', plotType = 'Ranadu', smoothBins = SB)
\end_layout

\begin_layout Plain Layout

Z <-
\end_layout

\begin_layout Plain Layout

  capture.output (Vr <-
\end_layout

\begin_layout Plain Layout

                    SmoothInterp(detrend (DT1[, c('Time', 'TTRR')]), .Length
 = 0))
\end_layout

\begin_layout Plain Layout

Z <-
\end_layout

\begin_layout Plain Layout

  capture.output (VrC <-
\end_layout

\begin_layout Plain Layout

                    SmoothInterp(detrend (DT1[, c('Time', 'DH')]), .Length
 = 0))
\end_layout

\begin_layout Plain Layout

Rate <- attr(DT1, 'Rate')
\end_layout

\begin_layout Plain Layout

vcv <- cbind(ts(Vr, frequency = Rate), ts(VrC, frequency = Rate))
\end_layout

\begin_layout Plain Layout

P <- spec.pgram(
\end_layout

\begin_layout Plain Layout

  vcv,
\end_layout

\begin_layout Plain Layout

  detrend = FALSE,
\end_layout

\begin_layout Plain Layout

  fast = TRUE,
\end_layout

\begin_layout Plain Layout

  plot = FALSE,
\end_layout

\begin_layout Plain Layout

  spans = 25
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

df1 <- data.frame(P$coh, log(P$freq))
\end_layout

\begin_layout Plain Layout

df2 <- data.frame (P$phase, log(P$freq))
\end_layout

\begin_layout Plain Layout

pf1 <- binStats (df1, bins = SB)
\end_layout

\begin_layout Plain Layout

pf2 <- binStats (df2, bins = SB)
\end_layout

\begin_layout Plain Layout

## Use DH2 to get the time-response-corrected-RT Q
\end_layout

\begin_layout Plain Layout

RX1 <- CohP(DT1, 'TTRR', 'DH', plotType = 'Ranadu', smoothBins = SB)
\end_layout

\begin_layout Plain Layout

RX2 <- CohP(DT2, 'TTRR', 'DH', plotType = 'Ranadu', smoothBins = SB)
\end_layout

\begin_layout Plain Layout

RX3 <- CohP(DT3, 'TTRR', 'DH', plotType = 'Ranadu', smoothBins = SB)
\end_layout

\begin_layout Plain Layout

RX4 <- CohP(DT4, 'TTRR', 'DH', plotType = 'Ranadu', smoothBins = SB)
\end_layout

\begin_layout Plain Layout

RX5 <- CohP(DT5, 'TTRR', 'DH', plotType = 'Ranadu', smoothBins = SB)
\end_layout

\begin_layout Plain Layout

RX6 <- CohP(DT6, 'TTRR', 'DH', plotType = 'Ranadu', smoothBins = SB)
\end_layout

\begin_layout Plain Layout

phase <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

nphase <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

phase2 <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

ar <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

ar2 <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

nar <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

for (RX in list(RX1, RX2, RX3, RX4, RX5, RX6)) {
\end_layout

\begin_layout Plain Layout

  for (i in 2:nrow(RX)) {
\end_layout

\begin_layout Plain Layout

    phase[RX$BIN.1[i]] <- phase[RX$BIN.1[i]] + RX$P.phase[i]
\end_layout

\begin_layout Plain Layout

    nphase[RX$BIN.1[i]] <- nphase[RX$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

    phase2[RX$BIN.1[i]] <- phase2[RX$BIN.1[i]] + RX$P.phase[i] ^ 2
\end_layout

\begin_layout Plain Layout

    ar[RX$BIN.1[i]] <-
\end_layout

\begin_layout Plain Layout

      ar[RX$BIN.1[i]] + sqrt(RX$P.spec...1.[i] / RX$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

    ar2[RX$BIN.1[i]] <-
\end_layout

\begin_layout Plain Layout

      ar2[RX$BIN.1[i]] + (RX$P.spec...1.[i] / RX$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

    nar[RX$BIN.1[i]] <- nar[RX$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

nphase[nphase == 0] <- 1
\end_layout

\begin_layout Plain Layout

nar[nar == 0] <- 1
\end_layout

\begin_layout Plain Layout

mphase <- phase / nphase
\end_layout

\begin_layout Plain Layout

mphase2 <- phase2 / nphase
\end_layout

\begin_layout Plain Layout

sdp <- sqrt(mphase2 - mphase ^ 2)
\end_layout

\begin_layout Plain Layout

mphase <- mphase * 180 / pi
\end_layout

\begin_layout Plain Layout

sdp <- sdp * 180 / pi
\end_layout

\begin_layout Plain Layout

sdp <- sdp * 2 / sqrt(nphase)
\end_layout

\begin_layout Plain Layout

ar <- ar / nar
\end_layout

\begin_layout Plain Layout

ar2 <- ar2 / nar
\end_layout

\begin_layout Plain Layout

sdr <- sqrt(ar2 - ar ^ 2)
\end_layout

\begin_layout Plain Layout

sdr <- sdr * 2 / sqrt(nar)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\change_inserted 1311305628 1586103454

\end_layout

\begin_layout Subsubsection

\change_inserted 1311305628 1586103455
The unheated Rosemount 102E4AL sensor
\begin_inset CommandInset label
LatexCommand label
name "subsec:The-unheated-Rosemount"

\end_inset


\change_unchanged

\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Segment
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
start
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
end
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6:50:00
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7:00:00
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7:33:00
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7:43:00
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10:46:00
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10:56:00
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11:42:00
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
11:52:00
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12:43:00
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12:53:00
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13:30:00
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13:40:00
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Flight segments from flight 3 of the VOCALS project, 21 October 2008.
 Listed times are UTC.
\end_layout

\end_inset


\end_layout

\end_inset


\change_inserted 1311305628 1586103442

\end_layout

\begin_layout Standard

\change_deleted 1311305628 1586103731
To extend this analysis to a larger data set, s
\change_inserted 1311305628 1586103986
To characterize the response of the Rosemount 102E4AL sensor, s
\change_unchanged
ix ten-minute low level flight segments in the marine boundary layer from
 one flight of the NCAR/NSF C-130 
\change_inserted 1311305628 1586126924
in the 
\begin_inset Quotes eld
\end_inset

VOCALS
\begin_inset Quotes erd
\end_inset

 project (
\begin_inset CommandInset citation
LatexCommand citet
key "wood2011vamos"
literal "false"

\end_inset

), which studied low-level clouds over the Pacific Ocean near Chile, 
\change_unchanged
were selected that had simular flight conditions including the intensity
 of the turbulence.
 The time intervals are listed in Table 1.
 For each flight segment, the phase and amplitude ratio between the measurement
 and the dynamic heating term were calculated,
\begin_inset Foot
status open

\begin_layout Plain Layout
The R routine 
\begin_inset Quotes eld
\end_inset

spec.pgram()
\begin_inset Quotes erd
\end_inset

 was used with 25-point modified Daniell smoothing.
\end_layout

\end_inset

 and the results for all six segments were averaged in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(SB,0)}
\end_layout

\end_inset

 logarithmically spaced intervals in frequency.
 The results for the average phase are shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:Vphase}
\end_layout

\end_inset

.
 
\change_deleted 1311305628 1586117061
The error bars in that figure indicate the two-standard-deviation limits
 of those mean values.

\change_unchanged
 The theoretical curve is based on best-fit parameters as determined from
 these measurements and those of the amplitude ratio, discussed next.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<Vphase, include=TRUE, echo=FALSE, fig.height=3.5, fig.cap='Phase lag of
\change_inserted 1311305628 1585691956
 measured
\change_unchanged
 recovery temperature behind dynamic heating, for the measurements (
\change_inserted 1311305628 1586116924
with 
\change_unchanged
error bars) and for the theoretical response for the best-fit parameters
 (green line).
 
\change_inserted 1311305628 1586117342
The error bars indicate two-standard-deviation ranges in the mean at each
 plotted point.
 
\change_unchanged
Data from the 
\change_deleted 1311305628 1586116987
VOCALS project, flight 3,
\change_unchanged
 flight segments 
\change_inserted 1311305628 1586116995
listed
\change_deleted 1311305628 1586116992
as
\change_unchanged
 in Table 1.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

df <- data.frame(frq=exp(pf2$xc), mphase=mphase, sdp=sdp)
\end_layout

\begin_layout Plain Layout

df <- df[df$frq > 0.01, ]
\end_layout

\begin_layout Plain Layout

df <- df[df$sdp > 0, ]
\end_layout

\begin_layout Plain Layout

df <- df[df$frq < 12, ]
\end_layout

\begin_layout Plain Layout

# plot(df$frq, df$mphase, type='p', pch=20, col='blue', log='x', xlim=c(1.e-2,
 15),
\end_layout

\begin_layout Plain Layout

#   xlab='frequency [Hz]', ylab='phase, RTRR x Q [degrees]', ylim=c(-80,
 9))
\end_layout

\begin_layout Plain Layout

# arrows(df$frq, df$mphase-df$sdp, df$frq, df$mphase+df$sdp, length=0.05,
 angle=90, code=3)
\end_layout

\begin_layout Plain Layout

g <- ggplot(df, aes(x=frq, y=mphase))+geom_point()
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab (
\change_inserted 1311305628 1585692382
bquote('phase [' ~ degree * ']'
\change_deleted 1311305628 1585692421
'phase RTRR x Q [degrees]'
\change_inserted 1311305628 1585693054
)
\change_unchanged
)
\end_layout

\begin_layout Plain Layout

g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=4),
\end_layout

\begin_layout Plain Layout

         labels = trans_format("log10", math_format(expr = 10^.x))) + xlab('frequ
ency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = "bt")
\end_layout

\begin_layout Plain Layout

g <- g + geom_errorbar(aes(ymin=mphase-sdp, ymax=mphase+sdp), width=0.06)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfAP, aes(x=Time, y=Phase), col='forestgreen')
\end_layout

\begin_layout Plain Layout

g + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

frq <- seq(0.01, 25, by=0.01)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<checkAmplitude, include=TRUE, fig.pos='t', fig.height = 3.5, fig.cap='The
 ratio of the spectral amplitude for the measurement of recovery temperature
 ($T_m(t)$) to that for dynamic heating ($Q$), shown as the plotted data
 points.
 There are additional data points at frequencies below about 0.04 Hz that
 do not appear in this plot because they lie above the upper limit for the
 ordinate.
 The green line is the prediction from the transfer function determined
 from the best-fit values matching the phase lag between these variables,
 and the dashed orange line is a similar result with the second time constant
 $
\backslash

\backslash
tau_2$ increased from 0.447 to 0.6 s to illustrate sensitivity to this parameter.'>
>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

dfr <- data.frame(frq=exp(pf2$xc), mrspec=ar, sdr=sdr)
\end_layout

\begin_layout Plain Layout

dfr <- dfr[dfr$frq > 0.01, ]
\end_layout

\begin_layout Plain Layout

dfr <- dfr[dfr$sdr > 0, ]
\end_layout

\begin_layout Plain Layout

dfr <- dfr[dfr$frq < 12, ]
\end_layout

\begin_layout Plain Layout

frq <- exp(pf2$xc[nar > 0])
\end_layout

\begin_layout Plain Layout

# spec1 <- spec1[nspec1 > 0]
\end_layout

\begin_layout Plain Layout

# spec2 <- spec2[nspec1 > 0]
\end_layout

\begin_layout Plain Layout

# rspec <- spec1 / spec2
\end_layout

\begin_layout Plain Layout

# plotWAC(data.frame(frq, mrspec), xlab='frequency [Hz]', ylab='amplitude
 ratio RTRR/Q', type='p', 
\end_layout

\begin_layout Plain Layout

#         col='blue', log='x', pch=20, xlim=c(0.1,15), ylim=c(0,1.2))
\end_layout

\begin_layout Plain Layout

# HR <- LTphase(frq, Param1)
\end_layout

\begin_layout Plain Layout

# P <- Param1
\end_layout

\begin_layout Plain Layout

# P$tau2 <- 0.84
\end_layout

\begin_layout Plain Layout

# HR2 <- LTphase(frq, P)
\end_layout

\begin_layout Plain Layout

# lines(frq, (HR2$Amp)^2, col='forestgreen', lwd=2)
\end_layout

\begin_layout Plain Layout

# lines(frq, (HR$Amp)^2, col='darkorange', lwd=2, lty=2)
\end_layout

\begin_layout Plain Layout

Param5 <- Param1
\end_layout

\begin_layout Plain Layout

Param5$tau2 <- 0.6
\end_layout

\begin_layout Plain Layout

H5 <- LTphase(dfr$frq, Param5)
\end_layout

\begin_layout Plain Layout

cTF5 <- H5$Amp
\end_layout

\begin_layout Plain Layout

phiTF5 <- H5$Phase
\end_layout

\begin_layout Plain Layout

dfr$Amp5 <- cTF5
\end_layout

\begin_layout Plain Layout

g <- ggplot(dfr, aes(x=frq, y=mrspec))+geom_point()
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab ('amplitude ratio
\change_deleted 1311305628 1585701343
 RTRR / Q
\change_unchanged
')
\end_layout

\begin_layout Plain Layout

g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=4),
\end_layout

\begin_layout Plain Layout

         labels = trans_format("log10", math_format(expr = 10^.x))) + xlab('frequ
ency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = "bt")
\end_layout

\begin_layout Plain Layout

g <- g + geom_errorbar(aes(ymin=mrspec-sdr, ymax=mrspec+sdr), width=0.06)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfAP, aes(x=Time, y=Amp
\change_inserted 1311305628 1586366592
, col='best', lty='best'
\change_unchanged
)
\change_deleted 1311305628 1586366605
, col='forestgreen'
\change_unchanged
)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfr, aes(x=frq, y=Amp5
\change_inserted 1311305628 1586366831
, col='tau2=0.6', lty='tau2=0.6'
\change_unchanged
)
\change_deleted 1311305628 1586366645
, col='darkorange', lty=2
\change_unchanged
)
\change_inserted 1311305628 1586366541

\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586366546

g <-
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586366546

  g + scale_colour_manual (
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586366546

    name = 'fit: ',
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586366656

    values = c("best" = "forestgreen", "tau2=0.6" = "darkorange")
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586366546

  )
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586366546

g <- g + scale_linetype_manual (name = 'fit: ', 
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586366666

                                values = c('best' = 1, 'tau2=0.6'=2))
\change_unchanged

\end_layout

\begin_layout Plain Layout

suppressWarnings(print(g + ylim(0, 1.3) + theme_WAC(1)))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The ratio of the amplitude of the response to that of the dynamic-heating
 signal, used as an estimate of the gain of the transfer function, is shown
 in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:checkAmplitude}
\end_layout

\end_inset

.
 It is useful to consider both the amplitude and phase when determining
 the response parameters because, as shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:LTsolution}
\end_layout

\end_inset

, the amplitude of the transfer function is more sensitive to 
\begin_inset Formula $\tau_{2}$
\end_inset

 than the phase but 
\begin_inset Formula $\tau_{1}$
\end_inset

 is a very sensitive predictor of the phase at high frequency.
 For the set of favored parameters, Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:checkAmplitude}
\end_layout

\end_inset

 shows the standard prediction and another with 
\begin_inset Formula $\tau_{2}$
\end_inset

 set to 0.6
\begin_inset space ~
\end_inset

s instead, to show the sensitivity of this result to that parameter.
 The best prediction based on the measured phases consistently underestimates
 the ratio of spectra for frequencies below about 0.1
\begin_inset space ~
\end_inset

Hz and above about 3
\begin_inset space ~
\end_inset

Hz but is reasonably consistent with the observed ratio between 0.1
\begin_inset space ~
\end_inset

Hz and 3
\begin_inset space ~
\end_inset

Hz.
 Below 0.1
\begin_inset space ~
\end_inset

Hz it appears likely that the sensor is responding to real fluctuations
 in temperature not attributable to dynamic heating, as would be expected
 at these low frequencies.
 Above 3
\begin_inset space ~
\end_inset

Hz the prediction is much too low, probably because there is noise or other
 spurious variance in 
\begin_inset Formula $T_{m}(t)$
\end_inset

 not caused by dynamic heating.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
The orange dashed line, showing the result when 
\begin_inset Formula $\tau_{2}$
\end_inset

 is decreased to 0.4
\begin_inset space ~
\end_inset

s, is a much better fit.
 This suggests that the second time constant determined from the fit to
 the phase is overestimated, so this revised value for 
\begin_inset Formula $\tau_{2}$
\end_inset

 will be interpreted as the best value.
 
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
However, the previous standard parameters as represented by the green line
 will continue to be used as the best estimate because the spectral ratio
 is more easily confounded, especially by departures of the data toward
 higher values, by extraneous sources of variance in 
\begin_inset Formula $T_{m}(t)$
\end_inset

 not produced by 
\begin_inset Formula $Q$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<fitCoefs, include=TRUE, echo=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Param2 <- Param1
\end_layout

\begin_layout Plain Layout

## Restrict dfr frequencies:
\end_layout

\begin_layout Plain Layout

dfr <- dfr[dfr$frq > 0.1 & dfr$frq < 3, ]
\end_layout

\begin_layout Plain Layout

minFn <- function(V) {
\end_layout

\begin_layout Plain Layout

  Param2$a <<- V[1]
\end_layout

\begin_layout Plain Layout

  Param2$tau1 <<- V[2]
\end_layout

\begin_layout Plain Layout

  Param2$tau2 <<- V[3]
\end_layout

\begin_layout Plain Layout

  Chisq <- 0
\end_layout

\begin_layout Plain Layout

  for (i in 1:nrow(df)) {
\end_layout

\begin_layout Plain Layout

    Chisq <- Chisq + (df$mphase[i] - LTphase(df$frq[i], Param2)$Phase)^2
 / df$sdp[i]^2
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  for (i in 1:nrow(dfr)) {
\end_layout

\begin_layout Plain Layout

    Chisq <- Chisq + (dfr$mrspec[i] - LTphase(dfr$frq[i], Param2)$Amp)^2
 / dfr$sdr[i]^2
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return (Chisq)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

A <- optim (c(Param2$a, Param2$tau1, Param2$tau2), minFn, hessian=TRUE)
\end_layout

\begin_layout Plain Layout

best <- A$par
\end_layout

\begin_layout Plain Layout

Herror <- solve(A$hessian / 4)  # factor of 4 because 2-sigma errors were
 used?
\end_layout

\begin_layout Plain Layout

uncLimits <- sqrt(diag(Herror))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The fit procedure used 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:responseAmp"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:responsePhase"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to find the theoretical value of the amplitude ratio and phase at each
 frequency represented in the observations.
 For assumed values of the three parameters 
\begin_inset Formula $a$
\end_inset

, 
\begin_inset Formula $\tau_{1}$
\end_inset

 and 
\begin_inset Formula $\tau_{2}$
\end_inset

, a chi-square was calculated from the differences between these theoretical
 values and the observed values.
 The frequencies used for the fit were 0.01 to 12
\begin_inset space ~
\end_inset

Hz for the measurements of phase and 0.1 to 3
\begin_inset space ~
\end_inset

Hz for the measurements of amplitude ratio, to avoid regions where effects
 other than dynamic heating appear to bias the measurements.
 Then a search procedure varied these parameters to seek the minimum value
 of the chi-square.
\begin_inset Foot
status open

\begin_layout Plain Layout
The code can be found in the 
\begin_inset Quotes eld
\end_inset

Rnw
\begin_inset Quotes erd
\end_inset

 document that generates the present document.
 It used the 
\begin_inset Quotes eld
\end_inset

optim()
\begin_inset Quotes erd
\end_inset

 function from the R 
\begin_inset Quotes eld
\end_inset

stats
\begin_inset Quotes erd
\end_inset

 package produced by the 
\begin_inset CommandInset citation
LatexCommand citet
key "Rlanguage"
literal "false"

\end_inset

.
\end_layout

\end_inset

 The resulting values were 
\begin_inset Formula $a=$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(best[1], 2)}
\end_layout

\end_inset

, 
\begin_inset Formula $\tau_{1}=$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(best[2], 3)}
\end_layout

\end_inset

 and 
\begin_inset Formula $\tau_{2}=$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(best[3], 2)}
\end_layout

\end_inset

.
 The chi-square for the fit is about 18 times larger than expected if the
 fit represents the measurements to measurement uncertainty, so it is difficult
 to assign uncertainty limits to this result on the basis of this fit because
 of this not-understood excess chi-square, but the fit minimum distinguished
 nearby values to about three significant digits in all three parameters.
 The Hessian from the fit implies that the results with standard uncertainties
 are 
\begin_inset Formula $a=$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(best[1], 3)}
\end_layout

\end_inset


\begin_inset Formula $\pm$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(uncLimits[1], 3)}
\end_layout

\end_inset

, 
\begin_inset Formula $\tau_{1}=$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(best[2], 4)}
\end_layout

\end_inset


\begin_inset Formula $\pm$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(uncLimits[2], 4)}
\end_layout

\end_inset

 and 
\begin_inset Formula $\tau_{2}=$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(best[3], 2)}
\end_layout

\end_inset


\begin_inset Formula $\pm$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(uncLimits[3], 2)}
\end_layout

\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
As shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:LTsolution}
\end_layout

\end_inset

, the phase of the response at high frequency is very sensitive to 
\begin_inset Formula $\tau_{1}$
\end_inset

 while the amplitude of the response near 0.3
\begin_inset space ~
\end_inset

Hz is sensitive to 
\begin_inset Formula $\tau_{2}$
\end_inset

.
 The fit is therefore better constrained by combining the two parts of the
 response function.
 These parameters led to the transfer function shown earlier in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:LTsolution}
\end_layout

\end_inset

 and used as the reference values for the unheated Rosemount 102E4AL in
 this study.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<correctRT, include=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Integrate to find the support temperature Ts:
\end_layout

\begin_layout Plain Layout

a <- Param1$a
\end_layout

\begin_layout Plain Layout

tau1 <- Param1$tau1
\end_layout

\begin_layout Plain Layout

tau2 <- Param1$tau2
\end_layout

\begin_layout Plain Layout

## RT is the working solution; Ts is the support temperature
\end_layout

\begin_layout Plain Layout

DT$Ts <- DT$RT
\end_layout

\begin_layout Plain Layout

Rate <- attr (DT, 'Rate')
\end_layout

\begin_layout Plain Layout

DT$DTMDT <- c(0, diff(DT$TTRR, 2), 0) * Rate / 2
\end_layout

\begin_layout Plain Layout

# DT$DTMDT <- (DT$DTMDT + c(0, DT$DTMDT[1:(nrow(DT)-1)])) / 2
\end_layout

\begin_layout Plain Layout

# DT$DTMDT <- as.vector (signal::filter(signal::sgolay(1, 3, m=1), DT$TTRR))
 * Rate
\end_layout

\begin_layout Plain Layout

fS <- function(y, i) {  # Eq.
 Ts3
\end_layout

\begin_layout Plain Layout

  ((1/a) * (tau1 * DT$DTMDT[i] + DT$TTRR[i] - (1-a) * y) - y) / (Rate *
 tau2)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DT$Ts <- rk4.integrate (fS, DT$Ts[1], 1:nrow(DT))
\end_layout

\begin_layout Plain Layout

DT$RT <- (1/a) * (tau1 * DT$DTMDT + DT$TTRR - (1-a) * DT$Ts)
\end_layout

\begin_layout Plain Layout

DT %>% select(Time, TTRR, RT, Ts) %>% 
\end_layout

\begin_layout Plain Layout

       selectTime(114500, 114505) %>% 
\end_layout

\begin_layout Plain Layout

       plotWAC()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To complete the 
\change_inserted 1311305628 1586118253
iteration discussed earlier
\change_deleted 1311305628 1586118243
cycle
\change_unchanged
, the measured recovery temperature was then corrected via method 1 from
 Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Integration-of-the"
plural "false"
caps "false"
noprefix "false"

\end_inset

, using the
\change_deleted 1311305628 1586118268
se
\change_unchanged
 parameters
\change_inserted 1311305628 1586118280
 from this first fit
\change_unchanged
, to find a prediction for the actual recovery temperature 
\begin_inset Formula $T_{r}(t)$
\end_inset

.
 After recalculating 
\begin_inset Formula $Q$
\end_inset

 using 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:DHterm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 with that estimate of 
\begin_inset Formula $T_{r}(t)$
\end_inset

 in place of 
\begin_inset Formula $T_{m}(t)$
\end_inset

, the calculation of phase and amplitude was repeated and the results were
 fitted again by adjusting the fit parameters.
 Only very minor changes arose from this procedure even after one iteration,
 but the iterated result is the one used here to represent the unheated
 Rosemount 102E4AL sensor
\change_inserted 1311305628 1586122936
.

\change_deleted 1311305628 1586122944
 as flown in the NSF/NCAR C-130.
\change_unchanged

\end_layout

\begin_layout Standard

\change_deleted 1311305628 1586123724
A similar evaluation examined the response of the same sensor when flown
 on the NSF/NCAR GV, which flies significantly faster than the C-130.
 The results of several studies using SOCRATES and CSET data were consistent
 with the results from VOCAL as used above, in some cases with values of
 the two time constants 
\begin_inset Formula $\tau_{1}$
\end_inset

 and 
\begin_inset Formula $\tau_{2}$
\end_inset

 a little smaller than found for the C-130.
 This might be expected at greater airspeed, as discussed in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Expected-dependence-on"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\change_unchanged

\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<GVcheck>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## This chunk checks GV measurements for consistency with the previous results
 from the C-130,
\end_layout

\begin_layout Plain Layout

## with results reasonably consistent with those results.
 Decided that they don't merit a
\end_layout

\begin_layout Plain Layout

## separate result for the GV.
\end_layout

\begin_layout Plain Layout

DSX <- getNetCDF(file.path(DataDirectory(), 'SOCRATES/rf15h.nc'),
\end_layout

\begin_layout Plain Layout

                 standardVariables(c('ATF1', 'ATH1', 'ATH2')), 55200, 62000)
\end_layout

\begin_layout Plain Layout

DCX <- getNetCDF(file.path(DataDirectory(), 'CSET/rf05h.nc'),
\end_layout

\begin_layout Plain Layout

                 standardVariables(c('ATF1', 'ATH1', 'ATH2')), 175000, 205000)
\end_layout

\begin_layout Plain Layout

rf.txt <- attr(DSX$ATF1, 'RecoveryFactor')
\end_layout

\begin_layout Plain Layout

rf <- gsub('mach', 'MACHX', rf.txt)
\end_layout

\begin_layout Plain Layout

rf <- gsub(' log', ' * log', rf)
\end_layout

\begin_layout Plain Layout

rf <- gsub(' 
\backslash

\backslash
(', ' * 
\backslash

\backslash
(', rf)
\end_layout

\begin_layout Plain Layout

rf <- with(DSX, eval(parse(text=rf)))
\end_layout

\begin_layout Plain Layout

rf2.txt <- attr(DSX$ATH1, 'RecoveryFactor')
\end_layout

\begin_layout Plain Layout

rf2 <- gsub('mach', 'MACHX', rf2.txt)
\end_layout

\begin_layout Plain Layout

rf2 <- gsub(' log', ' * log', rf2)
\end_layout

\begin_layout Plain Layout

rf2 <- gsub(' 
\backslash

\backslash
(', ' * 
\backslash

\backslash
(', rf2)
\end_layout

\begin_layout Plain Layout

rf2 <- with(DSX, eval(parse(text=rf2)))
\end_layout

\begin_layout Plain Layout

DSX$RTF1 <- DSX$ATF1 + rf * DSX$TASX^2 / 2010
\end_layout

\begin_layout Plain Layout

DSX$RTF1 <- SmoothInterp(DSX$RTF1, .Length=0)
\end_layout

\begin_layout Plain Layout

DSX$RTH1 <- DSX$ATH1 + rf2 * DSX$TASX^2 / 2010
\end_layout

\begin_layout Plain Layout

DSX$RTH1 <- SmoothInterp(DSX$RTH1, .Length=0)
\end_layout

\begin_layout Plain Layout

XXA <- rf * DSX$MACHX^2 / 5
\end_layout

\begin_layout Plain Layout

DSX$Q <- (DSX$RTF1 + 273.15) * XXA / (1 + XXA)
\end_layout

\begin_layout Plain Layout

DSX$Q <- SmoothInterp(DSX$Q, .Length=0)
\end_layout

\begin_layout Plain Layout

DSX$Q <- ShiftInTime(DSX$Q, .rate=25, .shift=-10)
\end_layout

\begin_layout Plain Layout

rf.txt <- attr(DCX$ATF1, 'RecoveryFactor')
\end_layout

\begin_layout Plain Layout

rf <- gsub('mach', 'MACHX', rf.txt)
\end_layout

\begin_layout Plain Layout

rf <- gsub(' log', ' * log', rf)
\end_layout

\begin_layout Plain Layout

rf <- gsub(' 
\backslash

\backslash
(', ' * 
\backslash

\backslash
(', rf)
\end_layout

\begin_layout Plain Layout

rf <- with(DCX, eval(parse(text=rf)))
\end_layout

\begin_layout Plain Layout

rf2.txt <- attr(DCX$ATH1, 'RecoveryFactor')
\end_layout

\begin_layout Plain Layout

rf2 <- gsub('mach', 'MACHX', rf2.txt)
\end_layout

\begin_layout Plain Layout

rf2 <- gsub(' log', ' * log', rf2)
\end_layout

\begin_layout Plain Layout

rf2 <- gsub(' 
\backslash

\backslash
(', ' * 
\backslash

\backslash
(', rf2)
\end_layout

\begin_layout Plain Layout

rf2 <- with(DCX, eval(parse(text=rf2)))
\end_layout

\begin_layout Plain Layout

DCX$RTF1 <- DCX$ATF1 + rf * DCX$TASX^2 / 2010
\end_layout

\begin_layout Plain Layout

DCX$RTF1 <- SmoothInterp(DCX$RTF1, .Length=0)
\end_layout

\begin_layout Plain Layout

DCX$RTH1 <- DCX$ATH1 + rf2 * DCX$TASX^2 / 2010
\end_layout

\begin_layout Plain Layout

DCX$RTH1 <- SmoothInterp(DCX$RTH1, .Length=0)
\end_layout

\begin_layout Plain Layout

XXA <- rf * DCX$MACHX^2 / 5
\end_layout

\begin_layout Plain Layout

DCX$Q <- (DCX$RTF1 + 273.15) * XXA / (1 + XXA)
\end_layout

\begin_layout Plain Layout

DCX$Q <- SmoothInterp(DCX$Q, .Length=0)
\end_layout

\begin_layout Plain Layout

DCX$Q <- ShiftInTime(DCX$Q, .rate=25, .shift=-10)
\end_layout

\begin_layout Plain Layout

## May need to revise this with corrected RT in second iteration
\end_layout

\begin_layout Plain Layout

# RX <- CohPhase(DSA, 'RTF1', 'Q', plotType='Ranadu')
\end_layout

\begin_layout Plain Layout

SB <- 100
\end_layout

\begin_layout Plain Layout

DSX$RT <- DSX$RTF1
\end_layout

\begin_layout Plain Layout

DCX$RT <- DCX$RTF1
\end_layout

\begin_layout Plain Layout

## Next is for Z adjustment later
\end_layout

\begin_layout Plain Layout

DZ <- rbind(DSX %>% selectTime(55200, 60200),
\end_layout

\begin_layout Plain Layout

            DSX %>% selectTime(60500, 61500),
\end_layout

\begin_layout Plain Layout

            DCX %>% selectTime(175200, 180200),
\end_layout

\begin_layout Plain Layout

            DCX %>% selectTime(194530, 195530),
\end_layout

\begin_layout Plain Layout

            DCX %>% selectTime(203717, 204717))
\end_layout

\begin_layout Plain Layout

DSA <- DSX %>% selectTime(55200, 60200)
\end_layout

\begin_layout Plain Layout

RXA <- DSX %>% selectTime(55200, 60200) %>% CohP('RT', 'Q', plotType='Ranadu',
 smoothBins=SB)
\end_layout

\begin_layout Plain Layout

RXB <- DSX %>% selectTime(60500, 61500) %>% CohP('RT', 'Q', plotType='Ranadu',
 smoothBins=SB)
\end_layout

\begin_layout Plain Layout

RXC <- DCX %>% selectTime(175200, 180200) %>% CohP('RT', 'Q', plotType='Ranadu',
 smoothBins=SB)
\end_layout

\begin_layout Plain Layout

RXD <- DCX %>% selectTime(194530, 195530) %>% CohP('RT', 'Q', plotType='Ranadu',
 smoothBins=SB)
\end_layout

\begin_layout Plain Layout

RXE <- DCX %>% selectTime(203717, 204717) %>% CohP('RT', 'Q', plotType='Ranadu',
 smoothBins=SB)
\end_layout

\begin_layout Plain Layout

## May need to revise this with corrected RT in second iteration
\end_layout

\begin_layout Plain Layout

Z <- capture.output (Vr <- SmoothInterp(detrend (DSA[, c('Time', 'RT')]),
 .Length=0))
\end_layout

\begin_layout Plain Layout

Z <- capture.output (VrC <- SmoothInterp(detrend (DSA[, c('Time', 'Q')]),
 .Length=0))
\end_layout

\begin_layout Plain Layout

Rate <- attr(DSA, 'Rate')
\end_layout

\begin_layout Plain Layout

vcv <- cbind(ts(Vr, frequency=Rate), ts(VrC, frequency=Rate))
\end_layout

\begin_layout Plain Layout

P <- spec.pgram(vcv, detrend=FALSE, fast=TRUE, plot=FALSE, spans=25)
\end_layout

\begin_layout Plain Layout

df1SF <- data.frame(P$coh, log(P$freq))
\end_layout

\begin_layout Plain Layout

df2SF <- data.frame (P$phase, log(P$freq))
\end_layout

\begin_layout Plain Layout

pf1SF <- binStats (df1SF, bins=SB)
\end_layout

\begin_layout Plain Layout

pf2SF <- binStats (df2SF, bins=SB)
\end_layout

\begin_layout Plain Layout

phaseSF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

nphaseSF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

phase2SF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

arSF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

ar2SF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

narSF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

for (RX in list(RXA, RXB, RXC, RXD, RXE)) {
\end_layout

\begin_layout Plain Layout

  for (i in 2:nrow(RX)) {
\end_layout

\begin_layout Plain Layout

    phaseSF[RX$BIN.1[i]] <- phaseSF[RX$BIN.1[i]] + RX$P.phase[i]
\end_layout

\begin_layout Plain Layout

    nphaseSF[RX$BIN.1[i]] <- nphaseSF[RX$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

    phase2SF[RX$BIN.1[i]] <- phase2SF[RX$BIN.1[i]] + RX$P.phase[i]^2
\end_layout

\begin_layout Plain Layout

    arSF[RX$BIN.1[i]] <- arSF[RX$BIN.1[i]] + sqrt(RX$P.spec...1.[i] / RX$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

    ar2SF[RX$BIN.1[i]] <- ar2SF[RX$BIN.1[i]] + (RX$P.spec...1.[i] / RX$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

    narSF[RX$BIN.1[i]] <- narSF[RX$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

nphaseSF[nphaseSF == 0] <- 1
\end_layout

\begin_layout Plain Layout

narSF[narSF == 0] <- 1
\end_layout

\begin_layout Plain Layout

mphaseSF <- phaseSF/nphaseSF
\end_layout

\begin_layout Plain Layout

mphase2SF <- phase2SF/nphaseSF
\end_layout

\begin_layout Plain Layout

sdpSF <- sqrt(mphase2SF - mphaseSF^2)
\end_layout

\begin_layout Plain Layout

mphaseSF <- mphaseSF * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpSF <- sdpSF * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpSF <- sdpSF * 2 / sqrt(nphaseSF)
\end_layout

\begin_layout Plain Layout

arSF <- arSF / narSF
\end_layout

\begin_layout Plain Layout

ar2SF <- ar2SF / narSF
\end_layout

\begin_layout Plain Layout

b <- ar2SF - arSF^2
\end_layout

\begin_layout Plain Layout

b[near(b, 0)] <- 0
\end_layout

\begin_layout Plain Layout

sdrSF <- sqrt(b)
\end_layout

\begin_layout Plain Layout

sdrSF <- sdrSF * 2 / sqrt(narSF)
\end_layout

\begin_layout Plain Layout

dfSF <- data.frame(frq=exp(pf2SF$xc), mphase=mphaseSF, sdp=sdpSF)
\end_layout

\begin_layout Plain Layout

dfSF <- dfSF[dfSF$frq > 0.05, ]
\end_layout

\begin_layout Plain Layout

dfSF <- dfSF[dfSF$sdp > 0, ]
\end_layout

\begin_layout Plain Layout

dfSF <- dfSF[dfSF$frq < 8, ]
\end_layout

\begin_layout Plain Layout

dfrSF <- data.frame(frq=exp(pf2SF$xc), mrspec=arSF, sdr=sdrSF)
\end_layout

\begin_layout Plain Layout

dfrSF <- dfrSF[dfrSF$frq > 0.05, ]
\end_layout

\begin_layout Plain Layout

dfrSF <- dfrSF[dfrSF$sdr > 0, ]
\end_layout

\begin_layout Plain Layout

dfrSF <- dfrSF[dfrSF$frq < 8, ]
\end_layout

\begin_layout Plain Layout

frq <- exp(pf2SF$xc)
\end_layout

\begin_layout Plain Layout

Parm <- Param1
\end_layout

\begin_layout Plain Layout

minFn <- function(V) {
\end_layout

\begin_layout Plain Layout

  Parm$a <<- V[1]
\end_layout

\begin_layout Plain Layout

  Parm$tau1 <<- V[2]
\end_layout

\begin_layout Plain Layout

  Parm$tau2 <<- V[3]
\end_layout

\begin_layout Plain Layout

  Chisq <- 0
\end_layout

\begin_layout Plain Layout

  for (i in 1:nrow(dfSF)) {
\end_layout

\begin_layout Plain Layout

    Chisq <- Chisq + (dfSF$mphase[i] - LTphase(dfSF$frq[i], Parm)$Phase)^2
 / dfSF$sdp[i]^2
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  for (i in 1:nrow(dfrSF)) {
\end_layout

\begin_layout Plain Layout

    Chisq <- Chisq + (dfrSF$mrspec[i] - LTphase(dfrSF$frq[i], Parm)$Amp)^2
 / dfrSF$sdr[i]^2
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return (Chisq)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

ASF <- optim (c(Parm$a, Parm$tau1, Parm$tau2), minFn, hessian=TRUE)
\end_layout

\begin_layout Plain Layout

bestSF <- ASF$par
\end_layout

\begin_layout Plain Layout

HerrorSF <- solve(ASF$hessian / 4)  # factor of 4 because 2-sigma errors
 were used?
\end_layout

\begin_layout Plain Layout

uncLimitsSF <- sqrt(diag(HerrorSF))
\end_layout

\begin_layout Plain Layout

print(bestSF)
\end_layout

\begin_layout Plain Layout

HSF <- LTphase(dfrSF$frq, Parm)
\end_layout

\begin_layout Plain Layout

dfrSF$Amp <- HSF$Amp
\end_layout

\begin_layout Plain Layout

dfrSF$Phase <- HSF$Phase
\end_layout

\begin_layout Plain Layout

ParamSF <- Param2
\end_layout

\begin_layout Plain Layout

ParGV <- Parm
\end_layout

\begin_layout Plain Layout

rhozero <- 1013.25 * 100 / (287.05 * 288.15)
\end_layout

\begin_layout Plain Layout

MRHO <- MachNumber(DZ$PSXC, DZ$QCXC) * DZ$PSXC * 100 / 
\end_layout

\begin_layout Plain Layout

        (287.05 * (273.15 + DZ$ATX)) / rhozero
\end_layout

\begin_layout Plain Layout

ParGV$tau1 <- ParGV$tau1 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ 0.6
\end_layout

\begin_layout Plain Layout

ParGV$tau2 <- ParGV$tau2 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ 0.6
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

g <- ggplot(dfSF, aes(x=frq, y=mphase))+geom_point()
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab ('phase RTF1 x Q [degrees]')
\end_layout

\begin_layout Plain Layout

g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=4),
\end_layout

\begin_layout Plain Layout

                       labels = trans_format("log10", math_format(expr =
 10^.x))) + xlab('frequency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = "bt")
\end_layout

\begin_layout Plain Layout

g <- g + geom_errorbar(aes(ymin=mphase-sdp, ymax=mphase+sdp), width=0.06)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfrSF, aes(x=frq, y=Phase), col='forestgreen')
\end_layout

\begin_layout Plain Layout

# g <- g + geom_path(data=dfAPSF, aes(x=Time, y=Phase), col='darkorange')
\end_layout

\begin_layout Plain Layout

g + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

frq <- exp(pf2SF$xc[narSF > 0])
\end_layout

\begin_layout Plain Layout

# spec1 <- spec1[nspec1 > 0]
\end_layout

\begin_layout Plain Layout

# spec2 <- spec2[nspec1 > 0]
\end_layout

\begin_layout Plain Layout

# rspec <- spec1 / spec2
\end_layout

\begin_layout Plain Layout

# plotWAC(data.frame(frq, mrspec), xlab='frequency [Hz]', ylab='amplitude
 ratio RTRR/Q', type='p', 
\end_layout

\begin_layout Plain Layout

#         col='blue', log='x', pch=20, xlim=c(0.1,15), ylim=c(0,1.2))
\end_layout

\begin_layout Plain Layout

# HR <- LTphase(frq, Param1)
\end_layout

\begin_layout Plain Layout

# P <- Param1
\end_layout

\begin_layout Plain Layout

# P$tau2 <- 0.84
\end_layout

\begin_layout Plain Layout

# HR2 <- LTphase(frq, P)
\end_layout

\begin_layout Plain Layout

# lines(frq, (HR2$Amp)^2, col='forestgreen', lwd=2)
\end_layout

\begin_layout Plain Layout

# lines(frq, (HR$Amp)^2, col='darkorange', lwd=2, lty=2)
\end_layout

\begin_layout Plain Layout

g <- ggplot(dfrSF, aes(x=frq, y=mrspec))+geom_point()
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab ('amplitude ratio RTF1 / Q')
\end_layout

\begin_layout Plain Layout

g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=2),
\end_layout

\begin_layout Plain Layout

                       labels = trans_format("log10", math_format(expr =
 10^.x))) + xlab('frequency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = "bt")
\end_layout

\begin_layout Plain Layout

g <- g + geom_errorbar(aes(ymin=mrspec-sdr, ymax=mrspec+sdr), width=0.06)
\end_layout

\begin_layout Plain Layout

# g <- g + geom_path(data=dfAPSF, aes(x=Time, y=Amp), col='darkorange')
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfrSF, aes(x=frq, y=Amp), col='forestgreen')
\end_layout

\begin_layout Plain Layout

suppressWarnings(print(g + ylim(0, 1.3) + theme_WAC(1)))
\end_layout

\begin_layout Plain Layout

CohPhase(DSA, 'RTF1', 'Q')
\end_layout

\begin_layout Plain Layout

DSA %>% select(Time, TASX, RTF1, Q, ATF1) %>% VSpec()
\end_layout

\begin_layout Plain Layout

print(bestSF)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<S11a>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DS11 <- getNetCDF(file.path(DataDirectory(), 'SOCRATES/SOCRATESrf11h.nc'),
 
\end_layout

\begin_layout Plain Layout

                  standardVariables(c('ATF1', 'ATH1')), 34850, 35900)
\end_layout

\begin_layout Plain Layout

# DS11 <- DS11 %>% selectTime(44300, 44800)
\end_layout

\begin_layout Plain Layout

dfAPSF <- dfAP[dfAP$Time > 0.5 & dfAP$Time < 8, ]
\end_layout

\begin_layout Plain Layout

## Revise the calculation of dynamic heating to avoid dependence on AT:
\end_layout

\begin_layout Plain Layout

rf.txt <- attr(DS11$ATF1, 'RecoveryFactor')
\end_layout

\begin_layout Plain Layout

rf <- gsub('mach', 'MACHX', rf.txt)
\end_layout

\begin_layout Plain Layout

rf <- gsub(' log', ' * log', rf)
\end_layout

\begin_layout Plain Layout

rf <- gsub(' 
\backslash

\backslash
(', ' * 
\backslash

\backslash
(', rf)
\end_layout

\begin_layout Plain Layout

rf <- with(DS11, eval(parse(text=rf)))
\end_layout

\begin_layout Plain Layout

## RTF1 is not in the netCDF file so recalculate it:
\end_layout

\begin_layout Plain Layout

DS11$RTF1 <- DS11$ATF1 + rf * DS11$TASX^2 / 2010
\end_layout

\begin_layout Plain Layout

DS11$RTF1 <- SmoothInterp(DS11$RTF1, .Length=0)
\end_layout

\begin_layout Plain Layout

## Now correct it using standard parameters:
\end_layout

\begin_layout Plain Layout

## Integrate to find the support temperature Ts:
\end_layout

\begin_layout Plain Layout

CorrectT <- FALSE
\end_layout

\begin_layout Plain Layout

# CorrectT <- TRUE
\end_layout

\begin_layout Plain Layout

if (CorrectT) {
\end_layout

\begin_layout Plain Layout

  a <- Param1$a
\end_layout

\begin_layout Plain Layout

  tau1 <- Param1$tau1
\end_layout

\begin_layout Plain Layout

  tau2 <- Param1$tau2
\end_layout

\begin_layout Plain Layout

  ## RT is the working solution; Ts is the support temperature
\end_layout

\begin_layout Plain Layout

  DS11$Ts <- DS11$RTF1
\end_layout

\begin_layout Plain Layout

  Rate <- attr (DS11, 'Rate')
\end_layout

\begin_layout Plain Layout

  DS11$DTMDT <- c(0, diff(DS11$RTF1, 2), 0) * Rate / 2
\end_layout

\begin_layout Plain Layout

  # DT$DTMDT <- (DT$DTMDT + c(0, DT$DTMDT[1:(nrow(DT)-1)])) / 2
\end_layout

\begin_layout Plain Layout

  # DT$DTMDT <- as.vector (signal::filter(signal::sgolay(1, 3, m=1), DT$TTRR))
 * Rate
\end_layout

\begin_layout Plain Layout

  fS <- function(y, i) {  # Eq.
 Ts3
\end_layout

\begin_layout Plain Layout

    ((1/a) * (tau1 * DS11$DTMDT[i] + DS11$RTF1[i] - (1-a) * y) - y) / (Rate
 * tau2)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  DS11$Ts <- rk4.integrate (fS, DS11$Ts[1], 1:nrow(DS11))
\end_layout

\begin_layout Plain Layout

  DS11$RT <- (1/a) * (tau1 * DS11$DTMDT + DS11$RTF1 - (1-a) * DS11$Ts)
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  DS11$RT <- DS11$RTF1
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

XXA <- rf * DS11$MACHX^2 / 5
\end_layout

\begin_layout Plain Layout

DS11$Q <- (DS11$RT + 273.15) * XXA / (1 + XXA)
\end_layout

\begin_layout Plain Layout

DS11$Q <- SmoothInterp(DS11$Q, .Length=0)
\end_layout

\begin_layout Plain Layout

## May need to revise this with corrected RT in second iteration
\end_layout

\begin_layout Plain Layout

RX <- CohPhase(DS11, 'RT', 'Q', plotType='Ranadu')
\end_layout

\begin_layout Plain Layout

SB <- 90
\end_layout

\begin_layout Plain Layout

Z <- capture.output (Vr <- SmoothInterp(detrend (DS11[, c('Time', 'RT')]),
 .Length=0))
\end_layout

\begin_layout Plain Layout

Z <- capture.output (VrC <- SmoothInterp(detrend (DS11[, c('Time', 'Q')]),
 .Length=0))
\end_layout

\begin_layout Plain Layout

Rate <- attr(DS11, 'Rate')
\end_layout

\begin_layout Plain Layout

vcv <- cbind(ts(Vr, frequency=Rate), ts(VrC, frequency=Rate))
\end_layout

\begin_layout Plain Layout

P <- spec.pgram(vcv, detrend=FALSE, fast=TRUE, plot=FALSE, spans=25)
\end_layout

\begin_layout Plain Layout

df1SF <- data.frame(P$coh, log(P$freq))
\end_layout

\begin_layout Plain Layout

df2SF <- data.frame (P$phase, log(P$freq))
\end_layout

\begin_layout Plain Layout

pf1SF <- binStats (df1SF, bins=SB)
\end_layout

\begin_layout Plain Layout

pf2SF <- binStats (df2SF, bins=SB)
\end_layout

\begin_layout Plain Layout

## Use DH2 to get the time-response-corrected-RT Q
\end_layout

\begin_layout Plain Layout

RX1 <- CohP(DS11, 'RT', 'Q', plotType='Ranadu', smoothBins=SB)
\end_layout

\begin_layout Plain Layout

phaseSF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

nphaseSF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

phase2SF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

arSF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

ar2SF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

narSF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

for (RX in list(RX1)) {
\end_layout

\begin_layout Plain Layout

  for (i in 2:nrow(RX)) {
\end_layout

\begin_layout Plain Layout

    phaseSF[RX$BIN.1[i]] <- phaseSF[RX$BIN.1[i]] + RX$P.phase[i]
\end_layout

\begin_layout Plain Layout

    nphaseSF[RX$BIN.1[i]] <- nphaseSF[RX$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

    phase2SF[RX$BIN.1[i]] <- phase2SF[RX$BIN.1[i]] + RX$P.phase[i]^2 
\end_layout

\begin_layout Plain Layout

    arSF[RX$BIN.1[i]] <- arSF[RX$BIN.1[i]] + sqrt(RX$P.spec...1.[i] / RX$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

    ar2SF[RX$BIN.1[i]] <- ar2SF[RX$BIN.1[i]] + (RX$P.spec...1.[i] / RX$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

    narSF[RX$BIN.1[i]] <- narSF[RX$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

nphaseSF[nphaseSF == 0] <- 1
\end_layout

\begin_layout Plain Layout

narSF[narSF == 0] <- 1
\end_layout

\begin_layout Plain Layout

mphaseSF <- phaseSF/nphaseSF
\end_layout

\begin_layout Plain Layout

mphase2SF <- phase2SF/nphaseSF
\end_layout

\begin_layout Plain Layout

sdpSF <- sqrt(mphase2SF - mphaseSF^2)
\end_layout

\begin_layout Plain Layout

mphaseSF <- mphaseSF * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpSF <- sdpSF * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpSF <- sdpSF * 2 / sqrt(nphaseSF)
\end_layout

\begin_layout Plain Layout

arSF <- arSF / narSF
\end_layout

\begin_layout Plain Layout

ar2SF <- ar2SF / narSF
\end_layout

\begin_layout Plain Layout

b <- ar2SF - arSF^2
\end_layout

\begin_layout Plain Layout

b[near(b, 0)] <- 0
\end_layout

\begin_layout Plain Layout

sdrSF <- sqrt(b)
\end_layout

\begin_layout Plain Layout

sdrSF <- sdrSF * 2 / sqrt(narSF)
\end_layout

\begin_layout Plain Layout

dfSF <- data.frame(frq=exp(pf2SF$xc), mphase=mphaseSF, sdp=sdpSF)
\end_layout

\begin_layout Plain Layout

dfSF <- dfSF[dfSF$frq > 0.5, ]
\end_layout

\begin_layout Plain Layout

dfSF <- dfSF[dfSF$sdp > 0, ]
\end_layout

\begin_layout Plain Layout

dfSF <- dfSF[dfSF$frq < 8, ]
\end_layout

\begin_layout Plain Layout

dfrSF <- data.frame(frq=exp(pf2SF$xc), mrspec=arSF, sdr=sdrSF)
\end_layout

\begin_layout Plain Layout

dfrSF <- dfrSF[dfrSF$frq > 0.5, ]
\end_layout

\begin_layout Plain Layout

dfrSF <- dfrSF[dfrSF$sdr > 0, ]
\end_layout

\begin_layout Plain Layout

dfrSF <- dfrSF[dfrSF$frq < 8, ]
\end_layout

\begin_layout Plain Layout

frq <- exp(pf2SF$xc)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Param2 <- Param1
\end_layout

\begin_layout Plain Layout

minFn <- function(V) {
\end_layout

\begin_layout Plain Layout

  Param2$a <<- V[1]
\end_layout

\begin_layout Plain Layout

  Param2$tau1 <<- V[2]
\end_layout

\begin_layout Plain Layout

  Param2$tau2 <<- V[3]
\end_layout

\begin_layout Plain Layout

  Chisq <- 0
\end_layout

\begin_layout Plain Layout

  for (i in 1:nrow(dfSF)) {
\end_layout

\begin_layout Plain Layout

    Chisq <- Chisq + (dfSF$mphase[i] - LTphase(dfSF$frq[i], Param2)$Phase)^2
 / dfSF$sdp[i]^2
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  for (i in 1:nrow(dfrSF)) {
\end_layout

\begin_layout Plain Layout

    Chisq <- Chisq + (dfrSF$mrspec[i] - LTphase(dfrSF$frq[i], Param2)$Amp)^2
 / dfrSF$sdr[i]^2
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return (Chisq)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

ASF <- optim (c(Param2$a, Param2$tau1, Param2$tau2), minFn, method='L-BFGS-B',
 lower=0, upper=1, hessian=TRUE)
\end_layout

\begin_layout Plain Layout

bestSF <- ASF$par
\end_layout

\begin_layout Plain Layout

HerrorSF <- solve(ASF$hessian / 4)  # factor of 4 because 2-sigma errors
 were used?
\end_layout

\begin_layout Plain Layout

uncLimitsSF <- sqrt(diag(HerrorSF))
\end_layout

\begin_layout Plain Layout

HSF <- LTphase(dfSF$frq, Param2)
\end_layout

\begin_layout Plain Layout

dfSF$Amp <- HSF$Amp
\end_layout

\begin_layout Plain Layout

dfSF$Phase <- HSF$Phase
\end_layout

\begin_layout Plain Layout

ParamSF <- Param2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

g <- ggplot(dfSF, aes(x=frq, y=mphase))+geom_point()
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab ('phase RTF1 x Q [degrees]')
\end_layout

\begin_layout Plain Layout

g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=4),
\end_layout

\begin_layout Plain Layout

                       labels = trans_format("log10", math_format(expr =
 10^.x))) + xlab('frequency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = "bt")
\end_layout

\begin_layout Plain Layout

g <- g + geom_errorbar(aes(ymin=mphase-sdp, ymax=mphase+sdp), width=0.06)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfSF, aes(x=frq, y=Phase), col='forestgreen')
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfAPSF, aes(x=Time, y=Phase), col='darkorange')
\end_layout

\begin_layout Plain Layout

g + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

frq <- exp(pf2SF$xc[narSF > 0])
\end_layout

\begin_layout Plain Layout

# spec1 <- spec1[nspec1 > 0]
\end_layout

\begin_layout Plain Layout

# spec2 <- spec2[nspec1 > 0]
\end_layout

\begin_layout Plain Layout

# rspec <- spec1 / spec2
\end_layout

\begin_layout Plain Layout

# plotWAC(data.frame(frq, mrspec), xlab='frequency [Hz]', ylab='amplitude
 ratio RTRR/Q', type='p', 
\end_layout

\begin_layout Plain Layout

#         col='blue', log='x', pch=20, xlim=c(0.1,15), ylim=c(0,1.2))
\end_layout

\begin_layout Plain Layout

# HR <- LTphase(frq, Param1)
\end_layout

\begin_layout Plain Layout

# P <- Param1
\end_layout

\begin_layout Plain Layout

# P$tau2 <- 0.84
\end_layout

\begin_layout Plain Layout

# HR2 <- LTphase(frq, P)
\end_layout

\begin_layout Plain Layout

# lines(frq, (HR2$Amp)^2, col='forestgreen', lwd=2)
\end_layout

\begin_layout Plain Layout

# lines(frq, (HR$Amp)^2, col='darkorange', lwd=2, lty=2)
\end_layout

\begin_layout Plain Layout

g <- ggplot(dfrSF, aes(x=frq, y=mrspec))+geom_point()
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab ('amplitude ratio RTF1 / Q')
\end_layout

\begin_layout Plain Layout

g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=2),
\end_layout

\begin_layout Plain Layout

                       labels = trans_format("log10", math_format(expr =
 10^.x))) + xlab('frequency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = "bt")
\end_layout

\begin_layout Plain Layout

g <- g + geom_errorbar(aes(ymin=mrspec-sdr, ymax=mrspec+sdr), width=0.06)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfAPSF, aes(x=Time, y=Amp), col='darkorange')
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfSF, aes(x=frq, y=Amp), col='forestgreen')
\end_layout

\begin_layout Plain Layout

suppressWarnings(print(g + ylim(0, 1.3) + theme_WAC(1)))
\end_layout

\begin_layout Plain Layout

print(bestSF)
\end_layout

\begin_layout Plain Layout

rhozero <- 1013.25*100/(287.05*288.15)
\end_layout

\begin_layout Plain Layout

MRHOGV <- MachNumber(DS11$PSXC, DS11$QCXC) * DS11$PSXC * 100 / (287.05 *
 
\end_layout

\begin_layout Plain Layout

                   (273.15 + DS11$ATX)) / rhozero
\end_layout

\begin_layout Plain Layout

ParamSF$tau1 <- ParamSF$tau1 * (mean(MRHOGV, na.rm=TRUE) / 0.3)^0.6
\end_layout

\begin_layout Plain Layout

ParamSF$tau2 <- ParamSF$tau2 * (mean(MRHOGV, na.rm=TRUE) / 0.3)^0.6
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\change_inserted 1311305628 1586123866

\end_layout

\begin_layout Standard

\change_inserted 1311305628 1586126818
The airflow and typical flow angles approaching a sensor can affect its
 response, so the results might change when installed on a different location
 or a different aircraft.
 Therefore a similar evaluation examined the response of this same sensor
 when flown on the NSF/NCAR GV, which flies significantly faster than the
 C-130.
 The results of a study using a combined low-level dataset from the SOCRATES
 (
\begin_inset CommandInset citation
LatexCommand citet
key "mcfarquharsouthern"
literal "false"

\end_inset

) and CSET (
\begin_inset CommandInset citation
LatexCommand citet
key "albrecht2019cloud"
literal "false"

\end_inset

) experiments, which were flown over the Pacific Ocean, were similar to
 but slightly different from the coefficients determined on the C-130, with
 both time constants a little smaller than found for the C-130 (
\begin_inset Formula $\tau_{1}=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

\change_inserted 1311305628 1586124406


\backslash
Sexpr{round(ParGV$tau1, 3)}
\change_unchanged

\end_layout

\end_inset

 and 
\begin_inset Formula $\tau_{2}=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

\change_inserted 1311305628 1586124250


\backslash
Sexpr{round(ParGV$tau2, 2)}
\change_unchanged

\end_layout

\end_inset

).
 This might be expected at greater airspeed, as discussed in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Expected-dependence-on"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 
\change_unchanged

\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The preceding results characterize the measurement on the NSF/NCAR C-130
 research aircraft.
 The airflow at the sensor may vary depending on its location on the aircraft
 or on which aircraft is used, so it is useful to consider another case
 where the sensor is installed on the GV.
 The case selected was a low-level flight segment from the SOCRATES research
 project, flight 3, 3:48:50 to 3:59:00 UTC\SpecialChar endofsentence
 The preceding analysis was repeated,
 with the result that the best-fit parameters were 
\begin_inset Formula $a=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestSF[1], 2)}
\end_layout

\end_inset

, 
\begin_inset Formula $\tau_{1}=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestSF[2], 3)}
\end_layout

\end_inset

 and 
\begin_inset Formula $\tau_{2}$
\end_inset

=
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestSF[3], 3)}
\end_layout

\end_inset

.
 The second time constant is significantly greater that that found previously
 for the C-130, but otherwise these are reasonably consistent with the previous
 results.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection

\change_deleted 1311305628 1586285516
The h
\change_inserted 1311305628 1586285521
H
\change_unchanged
eated sensors
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<SOCrf08, include=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DS <- getNetCDF('/Data/SOCRATES/SOCRATESrf08h.nc', 
\end_layout

\begin_layout Plain Layout

        standardVariables(c('ATF1', 'ATH1', 'ATH2', 'RTF1', 'RTH1', 'RTH2')),
\end_layout

\begin_layout Plain Layout

        45600, 50100)
\end_layout

\begin_layout Plain Layout

DS$TASX <- SmoothInterp(DS$TASX, .Length=0)
\end_layout

\begin_layout Plain Layout

DS$Q <- DS$TASX^2 / 2010
\end_layout

\begin_layout Plain Layout

DS$ATX <- DS$ATF1
\end_layout

\begin_layout Plain Layout

DS$AT <- reviseDH(DS, ParamSF, 0.985)
\end_layout

\begin_layout Plain Layout

DS$AT <- SmoothInterp(DS$AT, .Length=0)
\end_layout

\begin_layout Plain Layout

## Small time adjustment seems useful?
\end_layout

\begin_layout Plain Layout

# DS$Q <- ShiftInTime(DS$Q, .shift=-25, .rate=25)
\end_layout

\begin_layout Plain Layout

DS <- DS %>% selectTime(45600, 50100)
\end_layout

\begin_layout Plain Layout

DS$RHOCP <- 100 * DS$PSXC / (287.05 * 278) * 1005
\end_layout

\begin_layout Plain Layout

DS$RHOCP <- SmoothInterp(DS$RHOCP, .Length=0)
\end_layout

\begin_layout Plain Layout

SB <- 50
\end_layout

\begin_layout Plain Layout

Z <- capture.output (Vr <- SmoothInterp(detrend (DS[, c('Time', 'RTH1')]),
 .Length=0))
\end_layout

\begin_layout Plain Layout

Z <- capture.output (VrB <- SmoothInterp(detrend (DS[, c('Time', 'RTH2')]),
 .Length=0))
\end_layout

\begin_layout Plain Layout

Z <- capture.output (VrF <- SmoothInterp(detrend (DS[, c('Time', 'RTF1')]),
 .Length=0))
\end_layout

\begin_layout Plain Layout

Z <- capture.output (VrC <- SmoothInterp(detrend (DS[, c('Time', 'Q')]),
 .Length=0))
\end_layout

\begin_layout Plain Layout

Rate <- attr(DS, 'Rate')
\end_layout

\begin_layout Plain Layout

vcv <- cbind(ts(Vr, frequency=Rate), ts(VrC, frequency=Rate))
\end_layout

\begin_layout Plain Layout

P <- spec.pgram(vcv, detrend=FALSE, fast=TRUE, plot=FALSE, spans=25)
\end_layout

\begin_layout Plain Layout

vcv <- cbind(ts(VrB, frequency=Rate), ts(VrC, frequency=Rate))
\end_layout

\begin_layout Plain Layout

PB <- spec.pgram(vcv, detrend=FALSE, fast=TRUE, plot=FALSE, spans=25)
\end_layout

\begin_layout Plain Layout

vcv <- cbind(ts(VrF, frequency=Rate), ts(VrC, frequency=Rate))
\end_layout

\begin_layout Plain Layout

PF <- spec.pgram(vcv, detrend=FALSE, fast=TRUE, plot=FALSE, spans=25)
\end_layout

\begin_layout Plain Layout

dfHS <- data.frame(P$coh, log(P$freq))
\end_layout

\begin_layout Plain Layout

dfHSB <- data.frame(PB$coh, log(PB$freq))
\end_layout

\begin_layout Plain Layout

dfHSF <- data.frame(PF$coh, log(PF$freq))
\end_layout

\begin_layout Plain Layout

pfHS <- binStats (dfHS, bins=SB)
\end_layout

\begin_layout Plain Layout

RXHS <- CohP(DS, 'RTH1', 'Q', plotType='Ranadu', smoothBins=SB)
\end_layout

\begin_layout Plain Layout

pfHSB <- binStats (dfHSB, bins=SB)
\end_layout

\begin_layout Plain Layout

RXHSB <- CohP(DS, 'RTH2', 'Q', plotType='Ranadu', smoothBins=SB)
\end_layout

\begin_layout Plain Layout

pfHSF <- binStats (dfHSF, bins=SB)
\end_layout

\begin_layout Plain Layout

RXHSF <- CohP(DS, 'RTF1', 'Q', plotType='Ranadu', smoothBins=SB)
\end_layout

\begin_layout Plain Layout

phaseHS <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

nphaseHS <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

phase2HS <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

arHS <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

ar2HS <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

narHS <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

RXHS$P.spec...1.[RXHS$P.spec...1.
 < 0] <- 0
\end_layout

\begin_layout Plain Layout

phaseHSB <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

nphaseHSB <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

phase2HSB <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

arHSB <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

ar2HSB <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

narHSB <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

RXHSB$P.spec...1.[RXHSB$P.spec...1.
 < 0] <- 0
\end_layout

\begin_layout Plain Layout

phaseHSF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

nphaseHSF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

phase2HSF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

arHSF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

ar2HSF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

narHSF <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

RXHSF$P.spec...1.[RXHSF$P.spec...1.
 < 0] <- 0
\end_layout

\begin_layout Plain Layout

for (i in 2:nrow(RXHS)) {
\end_layout

\begin_layout Plain Layout

  phaseHS[RXHS$BIN.1[i]] <- phaseHS[RXHS$BIN.1[i]]+RXHS$P.phase[i]
\end_layout

\begin_layout Plain Layout

  nphaseHS[RXHS$BIN.1[i]] <- nphaseHS[RXHS$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

  phase2HS[RXHS$BIN.1[i]] <- phase2HS[RXHS$BIN.1[i]]+RXHS$P.phase[i]^2 
\end_layout

\begin_layout Plain Layout

  arHS[RXHS$BIN.1[i]] <- arHS[RXHS$BIN.1[i]] + 
\end_layout

\begin_layout Plain Layout

             sqrt(RXHS$P.spec...1.[i] / RXHS$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

  ar2HS[RXHS$BIN.1[i]] <- ar2HS[RXHS$BIN.1[i]] + 
\end_layout

\begin_layout Plain Layout

             (RXHS$P.spec...1.[i] / RXHS$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

  narHS[RXHS$BIN.1[i]] <- narHS[RXHS$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

  phaseHSB[RXHSB$BIN.1[i]] <- phaseHSB[RXHSB$BIN.1[i]]+RXHSB$P.phase[i]
\end_layout

\begin_layout Plain Layout

  nphaseHSB[RXHSB$BIN.1[i]] <- nphaseHSB[RXHSB$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

  phase2HSB[RXHSB$BIN.1[i]] <- phase2HSB[RXHSB$BIN.1[i]]+RXHSB$P.phase[i]^2
 
\end_layout

\begin_layout Plain Layout

  arHSB[RXHSB$BIN.1[i]] <- arHSB[RXHSB$BIN.1[i]] + 
\end_layout

\begin_layout Plain Layout

             sqrt(RXHSB$P.spec...1.[i] / RXHSB$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

  ar2HSB[RXHSB$BIN.1[i]] <- ar2HSB[RXHSB$BIN.1[i]] + 
\end_layout

\begin_layout Plain Layout

             (RXHSB$P.spec...1.[i] / RXHSB$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

  narHSB[RXHSB$BIN.1[i]] <- narHSB[RXHSB$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

  phaseHSF[RXHSF$BIN.1[i]] <- phaseHSF[RXHSF$BIN.1[i]]+RXHSF$P.phase[i]
\end_layout

\begin_layout Plain Layout

  nphaseHSF[RXHSF$BIN.1[i]] <- nphaseHSF[RXHSF$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

  phase2HSF[RXHSF$BIN.1[i]] <- phase2HSF[RXHSF$BIN.1[i]]+RXHSF$P.phase[i]^2
 
\end_layout

\begin_layout Plain Layout

  arHSF[RXHSF$BIN.1[i]] <- arHSF[RXHSF$BIN.1[i]] + 
\end_layout

\begin_layout Plain Layout

             sqrt(RXHSF$P.spec...1.[i] / RXHSF$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

  ar2HSF[RXHSF$BIN.1[i]] <- ar2HSF[RXHSF$BIN.1[i]] + 
\end_layout

\begin_layout Plain Layout

             (RXHSF$P.spec...1.[i] / RXHSF$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

  narHSF[RXHSF$BIN.1[i]] <- narHSF[RXHSF$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

narHS[narHS <= 0] <- 1
\end_layout

\begin_layout Plain Layout

nphaseHS[nphaseHS == 0] <- 1
\end_layout

\begin_layout Plain Layout

mphaseHS <- phaseHS/nphaseHS
\end_layout

\begin_layout Plain Layout

mphase2HS <- phase2HS/nphaseHS
\end_layout

\begin_layout Plain Layout

sdpHS <- sqrt(mphase2HS - mphaseHS^2)
\end_layout

\begin_layout Plain Layout

mphaseHS <- mphaseHS * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpHS <- sdpHS * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpHS <- sdpHS * 2 / sqrt(nphaseHS)
\end_layout

\begin_layout Plain Layout

arHS <- arHS / narHS
\end_layout

\begin_layout Plain Layout

ar2HS <- ar2HS / narHS
\end_layout

\begin_layout Plain Layout

b <- ar2HS - arHS^2
\end_layout

\begin_layout Plain Layout

b[near(b, 0)] <- 0
\end_layout

\begin_layout Plain Layout

sdrHS <- sqrt(b)
\end_layout

\begin_layout Plain Layout

sdrHS <- sdrHS * 2 / sqrt(narHS)
\end_layout

\begin_layout Plain Layout

narHSB[narHSB <= 0] <- 1
\end_layout

\begin_layout Plain Layout

nphaseHSB[nphaseHSB == 0] <- 1
\end_layout

\begin_layout Plain Layout

mphaseHSB <- phaseHSB/nphaseHSB
\end_layout

\begin_layout Plain Layout

mphase2HSB <- phase2HSB/nphaseHSB
\end_layout

\begin_layout Plain Layout

sdpHSB <- sqrt(mphase2HSB - mphaseHSB^2)
\end_layout

\begin_layout Plain Layout

mphaseHSB <- mphaseHSB * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpHSB <- sdpHSB * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpHSB <- sdpHSB * 2 / sqrt(nphaseHSB)
\end_layout

\begin_layout Plain Layout

arHSB <- arHSB / narHSB
\end_layout

\begin_layout Plain Layout

ar2HSB <- ar2HSB / narHSB
\end_layout

\begin_layout Plain Layout

b <- ar2HSB - arHSB^2
\end_layout

\begin_layout Plain Layout

b[near(b, 0)] <- 0
\end_layout

\begin_layout Plain Layout

sdrHSB <- sqrt(b)
\end_layout

\begin_layout Plain Layout

sdrHSB <- sdrHSB * 2 / sqrt(narHSB)
\end_layout

\begin_layout Plain Layout

narHSF[narHSF <= 0] <- 1
\end_layout

\begin_layout Plain Layout

nphaseHSF[nphaseHSF == 0] <- 1
\end_layout

\begin_layout Plain Layout

mphaseHSF <- phaseHSF/nphaseHSF
\end_layout

\begin_layout Plain Layout

mphase2HSF <- phase2HSF/nphaseHSF
\end_layout

\begin_layout Plain Layout

sdpHSF <- sqrt(mphase2HSF - mphaseHSF^2)
\end_layout

\begin_layout Plain Layout

mphaseHSF <- mphaseHSF * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpHSF <- sdpHSF * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpHSF <- sdpHSF * 2 / sqrt(nphaseHSF)
\end_layout

\begin_layout Plain Layout

arHSF <- arHSF / narHSF
\end_layout

\begin_layout Plain Layout

ar2HSF <- ar2HSF / narHSF
\end_layout

\begin_layout Plain Layout

b <- ar2HSF - arHSF^2
\end_layout

\begin_layout Plain Layout

b[near(b, 0)] <- 0
\end_layout

\begin_layout Plain Layout

sdrHSF <- sqrt(b)
\end_layout

\begin_layout Plain Layout

sdrHSF <- sdrHSF * 2 / sqrt(narHSF)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Measurements from two slower sensors, a heated Goodrich/Rosemount 102 sensor
 and a similar 
\begin_inset Quotes eld
\end_inset

Harco Model 100009-1 Deiced TAT
\begin_inset Quotes erd
\end_inset

 sensor, have also been evaluated.
 
\change_deleted 1311305628 1586288605
These sensors respond much more slowly than the unheated Rosemount and a
\change_inserted 1311305628 1586288608
A
\change_unchanged
ttempts to use the same three-parameter representation of the transfer function
 relative to dynamic heating led to unsatisfactory fits, so a different
 approach is used here.
 Because the evaluation in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-unheated-Rosemount"
plural "false"
caps "false"
noprefix "false"

\end_inset

 provides a good representation of the unheated Rosemount 102E4AL sensor,
 the measurements from that sensor, corrected as 
\change_inserted 1311305628 1586288634
will be 
\change_unchanged
described in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Correcting-the-Temperature"
plural "false"
caps "false"
noprefix "false"

\end_inset

, were used as the reference for the assumed-correct recovery temperature.
 Then the phase and amplitude ratio were found for the transfer function
 required to produce the heated-probe measurements from the unheated-probe
 measurement
\change_inserted 1311305628 1586285566
s
\change_unchanged
.
 This did not require any assumptions about equations or parameters determining
 the transfer function.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<extraUHR, include=FALSE, echo=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# SB <- 30
\end_layout

\begin_layout Plain Layout

Z <- capture.output (Vr <- SmoothInterp(detrend (DT1[, c('Time', 'TTWH')]),
 .Length=0))
\end_layout

\begin_layout Plain Layout

Z <- capture.output (VrC <- SmoothInterp(detrend (DT1[, c('Time', 'DH')]),
 .Length=0))
\end_layout

\begin_layout Plain Layout

Rate <- attr(DT1, 'Rate')
\end_layout

\begin_layout Plain Layout

vcv <- cbind(ts(Vr, frequency=Rate), ts(VrC, frequency=Rate))
\end_layout

\begin_layout Plain Layout

P <- spec.pgram(vcv, detrend=FALSE, fast=TRUE, plot=FALSE, spans=25)
\end_layout

\begin_layout Plain Layout

df1W <- data.frame(P$coh, log(P$freq))
\end_layout

\begin_layout Plain Layout

pf1W <- binStats (df1W, bins=SB)
\end_layout

\begin_layout Plain Layout

RX1W <- CohP(DT1, 'TTWH', 'RT', plotType='Ranadu', smoothBins=SB)
\end_layout

\begin_layout Plain Layout

RX2W <- CohP(DT2, 'TTWH', 'RT', plotType='Ranadu', smoothBins=SB)
\end_layout

\begin_layout Plain Layout

RX3W <- CohP(DT3, 'TTWH', 'RT', plotType='Ranadu', smoothBins=SB)
\end_layout

\begin_layout Plain Layout

RX4W <- CohP(DT4, 'TTWH', 'RT', plotType='Ranadu', smoothBins=SB)
\end_layout

\begin_layout Plain Layout

RX5W <- CohP(DT5, 'TTWH', 'RT', plotType='Ranadu', smoothBins=SB)
\end_layout

\begin_layout Plain Layout

# RX6W <- CohP(DT6, 'TTWH', 'DH', plotType='Ranadu', smoothBins=SB)
\end_layout

\begin_layout Plain Layout

phaseW <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

nphaseW <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

phase2W <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

arW <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

ar2W <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

narW <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

for (RX in list(RX1W, RX2W, RX3W, RX4W, RX5W)) {
\end_layout

\begin_layout Plain Layout

  for (i in 2:nrow(RX)) {
\end_layout

\begin_layout Plain Layout

    phaseW[RX$BIN.1[i]] <- phaseW[RX$BIN.1[i]]+RX$P.phase[i]
\end_layout

\begin_layout Plain Layout

    nphaseW[RX$BIN.1[i]] <- nphaseW[RX$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

    phase2W[RX$BIN.1[i]] <- phase2W[RX$BIN.1[i]]+RX$P.phase[i]^2 
\end_layout

\begin_layout Plain Layout

    arW[RX$BIN.1[i]] <- arW[RX$BIN.1[i]] + sqrt(RX$P.spec...1.[i] / RX$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

    ar2W[RX$BIN.1[i]] <- ar2W[RX$BIN.1[i]] + (RX$P.spec...1.[i] / RX$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

    narW[RX$BIN.1[i]] <- narW[RX$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

nphaseW[nphaseW == 0] <- 1
\end_layout

\begin_layout Plain Layout

mphaseW <- phaseW/nphaseW
\end_layout

\begin_layout Plain Layout

mphase2W <- phase2W/nphaseW
\end_layout

\begin_layout Plain Layout

sdpW <- sqrt(mphase2W - mphaseW^2)
\end_layout

\begin_layout Plain Layout

mphaseW <- mphaseW * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpW <- sdpW * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpW <- sdpW * 2 / sqrt(nphaseW)
\end_layout

\begin_layout Plain Layout

arW <- arW / narW
\end_layout

\begin_layout Plain Layout

ar2W <- ar2W / narW
\end_layout

\begin_layout Plain Layout

sdrW <- sqrt(ar2W - arW^2)
\end_layout

\begin_layout Plain Layout

sdrW <- sdrW * 2 / sqrt(narW)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The standard HARCO sensor was not flown on the same flight used to study
 the Rosemount sensor in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-unheated-Rosemount"
plural "false"
caps "false"
noprefix "false"

\end_inset

, so a different research flight will be used from the SOCRATES experiment.
 This flight segment was in modest turbulence (with eddy dissipation rate
 of approximately 
\begin_inset Formula $10^{-3}\mathrm{m}^{2}\mathrm{s^{-3}}$
\end_inset

) at low level and with an airspeed variance spectrum reasonably consistent
 with expectations for an inertial sub-range.
 Two sensors producing the measurements RTH1 and RTH1 are enclosed in the
 same housing.
 The characteristics are very similar so both will be evaluated here.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<RTH1Spec, include=
\change_deleted 1311305628 1586288678
TRUE
\change_inserted 1311305628 1586288680
FALSE
\change_unchanged
, echo=FALSE, fig.pos='t', 
\change_inserted 1311305628 1585741260
fig.height=4, 
\change_unchanged
fig.cap='
\change_deleted 1311305628 1585741193
Variance spectrum
\change_inserted 1311305628 1585741877
Spectral variance $P(
\backslash

\backslash
nu)$ weighted by frequency ($
\backslash

\backslash
nu$)
\change_unchanged
 for the recovery temperature measured by 
\change_deleted 1311305628 1585741430
the
\change_inserted 1311305628 1585741430
a
\change_unchanged
 heated 
\change_deleted 1311305628 1585741511
Rosemount 102 sensor (TTWH)
\change_unchanged
 and by 
\change_deleted 1311305628 1585741454
the
\change_inserted 1311305628 1585741454
an
\change_unchanged
 unheated Rosemount sensor
\change_deleted 1311305628 1585741531
 (TTRR)
\change_unchanged
.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585740855

# 
\change_unchanged
g <- VSpec(DT, 'TTWH', spans=99, ylim=c(1.e-6, 1))
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585740858

# 
\change_unchanged
suppressWarnings(print(VSpec(DT, 'TTRR', add=g, spans=99) + theme_WAC(1)))
\change_inserted 1311305628 1585740799

\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585740807

DT$temperature <- DT$TTWH
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585740807

DT %>% select(Time, TASX, temperature, TTRR) %>% 
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585740807

       VSpec(spans=199, VLabel=c('heated', 'unheated'), 
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585740807

             xlim=c(0.03, 12), ylim=c(4.e-7, 0.01), 
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585740807

             method='MEM', poles=100, smoothBins=200) + 
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585740807

  theme_WAC(1)
\change_unchanged

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<tfHR, include=FALSE, eval=FALSE, fig.height=3.6, fig.pos='p', fig.cap='Transfer
 function for the heated Rosemount 102 sensor, based on measurements from
 the NSF/NCAR C-130 in the VOCALS project.
 Because the results showed high variability and inconsistency for frequencies
 above 1 Hz, only results for frequencies below that limit are shown.
 See the text for the fitted equations producing these curves.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

frq <- seq(0.01, 1.1, by=0.01)
\end_layout

\begin_layout Plain Layout

dfAPW <- data.frame('Time' = frq)
\end_layout

\begin_layout Plain Layout

dfAPW$Amp <- cfr[1]+cfr[2]*log(frq)+cfr[3]*log(frq)^3+cfr[4]*log(frq)^5
\end_layout

\begin_layout Plain Layout

dfAPW$Amp[dfAPW$Time < 0.09] <- 1 
\end_layout

\begin_layout Plain Layout

APW <- LTphase(dfAPW$Time, Param2)
\end_layout

\begin_layout Plain Layout

dfAPW$Amp2 <- APW$Amp
\end_layout

\begin_layout Plain Layout

dfAPW$Phase <- cf[1]+cf[2]*log(frq)+cf[3]*log(frq)^2+cf[4]*atan(frq)
\end_layout

\begin_layout Plain Layout

dfAPW$Phase2 <- APW$Phase
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  ggplotWAC(
\end_layout

\begin_layout Plain Layout

    dfAPW,
\end_layout

\begin_layout Plain Layout

    panels = 2,
\end_layout

\begin_layout Plain Layout

    labelP = c('    Amplitude', 'Phase [degrees]'),
\end_layout

\begin_layout Plain Layout

    labelL = c('lfit', '3-par')
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab(bquote('transfer function H(' * nu
 ~ ')'))
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  g + scale_x_log10(
\end_layout

\begin_layout Plain Layout

    breaks = trans_breaks("log10", function(x)
\end_layout

\begin_layout Plain Layout

      10 ^ x, n = 3),
\end_layout

\begin_layout Plain Layout

    labels = trans_format("log10", math_format(expr = 10 ^ .x))
\end_layout

\begin_layout Plain Layout

  ) + xlab('frequency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = 'tb')
\end_layout

\begin_layout Plain Layout

g <- g + theme_WAC(1) + theme(legend.position = c(0.3, 0.65))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<checkH, include=TRUE, fig.cap='The ratio of the spectral amplitude for
 the measurement of recovery temperature ($T_m(t)$) from the heated HARCO
 sensor to that for dynamic heating ($Q$), shown as the plotted data points.
 The green line is the prediction from the transfer function determined
 from the best-fit values matching the phase lag and amplitude ratio between
 these variables.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

g <- ggplot(dfrH, aes(x=frq, y=mrspec))+geom_point()
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab ('amplitude ratio RTH1 / Q')
\end_layout

\begin_layout Plain Layout

g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=1),
\end_layout

\begin_layout Plain Layout

         labels = trans_format("log10", math_format(expr = 10^.x))) + xlab('frequ
ency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = "bt")
\end_layout

\begin_layout Plain Layout

g <- g + geom_errorbar(aes(ymin=mrspec-sdr, ymax=mrspec+sdr), width=0.02)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=HH, aes(x=frq, y=Amp), col='forestgreen')
\end_layout

\begin_layout Plain Layout

suppressWarnings(print(g + ylim(0, 1.05) + theme_WAC(1)))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\change_inserted 1311305628 1586290313
Because these sensors have similar response, only the heated HARCO sensor
 will be presented in detail here.
 A similar analysis has been performed for the heated Rosemount 102 sensor
 and some summary results for that sensor also will be presented.
 The spectral variance for both these measurements has apparent rapid attenuatio
n beginning at about 0.2
\begin_inset space ~
\end_inset

Hz, as shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

\change_inserted 1311305628 1586288764


\backslash
ref{fig:HARCOSpec}
\change_unchanged

\end_layout

\end_inset

, and the response is attenuated seriously above about 1
\begin_inset space ~
\end_inset

Hz.
 
\end_layout

\begin_layout Standard

\change_inserted 1311305628 1586290316
\begin_inset ERT
status open

\begin_layout Plain Layout

\change_inserted 1311305628 1586290453

<<HARCOSpec, include = TRUE, fig.cap='Spectral variance $P(
\backslash

\backslash
nu)$ weighted by frequency ($
\backslash

\backslash
nu$) for the recovery temperature measured by a heated  HARCO and an unheated
 Rosemount sensor.'>>=
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586290341

\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586290508

DCX$temperature <- DCX$RT
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586290812

DCX %>% selectTime(175200, 180200) %>% select(Time, TASX, temperature, RTH1)
 %>%
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586290629

        VSpec(VLabel=c('unheated', 'HARCO'), ylim=c(1.e-6, 0.1)) +
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586291523

        ylab(bquote('spectral variance ' ~ nu * 'P(' * nu * ')')) +    
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586291527

        theme_WAC(1) + theme(legend.position=c(0.7, 0.9))
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586290342

\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586290343

@
\change_unchanged

\end_layout

\end_inset


\end_layout

\begin_layout Standard

\change_deleted 1311305628 1586288207
Measurements from the first five flight segments listed in Table
\begin_inset space ~
\end_inset

1 were used for characterization of the heated Rosemount 102 sensor.
 (The last segment was excluded because some of the measurements from the
 heated sensor were missing.) The spectral variance for the recovery-temperature
 measurement from the heated sensor has apparent rapid attenuation beginning
 at about 0.2
\begin_inset space ~
\end_inset

Hz, as shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:RTH1Spec}
\end_layout

\end_inset

, and the response is attenuated seriously above about 1
\begin_inset space ~
\end_inset

Hz.
 The measured phase lag of the measurement behind the measurement from the
 unheated Rosemount 102E4AL sensor is shown in the bottom panel of Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:phaseG}
\end_layout

\end_inset

 and the corresponding estimate of the gain is shown in the top panel.
 
\change_inserted 1311305628 1586288207

\begin_inset Branch Extra
inverted 0
status open

\begin_layout Standard

\change_inserted 1311305628 1586288207
Measurements from the first five flight segments listed in Table
\begin_inset space ~
\end_inset

1 were used for characterization of the heated Rosemount 102 sensor.
 (The last segment was excluded because some of the measurements from the
 heated sensor were missing.) The spectral variance for the recovery-temperature
 measurement from the heated sensor has apparent rapid attenuation beginning
 at about 0.2
\begin_inset space ~
\end_inset

Hz, as shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

\change_inserted 1311305628 1586288207


\backslash
ref{fig:RTH1Spec}
\end_layout

\end_inset

, and the response is attenuated seriously above about 1
\begin_inset space ~
\end_inset

Hz.
 The measured phase lag of the measurement behind the measurement from the
 unheated Rosemount 102E4AL sensor is shown in the bottom panel of Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

\change_inserted 1311305628 1586288207


\backslash
ref{fig:phaseG}
\end_layout

\end_inset

 and the corresponding estimate of the gain is shown in the top panel.
 
\change_unchanged

\end_layout

\end_inset


\change_unchanged

\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<phaseG, include = 
\change_inserted 1311305628 1586288522
FALSE
\change_deleted 1311305628 1586288519
TRUE
\change_unchanged
, fig.show = 'asis', fig.height = 6, fig.cap = 'The gain (top) and phase (bottom)
 of the transfer function determined for the heated Rosemount 102 sensor
 (variable TTWH) and the recovery temperature obtained by applying transfer-func
tion corrections to the measurments from the unheated Rosemount 102E4AL
 sensor (variable RT).
 Error bars are two-standard-deviation estimates of the uncertainty in the
 mean values shown by plotted circles.
 Because the results showed high variability and inconsistency for frequencies
 above 1 Hz, only results for frequencies below that limit are shown.
 The fits are described in the text.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

dfW <- data.frame(frq=exp(pf1W$xc), mphase=mphaseW, sdp=sdpW)
\end_layout

\begin_layout Plain Layout

dfrW <- data.frame(frq=exp(pf1W$xc), mrspec=arW, sdr=sdrW)
\end_layout

\begin_layout Plain Layout

dfW <- dfW[dfW$frq > 0.01 & dfW$frq <= 1, ]
\end_layout

\begin_layout Plain Layout

dfrW <- dfrW[dfrW$frq > 0.01 & dfrW$frq <= 1, ]
\end_layout

\begin_layout Plain Layout

Param2 <- Param1
\end_layout

\begin_layout Plain Layout

Param2$tau1 <- 0.5
\end_layout

\begin_layout Plain Layout

Param2$tau2 <- 0.8
\end_layout

\begin_layout Plain Layout

minFn <- function(V) {
\end_layout

\begin_layout Plain Layout

  Param2$a <<- V[1]
\end_layout

\begin_layout Plain Layout

  Param2$tau1 <<- V[2]
\end_layout

\begin_layout Plain Layout

  Param2$tau2 <<- V[3]
\end_layout

\begin_layout Plain Layout

  Chisq <- 0
\end_layout

\begin_layout Plain Layout

  for (i in 1:nrow(dfW)) {
\end_layout

\begin_layout Plain Layout

    Chisq <- Chisq + (dfW$mphase[i] - LTphase(dfW$frq[i], Param2)$Phase)^2
 / dfW$sdp[i]^2
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  for (i in 1:nrow(dfrW)) {
\end_layout

\begin_layout Plain Layout

    Chisq <- Chisq + (dfrW$mrspec[i] - LTphase(dfrW$frq[i], Param2)$Amp)^2
 / dfrW$sdr[i]^2
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return (Chisq)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

AW <- optim (c(Param2$a, Param2$tau1, Param2$tau2), minFn, hessian=TRUE)
\end_layout

\begin_layout Plain Layout

bestW <- AW$par
\end_layout

\begin_layout Plain Layout

HerrorW <- solve(AW$hessian / 4)  # factor of 4 because 2-sigma errors were
 used?
\end_layout

\begin_layout Plain Layout

uncLimitsW <- sqrt(diag(HerrorW))
\end_layout

\begin_layout Plain Layout

g <- ggplot(dfW, aes(x=frq, y=mphase))+geom_point()
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab (bquote('
\change_inserted 1311305628 1585692133
phase [' ~ degree * ']'
\change_deleted 1311305628 1585692203
phase TTWH x RT [' * degree * ']'
\change_unchanged
))
\end_layout

\begin_layout Plain Layout

g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=2),
\end_layout

\begin_layout Plain Layout

                       labels = trans_format("log10", math_format(expr =
 10^.x))) + xlab('frequency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = "bt")
\end_layout

\begin_layout Plain Layout

g <- g + geom_errorbar(aes(ymin=mphase-sdp, ymax=mphase+sdp), width=0.05)
\end_layout

\begin_layout Plain Layout

# g <- g + geom_path(data=dfW, aes(x=frq, y=mphase), col='forestgreen')
\end_layout

\begin_layout Plain Layout

cf <- coef(lm(data=dfW, mphase ~ log(frq)+I(log(frq)^2)+I(atan(frq))))
\end_layout

\begin_layout Plain Layout

dfW$Ph <- cf[1]+cf[2]*log(dfW$frq)+cf[3]*log(dfW$frq)^2+cf[4]*atan(dfW$frq)
\end_layout

\begin_layout Plain Layout

dfW$PhLT <- LTphase(dfW$frq, Param2)$Phase
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfW, aes(x=frq, y=Ph, col='lfit', lty='lfit'))
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfW, aes(x=frq, y=PhLT, col='3-par', lty='3-par'))
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  g + scale_colour_manual (
\end_layout

\begin_layout Plain Layout

    name = 'fit: ',
\end_layout

\begin_layout Plain Layout

    values = c("lfit" = "forestgreen", "3-par" = "blue")
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

g <- g + scale_linetype_manual (name = 'fit: ', 
\end_layout

\begin_layout Plain Layout

                                values = c('lfit' = 4, '3-par'=1))
\end_layout

\begin_layout Plain Layout

g1 <- g + theme_WAC(1) + theme(legend.position = c(0.75, 0.9))
\end_layout

\begin_layout Plain Layout

g <- ggplot(dfrW, aes(x=frq, y=mrspec))+geom_point()
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab ('amplitude ratio TTWH / RT')
\end_layout

\begin_layout Plain Layout

g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=2),
\end_layout

\begin_layout Plain Layout

         labels = trans_format("log10", math_format(expr = 10^.x))) + xlab('frequ
ency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = "bt")
\end_layout

\begin_layout Plain Layout

g <- g + geom_errorbar(aes(ymin=mrspec-sdr, ymax=mrspec+sdr), width=0.05)
\end_layout

\begin_layout Plain Layout

# g <- g + geom_path(data=dfAP, aes(x=Time, y=Amp), col='forestgreen')
\end_layout

\begin_layout Plain Layout

# g <- g + geom_path(data=dfr, aes(x=frq, y=Amp5), col='darkorange', lty=2)
\end_layout

\begin_layout Plain Layout

cfr <- coef(lm(data=dfrW[dfrW$frq > 0.07, ], mrspec ~ log(frq) + I(log(frq)^3)
 + 
\end_layout

\begin_layout Plain Layout

               I(log(frq)^5)))
\end_layout

\begin_layout Plain Layout

dfrW$G <- cfr[1]+cfr[2]*log(dfrW$frq)+cfr[3]*log(dfrW$frq)^3+cfr[4]*log(dfrW$frq
)^5
\end_layout

\begin_layout Plain Layout

dfrW$G[dfrW$frq < 0.08] <- 1
\end_layout

\begin_layout Plain Layout

dfrW$GLT <- LTphase(dfrW$frq, Param2)$Amp
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfrW, aes(x=frq, y=G, col='lfit', lty='lfit'))
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfrW, aes(x=frq, y=GLT, col='3-par', lty='3-par'))
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  g + scale_colour_manual (
\end_layout

\begin_layout Plain Layout

    name = 'fit: ',
\end_layout

\begin_layout Plain Layout

    values = c("lfit" = "forestgreen", "3-par" = "blue")
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

g <- g + scale_linetype_manual (name = 'fit: ', 
\end_layout

\begin_layout Plain Layout

                                values = c('lfit' = 4, '3-par'=1))
\end_layout

\begin_layout Plain Layout

g2 <- g + ylim(0, 1.2) + theme_WAC(1) + theme(legend.position = c(0.75, 0.9))
\end_layout

\begin_layout Plain Layout

# suppressWarnings(print(g + ylim(0, 1.2) + theme_WAC(1) + 
\end_layout

\begin_layout Plain Layout

#                        theme(legend.position = c(0.75, 0.9))))
\end_layout

\begin_layout Plain Layout

g2 <- g2 + theme(plot.margin=unit(c(0.5,0.3,1.1,1.8),"lines"))  ## small adjustment
 for alignment
\end_layout

\begin_layout Plain Layout

grid.newpage()
\end_layout

\begin_layout Plain Layout

vp2 <- viewport(y=unit(0.61, 'npc'), height=unit(0.5, 'npc'),layout.pos.row=2)
\end_layout

\begin_layout Plain Layout

vp1 <- viewport(y=unit(0.25, 'npc'), height=unit(0.5, 'npc'),layout.pos.row=1)
\end_layout

\begin_layout Plain Layout

print(g2, vp=vp2)
\end_layout

\begin_layout Plain Layout

print(g1, vp=vp1)
\end_layout

\begin_layout Plain Layout

grid.newpage()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\change_inserted 1311305628 1586288841
\begin_inset Branch Extra
inverted 0
status open

\begin_layout Standard

\change_inserted 1311305628 1586288841
No combination of the three fit parameters {
\begin_inset Formula $a,\,\tau_{1},\,\tau_{2}$
\end_inset

} entering the transfer-function equations 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:responseAmp"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:responsePhase"
plural "false"
caps "false"
noprefix "false"

\end_inset

 provides a satisfactory representation of the measurements in those two
 plots, although the best fit (shown as the 
\begin_inset Quotes eld
\end_inset

3-par
\begin_inset Quotes erd
\end_inset

 line) for the values {
\begin_inset ERT
status open

\begin_layout Plain Layout

\change_inserted 1311305628 1586288841


\backslash
Sexpr{round(bestW[1], 2)}
\end_layout

\end_inset

,
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

\change_inserted 1311305628 1586288841


\backslash
Sexpr{round(bestW[2], 2)}
\end_layout

\end_inset

,
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

\change_inserted 1311305628 1586288841


\backslash
Sexpr{round(bestW[3], 2)}
\end_layout

\end_inset

} provides a fair approximation.
 Those figures show that the fit is inadequate (chisquare of over 16,000
 for 40 degrees of freedom) so it appears that for this sensor heat transfer
 is still more complicated than can be represented by the differential equations
 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

, perhaps because there are other paths by which heat can be transferred
 to or from the sensing wire.
 The small value for the parameter 
\begin_inset Formula $a$
\end_inset

 suggests that most of the heat transferred to or from the wire is through
 routes other than direct conduction from the air.
 
\end_layout

\begin_layout Standard

\change_inserted 1311305628 1586288841
Rather than seeking a more complicated representation of the transfer function,
 it can be represented instead by the lines in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

\change_inserted 1311305628 1586288841


\backslash
ref{fig:phaseG}
\end_layout

\end_inset

 labeled 
\begin_inset Quotes eld
\end_inset

lfit
\begin_inset Quotes erd
\end_inset

, fits to the measurements in terms of 
\begin_inset Formula $x=\log_{e}(\nu/\nu_{0})$
\end_inset

 where 
\begin_inset Formula $\nu=\omega/(2\pi)$
\end_inset

 is the frequency and 
\begin_inset Formula $\nu_{0}=1\,\mathrm{Hz}$
\end_inset

:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\mathrm{for}\,\nu>0.08\,\mathrm{Hz,\,\,}H(\omega)=(h_{0}+h_{1}x+h_{2}x^{3}+h_{3}x^{5}+h_{3}\arctan(\nu/\nu_{0}))e^{i\phi(\omega)}\label{eq:lfitR}
\end{equation}

\end_inset


\begin_inset Formula 
\[
\mathrm{for\:\nu\leq0.08\,\mathrm{Hz},\quad}H(\omega)=1
\]

\end_inset


\begin_inset Formula 
\[
\phi(\omega)=p_{0}+p_{1}x+p_{2}x^{2}+p_{3}\arctan(\nu/\nu_{0})
\]

\end_inset

The coefficients obtained by fitting to the observations are 
\begin_inset Formula $h_{0-3}=$
\end_inset

{
\begin_inset ERT
status open

\begin_layout Plain Layout

\change_inserted 1311305628 1586288841

$
\backslash
Sexpr{round(cfr[1], 3)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

\change_inserted 1311305628 1586288841

$
\backslash
Sexpr{round(cfr[2], 3)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

\change_inserted 1311305628 1586288841

$
\backslash
Sexpr{round(cfr[3], 4)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

\change_inserted 1311305628 1586288841

$
\backslash
Sexpr{round(cfr[4], 5)}$
\end_layout

\end_inset

} and 
\begin_inset Formula $p_{0-3}=$
\end_inset

{
\begin_inset ERT
status open

\begin_layout Plain Layout

\change_inserted 1311305628 1586288841

$
\backslash
Sexpr{round(cf[1], 1)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

\change_inserted 1311305628 1586288841

$
\backslash
Sexpr{format(cf[2], digits=1, nsmall=1)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

\change_inserted 1311305628 1586288841

$
\backslash
Sexpr{format(cf[3], digits=2, nsmall=2)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

\change_inserted 1311305628 1586288841

$
\backslash
Sexpr{round(cf[4], 1)}$
\end_layout

\end_inset

}.
 These equations are the basis for the 
\begin_inset Quotes eld
\end_inset

lfit
\begin_inset Quotes erd
\end_inset

 lines plotted in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

\change_inserted 1311305628 1586288841


\backslash
ref{fig:phaseG}
\end_layout

\end_inset

.
 For negative frequencies, the values of 
\begin_inset Formula $H(\omega)$
\end_inset

 are the complex conjugate of the values listed above.
\change_unchanged

\end_layout

\end_inset


\change_deleted 1311305628 1586288841
No combination of the three fit parameters {
\begin_inset Formula $a,\,\tau_{1},\,\tau_{2}$
\end_inset

} entering the transfer-function equations 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:responseAmp"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:responsePhase"
plural "false"
caps "false"
noprefix "false"

\end_inset

 provides a satisfactory representation of the measurements in those two
 plots, although the best fit (shown as the 
\begin_inset Quotes eld
\end_inset

3-par
\begin_inset Quotes erd
\end_inset

 line) for the values {
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestW[1], 2)}
\end_layout

\end_inset

,
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestW[2], 2)}
\end_layout

\end_inset

,
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestW[3], 2)}
\end_layout

\end_inset

} provides a fair approximation.
 Those figures show that the fit is inadequate (chisquare of over 16,000
 for 40 degrees of freedom) so it appears that for this sensor heat transfer
 is still more complicated than can be represented by the differential equations
 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

, perhaps because there are other paths by which heat can be transferred
 to or from the sensing wire.
 The small value for the parameter 
\begin_inset Formula $a$
\end_inset

 suggests that most of the heat transferred to or from the wire is through
 routes other than direct conduction from the air.
 
\end_layout

\begin_layout Standard

\change_deleted 1311305628 1586288841
Rather than seeking a more complicated representation of the transfer function,
 it can be represented instead by the lines in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:phaseG}
\end_layout

\end_inset

 labeled 
\begin_inset Quotes eld
\end_inset

lfit
\begin_inset Quotes erd
\end_inset

, fits to the measurements in terms of 
\begin_inset Formula $x=\log_{e}(\nu/\nu_{0})$
\end_inset

 where 
\begin_inset Formula $\nu=\omega/(2\pi)$
\end_inset

 is the frequency and 
\begin_inset Formula $\nu_{0}=1\,\mathrm{Hz}$
\end_inset

:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\mathrm{for}\,\nu>0.08\,\mathrm{Hz,\,\,}H(\omega)=(h_{0}+h_{1}x+h_{2}x^{3}+h_{3}x^{5}+h_{3}\arctan(\nu/\nu_{0}))e^{i\phi(\omega)}\label{eq:lfitR}
\end{equation}

\end_inset


\begin_inset Formula 
\[
\mathrm{for\:\nu\leq0.08\,\mathrm{Hz},\quad}H(\omega)=1
\]

\end_inset


\begin_inset Formula 
\[
\phi(\omega)=p_{0}+p_{1}x+p_{2}x^{2}+p_{3}\arctan(\nu/\nu_{0})
\]

\end_inset

The coefficients obtained by fitting to the observations are 
\begin_inset Formula $h_{0-3}=$
\end_inset

{
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{round(cfr[1], 3)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{round(cfr[2], 3)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{round(cfr[3], 4)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{round(cfr[4], 5)}$
\end_layout

\end_inset

} and 
\begin_inset Formula $p_{0-3}=$
\end_inset

{
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{round(cf[1], 1)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{format(cf[2], digits=1, nsmall=1)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{format(cf[3], digits=2, nsmall=2)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{round(cf[4], 1)}$
\end_layout

\end_inset

}.
 These equations are the basis for the 
\begin_inset Quotes eld
\end_inset

lfit
\begin_inset Quotes erd
\end_inset

 lines plotted in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:phaseG}
\end_layout

\end_inset

.
 
\change_inserted 1311305628 1585747305

\end_layout

\begin_layout Standard

\change_deleted 1311305628 1586291688
The reason that the three-parameter fit is unacceptable is that there is
 conflict between the constraints imposed by the amplitude ratio and the
 phase, such that either could be represented reasonably but not both.
 The actual transfer function has some complex features, including frequencies
 where the phase shift reaches values below 
\begin_inset Formula $-90^{\circ}$
\end_inset

 (not possible for a simple exponential time response) and values of the
 phase shift of about 
\begin_inset Formula $-36^{\circ}$
\end_inset

 at 0.1
\begin_inset space ~
\end_inset

Hz where the amplitude ratio remains near unity.
 The amplitude decreases to 
\begin_inset Formula $e^{-1}$
\end_inset

 at about 0.4
\begin_inset space ~
\end_inset

Hz, as would be the case for a first-order time constant of about 1
\begin_inset space ~
\end_inset

s, so this could be considered another measure of the response.
 However, that value does not extrapolate well to other frequencies and
 the phase shift at 0.4
\begin_inset space ~
\end_inset

Hz is approximately 
\begin_inset Formula $-90^{\circ}$
\end_inset

, which would indicate that the measurement of a real contribution to sensible-h
eat flux at this frequency would be zero.
\change_inserted 1311305628 1586291688

\begin_inset Branch Extra
inverted 0
status open

\begin_layout Standard

\change_inserted 1311305628 1586291688
The reason that the three-parameter fit is unacceptable is that there is
 conflict between the constraints imposed by the amplitude ratio and the
 phase, such that either could be represented reasonably but not both.
 The actual transfer function has some complex features, including frequencies
 where the phase shift reaches values below 
\begin_inset Formula $-90^{\circ}$
\end_inset

 (not possible for a simple exponential time response) and values of the
 phase shift of about 
\begin_inset Formula $-36^{\circ}$
\end_inset

 at 0.1
\begin_inset space ~
\end_inset

Hz where the amplitude ratio remains near unity.
 The amplitude decreases to 
\begin_inset Formula $e^{-1}$
\end_inset

 at about 0.4
\begin_inset space ~
\end_inset

Hz, as would be the case for a first-order time constant of about 1
\begin_inset space ~
\end_inset

s, so this could be considered another measure of the response.
 However, that value does not extrapolate well to other frequencies and
 the phase shift at 0.4
\begin_inset space ~
\end_inset

Hz is approximately 
\begin_inset Formula $-90^{\circ}$
\end_inset

, which would indicate that the measurement of a real contribution to sensible-h
eat flux at this frequency would be zero.
\change_unchanged

\end_layout

\end_inset


\change_unchanged

\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard

\change_inserted 1311305628 1586291741
To characterize the response of the 
\change_deleted 1311305628 1586289289
The 
\change_unchanged
heated HARCO sensor
\change_inserted 1311305628 1586289293
,
\change_unchanged
 
\change_deleted 1311305628 1586289305
was not flown on the same flights used to study the heated Rosemount 102
 sensor, so 
\change_inserted 1311305628 1586291852
boundary-layer 
\change_unchanged
flight segments from the SOCRATES and CSET projects
\change_inserted 1311305628 1586289380
 (referenced earlier in connection with the unheated probe)
\change_deleted 1311305628 1586289389
, listed in Table 2,
\change_unchanged
 were 
\change_inserted 1311305628 1586289457
compiled into one data set from the flight periods shown in Table
\begin_inset space ~
\end_inset

2.
\change_deleted 1311305628 1586289354
used for the HARCO sensor.

\change_unchanged
 
\change_inserted 1311305628 1586289587
An unheated Rosemount 102E4AL sensor was also available, so corrected measuremen
ts from that sensor were used as the reference against which to determine
 the gain and phase of the transfer function.
\change_unchanged

\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Project/Flight
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
start [UTC]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
end[UTC]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CSET/rf05
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2015-07-14 17:52:00
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
18:02:00
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CSET/rf05
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2015-07-14 19:45:30
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
19:55:30
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CSET/rf05
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2015-07-14 20:37:17
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20:47:17
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SOCRATES/rf15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2018-02-24 5:52:00
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6:02:00
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SOCRATES/rf15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2018-02-24 6:05:00
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6:15:00
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Flight segments used to determine the response characteristics of a heated
 HARCO sensor.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<GVHARCO, include = TRUE, fig.height = 6, fig.show='asis', fig.cap = 'The
 gain (top) and phase (bottom) for the transfer function characterizing
 a heated HARCO temperature sensor.
 The measurements are indicated by error bars that show two-standard-deviation
 limits from the mean value).
 Two fits to the measurements, one based on the three-parameter representation
 and one on a polynomial fit, are described in the text.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SB <- 50
\end_layout

\begin_layout Plain Layout

RXA <- DSX %>% selectTime(55200, 60200) %>% CohP('RTH1', 'RT', plotType='Ranadu'
, smoothBins=SB)
\end_layout

\begin_layout Plain Layout

RXB <- DSX %>% selectTime(60500, 61500) %>% CohP('RTH1', 'RT', plotType='Ranadu'
, smoothBins=SB)
\end_layout

\begin_layout Plain Layout

RXC <- DCX %>% selectTime(175200, 180200) %>% CohP('RTH1', 'RT', plotType='Ranad
u', smoothBins=SB)
\end_layout

\begin_layout Plain Layout

RXD <- DCX %>% selectTime(194530, 195530) %>% CohP('RTH1', 'RT', plotType='Ranad
u', smoothBins=SB)
\end_layout

\begin_layout Plain Layout

RXE <- DCX %>% selectTime(203717, 204717) %>% CohP('RTH1', 'RT', plotType='Ranad
u', smoothBins=SB)
\end_layout

\begin_layout Plain Layout

## May need to revise this with corrected RT in second iteration
\end_layout

\begin_layout Plain Layout

Z <- capture.output (Vr <- SmoothInterp(detrend (DSA[, c('Time', 'RTH1')]),
 .Length=0))
\end_layout

\begin_layout Plain Layout

Z <- capture.output (VrC <- SmoothInterp(detrend (DSA[, c('Time', 'RT')]),
 .Length=0))
\end_layout

\begin_layout Plain Layout

Rate <- attr(DSA, 'Rate')
\end_layout

\begin_layout Plain Layout

vcv <- cbind(ts(Vr, frequency=Rate), ts(VrC, frequency=Rate))
\end_layout

\begin_layout Plain Layout

P <- spec.pgram(vcv, detrend=FALSE, fast=TRUE, plot=FALSE, spans=25)
\end_layout

\begin_layout Plain Layout

df1SH <- data.frame(P$coh, log(P$freq))
\end_layout

\begin_layout Plain Layout

df2SH <- data.frame (P$phase, log(P$freq))
\end_layout

\begin_layout Plain Layout

pf1SH <- binStats (df1SH, bins=SB)
\end_layout

\begin_layout Plain Layout

pf2SH <- binStats (df2SH, bins=SB)
\end_layout

\begin_layout Plain Layout

phaseSH <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

nphaseSH <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

phase2SH <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

arSH <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

ar2SH <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

narSH <- rep(0, SB)
\end_layout

\begin_layout Plain Layout

for (RX in list(RXA, RXB, RXC, RXD, RXE)) {
\end_layout

\begin_layout Plain Layout

  for (i in 2:nrow(RX)) {
\end_layout

\begin_layout Plain Layout

    phaseSH[RX$BIN.1[i]] <- phaseSH[RX$BIN.1[i]] + RX$P.phase[i]
\end_layout

\begin_layout Plain Layout

    nphaseSH[RX$BIN.1[i]] <- nphaseSH[RX$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

    phase2SH[RX$BIN.1[i]] <- phase2SH[RX$BIN.1[i]] + RX$P.phase[i]^2
\end_layout

\begin_layout Plain Layout

    arSH[RX$BIN.1[i]] <- arSH[RX$BIN.1[i]] + sqrt(RX$P.spec...1.[i] / RX$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

    ar2SH[RX$BIN.1[i]] <- ar2SH[RX$BIN.1[i]] + (RX$P.spec...1.[i] / RX$P.spec...2.[i])
\end_layout

\begin_layout Plain Layout

    narSH[RX$BIN.1[i]] <- narSH[RX$BIN.1[i]] + 1
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

nphaseSH[nphaseSH == 0] <- 1
\end_layout

\begin_layout Plain Layout

narSH[narSH == 0] <- 1
\end_layout

\begin_layout Plain Layout

mphaseSH <- phaseSH/nphaseSH
\end_layout

\begin_layout Plain Layout

mphase2SH <- phase2SH/nphaseSH
\end_layout

\begin_layout Plain Layout

sdpSH <- sqrt(mphase2SH - mphaseSH^2)
\end_layout

\begin_layout Plain Layout

mphaseSH <- mphaseSH * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpSH <- sdpSH * 180 / pi
\end_layout

\begin_layout Plain Layout

sdpSH <- sdpSH * 2 / sqrt(nphaseSH)
\end_layout

\begin_layout Plain Layout

arSH <- arSH / narSH
\end_layout

\begin_layout Plain Layout

ar2SH <- ar2SH / narSH
\end_layout

\begin_layout Plain Layout

b <- ar2SH - arSH^2
\end_layout

\begin_layout Plain Layout

b[near(b, 0)] <- 0
\end_layout

\begin_layout Plain Layout

sdrSH <- sqrt(b)
\end_layout

\begin_layout Plain Layout

sdrSH <- sdrSH * 2 / sqrt(narSH)
\end_layout

\begin_layout Plain Layout

dfSH <- data.frame(frq=exp(pf2SH$xc), mphase=mphaseSH, sdp=sdpSH)
\end_layout

\begin_layout Plain Layout

dfSH <- dfSH[dfSH$frq > 0.01, ]
\end_layout

\begin_layout Plain Layout

dfSH <- dfSH[dfSH$sdp > 0, ]
\end_layout

\begin_layout Plain Layout

dfSH <- dfSH[dfSH$frq < 2, ]
\end_layout

\begin_layout Plain Layout

dfrSH <- data.frame(frq=exp(pf2SH$xc), mrspec=arSH, sdr=sdrSH)
\end_layout

\begin_layout Plain Layout

dfrSH <- dfrSH[dfrSH$frq > 0.01, ]
\end_layout

\begin_layout Plain Layout

dfrSH <- dfrSH[dfrSH$sdr > 0, ]
\end_layout

\begin_layout Plain Layout

dfrSH <- dfrSH[dfrSH$frq < 2, ]
\end_layout

\begin_layout Plain Layout

frq <- exp(pf2SH$xc)
\end_layout

\begin_layout Plain Layout

Parm <- Param1
\end_layout

\begin_layout Plain Layout

Parm$a <- 0.1
\end_layout

\begin_layout Plain Layout

Parm$tau1 <- 0.1
\end_layout

\begin_layout Plain Layout

Parm$tau2 <- 1.5
\end_layout

\begin_layout Plain Layout

minFn <- function(V) {
\end_layout

\begin_layout Plain Layout

  Parm$a <<- V[1]
\end_layout

\begin_layout Plain Layout

  Parm$tau1 <<- V[2]
\end_layout

\begin_layout Plain Layout

  Parm$tau2 <<- V[3]
\end_layout

\begin_layout Plain Layout

  Chisq <- 0
\end_layout

\begin_layout Plain Layout

  for (i in 1:nrow(dfSH)) {
\end_layout

\begin_layout Plain Layout

    Chisq <- Chisq + (dfSH$mphase[i] - LTphase(dfSH$frq[i], Parm)$Phase)^2
 / dfSH$sdp[i]^2
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  for (i in 1:nrow(dfrSH)) {
\end_layout

\begin_layout Plain Layout

    Chisq <- Chisq + (dfrSH$mrspec[i] - LTphase(dfrSH$frq[i], Parm)$Amp)^2
 / dfrSH$sdr[i]^2
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return (Chisq)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

ASH <- optim (c(Parm$a, Parm$tau1, Parm$tau2), minFn, method='L-BFGS-B',
 
\end_layout

\begin_layout Plain Layout

              lower=0, hessian=TRUE)
\end_layout

\begin_layout Plain Layout

bestSH <- ASH$par
\end_layout

\begin_layout Plain Layout

HerrorSH <- solve(ASH$hessian / 4)  # factor of 4 because 2-sigma errors
 were used?
\end_layout

\begin_layout Plain Layout

uncLimitsSH <- sqrt(diag(HerrorSH))
\end_layout

\begin_layout Plain Layout

# print(bestSH)
\end_layout

\begin_layout Plain Layout

HSH <- LTphase(dfrSH$frq, Parm)
\end_layout

\begin_layout Plain Layout

dfrSH$Amp <- HSH$Amp
\end_layout

\begin_layout Plain Layout

dfrSH$Phase <- HSH$Phase
\end_layout

\begin_layout Plain Layout

ParamSH <- Param2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

g <- ggplot(dfSH, aes(x=frq, y=mphase))+geom_point()
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab ('phase RTH1 x RT [degrees]')
\end_layout

\begin_layout Plain Layout

g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=2),
\end_layout

\begin_layout Plain Layout

                       labels = trans_format("log10", math_format(expr =
 10^.x))) + xlab('frequency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = "bt")
\end_layout

\begin_layout Plain Layout

g <- g + geom_errorbar(aes(ymin=mphase-sdp, ymax=mphase+sdp), width=0.06)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfrSH, aes(x=frq, y=Phase), col='forestgreen')
\end_layout

\begin_layout Plain Layout

cf <- coef(lm(data=dfSH, mphase ~ log(frq)+I(log(frq)^2)+I(atan(frq))))
\end_layout

\begin_layout Plain Layout

dfSH$Ph <- cf[1]+cf[2]*log(dfSH$frq) 
\change_inserted 1311305628 1585750140
+
\change_unchanged
 cf[3]*log(dfSH$frq)^2 + 
\end_layout

\begin_layout Plain Layout

           cf[4]*atan(dfSH$frq)
\end_layout

\begin_layout Plain Layout

dfSH$PhLT <- LTphase(dfSH$frq, Parm)$Phase
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfSH, aes(x=frq, y=Ph, col='lfit', lty='lfit'))
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfSH, aes(x=frq, y=PhLT, col='3-par', lty='3-par'))
\end_layout

\begin_layout Plain Layout

# g <- g + geom_path(data=dfAPSH, aes(x=Time, y=Phase), col='darkorange')
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  g + scale_colour_manual (
\end_layout

\begin_layout Plain Layout

    name = 'fit: ',
\end_layout

\begin_layout Plain Layout

    values = c("lfit" = "forestgreen", "3-par" = "blue")
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

g <- g + scale_linetype_manual (name = 'fit: ', 
\end_layout

\begin_layout Plain Layout

                                values = c('lfit' = 4, '3-par'=1))
\end_layout

\begin_layout Plain Layout

g1 <- g + theme_WAC(1) + theme(legend.position = c(0.75, 0.9))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

frq <- exp(pf2SH$xc[narSH > 0])
\end_layout

\begin_layout Plain Layout

g <- ggplot(dfrSH, aes(x=frq, y=mrspec))+geom_point()
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab ('amplitude ratio RTH1 / RT')
\end_layout

\begin_layout Plain Layout

g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=2),
\end_layout

\begin_layout Plain Layout

                       labels = trans_format("log10", math_format(expr =
 10^.x))) + xlab('frequency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = "bt")
\end_layout

\begin_layout Plain Layout

g <- g + geom_errorbar(aes(ymin=mrspec-sdr, ymax=mrspec+sdr), width=0.06)
\end_layout

\begin_layout Plain Layout

# g <- g + geom_path(data=dfAPSH, aes(x=Time, y=Amp), col='darkorange')
\end_layout

\begin_layout Plain Layout

cfr <- coef(lm(data=dfrSH, mrspec ~ log(frq) + I(log(frq)^3) + 
\end_layout

\begin_layout Plain Layout

               I(log(frq)^5)))
\end_layout

\begin_layout Plain Layout

cfr <- coef(lm(data=dfrSH, mrspec ~ log(frq) + I(log(frq)^3) +
\end_layout

\begin_layout Plain Layout

            I(log(frq)^4)+I(log(frq)^5)))
\end_layout

\begin_layout Plain Layout

fr <- log(dfrSH$frq)
\end_layout

\begin_layout Plain Layout

dfrSH$G <- cfr[1] + fr * (cfr[2] + fr * fr * (cfr[3] + fr * (cfr[4] + 
\change_inserted 1311305628 1585749535

\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585749542

                     
\change_unchanged
fr * cfr[5])))
\end_layout

\begin_layout Plain Layout

dfrSH$G[dfrSH$frq < 0.024] <- 1
\end_layout

\begin_layout Plain Layout

dfrSH$GLT <- LTphase(dfrSH$frq, Parm)$Amp
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfrSH, aes(x=frq, y=G, col='lfit', lty='lfit'))
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(data=dfrSH, aes(x=frq, y=GLT, col='3-par', lty='3-par'))
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  g + scale_colour_manual (
\end_layout

\begin_layout Plain Layout

    name = 'fit: ',
\end_layout

\begin_layout Plain Layout

    values = c("lfit" = "forestgreen", "3-par" = "blue")
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

g <- g + scale_linetype_manual (name = 'fit: ', 
\end_layout

\begin_layout Plain Layout

                                values = c('lfit' = 4, '3-par'=1))
\end_layout

\begin_layout Plain Layout

g2 <- g + ylim(0, 1.3) + theme_WAC(1) + theme(legend.position = c(0.75, 0.9))
\end_layout

\begin_layout Plain Layout

g2 <- g2 + theme(plot.margin=unit(c(0.3,0.3,1.1,2.0),"lines"))  ## small adjustment
 for alignment
\end_layout

\begin_layout Plain Layout

grid.newpage()
\end_layout

\begin_layout Plain Layout

vp2 <- viewport(y=unit(0.61, 'npc'), height=unit(0.5, 'npc'),layout.pos.row=2)
\end_layout

\begin_layout Plain Layout

vp1 <- viewport(y=unit(0.25, 'npc'), height=unit(0.5, 'npc'),layout.pos.row=1)
\end_layout

\begin_layout Plain Layout

print(g2, vp=vp2)
\end_layout

\begin_layout Plain Layout

print(g1, vp=vp1)
\end_layout

\begin_layout Plain Layout

grid.newpage()
\end_layout

\begin_layout Plain Layout

# suppressWarnings(print(g + ylim(0, 1.3) + theme(legend.position = c(0.75,
 0.9)) + theme_WAC(1)))
\end_layout

\begin_layout Plain Layout

# CohPhase(DSA, 'RTH1', 'RTF1')
\end_layout

\begin_layout Plain Layout

# DSA %>% select(Time, TASX, RTH1, RT, ATH1) %>% VSpec()
\end_layout

\begin_layout Plain Layout

# print(bestSH)
\end_layout

\begin_layout Plain Layout

## Save for later use:
\end_layout

\begin_layout Plain Layout

cfHARCO <- cf
\end_layout

\begin_layout Plain Layout

cfrHARCO <- cfr
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\change_deleted 1311305628 1586291824
Flight segments were all at low level and in boundary-layer conditions and
 were of equal duration to facilitate averaging of the variance spectra.
 
\change_unchanged
The measured phase and amplitude ratio for this data set are shown in Figs.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:GVHARCO}
\end_layout

\end_inset

.
 The 
\change_deleted 1311305628 1586285292
best 
\change_unchanged
fit for the response function defined by 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:responseAmp"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:responsePhase"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is shown as the blue line labeled 
\begin_inset Quotes eld
\end_inset

3-par
\begin_inset Quotes erd
\end_inset

 in that figure.
 The 
\change_inserted 1311305628 1586285319
fitted
\change_deleted 1311305628 1586285323
best-fit
\change_unchanged
 values for {
\begin_inset Formula $a,\,\tau_{1},\,\tau_{2}$
\end_inset

} were {0, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestSH[2], 2)}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestSH[3], 2)}
\end_layout

\end_inset

}, and to obtain this result the fit had to be constrained to keep 
\begin_inset Formula $a$
\end_inset

 non-negative.
 A value of zero for the parameter 
\begin_inset Formula $a$
\end_inset

 would indicate that no heat is transferred from the sensing wire to the
 air, but instead all is transferred to the support which has a relatively
 slow characteristic response.
 The transfer function 
\change_inserted 1311305628 1586291949
and typical variance spectrum for the heated Rosemount 102 sensor 
\change_unchanged
is quite similar 
\change_inserted 1311305628 1586291959
to this plot, 
\change_deleted 1311305628 1586291974
to that of the heated Rosemount 102 sensor shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:phaseG}
\end_layout

\end_inset


\change_unchanged
, and the typical variance spectrum shows a decrease with frequency similar
 to that in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:
\change_inserted 1311305628 1586291991
HARCOSpec
\change_deleted 1311305628 1586291985
RTH1Spec
\change_unchanged
}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard

\change_deleted 1311305628 1586292005
As for the heated Rosemount, t
\change_inserted 1311305628 1586292006
T
\change_unchanged
he 
\change_deleted 1311305628 1586285351
best
\change_inserted 1311305628 1586285355
three-parameter
\change_unchanged
 fit is not consistent with the measurement errors even though it provides
 an approximate representation of the transfer function.
 
\change_inserted 1311305628 1586293384
The apparent reason is that there is conflict between the constraints imposed
 by the amplitude ratio and the phase, such that either could be represented
 reasonably but not both.
 The actual transfer function has some complex features, including frequencies
 where the phase shift reaches values below 
\begin_inset Formula $-90^{\circ}$
\end_inset

 (not possible for a simple exponential time response) and values of the
 phase shift of about 
\begin_inset Formula $-38^{\circ}$
\end_inset

 at 0.1
\begin_inset space ~
\end_inset

Hz where the amplitude ratio is still high (about 0.75).
 The amplitude decreases to 
\begin_inset Formula $e^{-1}$
\end_inset

 at about 0.34
\begin_inset space ~
\end_inset

Hz, as would be the case for a first-order time constant of about 1.3
\begin_inset space ~
\end_inset

s, so this could be considered another measure of the response.
 However, that value does not extrapolate well to other frequencies and
 the phase shift at 0.34
\begin_inset space ~
\end_inset

Hz is approximately 
\begin_inset Formula $-73^{\circ}$
\end_inset

, which would indicate that the measurement of a real contribution to sensible-h
eat flux at this frequency would be only about 10% of the correct value.
\end_layout

\begin_layout Standard

\change_inserted 1311305628 1586293417
Because the three-parameter fit distorted the measured result, 
\change_deleted 1311305628 1586293430
Therefore 
\change_unchanged
fits in the logarithm of the frequency were 
\change_deleted 1311305628 1586285370
again 
\change_unchanged
used to provide a better representation of the measurements, as shown by
 the dashed green lines labeled 
\begin_inset Quotes eld
\end_inset

lfit
\begin_inset Quotes erd
\end_inset

.
 Those fits are given by these equations and coefficients: with 
\begin_inset Formula $x=\log_{e}(\nu/\nu_{0})$
\end_inset

 where 
\begin_inset Formula $\nu=\omega/(2\pi)$
\end_inset

 is the frequency and 
\begin_inset Formula $\nu_{0}=1\,\mathrm{Hz}$
\end_inset

:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\mathrm{for}\,\nu>0.024\,\mathrm{Hz,\,\,}H(\omega)=(h_{0}+h_{1}x+h_{2}x^{3}+h_{3}x^{4}+h_{4}x^{5})e^{i\phi(\omega)}\label{eq:lfitH}
\end{equation}

\end_inset


\begin_inset Formula 
\[
\mathrm{for\:\nu\leq0.024\,\mathrm{Hz},\quad}H(\omega)=1
\]

\end_inset


\begin_inset Formula 
\[
\phi(\omega)=p_{0}+p_{1}x+p_{2}x^{2}+p_{3}\arctan(\nu/\nu_{0})
\]

\end_inset

The coefficients obtained by fitting to the observations are 
\begin_inset Formula $h_{0-4}=$
\end_inset

{
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{round(cfr[1], 3)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{round(cfr[2], 3)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{format(cfr[3], digits=3, nsmall=4)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{round(cfr[4], 4)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{round(cfr[5], 5)}$
\end_layout

\end_inset

} and 
\begin_inset Formula $p_{0-3}=$
\end_inset

{
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{round(cf[1], 1)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{round(cf[2], 1)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{round(cf[3], 2)}$
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
Sexpr{round(cf[4], 1)}$
\end_layout

\end_inset

}.

\change_inserted 1311305628 1586294088
 This fit can be used to represent the transfer function better than the
 three-parameter fit (with negative-frequency values defined as the complex
 conjugate of the values at the corresponding positive frequency), although
 the fit needs to be modified above about 2
\begin_inset space ~
\end_inset

Hz because those values were not constrained by the measurements.
 A suggested modification is to extrapolate the value at 2_Hz to higher
 values; this appears to be adequate because there is so little variance
 measured by this sensor at these frequencies, but it is important to avoid
 possible zeroes that otherwise arise from extrapolation.
\change_unchanged

\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
For the contribution of these measurements to fits to determine the response
 parameters, measurements of phase were used only for frequencies from 0.05
 to 1
\begin_inset space ~
\end_inset

Hz and those of amplitude ratio only for frequencies from 0.13 to 1
\begin_inset space ~
\end_inset

Hz.
 The fit does not appear to be as consistent with the measured values as
 the fit for the unheated Rosemount
\begin_inset Foot
status open

\begin_layout Plain Layout
Chi-square 405 for 36 degrees of freedom.
\end_layout

\end_inset

, especially in regard to the amplitude, perhaps indicating that the two-differe
ntial-equation representation of the response is incomplete in this case.
 The best-fit parameters indicated for this sensor are 
\begin_inset Formula $a=$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestHS[1], 2)}
\end_layout

\end_inset

, 
\begin_inset Formula $\tau_{1}=$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestHS[2], 2)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

s and 
\begin_inset Formula $\tau_{2}=$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestHS[3], 2)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

s for sensor 1 (RTH1) and 
\begin_inset Formula $a=$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestHSB[1], 2)}
\end_layout

\end_inset

, 
\begin_inset Formula $\tau_{1}=$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestHSB[2], 2)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

s and 
\begin_inset Formula $\tau_{2}=$
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestHSB[3], 2)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

s for sensor 2 (RTH2).
 The best fit indicates that most heat transfer from or to the wire comes
 from the support and only a smaller fraction is contributed by the air
 itself.
 However, this is still a two-time-constant fit because the support responds
 to the air temperature and the wire separately responds to the support
 temperature.
 This leads to phase shifts more negative than 
\begin_inset Formula $-90^{\circ}$
\end_inset

, which would not be possible for a single-time-constant response.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Subsubsection
Expected dependence on flight conditions
\begin_inset CommandInset label
LatexCommand label
name "subsec:Expected-dependence-on"

\end_inset


\end_layout

\begin_layout Standard
Based on measurements in a wind tunnel, 
\begin_inset CommandInset citation
LatexCommand citet
key "GoodrichTR5755"
literal "false"

\end_inset

 indicated that the fast-response characteristic time 
\begin_inset Formula $\tau_{1}$
\end_inset

 for the unheated Rosemount 102E4AL sensor varies approximately as 
\begin_inset Formula $\log(Z^{-0.6})$
\end_inset

 where 
\begin_inset Formula $Z=M\rho_{a}/\rho_{s}$
\end_inset

 with 
\begin_inset Formula $M$
\end_inset

 the Mach number, 
\begin_inset Formula $\rho_{a}$
\end_inset

 the air density and 
\begin_inset Formula $\rho_{0}$
\end_inset

 the air density under standard conditions.
 The mean value of 
\begin_inset Formula $Z$
\end_inset

 for the flight segments used to find the best-fit parameters was 
\begin_inset Formula $Z=0.3$
\end_inset

, so this suggests that the first characteristic time for that sensor is
 best represented by
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\tau_{1}^{\prime}(Z)=\tau_{1}\left(\frac{0.3}{Z}\right)^{0.6}\,\,\,.\label{eq:tau1prime}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
For GV flight conditions, 
\begin_inset Formula $Z$
\end_inset

 can vary from about 0.18 to 0.38, so this suggests a range for 
\begin_inset Formula $\tau_{1}$
\end_inset

 from 0.029 to 0.046
\begin_inset space ~
\end_inset

s.
 There is no similar evidence for 
\begin_inset Formula $\tau_{2}$
\end_inset

, but it might be expected to have similar dependence because this is approximat
ely the Reynolds number dependence and the Nusselt number characterizing
 ventilated heat transfer often is represented by a power-law relationship
 to the Reynolds number.
 If both heat transfer terms scale similarly, it might be expected that
 
\begin_inset Formula $a$
\end_inset

 will be unchanged.
\end_layout

\begin_layout Standard
For these reasons, the time parameters obtained in preceding sections have
 been adjusted to a reference value of 
\begin_inset Formula $Z=0.3$
\end_inset

 in the Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Parameters"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 For other conditions, it is suggested that the best estimate will be to
 multiply 
\begin_inset Formula $\tau_{1}$
\end_inset

 and 
\begin_inset Formula $\tau_{2}$
\end_inset

 by 
\begin_inset Formula $(0.3/Z)^{0.6}$
\end_inset

.

\change_inserted 1311305628 1585747819
 Having these parameters vary is in conflict with the 
\begin_inset Quotes eld
\end_inset

LTI
\begin_inset Quotes erd
\end_inset

 assumption leading to the transfer function, but these variations are minor
 over short times so incorporating this variation should produce reasonable
 results.
\change_unchanged

\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<adjustP, include=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

rhozero <- 1013.25 * 100 / (287.05 * 288.15)
\end_layout

\begin_layout Plain Layout

MRHO <- MachNumber(DZV$PSXC, DZV$QCXC) * DZV$PSXC * 100 / 
\end_layout

\begin_layout Plain Layout

        (287.05 * (273.15 + DZV$ATX)) / rhozero
\end_layout

\begin_layout Plain Layout

Param1$tau1 <- Param1$tau1 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ 0.6
\end_layout

\begin_layout Plain Layout

Param1$tau2 <- Param1$tau2 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ 0.6
\end_layout

\begin_layout Plain Layout

MRHO <- MachNumber(DS$PSXC, DS$QCXC) * DS$PSXC * 100 / 
\end_layout

\begin_layout Plain Layout

        (287.05 * (273.15 + DS$ATX)) / rhozero
\end_layout

\begin_layout Plain Layout

# ParamHS$tau1 <- ParamHS$tau1 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ 0.6
\end_layout

\begin_layout Plain Layout

# ParamHS$tau2 <- ParamHS$tau2 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ 0.6
\end_layout

\begin_layout Plain Layout

# ParamHSB$tau1 <- ParamHSB$tau1 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ 0.6
\end_layout

\begin_layout Plain Layout

# ParamHSB$tau2 <- ParamHSB$tau2 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ 0.6
\end_layout

\begin_layout Plain Layout

bestSH[2] <- bestSH[2] * (mean(MRHO
\change_deleted 1311305628 1585758897
GV
\change_unchanged
, na.rm = TRUE) / 0.3) ^ 0.6
\end_layout

\begin_layout Plain Layout

bestSH[3] <- bestSH[3] * (mean(MRHO
\change_deleted 1311305628 1585758895
GV
\change_unchanged
, na.rm = TRUE) / 0.3) ^ 0.6
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Float table
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
sensor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\begin_inset Formula $a$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\begin_inset Formula $\tau_{1}$
\end_inset


\series default
 [s]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\begin_inset Formula $\tau_{2}$
\end_inset


\series default
 [s]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
unheated Rosemount 102E4ALon C-130
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(Param1$a, 2)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(Param1$tau1, 3)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(Param1$tau2,2)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
unheated Rosemount 102E4AL on GV
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{format(ParGV$a, digits=2, nsmall=2)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(ParGV$tau1, 3)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{format(ParGV$tau2, digits=2, nsmall=2)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
heated Rosemount 102 on C-130
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{format(bestW[1], digits=2, nsmall=2)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{format(bestW[2], digits=2, nsmall=2)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{format(bestW[3], digits=2, nsmall=2)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
heated HARCO on GV
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{format(bestSH[1], digits=1, nsmall=1)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{format(bestSH[2], digits=2, nsmall=2)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{format(bestSH[3], digits=2, nsmall=2)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
Parameters for the time response of available temperature sensors on the
 NSF/NCAR aircraft, adjusted to 
\begin_inset Formula $Z=0.3$
\end_inset

.
 For other conditions, scale as represented for 
\begin_inset Formula $\tau_{1}^{\prime}$
\end_inset

 in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:tau1prime"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\begin_inset CommandInset label
LatexCommand label
name "tab:Parameters"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
heated Rosemount on C-130
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(ParamW$a, 2)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(ParamW$tau1, 2)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(ParamW$tau2, 2)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Response to a step change
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<VOCALSrf03, include=FALSE, echo=FALSE, fig.height=4, fig.cap='Temperature
 measured during descent through an inversion capping the marine boundary
 layer, from VOCALS flight 3, starting at 8:13:50 UTC.
 The descent rate was approximately 5 m/s.
 The dashed red line shows a dry-adiabatic lapse rate in the marine boundary
 layer, and the dashed blue line is a reference line indicating the location
 of the top of the boundary layer.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Data <-
\end_layout

\begin_layout Plain Layout

  getNetCDF(
\end_layout

\begin_layout Plain Layout

    file.path(DataDirectory(), 'VOCALS/VOCALSrf03h.nc'),
\end_layout

\begin_layout Plain Layout

    c(
\end_layout

\begin_layout Plain Layout

      'PALT',
\end_layout

\begin_layout Plain Layout

      'GGALT_NTL',
\end_layout

\begin_layout Plain Layout

      'ATX',
\end_layout

\begin_layout Plain Layout

      'ATRL',
\end_layout

\begin_layout Plain Layout

      'ATRR',
\end_layout

\begin_layout Plain Layout

      'ATWH',
\end_layout

\begin_layout Plain Layout

      'DPXC',
\end_layout

\begin_layout Plain Layout

      'PSXC',
\end_layout

\begin_layout Plain Layout

      'QCXC',
\end_layout

\begin_layout Plain Layout

      'TTRR'
\end_layout

\begin_layout Plain Layout

    )
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

Data %>% select(Time, PALT, ATRR) %>% 
\end_layout

\begin_layout Plain Layout

  selectTime(81350, 81358) %>%
\end_layout

\begin_layout Plain Layout

  select(ATRR) %>% 
\end_layout

\begin_layout Plain Layout

  plot(
\end_layout

\begin_layout Plain Layout

    type = 'b',
\end_layout

\begin_layout Plain Layout

    pch = 20,
\end_layout

\begin_layout Plain Layout

    ylab = bquote('ATRR [' * degree ~ 'C]'),
\end_layout

\begin_layout Plain Layout

    xlab = 'sample number',
\end_layout

\begin_layout Plain Layout

    col = 'blue'
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

x <- 0:250
\end_layout

\begin_layout Plain Layout

y <- 6.9 - x * 5 / 25 * 10 / 1000
\end_layout

\begin_layout Plain Layout

lines(x, y, col = 'red', lty = 2)
\end_layout

\begin_layout Plain Layout

abline(v = 10, col = 'black', lty = 2)
\end_layout

\begin_layout Plain Layout

## Get Z for scaling the time constants:
\end_layout

\begin_layout Plain Layout

rhozero <- 1013.25 * 100 / (287.05 * 288.15)
\end_layout

\begin_layout Plain Layout

Z <- MachNumber(Data$PSXC, Data$QCXC) * 100 * Data$PSXC /
\end_layout

\begin_layout Plain Layout

  (287.05 * (273.15 + Data$ATRR)) / rhozero
\end_layout

\begin_layout Plain Layout

ParamS <- ParamSF
\end_layout

\begin_layout Plain Layout

ParamS$tau1 <- ParamS$tau1 * (mean(Z, na.rm = TRUE) / 0.3) ^ 0.6
\end_layout

\begin_layout Plain Layout

ParamS$tau2 <- ParamS$tau2 * (mean(Z, na.rm = TRUE) / 0.3) ^ 0.6
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<tfit, include=TRUE, echo=FALSE, fig.pos='t', fig.cap='(blue dots): Temperature
 measured at 25 Hz during descent through an inversion capping the marine
 boundary layer, from VOCALS flight 3, starting at 8:13:50 UTC.
 The descent rate was approximately 5 m/s.
 The dashed red line shows a dry-adiabatic lapse rate in the marine boundary
 layer, and the dashed black line is a reference line indicating the location
 of the top of the boundary layer.The  prediction using the parameters listed
 in the text is shown as the green line, significantly obscured by the blue
 dots representing the measurements.
 The dashed brown line is the calculated temperature of the support that
 contacts the sensing wire.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Data %>% select(Time, PALT, ATRR) %>% 
\end_layout

\begin_layout Plain Layout

  selectTime(81350, 81358) %>% 
\end_layout

\begin_layout Plain Layout

  select(ATRR) %>% 
\end_layout

\begin_layout Plain Layout

  plot(
\end_layout

\begin_layout Plain Layout

    type = 'b',
\end_layout

\begin_layout Plain Layout

    pch = 20,
\end_layout

\begin_layout Plain Layout

    ylab = bquote('ATRR [' * degree ~ 'C]'),
\end_layout

\begin_layout Plain Layout

    xlab = 'sample number',
\end_layout

\begin_layout Plain Layout

    col = 'blue'
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

x <- 0:200
\end_layout

\begin_layout Plain Layout

y <- 6.9 - x * 5 / 25 * 10 / 1000
\end_layout

\begin_layout Plain Layout

lines(x[11:200], y[11:200], col = 'red', lty = 2)
\end_layout

\begin_layout Plain Layout

lines(c(10, 10), c(y[11], 14.3), col = 'black', lty = 2)
\end_layout

\begin_layout Plain Layout

xx <- 0:2000
\end_layout

\begin_layout Plain Layout

yy <- 6.9 - xx * 5 / 250 * 10 / 1000
\end_layout

\begin_layout Plain Layout

yy[1:110] <- 14.30
\end_layout

\begin_layout Plain Layout

# calculate the response, given tau:
\end_layout

\begin_layout Plain Layout

tau <- 0.05
\end_layout

\begin_layout Plain Layout

taua <- 0.09
\end_layout

\begin_layout Plain Layout

tau2 <- 0.90
\end_layout

\begin_layout Plain Layout

tau2a <- 1.0
\end_layout

\begin_layout Plain Layout

a <- 0.62
\end_layout

\begin_layout Plain Layout

aa <- 0.65
\end_layout

\begin_layout Plain Layout

tau <- Param1$tau1
\end_layout

\begin_layout Plain Layout

# tau2 <- Param1$tau2
\end_layout

\begin_layout Plain Layout

tau2a <- 1.1
\end_layout

\begin_layout Plain Layout

taua <- 0.05
\end_layout

\begin_layout Plain Layout

a <- Param1$a
\end_layout

\begin_layout Plain Layout

a <- ParamS$a
\end_layout

\begin_layout Plain Layout

tau1 <- ParamS$tau1
\end_layout

\begin_layout Plain Layout

tau2 <- ParamS$tau2
\end_layout

\begin_layout Plain Layout

tau1a <- 0.06
\end_layout

\begin_layout Plain Layout

tau2a <- 1.3
\end_layout

\begin_layout Plain Layout

aa <- a - 0.02
\end_layout

\begin_layout Plain Layout

ym <- yy
\end_layout

\begin_layout Plain Layout

ymf <- ym
\end_layout

\begin_layout Plain Layout

yr <- yy
\end_layout

\begin_layout Plain Layout

yra <- yy
\end_layout

\begin_layout Plain Layout

for (i in 2:2000) {
\end_layout

\begin_layout Plain Layout

  yr[i] <- yr[i - 1] + (yy[i] - yr[i - 1]) * 0.004 / tau2
\end_layout

\begin_layout Plain Layout

  yra[i] <- yra[i - 1] + (yy[i] - yra[i - 1]) * 0.004 / tau2a
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

for (i in 2:2000) {
\end_layout

\begin_layout Plain Layout

  ym[i] <-
\end_layout

\begin_layout Plain Layout

    ym[i - 1] + (a * yy[i] + (1 - a) * yr[i] - ym[i - 1]) * 0.004 / tau1
\end_layout

\begin_layout Plain Layout

  ymf[i] <-
\end_layout

\begin_layout Plain Layout

    ymf[i - 1] + (aa * yy[i] + (1 - aa) * yra[i] - ymf[i - 1]) * 0.004 /
 tau1a
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

lines(xx / 10, ym, col = 'forestgreen', lwd = 2)
\end_layout

\begin_layout Plain Layout

# lines(xx / 10, ymf, col = 'darkorange', lwd = 2)
\end_layout

\begin_layout Plain Layout

lines(xx / 10,
\end_layout

\begin_layout Plain Layout

      yr,
\end_layout

\begin_layout Plain Layout

      col = 'brown',
\end_layout

\begin_layout Plain Layout

      lwd = 2,
\end_layout

\begin_layout Plain Layout

      lty = 2)
\end_layout

\begin_layout Plain Layout

legend('topright', legend=c('measured','predicted', 'support'), lwd=c(2,2,2),
 lty=c(1,1,2),
\end_layout

\begin_layout Plain Layout

       col=c('blue', 'forestgreen', 'brown'))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The preceding subsection developed estimates of the 
\change_inserted 1311305628 1586295635
sensor 
\change_unchanged
response 
\change_deleted 1311305628 1586368428
parameters for various sensors 
\change_unchanged
with low uncertainty compared to previous estimates, so that will be the
 primary constraint on these parameters.
 It is nevertheless useful to 
\change_inserted 1311305628 1586368381
check if
\change_deleted 1311305628 1586368377
investigate
\change_unchanged
 other measurements 
\change_inserted 1311305628 1586368484
that are sensitive to the time response are consistent with the characterization
 developed in the preceding subsections.
 
\change_deleted 1311305628 1586368490
that can constrain the response parameters.
 
\change_unchanged
Previous studies have mostly used sharp temperature changes in the atmosphere,
 for example from climbs through the inversion at the top of a boundary
 layer, to study the time response.
 A search of representative VOCALS climbs and descents through inversions
 capping the marine boundary layer found many with unusable structure but
 one near-ideal example, from VOCALS research flight 3, with a descent through
 the inversion at 8:13:50 UTC.
 The instrument list for this experiment includes two unheated Rosemount102E4AL
 sensors
\change_deleted 1311305628 1586371220
, including ATRR (ATX)
\change_unchanged
\SpecialChar endofsentence
 Figure 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:tfit}
\end_layout

\end_inset

 shows the time history of the measured temperature for 8
\begin_inset space ~
\end_inset

s during this descent, at a rate of approximately 1000
\begin_inset space ~
\end_inset

ft/min (around 5
\begin_inset space ~
\end_inset

m/s).
 The temperature structure in this case is remarkably consistent with a
 near-constant temperature above the inversion and a near-adiabatic-temperature
 structure below the inversion.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<VOCALSrf03, include=TRUE, echo=FALSE, fig.height=4, fig.cap='Temperature
 measured during descent through an inversion capping the marine boundary
 layer, from VOCALS flight 3, starting at 8:13:50 UTC.
 The descent rate was approximately 5 m/s.
 The dashed red line shows a dry-adiabatic lapse rate in the marine boundary
 layer, and the dashed blue line is a reference line indicating the location
 of the top of the boundary layer.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Data <- getNetCDF(file.path(DataDirectory(), 'VOCALS/VOCALSrf03h.nc'), c('PALT',
 'GGALT_NTL', 'ATX', 'ATRL', 'ATRR', 'ATWH', 'DPXC', 'PSXC', 'QCXC', 'TTRR'))
\end_layout

\begin_layout Plain Layout

# Data %>% select(Time, PALT, ATX) %>% selectTime(81349, 81351) %>% select(Time,
 ATX) %>% plot()
\end_layout

\begin_layout Plain Layout

# Data %>% select(Time, PALT, ATX) %>% selectTime(81349, 81351) %>% select(Time,
 ATX) %>% plot(type='b', pch=20)
\end_layout

\begin_layout Plain Layout

# Data %>% select(Time, PALT, ATX) %>% selectTime(81350, 81351) %>% select(Time,
 ATX) %>% plot(type='b', pch=20)
\end_layout

\begin_layout Plain Layout

# Data %>% select(Time, PALT, ATRR) %>% selectTime(81350, 81351) %>% select(Time
, ATRR) %>% plot(type='b', pch=20) 
\end_layout

\begin_layout Plain Layout

Data %>% select(Time, PALT, ATRR) %>% selectTime(81350, 81358) %>% select(ATRR)
 %>% plot(type='b', pch=20, ylab='ATRR', xlab='sample number', col='blue')
\end_layout

\begin_layout Plain Layout

x <- 0:250
\end_layout

\begin_layout Plain Layout

y <- 6.9-x*5/25*10/1000 
\end_layout

\begin_layout Plain Layout

lines(x, y, col='red', lty=2) 
\end_layout

\begin_layout Plain Layout

abline(v=10, col='black', lty=2) 
\end_layout

\begin_layout Plain Layout

## Get Z for scaling the time constants: 
\end_layout

\begin_layout Plain Layout

rhozero <- 1013.25*100/(287.05*288.15) 
\end_layout

\begin_layout Plain Layout

Z <- MachNumber(Data$PSXC, Data$QCXC) * 100 * Data$PSXC / 
\end_layout

\begin_layout Plain Layout

     (287.05 * (273.15 + Data$ATRR)) / rhozero 
\end_layout

\begin_layout Plain Layout

ParamS <- Param1 
\end_layout

\begin_layout Plain Layout

ParamS$tau1 <- ParamS$tau1 * (mean(Z, na.rm=TRUE) / 0.3)^0.6 
\end_layout

\begin_layout Plain Layout

ParamS$tau2 <- ParamS$tau2 * (mean(Z, na.rm=TRUE) / 0.3)^0.6
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<<tfit, include=TRUE, echo=FALSE, fig.height=4, fig.cap='The 25 Hz measurements
 from the previous figure (blue dots) and the predictions using the parameters
 listed in the text (green line).
 The dashed brown line is the calculated temperature of the support that
 contacts the sensing wire.
 Also shown as the orange line is the result if the parameters are changed
 to $a=0.713$, $
\backslash

\backslash
tau_1$=0.06 s and $
\backslash

\backslash
tau_2$=1.3 s.'>>=
\end_layout

\begin_layout Plain Layout

Data %>% select(Time, PALT, ATRR) %>% selectTime(81350, 81358) %>% select(ATRR)
 %>% plot(type='b', pch=20, ylab='ATRR', xlab='sample number', col='blue')
 x <- 0:200 y <- 6.9-x*5/25*10/1000 lines(x[11:200], y[11:200], col='red',
 lty=2) lines(c(10,10), c(y[11], 14.3), col='black', lty=2) xx <- 0:2000
 yy <- 6.9 - xx * 5 / 250 * 10 / 1000 yy[1:110] <- 14.30 # calculate the response,
 given tau: tau <- 0.05 taua <- 0.09 tau2 <- 0.90 tau2a <- 1.0 a <- 0.62 aa <-
 0.65 tau <- Param1$tau1 # tau2 <- Param1$tau2 tau2a <- 1.1 taua <- 0.05 a
 <- Param1$a a <- ParamS$a tau1 <- ParamS$tau1 tau2 <- ParamS$tau2 tau1a
 <- 0.06 tau2a <- 1.3 aa <- a - 0.02 ym <- yy ymf <- ym yr <- yy yra <- yy
 for (i in 2:2000) {   yr[i] <- yr[i-1] + (yy[i] - yr[i-1]) * 0.004 / tau2
   yra[i] <- yra[i-1] + (yy[i] - yra[i-1]) * 0.004 / tau2a } for (i in 2:2000)
 {   ym[i] <- ym[i-1] + (a * yy[i] + (1-a) * yr[i] - ym[i-1]) * 0.004 / tau1
    ymf[i] <- ymf[i-1] + (aa * yy[i] + (1-aa) * yra[i] - ymf[i-1]) * 0.004
 / tau1a  } lines(xx/10, ym, col='forestgreen', lwd=2) lines(xx/10, ymf,
 col='darkorange', lwd=2) lines(xx/10, yr, col='brown', lwd=2, lty=2)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

The suggested measurand history, if the discontinuity at the inversion is
 discrete, is that shown by the dashed black and dashed red lines, x(t)=
\backslash
{14.3, 6.878, 6.876, 6.874, 6.872, 6.870, 6.868, 6.866, 6.864, 6.862, 6.860, ...
\backslash
} for t=
\backslash
{10, 11, 12, ...
\backslash
}.
 The predicted time response from 
\backslash
eqref{eq:Tm} for assumed time constants as given in Table 1 for the unheated
 Rosemount 102E4AL sensor adjusted for air density and flight speed ($a=0.733$,
 $
\backslash
tau_{1}=0.030$~s and $
\backslash
tau_{2}=0.43$~s) is shown as the green line in Fig.~
\backslash
ref{fig:tfit}.
 The predicted response is significantly faster than that of the observations,
 and the fit to observations can be improved by adjusting the time constants
 as listed in the figure caption.
 The adjusted values needed to match the observations are so far outside
 estimated uncertainty limits for the parameters that it seems likely that
 the actual temperature at the top of the boundary layer is not as sharply
 discontinuous as assumed but is smoothed by some mixing.
 The rapid initial change does supports a small value of $
\backslash
tau_{1}$, and the results may suggest a longer time constant for the support
 structure, but this evidence is weak in comparison to that arising from
 the phase and amplitude ratio obtained for dynamic heating.
 
\end_layout

\begin_layout Plain Layout


\backslash
subsection{Application to a speed run}
\end_layout

\begin_layout Plain Layout

Because the assumed response of the support is characterized by a simple
 time constant, during the speed run the support will lag in temperature
 by $
\backslash
tau_{2}$.
 Then, from 
\backslash
eqref{eq:Tm}, $T_{m}(t)$ will lag by $
\backslash
tau_{1}$ behind the temperature to which the sensor responds, which is $aT(t)+(1
-a)T(t-
\backslash
tau_{2})$.
 For a ramp input such that $T(t)=T_{0}+kt$, the solution to 
\backslash
eqref{eq:Tm} is that the measured temperature $T_{m}(t)$ lags $T(t)$ by
 $
\backslash
psi$, so that $T_{m}(t)=T_{0}+k(t-
\backslash
psi)$.
 Then
\backslash

\backslash
 
\backslash
[ k
\backslash
tau_{1}=a(T_{0}+kt)+(1-a)(T_{0}+k(t-
\backslash
tau_{2})-T_{0}-kt+k
\backslash
psi 
\backslash
]
\end_layout

\begin_layout Plain Layout

which requires the recovery-temperature lag to be
\backslash

\backslash
 
\backslash
begin{equation} 
\backslash
psi=
\backslash
tau_{1}+(1-a)
\backslash
tau_{2}
\backslash
label{eq:delta} 
\backslash
end{equation}
\end_layout

\begin_layout Plain Layout

<<SRDW, include=TRUE, fig.height=4.2, fig.cap='History of the airspeed during
 a segment of flight 15 from the DEEPWAVE project.'>>=
\end_layout

\begin_layout Plain Layout

Project <- 'DEEPWAVE' Flight <- 'rf15h' startTime <- 32300 endTime <- 32815
 fname <- file.path(DataDirectory(), Project, '/', Project,   Flight,'.nc',
 fsep='') FI <- DataFileInfo(fname, LLrange=FALSE) iv <- which(grepl('^RT',
 FI$Variables)) ProjDir <- Project VL <- c('TASX', 'EWX', 'PSXC', 'RTX',
 'RTH1', 'RTH2', 'RTF1', 'ATX',   'GGALT', 'PITCH', 'ADIFR', 'QCF', 'AKRD',
 'WIC', 'QCXC') VL <- c(VL, FI$Variables[iv]) VL <- unique(VL) DSR <- getNetCDF
 (sprintf ('%s%s/%s%s.nc', DataDirectory (),   ProjDir, Project, Flight),
 VL,    Start=startTime, End=endTime) DSR %>% select(Time, TASX) %>% selectTime(
32310, 32700) %>% plotWAC() ## Find the average Z: (but there is significant
 Mach number variation...) Z <- MachNumber(DSR$PSXC, DSR$QCXC) * 100 * DSR$PSXC
 / (287.05 * (273.15 + DSR$ATX)) / rhozero ParamS <- Param1 ParamS$tau1 <-
 ParamS$tau1 * (mean(Z, na.rm=TRUE) / 0.3)^0.6 ParamS$tau2 <- ParamS$tau2 *
 (mean(Z, na.rm=TRUE) / 0.3)^0.6 ParamWZ <- ParamW ParamHZ <- ParamHS ParamWZ$tau1
 <- ParamW$tau1 * (mean(Z, na.rm=TRUE) / 0.3)^0.6 ParamHZ$tau1 <- ParamHZ$tau1
 * (mean(Z, na.rm=TRUE) / 0.3)^0.6 ParamWZ$tau2 <- ParamW$tau2 * (mean(Z, na.rm=TRUE
) / 0.3)^0.6 ParamHZ$tau2 <- ParamHZ$tau2 * (mean(Z, na.rm=TRUE) / 0.3)^0.6
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

For the Rosemount 102E4AL, the fitted values from the previous subsection
 would then cause a lag
\end_layout

\begin_layout Plain Layout

y <- 6.9-x*5/25*10/1000
\end_layout

\begin_layout Plain Layout

lines(x, y, col='red', lty=2)
\end_layout

\begin_layout Plain Layout

abline(v=10, col='black', lty=2)
\end_layout

\begin_layout Plain Layout

## Get Z for scaling the time constants:
\end_layout

\begin_layout Plain Layout

rhozero <- 1013.25*100/(287.05*288.15)
\end_layout

\begin_layout Plain Layout

Z <- MachNumber(Data$PSXC, Data$QCXC) * 100 * Data$PSXC / (287.05 * (273.15
 + Data$ATRR)) / rhozero
\end_layout

\begin_layout Plain Layout

ParamS <- Param1
\end_layout

\begin_layout Plain Layout

ParamS$tau1 <- ParamS$tau1 * (mean(Z, na.rm=TRUE) / 0.3)^0.6
\end_layout

\begin_layout Plain Layout

ParamS$tau2 <- ParamS$tau2 * (mean(Z, na.rm=TRUE) / 0.3)^0.6
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Also shown as the orange line is the result if the parameters are changed
 to $a=0.713$, $
\backslash

\backslash
tau_1$=0.06 s and $
\backslash

\backslash
tau_2$=1.3 s.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The suggested measurand history, if the discontinuity at the inversion is
 discrete, is that shown by the dashed black and dashed red lines, x(t)={14.3,
 6.878, 6.876, 6.874, 6.872, 6.870, 6.868, 6.866, 6.864, 6.862, 6.860, ...} for t={10,
 11, 12, ...}.
 The predicted time response from 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for assumed time constants for the unheated Rosemount 102E4AL sensor adjusted
 for air density and flight speed is shown as the green line in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:tfit}
\end_layout

\end_inset

.
 The predicted response is consistent with the observations and supports
 the 
\change_inserted 1311305628 1586371278
approximate 
\change_unchanged
validity of the parameters determined from fits to the response to dynamic
 heating.
 
\end_layout

\begin_layout Subsection
Application to a 
\change_inserted 1311305628 1586371432

\begin_inset Quotes eld
\end_inset


\change_unchanged
speed run
\change_inserted 1311305628 1586371434

\begin_inset Quotes erd
\end_inset


\change_unchanged

\end_layout

\begin_layout Standard

\change_inserted 1311305628 1586371556
Another situation where a temperature lag can be observed is when the airspeed
 changes during level flight and causes a change in dynamic heating.
 An example is shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

\change_inserted 1311305628 1586296431


\backslash
ref{fig:SRDW}
\end_layout

\end_inset

, where the airspeed was increased steadily in level flight from near the
 lower limit of the flight envelope to near the upper limit and then was
 decreased back to the starting value.
 A plot of recovery temperature should also increase and decrease as the
 dynamic heating changes, but with a lag caused by the sensor response.
 
\end_layout

\begin_layout Standard

\change_inserted 1311305628 1586371627
The assumed model provided by 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 leads to a prediction of the time lag.
 
\change_unchanged
Because the assumed response of the support is characterized by a simple
 time constant, during the speed run the support will lag in temperature
 by 
\begin_inset Formula $\tau_{2}$
\end_inset

.
 Then, from 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

, 
\begin_inset Formula $T_{m}(t)$
\end_inset

 will lag by 
\begin_inset Formula $\tau_{1}$
\end_inset

 behind the temperature to which the sensor responds, which is 
\begin_inset Formula $aT(t)+(1-a)T(t-\tau_{2})$
\end_inset

.
 For a ramp input such that 
\begin_inset Formula $T(t)=T_{0}+kt$
\end_inset

, the solution to 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is that the measured temperature 
\begin_inset Formula $T_{m}(t)$
\end_inset

 lags 
\begin_inset Formula $T(t)$
\end_inset

 by 
\begin_inset Formula $\psi$
\end_inset

, so that 
\begin_inset Formula $T_{m}(t)=T_{0}+k(t-\psi)$
\end_inset

.
 Then
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
k\tau_{1}=a(T_{0}+kt)+(1-a)(T_{0}+k(t-\tau_{2})-T_{0}-kt+k\psi
\]

\end_inset


\end_layout

\begin_layout Standard
which requires the recovery-temperature lag to be
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\psi=\tau_{1}+(1-a)\tau_{2}\label{eq:delta}
\end{equation}

\end_inset


\change_inserted 1311305628 1586296730
This lag will produce hysteresis in the measured temperature during the
 speed run.
\begin_inset Newline newline
\end_inset


\change_deleted 1311305628 1586371500

\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<SRDW, include=TRUE, fig.pos='t', fig.height=3.2, fig.cap='History of the airspeed
 during a 
\change_deleted 1311305628 1586295948
segment of flight 15 from the DEEPWAVE project (a
\change_unchanged
 
\begin_inset Quotes eld
\end_inset

speed-run
\begin_inset Quotes erd
\end_inset

 maneuver
\change_deleted 1311305628 1586295963
)
\change_inserted 1311305628 1586296193
 where the airspeed varied during level flight over the available speed
 range of the aircraft
\change_unchanged
.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Project <- 'DEEPWAVE'
\end_layout

\begin_layout Plain Layout

Flight <- 'rf15h'
\end_layout

\begin_layout Plain Layout

startTime <- 32300
\end_layout

\begin_layout Plain Layout

endTime <- 32815
\end_layout

\begin_layout Plain Layout

fname <- file.path(DataDirectory(), Project, '/', Project,
\end_layout

\begin_layout Plain Layout

                   Flight, '.nc', fsep = '')
\end_layout

\begin_layout Plain Layout

FI <- DataFileInfo(fname, LLrange = FALSE)
\end_layout

\begin_layout Plain Layout

iv <- which(grepl('^RT', FI$Variables))
\end_layout

\begin_layout Plain Layout

ProjDir <- Project
\end_layout

\begin_layout Plain Layout

VL <- c(
\end_layout

\begin_layout Plain Layout

  'TASX',
\end_layout

\begin_layout Plain Layout

  'EWX',
\end_layout

\begin_layout Plain Layout

  'PSXC',
\end_layout

\begin_layout Plain Layout

  'RTX',
\end_layout

\begin_layout Plain Layout

  'RTH1',
\end_layout

\begin_layout Plain Layout

  'RTH2',
\end_layout

\begin_layout Plain Layout

  'RTF1',
\end_layout

\begin_layout Plain Layout

  'ATX',
\end_layout

\begin_layout Plain Layout

  'GGALT',
\end_layout

\begin_layout Plain Layout

  'PITCH',
\end_layout

\begin_layout Plain Layout

  'ADIFR',
\end_layout

\begin_layout Plain Layout

  'QCF',
\end_layout

\begin_layout Plain Layout

  'AKRD',
\end_layout

\begin_layout Plain Layout

  'WIC',
\end_layout

\begin_layout Plain Layout

  'QCXC'
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

VL <- c(VL, FI$Variables[iv])
\end_layout

\begin_layout Plain Layout

VL <- unique(VL)
\end_layout

\begin_layout Plain Layout

DSR <- getNetCDF (
\end_layout

\begin_layout Plain Layout

  sprintf ('%s%s/%s%s.nc', DataDirectory (),
\end_layout

\begin_layout Plain Layout

           ProjDir, Project, Flight),
\end_layout

\begin_layout Plain Layout

  VL,
\end_layout

\begin_layout Plain Layout

  Start = startTime,
\end_layout

\begin_layout Plain Layout

  End = endTime
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

DSR %>% select(Time, TASX) %>% 
\end_layout

\begin_layout Plain Layout

  selectTime(32310, 32700) %>% 
\end_layout

\begin_layout Plain Layout

  plotWAC()
\end_layout

\begin_layout Plain Layout

## Find the average Z: (but there is significant Mach number variation...)
\end_layout

\begin_layout Plain Layout

Z <- MachNumber(DSR$PSXC, DSR$QCXC) * 100 * DSR$PSXC / 
\end_layout

\begin_layout Plain Layout

     (287.05 * (273.15 + DSR$ATX)) / rhozero
\end_layout

\begin_layout Plain Layout

ParamS <- Param1
\end_layout

\begin_layout Plain Layout

ParamS$tau1 <- ParamS$tau1 * (mean(Z, na.rm = TRUE) / 0.3) ^ -0.6
\end_layout

\begin_layout Plain Layout

ParamS$tau2 <- ParamS$tau2 * (mean(Z, na.rm = TRUE) / 0.3) ^ -0.6
\end_layout

\begin_layout Plain Layout

ParamHZ <- Param1
\end_layout

\begin_layout Plain Layout

ParamHZ$tau1 <- ParamHZ$tau1 * (mean(Z, na.rm = TRUE) / 0.3) ^ -0.6
\end_layout

\begin_layout Plain Layout

ParamHZ$tau2 <- ParamHZ$tau2 * (mean(Z, na.rm = TRUE) / 0.3) ^ -0.6
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Extra
inverted 0
status open

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<XTR>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

ParamWZ <- ParamW
\end_layout

\begin_layout Plain Layout

ParamWZ$tau1 <- ParamW$tau1 * (mean(Z, na.rm = TRUE) / 0.3) ^ -0.6
\end_layout

\begin_layout Plain Layout

ParamWZ$tau2 <- ParamW$tau2 * (mean(Z, na.rm = TRUE) / 0.3) ^ -0.6
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
For the Rosemount 102E4AL, the fitted values from Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-unheated-Rosemount"
plural "false"
caps "false"
noprefix "false"

\end_inset

 would then cause a lag of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(Param1$tau1+(1-Param1$a)*Param1$tau2, 2)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

s
\change_inserted 1311305628 1586373445
, which is hard to detect.
\change_deleted 1311305628 1586373420
.
 
\change_unchanged

\begin_inset Branch Extra
inverted 0
status open

\begin_layout Standard
For the heated Rosemount the expected lag is about 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestW[2]+(1-bestW[1])*bestW[3], 2)}
\end_layout

\end_inset

.
\end_layout

\end_inset

For the heated HARCO 
\change_deleted 1311305628 1586296910
probe
\change_inserted 1311305628 1586296912
sensor
\change_unchanged
 the predicted lag would be 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(bestSH[2]+(1-bestSH[1])*bestSH[3], 2)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

s
\change_deleted 1311305628 1586374960
.
\change_inserted 1311305628 1586374976
, which is easily observed.
 
\change_unchanged

\end_layout

\begin_layout Standard

\change_deleted 1311305628 1586296840
An example of a speed run is shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:SRDW}
\end_layout

\end_inset

, where the airspeed was increased steadily in level flight from near the
 lower limit of the flight envelope to near the upper limit and then was
 decreased back to the starting value.
 A plot of recovery temperature should also increase and decrease with a
 lag given by 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:delta"
plural "false"
caps "false"
noprefix "false"

\end_inset

.

\change_unchanged
 
\change_deleted 1311305628 1586296953
For a HARCO heated sensor, this plot is shown in 
\change_unchanged
Fig
\change_inserted 1311305628 1586296957
ure
\change_deleted 1311305628 1586296958
.
\change_unchanged

\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:SRnodelay}
\end_layout

\end_inset


\change_deleted 1311305628 1586296962
.
 
\change_inserted 1311305628 1586296978
 shows this 
\change_deleted 1311305628 1586296981
The 
\change_unchanged
hysteresis
\change_inserted 1311305628 1586296990
, which appears as
\change_unchanged
 
\change_deleted 1311305628 1586296995
depicted by 
\change_unchanged
the difference between the segment with increasing speed and that with decreasin
g speed
\change_deleted 1311305628 1586297010
 arises from the sensor time lag
\change_unchanged
.
\begin_inset Note Note
status open

\begin_layout Plain Layout
The delay can be estimated by shifting the measurements later in time and
 repeating the fit to search for the smallest standard deviation about the
 fitted line.
 The smallest standard deviation occurs for a shift of 2.225
\begin_inset space ~
\end_inset

s, larger than the value of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(ParamHZ$tau1+(1-ParamHZ$a)*ParamHZ$tau2, 2)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

s expected from the phase-lag analysis.
\end_layout

\end_inset

 
\change_inserted 1311305628 1586297106
A correction based on simply shifting the measurements in time works reasonably
 but doesn't take into account that 
\change_deleted 1311305628 1586297108
Because 
\change_unchanged
the Mach number and hence the time parameters vary significantly during
 the speed run
\change_inserted 1311305628 1586297123
.
 A better
\change_deleted 1311305628 1586297126
, a
\change_unchanged
 test of the time-response parameters is to apply the first correction scheme
 outlined in 
\change_deleted 1311305628 1586371893
Sect.
\change_inserted 1311305628 1586371898
Appendix
\change_unchanged

\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-resulting-transfer"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to the measurements
\change_inserted 1311305628 1586297171
, with varying response parameters dependent on 
\change_deleted 1311305628 1586297173
.
 
\change_inserted 1311305628 1586301524
the Mach number.
 The specific correction equation used is 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:HARCOsoln"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 
\change_deleted 1311305628 1585761996
For 
\begin_inset Formula $a=0$
\end_inset

, as for the heated HARCO, the solution for the estimated actual recovery
 temperature 
\begin_inset Formula $T_{r}(t)$
\end_inset

 is
\end_layout

\begin_layout Standard

\change_deleted 1311305628 1585761996
\begin_inset Formula 
\begin{equation}
T_{r}(t)=(\tau_{1}+\tau_{2})\frac{dT_{m}(t)}{dt}+T_{m}(t)+\tau_{2}\tau_{1}\frac{d^{2}T_{m}(t)}{dt^{2}}\label{eq:solna0}
\end{equation}

\end_inset

No integration is needed because all terms on the right side are measured
 or obtainable from finite differences.
 This is particularly suited to the speed run because the variation in 
\begin_inset Formula $\tau_{1}$
\end_inset

 and 
\begin_inset Formula $\tau_{2}$
\end_inset

 with airspeed can be incorporated into the solution.

\change_unchanged
 Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:srRTH1delay}
\end_layout

\end_inset

 shows that the delay is mostly removed by this procedure.
 The residual standard deviation about the fit is reduced from 
\begin_inset Formula $0.26^{\circ}$
\end_inset

C before correction to 
\begin_inset Formula $0.10^{\circ}$
\end_inset

C after correction.
 The minimum standard deviation results from increasing the time constants
 
\change_deleted 1311305628 1585748805
by
\change_inserted 1311305628 1585748813
an additional
\change_unchanged
 
\change_inserted 1311305628 1585762040
10
\change_deleted 1311305628 1585762038
12
\change_unchanged
%, so measurements from this speed-run maneuver 
\change_deleted 1311305628 1586371974
indicate
\change_inserted 1311305628 1586371995
are consistent with the 
\change_deleted 1311305628 1586372002
 that the 
\change_inserted 1311305628 1586372006
predicted 
\change_unchanged
time response 
\change_deleted 1311305628 1586372019
determined for the heated HARCO sensor is valid 
\change_unchanged
to within about this uncertainty.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<SRnodelay, include=TRUE, fig.pos='t', fig.cap='The recovery temperature
 measured 
\change_inserted 1311305628 1586297417
by a heated HARCO sensor 
\change_unchanged
during the speed-run maneuver shown in the previous figure
\change_deleted 1311305628 1586297403
, without any imposed delay
\change_unchanged
.
 
\change_inserted 1311305628 1586371848
The abscissa is the dynamic-heating term, where $V$ is the airspeed and
 $Cp$ is the specific heat at constant pressure.
 The measurements while the airspeed was increasing are shown by the green
 line and those for decreasing airspeed by the red line.
 
\change_unchanged
The dashed orange line indicates the regression fit, with standard deviation
 about the fit of 0.26$^{
\backslash

\backslash
circ}$C.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Cp <- SpecificHeats (DSR$EWX / DSR$PSXC)[, 1]
\end_layout

\begin_layout Plain Layout

DSR$X <- DSR$TASX ^ 2 / (2 * Cp)
\end_layout

\begin_layout Plain Layout

Rate <- 1
\end_layout

\begin_layout Plain Layout

if (grepl('h', Flight)) {
\end_layout

\begin_layout Plain Layout

  Rate <- 25
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

DSR$RT <- DSR$RTH1
\end_layout

\begin_layout Plain Layout

DSS <- DSR
\end_layout

\begin_layout Plain Layout

DSR <- DSR %>% selectTime(32310, 32700)
\end_layout

\begin_layout Plain Layout

DSR <- transferAttributes(DSS, DSR)
\end_layout

\begin_layout Plain Layout

cf <- coef(fm <- lm (RT ~ X, data = DSR))
\end_layout

\begin_layout Plain Layout

rms <- summary(fm)$sigma
\end_layout

\begin_layout Plain Layout

RTSEL <- 'RTH1'
\end_layout

\begin_layout Plain Layout

xp <- c(min(DSR$X, na.rm = TRUE), max(DSR$X, na.rm = TRUE))
\end_layout

\begin_layout Plain Layout

yp <- cf[1] + cf[2] * xp
\end_layout

\begin_layout Plain Layout

d <- data.frame(xp = xp, yp = yp)
\end_layout

\begin_layout Plain Layout

Xlab <- expression(paste(V ^ 2, '/(2', 
\change_inserted 1311305628 1586297433
C
\change_deleted 1311305628 1586297433
c
\change_unchanged
[p], ')', sep = ''))
\end_layout

\begin_layout Plain Layout

dX <- c(0, diff(DSR$X))
\end_layout

\begin_layout Plain Layout

dXS <- SmoothInterp(dX)
\end_layout

\begin_layout Plain Layout

DSR$RT2 <- DSR$RT
\end_layout

\begin_layout Plain Layout

DSR$RT1 <- DSR$RT
\end_layout

\begin_layout Plain Layout

DSR$RT2[dXS <= 0] <- NA  # Don't plot decreasing-speed as green
\end_layout

\begin_layout Plain Layout

DSR$RT1[dXS >= 0] <- NA
\end_layout

\begin_layout Plain Layout

delay <- 0
\end_layout

\begin_layout Plain Layout

g <- ggplot (data = DSR, aes(x = X, y = RT))
\end_layout

\begin_layout Plain Layout

if (Rate == 1) {
\end_layout

\begin_layout Plain Layout

  g <- g + geom_point(colour = 'blue')
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(aes(y = RT1, colour = 'decreasing'),
\end_layout

\begin_layout Plain Layout

                   na.rm = TRUE,
\end_layout

\begin_layout Plain Layout

                   lwd = 1.8)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(aes(y = RT2, colour = 'increasing'),
\end_layout

\begin_layout Plain Layout

                   lwd = 1.8,
\end_layout

\begin_layout Plain Layout

                   na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(
\end_layout

\begin_layout Plain Layout

  data = d,
\end_layout

\begin_layout Plain Layout

  aes(x = xp, y = yp),
\end_layout

\begin_layout Plain Layout

  colour = 'darkorange',
\end_layout

\begin_layout Plain Layout

  lwd = 1.5,
\end_layout

\begin_layout Plain Layout

  lty = 2
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

# g <-
\end_layout

\begin_layout Plain Layout

#  g + ggtitle(sprintf(
\end_layout

\begin_layout Plain Layout

#    'sensor is %s; fit coefficients %.1f %.2f rms %.3f; no delay',
\end_layout

\begin_layout Plain Layout

#    RTSEL,
\end_layout

\begin_layout Plain Layout

#    cf[1],
\end_layout

\begin_layout Plain Layout

#    cf[2],
\end_layout

\begin_layout Plain Layout

#    rms
\end_layout

\begin_layout Plain Layout

#  ))
\end_layout

\begin_layout Plain Layout

g <- g + scale_colour_manual (
\end_layout

\begin_layout Plain Layout

  name = 'airspeed: ',
\end_layout

\begin_layout Plain Layout

  values = c("increasing" = "forestgreen", "decreasing" = "red")
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

# print (sprintf('RTX is %s; fit coefficients %.3f %.3f rms %.2f; delay %d
 ms',
\end_layout

\begin_layout Plain Layout

#   RTSEL, cf[1], cf[2], rms, input$sliderSR))
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  g + ylab(expression(paste('Recovery Temperature [', degree, 'C]'))) +
 
\end_layout

\begin_layout Plain Layout

  xlab(Xlab) + 
\end_layout

\begin_layout Plain Layout

  theme_WAC(1)
\end_layout

\begin_layout Plain Layout

g + theme(plot.title = element_text(size = 12))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<srRTH1delay, include=TRUE, fig.pos='t', fig.cap='The same measurements as
 shown in the previous figure but with the measurements of recovery temperature
 corrected  to compensate for the response time of the heated HARCO sensor.
 The residual standard deviation about the fit is $0.1
\change_inserted 1311305628 1585762179
0
\change_deleted 1311305628 1585762179
2
\change_unchanged
^{
\backslash

\backslash
circ}$C after this correction.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

delay <- -2200
\end_layout

\begin_layout Plain Layout

DSR <- DSS
\end_layout

\begin_layout Plain Layout

MRHO <- MachNumber(DSR$PSXC, DSR$QCXC) * DSR$PSXC * 100 / 
\end_layout

\begin_layout Plain Layout

        (287.05 * (273.15 + DSR$ATX)) / rhozero
\change_inserted 1311305628 1585749901

\end_layout

\begin_layout Plain Layout

\change_deleted 1311305628 1585756708

\end_layout

\begin_layout Plain Layout

a <- bestSH[1]
\end_layout

\begin_layout Plain Layout

tau1 <- bestSH[2] * (
\change_inserted 1311305628 1585748606
0.3 / 
\change_unchanged
MRHO
\change_deleted 1311305628 1585748609
 / 0.3
\change_unchanged
) ^ 0.6  ## Note that these are variable
\end_layout

\begin_layout Plain Layout

tau2 <- bestSH[3] * (
\change_inserted 1311305628 1585748621
0.3 / 
\change_unchanged
MRHO
\change_deleted 1311305628 1585748615
 / 0.3
\change_unchanged
) ^ 0.6
\end_layout

\begin_layout Plain Layout

## RT is the working solution
\end_layout

\begin_layout Plain Layout

Rate <- attr (DSR, 'Rate')
\end_layout

\begin_layout Plain Layout

DSR$DTMDT <- c(0, diff(DSR$RTH1, 2), 0) * Rate / 2
\end_layout

\begin_layout Plain Layout

DSR$DTM2DT2 <- (c(diff(DSR$RTH1), 0) - c(0, diff(DSR$RTH1))) * Rate^2
\end_layout

\begin_layout Plain Layout

DSR$RT <- (tau1 + tau2) * DSR$DTMDT + DSR$RTH1 + tau1 * tau2 * DSR$DTM2DT2
\end_layout

\begin_layout Plain Layout

# DSR$RT <- ShiftInTime(DSR[, RTSEL], .rate=Rate, .shift = delay)
\end_layout

\begin_layout Plain Layout

DSR <- DSR %>% selectTime(32310, 32700)
\end_layout

\begin_layout Plain Layout

DSR <- transferAttributes(DSS, DSR)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585756726

N <- 2^13  ## encompasses the speed run
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585756726

Nby2 <- N / 2
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585756726

N1 <- (N - nrow(DSR)) %/% 2
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585756726

N2 <- N - nrow(DSR) - N1
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585756726

RTH1 <- c(rep(DSR$RTH1[1], N1), DSR$RTH1, rep(DSR$RTH1[nrow(DSR)], N2))
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585756726

ff1 <- fft(RTH1)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585756726

RTH <- Re(fft(ff1, inverse=TRUE)) / N
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585756726

df <- Rate / N
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585756726

frq <- c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585756726

fr <- log(frq[1:(Nby2+1)])
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585756726

## Get the transfer function from the fitted parameterized form:
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585756726

Ph <- cfHARCO[1] + cfHARCO[2] * fr + 
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585756726

           cfHARCO[3] * fr^2 + cfHARCO[4] * atan(frq[1:(Nby2+1)])
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585756726

Ph[1] <- 0
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585756726

G <- cfrHARCO[1] + fr * (cfrHARCO[2] + fr * fr * (cfrHARCO[3] + 
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585756726

           fr * (cfrHARCO[4] + fr * cfrHARCO[5])))
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585756726

G[frq[1:length(fr)] < 0.024] <- 1
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585756726

G[frq[1:length(fr)] > 2] <- G[which.min(abs(frq-2))]
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585756726

H <- rep(complex(modulus=0), N)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585756726

H[1:(Nby2+1)] <- complex(modulus=G, argument=Ph * pi / 180)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585756726

H[(Nby2+2):N] <- rev(Conj(H[2:Nby2]))
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585756726

RTC <- Re(fft(ff1 / H, inverse = TRUE)) / N
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585756726

DSR$RTC <- RTC[(N1+1):(N-N2)]
\end_layout

\begin_layout Plain Layout

cf <- coef(fm <- lm (RT ~ X, data = DSR))
\end_layout

\begin_layout Plain Layout

xp <- c(min(DSR$X, na.rm = TRUE), max(DSR$X, na.rm = TRUE))
\end_layout

\begin_layout Plain Layout

yp <- cf[1] + cf[2] * xp
\end_layout

\begin_layout Plain Layout

d <- data.frame(xp = xp, yp = yp)
\end_layout

\begin_layout Plain Layout

rms <- summary(fm)$sigma
\end_layout

\begin_layout Plain Layout

DSR$RT2 <- DSR$RT
\end_layout

\begin_layout Plain Layout

DSR$RT1 <- DSR$RT
\end_layout

\begin_layout Plain Layout

DSR$RT2[dXS <= 0] <- NA  # Don't plot decreasing-speed as green
\end_layout

\begin_layout Plain Layout

DSR$RT1[dXS >= 0] <- NA
\end_layout

\begin_layout Plain Layout

g <- ggplot (data = DSR, aes(x = X, y = RT))
\end_layout

\begin_layout Plain Layout

if (Rate == 1) {
\end_layout

\begin_layout Plain Layout

  g <- g + geom_point(colour = 'blue')
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(aes(y = RT1, colour = 'decreasing'),
\end_layout

\begin_layout Plain Layout

                   na.rm = TRUE,
\end_layout

\begin_layout Plain Layout

                   lwd = 1.8)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(aes(y = RT2, colour = 'increasing'),
\end_layout

\begin_layout Plain Layout

                   lwd = 1.8,
\end_layout

\begin_layout Plain Layout

                   na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(
\end_layout

\begin_layout Plain Layout

  data = d,
\end_layout

\begin_layout Plain Layout

  aes(x = xp, y = yp),
\end_layout

\begin_layout Plain Layout

  colour = 'darkorange',
\end_layout

\begin_layout Plain Layout

  lwd = 1.5,
\end_layout

\begin_layout Plain Layout

  lty = 2
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  g + scale_colour_manual (
\end_layout

\begin_layout Plain Layout

    name = 'airspeed: ',
\end_layout

\begin_layout Plain Layout

    values = c("increasing" = "forestgreen", "decreasing" = "red")
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

# print (sprintf('RTX is %s; fit coefficients %.3f %.3f rms %.2f; delay %d
 ms',
\end_layout

\begin_layout Plain Layout

#   RTSEL, cf[1], cf[2], rms, input$sliderSR))
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  g + ylab(expression(paste('Recovery Temperature [', degree, 'C]'))) +
 xlab(Xlab) + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

g + theme(plot.title = element_text(size = 12))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Extra
inverted 0
status open

\begin_layout Subsection
The measured temperature in an inertial sub-range
\end_layout

\begin_layout Standard
One further check of the time-constant parameters can be obtained by comparing
 the slope of the spectral variance of the recovery temperature to the expected
 slope in an inertial sub-range.
 Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:VCLS2}
\end_layout

\end_inset

 shows an example of the measured variance spectrum for the recovery temperature
 measured during a low-level flight segment similar to those used to determine
 the phase lag in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:The-unheated-Rosemount"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The turbulent air motions in this region are consistent with expectations
 for an inertial sub-range, so it might be expected that the slope would
 conform to the expected 
\begin_inset Formula $-5/3$
\end_inset

 slope (or 
\begin_inset Formula $-2/3$
\end_inset

 in this spectrum that is weighted by the frequency).
 The measured spectrum (for TTRR) decreases a little more rapidly with frequency
 than expected but does not appear to be as far from the expected slope
 as would be expected from the transfer function, for example on the basis
 of Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:LTsolution}
\end_layout

\end_inset

.
 If the spectrum is corrected according to the transfer function, the result,
 shown as the variable 
\begin_inset Quotes eld
\end_inset

TTRRC,
\begin_inset Quotes erd
\end_inset

 has significant excess variance above about 2
\begin_inset space ~
\end_inset

Hz.
 The spectral variance as measured and as corrected both appear to be too
 high.
 This is not understood but appears to indicate that there is some spurious
 contribution to the variance at 2
\begin_inset space ~
\end_inset

Hz and above.
 This was also evident in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:checkAmplitude}
\end_layout

\end_inset

, where some source of variance other than dynamic heating appears to contribute
 to the amplitude fluctuations above 3
\begin_inset space ~
\end_inset

Hz.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<VCLS2, include=TRUE, echo=FALSE, fig.cap='The variance spectrum for the
 recovery temperature measured by a Rosemount 102E4AL sensor during a flight
 segment from VOCALS C-130 flight 3, 11:39:00 -- 11:52:00 UTC.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

D <- getNetCDF(
\end_layout

\begin_layout Plain Layout

  file.path(DataDirectory(), 'VOCALS/VOCALSrf03h.nc'),
\end_layout

\begin_layout Plain Layout

  c('TASX', 'PALT', 'TTRR', 'ATRR'),
\end_layout

\begin_layout Plain Layout

  113800,
\end_layout

\begin_layout Plain Layout

  115300
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

D$DH <- D$TASX ^ 2 / 2010
\end_layout

\begin_layout Plain Layout

DT <- D %>% selectTime(113900, 115200)
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  VSpecC(
\end_layout

\begin_layout Plain Layout

    DT,
\end_layout

\begin_layout Plain Layout

    'TTRR',
\end_layout

\begin_layout Plain Layout

    spans = 99,
\end_layout

\begin_layout Plain Layout

    xlim = c(0.01, 15),
\end_layout

\begin_layout Plain Layout

    ylim = c(1.e-5, 1.e-1)
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

DT$TTRRC <- DT$TTRR
\end_layout

\begin_layout Plain Layout

VSpecC(DT,
\end_layout

\begin_layout Plain Layout

       'TTRRC',
\end_layout

\begin_layout Plain Layout

       add = g,
\end_layout

\begin_layout Plain Layout

       corrected = TRUE,
\end_layout

\begin_layout Plain Layout

       Par = Param1) + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

# g <- VSpec(DT, 'ATRR', spans=99, add=g)
\end_layout

\begin_layout Plain Layout

# VSpec(DT, 'DH', spans=99, add=g) + theme_WAC()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

<<specialVSpec>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#' @title VSpec ## SPECIAL FOR SHOWING TRANSFER-FUNCTION MOD
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

VSpecC <-
\end_layout

\begin_layout Plain Layout

  function (.data,
\end_layout

\begin_layout Plain Layout

            .Variable = NA,
\end_layout

\begin_layout Plain Layout

            VLabel = NA,
\end_layout

\begin_layout Plain Layout

            col = NA,
\end_layout

\begin_layout Plain Layout

            type = 'spectrum',
\end_layout

\begin_layout Plain Layout

            corrected = FALSE,
\end_layout

\begin_layout Plain Layout

            method = NA,
\end_layout

\begin_layout Plain Layout

            xlim = NA,
\end_layout

\begin_layout Plain Layout

            ylim = NA,
\end_layout

\begin_layout Plain Layout

            Par = NA,
\end_layout

\begin_layout Plain Layout

            # c(0.001, 15), ylim=c(0.0001,1),
\end_layout

\begin_layout Plain Layout

            spans = 49,
\end_layout

\begin_layout Plain Layout

            ae = 0.2,
\end_layout

\begin_layout Plain Layout

            smoothBins = 0,
\end_layout

\begin_layout Plain Layout

            segLength = 512,
\end_layout

\begin_layout Plain Layout

            poles = 50,
\end_layout

\begin_layout Plain Layout

            resolution = 0.0001,
\end_layout

\begin_layout Plain Layout

            showErrors = 0,
\end_layout

\begin_layout Plain Layout

            WavelengthScale = TRUE,
\end_layout

\begin_layout Plain Layout

            ADD = NA,
\end_layout

\begin_layout Plain Layout

            add = NA,
\end_layout

\begin_layout Plain Layout

            EDR = FALSE,
\end_layout

\begin_layout Plain Layout

            WACtheme = NA) {
\end_layout

\begin_layout Plain Layout

    if (!is.data.frame(.data)) {
\end_layout

\begin_layout Plain Layout

      # See if the first argument can be split into a data.frame and a variable:
\end_layout

\begin_layout Plain Layout

      X <- substitute(.data)
\end_layout

\begin_layout Plain Layout

      if (is.call(X)) {
\end_layout

\begin_layout Plain Layout

        V <- try(eval(X), silent = TRUE)
\end_layout

\begin_layout Plain Layout

        if (grepl('Error', V[[1]])) {
\end_layout

\begin_layout Plain Layout

          V <- eval(plyr::as.quoted(X))  # eval(X) for names()
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        if (is.character(V[1])) {
\end_layout

\begin_layout Plain Layout

          
\end_layout

\begin_layout Plain Layout

        } else {
\end_layout

\begin_layout Plain Layout

          V <- plyr::as.quoted(X)
\end_layout

\begin_layout Plain Layout

          if (is.symbol(V[[1]])) {
\end_layout

\begin_layout Plain Layout

            V <- vapply(V, deparse, 'character')
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        V <- plyr::as.quoted(X)
\end_layout

\begin_layout Plain Layout

        if (is.symbol(V[[1]])) {
\end_layout

\begin_layout Plain Layout

          V <- vapply(V, deparse, 'character')
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      # print (c('first argument evaluates to', V))
\end_layout

\begin_layout Plain Layout

      # Extract data.frame:
\end_layout

\begin_layout Plain Layout

      .data <- get(V[[1]])
\end_layout

\begin_layout Plain Layout

      .Variable <- V[[2]]
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    # print(str(.data))
\end_layout

\begin_layout Plain Layout

    if (is.data.frame(.data)) {
\end_layout

\begin_layout Plain Layout

      ## must be true, or exit.
 Needs to contain Time and TASX
\end_layout

\begin_layout Plain Layout

      ## in addition to .Variable
\end_layout

\begin_layout Plain Layout

      nm <- names(.data)
\end_layout

\begin_layout Plain Layout

      V <- try(is.na(.Variable), silent = TRUE)
\end_layout

\begin_layout Plain Layout

      if (grepl('Error', V[[1]])) {
\end_layout

\begin_layout Plain Layout

        X <- substitute(.Variable)
\end_layout

\begin_layout Plain Layout

        if (is.call(X)) {
\end_layout

\begin_layout Plain Layout

          V <- try(eval(X), silent = TRUE)
\end_layout

\begin_layout Plain Layout

          if (grepl('Error', V[[1]])) {
\end_layout

\begin_layout Plain Layout

            V <- eval(plyr::as.quoted(X))  # eval(X) for names()
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          if (is.character(V[1])) {
\end_layout

\begin_layout Plain Layout

            
\end_layout

\begin_layout Plain Layout

          } else {
\end_layout

\begin_layout Plain Layout

            V <- plyr::as.quoted(X)
\end_layout

\begin_layout Plain Layout

            if (is.symbol(V[[1]])) {
\end_layout

\begin_layout Plain Layout

              V <- vapply(V, deparse, 'character')
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        } else {
\end_layout

\begin_layout Plain Layout

          V <- plyr::as.quoted(X)
\end_layout

\begin_layout Plain Layout

          if (is.symbol(V[[1]])) {
\end_layout

\begin_layout Plain Layout

            V <- vapply(V, deparse, 'character')
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        .Variable <- V
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      if (is.na(.Variable[1])) {
\end_layout

\begin_layout Plain Layout

        nm <- nm[-which('Time' == nm)]
\end_layout

\begin_layout Plain Layout

        nm <- nm[-which('TASX' == nm)]
\end_layout

\begin_layout Plain Layout

        .Variable <- nm
\end_layout

\begin_layout Plain Layout

        if (length(.Variable) > 3) {
\end_layout

\begin_layout Plain Layout

          .Variable <- .Variable[1:3]
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      print('VSpec ERROR: first argument is not a data.frame.')
\end_layout

\begin_layout Plain Layout

      return (NA)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if (is.null(attr(.data, 'Rate'))) {
\end_layout

\begin_layout Plain Layout

      print ('VSpec warning: Rate attribute missing from data.frame, so using
 Rate=1')
\end_layout

\begin_layout Plain Layout

      Rate <- 1
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      Rate <- attr(.data, 'Rate')
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if (is.na(xlim[1])) {
\end_layout

\begin_layout Plain Layout

      if (Rate == 1) {
\end_layout

\begin_layout Plain Layout

        xlim <- c(0.001, 1)
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        xlim <- c(0.001, 15)
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if (is.na(ylim[1])) {
\end_layout

\begin_layout Plain Layout

      ylim <- c(1.e-4, 1.)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if (!is.na(method)) {
\end_layout

\begin_layout Plain Layout

      type <- method
\end_layout

\begin_layout Plain Layout

    }  ## method over-rides if present
\end_layout

\begin_layout Plain Layout

    for (.V in .Variable) {
\end_layout

\begin_layout Plain Layout

      if (.V %in% names(.data)) {
\end_layout

\begin_layout Plain Layout

        NV <- which(.V == .Variable)
\end_layout

\begin_layout Plain Layout

        Z <- capture.output (v <- detrend (.data[, c('Time', .V)]))
\end_layout

\begin_layout Plain Layout

        if (!is.na(VLabel[1]) &&
\end_layout

\begin_layout Plain Layout

            length(VLabel) >= NV) {
\end_layout

\begin_layout Plain Layout

          ## use this alternate name in legend
\end_layout

\begin_layout Plain Layout

          V <- VLabel[NV]
\end_layout

\begin_layout Plain Layout

        } else {
\end_layout

\begin_layout Plain Layout

          V <- .V
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        print(sprintf(
\end_layout

\begin_layout Plain Layout

          'VSpec ERROR: Variable %s is not in the supplied data.frame',
\end_layout

\begin_layout Plain Layout

          .V
\end_layout

\begin_layout Plain Layout

        ))
\end_layout

\begin_layout Plain Layout

        return (NA)
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      if (type != 'spectrum' &&
\end_layout

\begin_layout Plain Layout

          type != 'Welch' && type != 'MEM' && type != 'mem') {
\end_layout

\begin_layout Plain Layout

        print (sprintf ('type %s is unavailable; using type=spectrum', type))
\end_layout

\begin_layout Plain Layout

        type <- 'spectrum'
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      siglim <- 1  ## 1-sigma error limits
\end_layout

\begin_layout Plain Layout

      if (type == 'spectrum') {
\end_layout

\begin_layout Plain Layout

        if (!is.null(spans[1])) {
\end_layout

\begin_layout Plain Layout

          if (!(spans[1] %% 2)) {
\end_layout

\begin_layout Plain Layout

            spans[1] <- spans[1] + 1
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          if (spans[1] <= 5) {
\end_layout

\begin_layout Plain Layout

            spans <- NULL
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        S <-
\end_layout

\begin_layout Plain Layout

          spectrum (ts(
\end_layout

\begin_layout Plain Layout

            SmoothInterp(v, .maxGap = 1000 * Rate, .Length = 0),
\end_layout

\begin_layout Plain Layout

            frequency = Rate
\end_layout

\begin_layout Plain Layout

          ),
\end_layout

\begin_layout Plain Layout

          span = spans,
\end_layout

\begin_layout Plain Layout

          plot = FALSE)
\end_layout

\begin_layout Plain Layout

        freq <- S$freq
\end_layout

\begin_layout Plain Layout

        if (corrected) {
\end_layout

\begin_layout Plain Layout

          ARX <- LTphase(freq, Par)
\end_layout

\begin_layout Plain Layout

          S$spec <- S$spec / ARX$Amp ^ 2
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        fpf <- 2 * S$spec * freq
\end_layout

\begin_layout Plain Layout

      } else if (type == 'Welch') {
\end_layout

\begin_layout Plain Layout

        ## bspec section
\end_layout

\begin_layout Plain Layout

        ## force segLength to a power of 2
\end_layout

\begin_layout Plain Layout

        segl <- segLength
\end_layout

\begin_layout Plain Layout

        rsl <- log(segl) / log(2)
\end_layout

\begin_layout Plain Layout

        ns <- round (rsl)
\end_layout

\begin_layout Plain Layout

        if (2 ^ ns != segl) {
\end_layout

\begin_layout Plain Layout

          if (2 ^ ns > segl) {
\end_layout

\begin_layout Plain Layout

            segl <- 2 ^ (ns - 1)
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          else {
\end_layout

\begin_layout Plain Layout

            segl <- 2 ^ (ns + 1)
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          segLength <- segl
\end_layout

\begin_layout Plain Layout

          print (sprintf ('reset segLength to %d', segLength))
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        S2 <-
\end_layout

\begin_layout Plain Layout

          bspec::welchPSD (
\end_layout

\begin_layout Plain Layout

            ts(SmoothInterp(v, .Length = 0), frequency = Rate),
\end_layout

\begin_layout Plain Layout

            seglength = segLength,
\end_layout

\begin_layout Plain Layout

            windowfun = bspec::hammingwindow
\end_layout

\begin_layout Plain Layout

          )
\end_layout

\begin_layout Plain Layout

        # ci <- quantile.bspec(BSP, probs = c(0.025, 0.975),
\end_layout

\begin_layout Plain Layout

        #   two.sided = FALSE)
\end_layout

\begin_layout Plain Layout

        coverage <- 0.683
\end_layout

\begin_layout Plain Layout

        tail <- 1 - coverage
\end_layout

\begin_layout Plain Layout

        df <- 2 * 9 * S2$segments / 11 ##1.768849
\end_layout

\begin_layout Plain Layout

        upper.quantile <-
\end_layout

\begin_layout Plain Layout

          1 - tail * pchisq(df, df, lower.tail = FALSE)
\end_layout

\begin_layout Plain Layout

        lower.quantile <- tail * pchisq(df, df)
\end_layout

\begin_layout Plain Layout

        ci <- 1 / (qchisq(c(upper.quantile, lower.quantile), df) / df)
\end_layout

\begin_layout Plain Layout

        df <- 1.46 * (S2$segments + 1)
\end_layout

\begin_layout Plain Layout

        lower.limit <- qchisq (pnorm(-siglim), df) / df
\end_layout

\begin_layout Plain Layout

        upper.limit <- qchisq (pnorm(siglim), df) / df
\end_layout

\begin_layout Plain Layout

        # ci <- 0.5 + (ci-0.5) / sqrt(9 * S2$segments / 11)
\end_layout

\begin_layout Plain Layout

        # print (sprintf ('ci2=%.3f -- %.3f segments %d', ci[1], ci[2], S2$segment
s))
\end_layout

\begin_layout Plain Layout

        freq <- S2$frequency[-1]
\end_layout

\begin_layout Plain Layout

        fpf <- S2$power[-1] * freq
\end_layout

\begin_layout Plain Layout

      } else if (type == 'MEM' || type == 'mem') {
\end_layout

\begin_layout Plain Layout

        ## MEM section
\end_layout

\begin_layout Plain Layout

        A <- memCoef (v, poles)
\end_layout

\begin_layout Plain Layout

        ld <- nrow(.data)
\end_layout

\begin_layout Plain Layout

        fmin <- log (Rate / ld)
\end_layout

\begin_layout Plain Layout

        fmax <- log (0.5 * Rate)
\end_layout

\begin_layout Plain Layout

        bins <- as.integer (1 / resolution)
\end_layout

\begin_layout Plain Layout

        df <- (fmax - fmin) / bins
\end_layout

\begin_layout Plain Layout

        fdtl <- fmin + df * (0:bins)
\end_layout

\begin_layout Plain Layout

        freq <- exp (fdtl)
\end_layout

\begin_layout Plain Layout

        psComplex <- memEstimate (freq / Rate, A) / Rate
\end_layout

\begin_layout Plain Layout

        ps <- 2 * Rate * Mod (psComplex) ^ 2
\end_layout

\begin_layout Plain Layout

        fpf <- freq * ps
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      tasAverage <- mean(.data$TASX, na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

      if (EDR) {
\end_layout

\begin_layout Plain Layout

        ps <- fpf / freq
\end_layout

\begin_layout Plain Layout

        fpf <- (2 * pi / tasAverage) * (1.5 * ps) ^ 1.5 * freq ^ 2.5
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      if (smoothBins > 9) {
\end_layout

\begin_layout Plain Layout

        bs1 <- binStats(data.frame(fpf, log(freq)), bins = smoothBins)
\end_layout

\begin_layout Plain Layout

        bs1 <-
\end_layout

\begin_layout Plain Layout

          rbind (bs1,
\end_layout

\begin_layout Plain Layout

                 data.frame(
\end_layout

\begin_layout Plain Layout

                   xc = bs1$xc[nrow(bs1)],
\end_layout

\begin_layout Plain Layout

                   ybar = bs1$ybar[nrow(bs1)],
\end_layout

\begin_layout Plain Layout

                   sigma = bs1$sigma[nrow(bs1)],
\end_layout

\begin_layout Plain Layout

                   nb = 1
\end_layout

\begin_layout Plain Layout

                 ))
\end_layout

\begin_layout Plain Layout

        bs1 <- bs1[!is.na(bs1$ybar), ]
\end_layout

\begin_layout Plain Layout

        freq <- exp(bs1$xc)
\end_layout

\begin_layout Plain Layout

        fpf <- bs1$ybar
\end_layout

\begin_layout Plain Layout

        bs1$sigma <- ifelse (bs1$nb > 2, bs1$sigma / sqrt(bs1$nb), NA)
\end_layout

\begin_layout Plain Layout

        rna <- is.na(bs1$sigma)
\end_layout

\begin_layout Plain Layout

        bs1$sigma[rna] <- bs1$ybar[rna] / 2
\end_layout

\begin_layout Plain Layout

        # bs1 <<- bs1
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      if (.V == .Variable[1]) {
\end_layout

\begin_layout Plain Layout

        DF <- data.frame(freq, fpf)
\end_layout

\begin_layout Plain Layout

      } else if (.V == .Variable[2]) {
\end_layout

\begin_layout Plain Layout

        DF$fpf2 <- fpf
\end_layout

\begin_layout Plain Layout

      } else if (.V == .Variable[3]) {
\end_layout

\begin_layout Plain Layout

        DF$fpf3 <- fpf
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    VL <- .Variable
\end_layout

\begin_layout Plain Layout

    if (!is.na(VLabel[1])) {
\end_layout

\begin_layout Plain Layout

      VL <- VLabel
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if (is.na(col[1])) {
\end_layout

\begin_layout Plain Layout

      col = c("blue", "forestgreen", "black", "darkorange")
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if (!is.na(add[1])) {
\end_layout

\begin_layout Plain Layout

      ADD <- add
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    for (.V in .Variable) {
\end_layout

\begin_layout Plain Layout

      NV <- which(.V == .Variable)
\end_layout

\begin_layout Plain Layout

      if (is.na(ADD[1])) {
\end_layout

\begin_layout Plain Layout

        if (NV == 1) {
\end_layout

\begin_layout Plain Layout

          ## first call: redefine VSpecDF
\end_layout

\begin_layout Plain Layout

          try(rm(list = names(VSpecEnv), envir = VSpecEnv), silent = TRUE)
\end_layout

\begin_layout Plain Layout

          VSpecEnv$Variable <- .Variable
\end_layout

\begin_layout Plain Layout

          assign('VSpecDF1', DF, envir = VSpecEnv)
\end_layout

\begin_layout Plain Layout

          labx <- 'frequency [Hz]'
\end_layout

\begin_layout Plain Layout

          if (EDR) {
\end_layout

\begin_layout Plain Layout

            # laby <- sprintf('eddy dissipation rate for %s', .V)
\end_layout

\begin_layout Plain Layout

            laby <-
\end_layout

\begin_layout Plain Layout

              expression(paste("eddy dissipation rate [m" ^ "2", "s" ^ "-3",
 "]"))
\end_layout

\begin_layout Plain Layout

          } else {
\end_layout

\begin_layout Plain Layout

            laby <- sprintf('variance spectrum fP(f) for %s', .V)
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

          g <- ggplot(data = DF)
\end_layout

\begin_layout Plain Layout

          g <-
\end_layout

\begin_layout Plain Layout

            g + geom_path (aes(
\end_layout

\begin_layout Plain Layout

              x = freq,
\end_layout

\begin_layout Plain Layout

              y = fpf,
\end_layout

\begin_layout Plain Layout

              colour = VL[1]
\end_layout

\begin_layout Plain Layout

            ),
\end_layout

\begin_layout Plain Layout

            data = DF,
\end_layout

\begin_layout Plain Layout

            na.rm = TRUE) +
\end_layout

\begin_layout Plain Layout

            xlab(labx) + ylab (laby)
\end_layout

\begin_layout Plain Layout

          .clinesVSpec <- col[1]
\end_layout

\begin_layout Plain Layout

          names(.clinesVSpec) <- VL[1]
\end_layout

\begin_layout Plain Layout

          VSpecEnv$clinesVSpec <- .clinesVSpec
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        if (NV == 2) {
\end_layout

\begin_layout Plain Layout

          g <-
\end_layout

\begin_layout Plain Layout

            g + geom_path (aes(
\end_layout

\begin_layout Plain Layout

              x = freq,
\end_layout

\begin_layout Plain Layout

              y = fpf2,
\end_layout

\begin_layout Plain Layout

              colour = VL[2]
\end_layout

\begin_layout Plain Layout

            ),
\end_layout

\begin_layout Plain Layout

            data = DF,
\end_layout

\begin_layout Plain Layout

            na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

          cl2 <- ifelse (length(col) >= 2, col[2], 'forestgreen')
\end_layout

\begin_layout Plain Layout

          names(cl2) <- VL[2]
\end_layout

\begin_layout Plain Layout

          .clinesVSpec <- c(VSpecEnv$clinesVSpec, cl2)
\end_layout

\begin_layout Plain Layout

          VSpecEnv$clinesVSpec <- .clinesVSpec
\end_layout

\begin_layout Plain Layout

        } else if (NV == 3) {
\end_layout

\begin_layout Plain Layout

          g <-
\end_layout

\begin_layout Plain Layout

            g + geom_path (aes(
\end_layout

\begin_layout Plain Layout

              x = freq,
\end_layout

\begin_layout Plain Layout

              y = fpf3,
\end_layout

\begin_layout Plain Layout

              colour = VL[3]
\end_layout

\begin_layout Plain Layout

            ),
\end_layout

\begin_layout Plain Layout

            data = DF,
\end_layout

\begin_layout Plain Layout

            na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

          cl3 <- ifelse (length(col) >= 3, col[3], 'black')
\end_layout

\begin_layout Plain Layout

          names(cl3) <- VL[3]
\end_layout

\begin_layout Plain Layout

          .clinesVSpec <- c(VSpecEnv$clinesVSpec, cl3)
\end_layout

\begin_layout Plain Layout

          VSpecEnv$clinesVSpec <- .clinesVSpec
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        ## assign name based on elements in clinesVSpec
\end_layout

\begin_layout Plain Layout

        N <- length(VSpecEnv$clinesVSpec) + 1
\end_layout

\begin_layout Plain Layout

        nc <- names(VSpecEnv$clinesVSpec)
\end_layout

\begin_layout Plain Layout

        .clinesVSpec <- c(VSpecEnv$clinesVSpec, col[N])
\end_layout

\begin_layout Plain Layout

        names(.clinesVSpec) <- c(nc, V)
\end_layout

\begin_layout Plain Layout

        VSpecEnv$clinesVSpec <- .clinesVSpec
\end_layout

\begin_layout Plain Layout

        VName <- sprintf('VSpecDF%d', N)
\end_layout

\begin_layout Plain Layout

        assign(VName, DF, pos = VSpecEnv)
\end_layout

\begin_layout Plain Layout

        if (N == 2) {
\end_layout

\begin_layout Plain Layout

          VSpecEnv$VSpecVar2 <- V
\end_layout

\begin_layout Plain Layout

          g <-
\end_layout

\begin_layout Plain Layout

            ADD + geom_path (
\end_layout

\begin_layout Plain Layout

              aes(
\end_layout

\begin_layout Plain Layout

                x = freq,
\end_layout

\begin_layout Plain Layout

                y = fpf,
\end_layout

\begin_layout Plain Layout

                colour = VSpecEnv$VSpecVar2
\end_layout

\begin_layout Plain Layout

              ),
\end_layout

\begin_layout Plain Layout

              data = get(VName, envir = VSpecEnv),
\end_layout

\begin_layout Plain Layout

              na.rm = TRUE
\end_layout

\begin_layout Plain Layout

            )
\end_layout

\begin_layout Plain Layout

        } else if (N == 3) {
\end_layout

\begin_layout Plain Layout

          VSpecEnv$VSpecVar3 <- V
\end_layout

\begin_layout Plain Layout

          g <-
\end_layout

\begin_layout Plain Layout

            ADD + geom_path (
\end_layout

\begin_layout Plain Layout

              aes(
\end_layout

\begin_layout Plain Layout

                x = freq,
\end_layout

\begin_layout Plain Layout

                y = fpf,
\end_layout

\begin_layout Plain Layout

                colour = VSpecEnv$VSpecVar3
\end_layout

\begin_layout Plain Layout

              ),
\end_layout

\begin_layout Plain Layout

              data = get(VName, envir = VSpecEnv),
\end_layout

\begin_layout Plain Layout

              na.rm = TRUE
\end_layout

\begin_layout Plain Layout

            )
\end_layout

\begin_layout Plain Layout

        } else if (N == 4) {
\end_layout

\begin_layout Plain Layout

          VSpecEnv$VSpecVar4 <- V
\end_layout

\begin_layout Plain Layout

          g <-
\end_layout

\begin_layout Plain Layout

            ADD + geom_path (
\end_layout

\begin_layout Plain Layout

              aes(
\end_layout

\begin_layout Plain Layout

                x = freq,
\end_layout

\begin_layout Plain Layout

                y = fpf,
\end_layout

\begin_layout Plain Layout

                colour = VSpecEnv$VSpecVar4
\end_layout

\begin_layout Plain Layout

              ),
\end_layout

\begin_layout Plain Layout

              data = get(VName, envir = VSpecEnv),
\end_layout

\begin_layout Plain Layout

              na.rm = TRUE
\end_layout

\begin_layout Plain Layout

            )
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    g <-
\end_layout

\begin_layout Plain Layout

      suppressMessages(g + scale_colour_manual (name = '', values = .clinesVSpec)
)
\end_layout

\begin_layout Plain Layout

    # print (.clinesVSpec)
\end_layout

\begin_layout Plain Layout

    if (showErrors > 0) {
\end_layout

\begin_layout Plain Layout

      if (smoothBins > 9) {
\end_layout

\begin_layout Plain Layout

        bse <-
\end_layout

\begin_layout Plain Layout

          data.frame(
\end_layout

\begin_layout Plain Layout

            x = exp(bs1$xc),
\end_layout

\begin_layout Plain Layout

            ymin = bs1$ybar - showErrors * bs1$sigma,
\end_layout

\begin_layout Plain Layout

            ymax = bs1$ybar + showErrors * bs1$sigma
\end_layout

\begin_layout Plain Layout

          )
\end_layout

\begin_layout Plain Layout

        bse$ymin[bse$ymin < ylim[1]] <- ylim[1]
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        coverage <-
\end_layout

\begin_layout Plain Layout

          pnorm(showErrors) - pnorm(-showErrors)  ## 1-sigma, 0.68269
\end_layout

\begin_layout Plain Layout

        tail <- 1 - coverage
\end_layout

\begin_layout Plain Layout

        if (type == 'spectrum') {
\end_layout

\begin_layout Plain Layout

          df <- S$df
\end_layout

\begin_layout Plain Layout

        } else if (type == 'Welch') {
\end_layout

\begin_layout Plain Layout

          df <- 1.46 * (S2$segments + 1)
\end_layout

\begin_layout Plain Layout

        } else if (type == 'MEM') {
\end_layout

\begin_layout Plain Layout

          df <- length(v) / poles
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        uq <- 1 - tail * pchisq(df, df, lower.tail = FALSE)
\end_layout

\begin_layout Plain Layout

        lq <- tail * pchisq(df, df, lower.tail = TRUE)
\end_layout

\begin_layout Plain Layout

        ci <- 1 / (qchisq(c(uq, lq), df) / df)
\end_layout

\begin_layout Plain Layout

        lower.limit <- qchisq (pnorm(-showErrors), df) / df
\end_layout

\begin_layout Plain Layout

        upper.limit <- qchisq (pnorm(showErrors), df) / df
\end_layout

\begin_layout Plain Layout

        bse <-
\end_layout

\begin_layout Plain Layout

          data.frame(x = freq,
\end_layout

\begin_layout Plain Layout

                     ymin = lower.limit * fpf,
\end_layout

\begin_layout Plain Layout

                     ymax = upper.limit * fpf)
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      # g <- g + geom_ribbon(data=bs1, aes(x=exp(xc), ymin=max(ylim[1],
 ybar-showErrors*sigma), ymax=ybar+showErrors*sigma),
\end_layout

\begin_layout Plain Layout

      #   fill='cyan', alpha=0.25, show.legend=FALSE, inherit.aes=FALSE, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

      g <- g + geom_ribbon(
\end_layout

\begin_layout Plain Layout

        data = bse,
\end_layout

\begin_layout Plain Layout

        aes(x = x, ymin = ymin, ymax = ymax),
\end_layout

\begin_layout Plain Layout

        fill = 'gray50',
\end_layout

\begin_layout Plain Layout

        alpha = 0.5,
\end_layout

\begin_layout Plain Layout

        show.legend = FALSE,
\end_layout

\begin_layout Plain Layout

        inherit.aes = FALSE,
\end_layout

\begin_layout Plain Layout

        na.rm = TRUE
\end_layout

\begin_layout Plain Layout

      )
\end_layout

\begin_layout Plain Layout

      # bs1$xc <- exp(bs1$xc)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if (is.na(ADD[1])) {
\end_layout

\begin_layout Plain Layout

      g <-
\end_layout

\begin_layout Plain Layout

        g + scale_x_log10(
\end_layout

\begin_layout Plain Layout

          breaks = trans_breaks("log10", function(x)
\end_layout

\begin_layout Plain Layout

            10 ^ x, n = 4),
\end_layout

\begin_layout Plain Layout

          #limits = xlim,
\end_layout

\begin_layout Plain Layout

          labels = trans_format("log10", math_format(10 ^ .x))
\end_layout

\begin_layout Plain Layout

        ) +
\end_layout

\begin_layout Plain Layout

        scale_y_log10(
\end_layout

\begin_layout Plain Layout

          breaks = trans_breaks("log10", function(x)
\end_layout

\begin_layout Plain Layout

            10 ^ x, n = 4),
\end_layout

\begin_layout Plain Layout

          #limits = ylim,
\end_layout

\begin_layout Plain Layout

          labels = trans_format("log10", math_format(10 ^ .x))
\end_layout

\begin_layout Plain Layout

        ) +
\end_layout

\begin_layout Plain Layout

        annotation_logticks(sides = 'trbl') +
\end_layout

\begin_layout Plain Layout

        coord_cartesian(xlim = xlim, ylim = ylim)
\end_layout

\begin_layout Plain Layout

      # g <- g + theme(panel.grid.minor = element_line(colour = "black"))
\end_layout

\begin_layout Plain Layout

      if (EDR) {
\end_layout

\begin_layout Plain Layout

        ## add line showing highest-decade average EDR
\end_layout

\begin_layout Plain Layout

        imx <- length(freq)
\end_layout

\begin_layout Plain Layout

        imn <- which (freq > freq[imx] / 20)[1]
\end_layout

\begin_layout Plain Layout

        aveEDR <- mean(fpf[imn:imx], na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

        ttl <- sprintf ('EDR=%.2e', aveEDR)
\end_layout

\begin_layout Plain Layout

        DFL <- data.frame(x = c(freq[imn], freq[imx]), y = rep(aveEDR, 2))
\end_layout

\begin_layout Plain Layout

        g <-
\end_layout

\begin_layout Plain Layout

          g + geom_path(data = DFL,
\end_layout

\begin_layout Plain Layout

                        aes(x = x, y = y),
\end_layout

\begin_layout Plain Layout

                        lwd = 1.5,
\end_layout

\begin_layout Plain Layout

                        colour = 'red')
\end_layout

\begin_layout Plain Layout

        g <- g + ggtitle (bquote(.(ttl) ~ ' m' ^ 2 ~ 's' ^ -3))
\end_layout

\begin_layout Plain Layout

        # g <- g + ggtitle(sprintf(' mean eddy dissipation rate %.2e m^2/s^3',
 aveEDR))
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        for (i in (-8:0)) {
\end_layout

\begin_layout Plain Layout

          a = ae * 10.
 ^ (i * (2 / 3)) * tasAverage ^ (2 / 3)
\end_layout

\begin_layout Plain Layout

          lw = ifelse(i == -4, 1.2, 0.5)
\end_layout

\begin_layout Plain Layout

          DFL <-
\end_layout

\begin_layout Plain Layout

            data.frame(x = xlim, y = c(a / xlim[1] ^ (2 / 3), a / xlim[2]
 ^ (2 / 3)))
\end_layout

\begin_layout Plain Layout

          # print(DFL)
\end_layout

\begin_layout Plain Layout

          g <-
\end_layout

\begin_layout Plain Layout

            g + geom_path (
\end_layout

\begin_layout Plain Layout

              data = DFL,
\end_layout

\begin_layout Plain Layout

              aes(x = x, y = y),
\end_layout

\begin_layout Plain Layout

              colour = 'darkorange',
\end_layout

\begin_layout Plain Layout

              lwd = lw,
\end_layout

\begin_layout Plain Layout

              lty = 3
\end_layout

\begin_layout Plain Layout

            )
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      if (WavelengthScale) {
\end_layout

\begin_layout Plain Layout

        yl <- c(ylim[1] * 1.2, ylim[1] * 1.5)
\end_layout

\begin_layout Plain Layout

        lclr <- 'slategrey'
\end_layout

\begin_layout Plain Layout

        for (j1 in c(10, 100, 1000, 10000, 100000)) {
\end_layout

\begin_layout Plain Layout

          DFL2 <- data.frame(x = rep(tasAverage / j1, 2), y = yl)
\end_layout

\begin_layout Plain Layout

          g <-
\end_layout

\begin_layout Plain Layout

            g + geom_path(
\end_layout

\begin_layout Plain Layout

              data = DFL2,
\end_layout

\begin_layout Plain Layout

              aes(x = x, y = y),
\end_layout

\begin_layout Plain Layout

              colour = lclr,
\end_layout

\begin_layout Plain Layout

              lwd = 1.0
\end_layout

\begin_layout Plain Layout

            )
\end_layout

\begin_layout Plain Layout

          if (j1 != 100000) {
\end_layout

\begin_layout Plain Layout

            for (j2 in 2:9) {
\end_layout

\begin_layout Plain Layout

              DFL2 <- data.frame(x = rep(tasAverage / (j1 * j2), 2), y =
 yl)
\end_layout

\begin_layout Plain Layout

              g <-
\end_layout

\begin_layout Plain Layout

                g + geom_path(
\end_layout

\begin_layout Plain Layout

                  data = DFL2,
\end_layout

\begin_layout Plain Layout

                  aes(x = x, y = y),
\end_layout

\begin_layout Plain Layout

                  colour = lclr,
\end_layout

\begin_layout Plain Layout

                  lwd = 0.6
\end_layout

\begin_layout Plain Layout

                )
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

          }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        DFL2 <-
\end_layout

\begin_layout Plain Layout

          data.frame (x = tasAverage * c(1 / 10, 1 / 100000), y = rep(yl[1],
 2))
\end_layout

\begin_layout Plain Layout

        g <-
\end_layout

\begin_layout Plain Layout

          g + geom_path(data = DFL2,
\end_layout

\begin_layout Plain Layout

                        aes(x = x, y = y),
\end_layout

\begin_layout Plain Layout

                        colour = lclr,
\end_layout

\begin_layout Plain Layout

                        lwd = 1.0)
\end_layout

\begin_layout Plain Layout

        g <- g + annotate(
\end_layout

\begin_layout Plain Layout

          "text",
\end_layout

\begin_layout Plain Layout

          x = tasAverage * c(1 / 100000, 1 / 10000, 1 / 1000, 1 / 100, 1
 /
\end_layout

\begin_layout Plain Layout

                               10),
\end_layout

\begin_layout Plain Layout

          y = rep(yl[2] * 1.5, 5),
\end_layout

\begin_layout Plain Layout

          label = c("100 km", "10 km", "1 km", "0.1 km", " "),
\end_layout

\begin_layout Plain Layout

          colour = lclr
\end_layout

\begin_layout Plain Layout

        )
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      # g <- g + theme_WAC()
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if (!is.na(WACtheme)) {
\end_layout

\begin_layout Plain Layout

      g <- g + theme_WAC()
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    return(g)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\change_deleted 1311305628 1586299866

\end_layout

\begin_layout Standard

\change_deleted 1311305628 1586299866
Correcting the Temperature
\begin_inset CommandInset label
LatexCommand label
name "sec:Correcting-the-Temperature"

\end_inset


\end_layout

\begin_layout Standard

\change_deleted 1311305628 1586299866
The true recovery temperature 
\begin_inset Formula $T_{r}$
\end_inset

 can be retrieved from the measured temperature 
\begin_inset Formula $T_{m}$
\end_inset

 in two ways, either from the differential equations or by Fourier transformatio
n.
 These methods are illustrated here.
\end_layout

\begin_layout Standard

\change_deleted 1311305628 1586299866
Integration of the differential equations
\begin_inset CommandInset label
LatexCommand label
name "subsec:Integration-of-the"

\end_inset


\end_layout

\begin_layout Standard

\change_deleted 1311305628 1586299866
The differential equations 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 provide a basis for correcting the measured temperature to account for
 the time response of the sensor.
 They should be applied to the recovery temperature 
\begin_inset Formula $T_{r}(t)$
\end_inset

, which is the measurand.
 The actual measurement is 
\begin_inset Formula $T_{m}(t)$
\end_inset

 and the temperature of the support is 
\begin_inset Formula $T_{s}(t)$
\end_inset

, so those equations, rearranged, are:
\end_layout

\begin_layout Standard

\change_deleted 1311305628 1586299866
\begin_inset Formula 
\begin{equation}
\frac{dT_{s}(t)}{dt}=\frac{T_{r}(t)-T_{s}(t)}{\tau_{2}}\label{eq:Ts2}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
T_{r}(t)=\frac{1}{a}\left\{ \tau_{1}\frac{dT_{m}(t)}{dt}+T_{m}(T)-(1-a)T_{s}(t)\right\} \label{eq:Tm2}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard

\change_deleted 1311305628 1586299866
There are two unknowns (
\begin_inset Formula $T_{r}(t)$
\end_inset

, the actual recovery temperature, and 
\begin_inset Formula $T_{s}(t)$
\end_inset

).
 Those unknowns are specified by the two preceding equations because all
 other terms are known, including 
\begin_inset Formula $dT_{m}/dt$
\end_inset

 which can be represented using the numerical derivative of the measurements
 
\begin_inset Formula $T_{m}(t)$
\end_inset

.
 The second equation can be used to eliminate 
\begin_inset Formula $T_{r}$
\end_inset

 from the first:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\frac{dT_{s}(t)}{dt}=\frac{\frac{1}{a}\left\{ \tau_{1}\frac{dT_{m}(t)}{dt}+T_{m}(T)-(1-a)T_{s}(t)\right\} -T_{s}(t)}{\tau_{2}}\label{eq:Ts3}
\end{equation}

\end_inset

From an initial value 
\begin_inset Formula $T_{s}(0)$
\end_inset

, assumed to be 
\begin_inset Formula $T_{m}(0)$
\end_inset

, this equation can be integrated to find the temperature of the support,
 
\begin_inset Formula $T_{s}(t)$
\end_inset

.
 Once that is known, 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 specifies the estimate of the true recovery temperature 
\begin_inset Formula $T_{r}(t)$
\end_inset

 without further integration.
 The only choices needed are the numerical method used to find the derivative
 
\begin_inset Formula $dT_{m}/dt$
\end_inset

 (e.g., here from consecutive differences or higher-order approximations)
 and the integration method applied to 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts3"
plural "false"
caps "false"
noprefix "false"

\end_inset

, here a fourth-order Runge-Kutta integration with Cash-Karp 
\begin_inset CommandInset citation
LatexCommand citet
key "cash1990variable"
literal "false"

\end_inset

 adjustment of the step size.
\end_layout

\begin_layout Standard

\change_deleted 1311305628 1586299866
The HARCO presents a special case because the best-fit value is 
\begin_inset Formula $a=0$
\end_inset

 so 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 can't be used.
 However, in this case the differential equations can still be combined
 to give
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
T_{r}(t)=(\tau_{1}+\tau_{2})\frac{dT_{m}(t)}{dt}+T_{m}(t)+\tau_{2}\tau_{1}\frac{d^{2}T_{m}(t)}{dt^{2}}\label{eq:HARCOsoln}
\end{equation}

\end_inset

a form that can be used directly without integration because finite-difference
 equations can be used for the derivatives of the measured 
\begin_inset Formula $T_{m}(t)$
\end_inset

.
 However, this is not as good a representation of the transfer function
 as is possible with the fitted representation shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:GVHARCO}
\end_layout

\end_inset

 and given by 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:lfitH"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 That fit can be used with the Fourier-transform approach to correction,
 as shown in the next subsection.
\end_layout

\begin_layout Standard

\change_deleted 1311305628 1586299866
\begin_inset Branch Extra
inverted 0
status open

\begin_layout Standard
The heated Rosemount sensor presents a special case because the best-fit
 parameters included 
\begin_inset Formula $a=0$
\end_inset

 so it isn't possible to substitute 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 into 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 as for the other sensors.
 Instead, 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 can be solved to find the support temperature 
\begin_inset Formula $T_{s}(t)$
\end_inset

:
\begin_inset Formula 
\begin{equation}
T_{s}(t)=\tau_{1}\frac{dT_{m}(t)}{dt}+T_{m}(t)\label{eq:Ts4}
\end{equation}

\end_inset

which can be solved for 
\begin_inset Formula $T_{s}(t)$
\end_inset

 because both 
\begin_inset Formula $T_{m}(t)$
\end_inset

 and 
\begin_inset Formula $dT_{m}(t)/dt$
\end_inset

 are measured.
 With this solution and the resulting derivative 
\begin_inset Formula $dT_{s}(t)/dt$
\end_inset

 of this solution, 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 leads to 
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
T_{r}(t)=T_{s}(t)+\tau_{2}\frac{dT_{s}(t)}{dt}\label{eq:Tm4}
\end{equation}

\end_inset

which gives the solution directly (without integration) because all terms
 on the right side are known.
 The result could also be written by combining 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm4"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts4"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to give
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
T_{r}(t)=(\tau_{1}+\tau_{2})\frac{dT_{m}(t)}{dt}+T_{m}(t)+\tau_{2}\tau_{1}\frac{d^{2}T_{m}(t)}{dt^{2}}\label{eq:Tm5}
\end{equation}

\end_inset

which, without the second-derivative term, would represent a first-order
 response with time constant 
\begin_inset Formula $\tau=\tau_{1}+\tau_{2}$
\end_inset

.
 The transfer function for the HARCO (Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:rfHARCO}
\end_layout

\end_inset

 shows that, contrary to first-order response, the phase lag can be negative
 for some frequencies, so the second-derivative term plays an important
 role.
 The second derivative in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm5"
plural "false"
caps "false"
noprefix "false"

\end_inset

 can be represented, for example, by
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\frac{d^{2}T_{m}(t)}{dt^{2}}=\frac{T_{m}(t-\delta t)-2T_{m}(t)+T_{m}(t+\delta t)}{(\delta t)^{2}}\label{eq:deriv2nd}
\end{equation}

\end_inset

where all quantities on the right side are known from the measurement sequence.
 Equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm5"
plural "false"
caps "false"
noprefix "false"

\end_inset

 thus provides the corrected recovery temperature 
\begin_inset Formula $T_{r}(t)$
\end_inset

 without any need to calculate the temperature of the support.
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\change_deleted 1311305628 1586299866
\begin_inset ERT
status open

\begin_layout Plain Layout

<<method1, include=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

a <- Param1$a
\end_layout

\begin_layout Plain Layout

tau1 <- Param1$tau1
\end_layout

\begin_layout Plain Layout

tau2 <- Param1$tau2
\end_layout

\begin_layout Plain Layout

## RT is the working solution; Ts is the support temperature
\end_layout

\begin_layout Plain Layout

DT$Ts <- DT$RT
\end_layout

\begin_layout Plain Layout

Rate <- attr (DT, 'Rate')
\end_layout

\begin_layout Plain Layout

DT$DTMDT <- c(0, diff(DT$TTRR, 2), 0) * Rate / 2
\change_inserted 1311305628 1585841550

\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585841563

DT$DTMDT <-  (c(0, 8*diff(DT$TTRR, 2), 0) - 
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585841566

              c(0, 0, diff(DT$TTRR, 4), 0, 0)) * Rate / 12
\change_unchanged

\end_layout

\begin_layout Plain Layout

# DT$DTMDT <- (DT$DTMDT + c(0, DT$DTMDT[1:(nrow(DT)-1)])) / 2
\end_layout

\begin_layout Plain Layout

# DT$DTMDT <- as.vector (signal::filter(signal::sgolay(1, 3, m=1), DT$TTRR))
 * Rate
\end_layout

\begin_layout Plain Layout

fS <- function(y, i) {
\end_layout

\begin_layout Plain Layout

  # Eq.
 Ts3
\end_layout

\begin_layout Plain Layout

  ((tau1 * DT$DTMDT[i] + DT$TTRR[i] - (1 - a) * y)/a - y) / (Rate * tau2)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DT$Ts <- rk4.integrate (fS, DT$Ts[1], 1:nrow(DT))
\end_layout

\begin_layout Plain Layout

DT$RT <- (1 / a) * (tau1 * DT$DTMDT + DT$TTRR - (1 - a) * DT$Ts)
\end_layout

\begin_layout Plain Layout

DT %>% select(Time, TTRR, RT, Ts) %>% 
\end_layout

\begin_layout Plain Layout

  selectTime(114500, 114505) %>% 
\end_layout

\begin_layout Plain Layout

  plotWAC()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\change_deleted 1311305628 1586299866
\begin_inset ERT
status open

\begin_layout Plain Layout

<<meth1Example, include=FALSE, fig.height=4, fig.cap=c('Example of the change
 produced by the correction procedure.
 The original measurement of recovery temperature is TTRR and the revised
 value is RT.
 The estimated temperature of the support (Ts) is also shown.
 The plotted time is seconds after 11:45:00 UTC for VOCALS flight 3.', 'Variance
 spectra for the original measurement of recovery temperature (TTRR) and
 for the corrected value (RT).')>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DT %>% select(Time, TTRR, RT, Ts) %>% 
\end_layout

\begin_layout Plain Layout

  selectTime(114500, 114505) %>% 
\end_layout

\begin_layout Plain Layout

  plotWAC(legend.position = 'topright')
\end_layout

\begin_layout Plain Layout

g <- VSpec(DT, 'TTRR', ylim = c(1.e-5, 0.1))
\end_layout

\begin_layout Plain Layout

VSpec(DT, 'RT', add = g) + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\change_deleted 1311305628 1586299866
An example of the corrected recovery temperature will be shown in the next
 subsection, where the two approaches to correction can be compared.
\end_layout

\begin_layout Standard

\change_deleted 1311305628 1586299866
Inverse Fourier transformation
\end_layout

\begin_layout Standard

\change_deleted 1311305628 1586299866
An alternate approach is to use Fourier transforms:
\end_layout

\begin_layout Enumerate

\change_deleted 1311305628 1586299866
Calculate the Fourier transform of the measured time series: 
\begin_inset Formula $\hat{T}_{m}(\omega)=\mathcal{F}\left(T_{m}(t)\right)$
\end_inset

 where 
\begin_inset Formula $\omega$
\end_inset

 is the angular frequency and 
\begin_inset Formula $\mathcal{F}$
\end_inset

 denotes the Fourier transform.
\end_layout

\begin_layout Enumerate

\change_deleted 1311305628 1586299866
Divide the result by the complex representation of the transfer function:
 
\begin_inset Formula $\hat{T}_{r}(\omega)=\hat{T}_{m}(\omega)/H(\omega)$
\end_inset

.
 If the Fourier transform covers positive and negative frequencies, so should
 the transfer function.
\end_layout

\begin_layout Enumerate

\change_deleted 1311305628 1586299866
Use the inverse Fourier transform to find a retrieved estimate of the recovery
 temperature: 
\begin_inset Formula $T_{r}(t)=\mathrm{Re}\left(\mathcal{F}^{-1}\left(\hat{T}_{r}(\omega)\right)\right)$
\end_inset

 where Re denotes the real part of the complex result.
\end_layout

\begin_layout Standard

\change_deleted 1311305628 1586299866
\begin_inset ERT
status open

\begin_layout Plain Layout

<<setUpFFT, include=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

N <- length(DT$TTRR)
\end_layout

\begin_layout Plain Layout

if (N %% 2 == 1) {
\end_layout

\begin_layout Plain Layout

  N <- N - 1
\end_layout

\begin_layout Plain Layout

  DT  <- DT[-nrow(DT), ]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

f <- fft (DT$TTRR)
\end_layout

\begin_layout Plain Layout

N <- length(f)
\end_layout

\begin_layout Plain Layout

df <- Rate / N
\end_layout

\begin_layout Plain Layout

frq <- c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
\end_layout

\begin_layout Plain Layout

N2 <- N %/% 2
\end_layout

\begin_layout Plain Layout

fmax <- 2
\end_layout

\begin_layout Plain Layout

nlim <- which(frq > fmax)[1]
\end_layout

\begin_layout Plain Layout

# f[nlim:N2] <- f[nlim:N2] * (fmax / frq[nlim:(N2-1)])
\end_layout

\begin_layout Plain Layout

# f[(N2+1):(N-nlim)] <- Conj(rev(f[nlim:N2]))
\end_layout

\begin_layout Plain Layout

## Modify the spectrum by the inverse of the response function:
\end_layout

\begin_layout Plain Layout

AFFT <- LTphase(frq, Param1)
\end_layout

\begin_layout Plain Layout

AFFT$frq <- frq
\end_layout

\begin_layout Plain Layout

AFFT$Phase <- AFFT$Phase * pi / 180
\end_layout

\begin_layout Plain Layout

H <- complex (modulus = AFFT$Amp, argument = AFFT$Phase)
\end_layout

\begin_layout Plain Layout

xn <- Re(fft(f / H, inverse = TRUE)) / N
\end_layout

\begin_layout Plain Layout

DT$FFT <- xn
\change_inserted 1311305628 1585848992

\end_layout

\begin_layout Plain Layout

# g <- VSpec(DT, 'TTRR', ylim=c(1.e-5, 0.1))
\end_layout

\begin_layout Plain Layout

# g <- VSpec(DT, 'FFT', add=g)
\end_layout

\begin_layout Plain Layout

# VSpec(DT, 'RT', add=g) + theme_WAC()
\end_layout

\begin_layout Plain Layout

# DT %>% select(Time, TTRR, FFT) %>% selectTime(114500, 114505) %>% plotWAC()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\change_deleted 1311305628 1586299866
\begin_inset ERT
status open

\begin_layout Plain Layout

<<sampleFFT, include=TRUE, fig.height=4, fig.cap=c('Example of the change
 produced by the FFT correction procedure.
 The original measurement of recovery temperature is T
\change_inserted 1311305628 1585835736
m
\change_deleted 1311305628 1585835738
TRR
\change_unchanged
 and the revised value
\change_inserted 1311305628 1585835751
s
\change_unchanged
 
\change_inserted 1311305628 1585835756
are
\change_deleted 1311305628 1585835754
is
\change_unchanged
 
\change_inserted 1311305628 1585835795
RT (from integration) and 
\change_unchanged
FFT
\change_inserted 1311305628 1585835808
 (from Fourier transforms)
\change_unchanged
.
 
\change_deleted 1311305628 1585835819
The corrected value obtained by the previous method (RT) is also shown.
 
\change_unchanged
The dashed green line labeled 
\begin_inset Quotes eld
\end_inset

Ts
\begin_inset Quotes erd
\end_inset

 is the calculated temperature of the support.
 The plotted time is seconds after 11:45:00 UTC for VOCALS flight 3.', 'Variance
 spectra for the original measurement of recovery temperature (T
\change_inserted 1311305628 1585835834
m
\change_deleted 1311305628 1585835832
TRR
\change_unchanged
) and for the corrected value
\change_inserted 1311305628 1585835841
s
\change_unchanged
 (
\change_inserted 1311305628 1585835851
RT and 
\change_unchanged
FFT).')>>=
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585835689

\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585835708

DT$Tm <- DT$TTRR
\change_unchanged

\end_layout

\begin_layout Plain Layout

DT %>% select(Time, T
\change_inserted 1311305628 1585835713
m
\change_deleted 1311305628 1585835715
TRR
\change_unchanged
, FFT, RT, Ts) %>% 
\end_layout

\begin_layout Plain Layout

  selectTime(114500, 114505) %>% 
\end_layout

\begin_layout Plain Layout

  plotWAC(col=c('blue', 'black', 'darkorange', 'forestgreen'), 
\end_layout

\begin_layout Plain Layout

          lty=c(1,1,2,2), lwd=c(2,2,2,1.5)
\change_inserted 1311305628 1585836258
, legend.position='bottom'
\change_unchanged
)
\end_layout

\begin_layout Plain Layout

# g <- VSpec(DT, 'TTRR', ylim = c(1.e-5, 0.1))
\end_layout

\begin_layout Plain Layout

# VSpec(DT, 'FFT', add = g) + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

DT %>% select(Time, TASX, T
\change_inserted 1311305628 1585836158
m
\change_deleted 1311305628 1585836162
TRR
\change_unchanged
, RT, FFT) %>% 
\end_layout

\begin_layout Plain Layout

       VSpec(method='MEM', ylim=c(1.e-5, 0.1)
\change_deleted 1311305628 1585835214
, WACtheme=1
\change_unchanged
)
\change_inserted 1311305628 1585835222
 +
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585835230

       theme_WAC(1)
\change_unchanged

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\change_deleted 1311305628 1586299866
The result of this procedure is illustrated in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:sampleFFT1}
\end_layout

\end_inset

, where the result is shown along with that obtained by the preceding method.
 The agreement between the two correction methods is very good, and both
 show evidence of faster and higher-amplitude response to fluctuations.
 The Foureir-transform method provides some higher-amplitude changes and
 may be preferable.
 However, the resulting variance spectrum (Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:sampleFFT2}
\end_layout

\end_inset

) appears less satisfactory because it has high variance above about 5
\begin_inset space ~
\end_inset

Hz that is not understood.
 This is likely the fault of the measurement itself, although the correction
 procedure tends to amplify whatever causes this excess noise.
\end_layout

\begin_layout Standard

\change_deleted 1311305628 1586299866
Taking the Fourier transform of an entire 25-Hz measurement for a flight
 of several hours becomes impractical.
 However, it is possible to segment the time series, calculate Fourier transform
s for the segments, and then combine the results to represent the entire
 flight.
 Tests have shown that, for example, dividing into 
\begin_inset Formula $2^{16}$
\end_inset

-sample overlapping segments, using fast Fourier transforms, and combining
 the middle half of each segment is feasible with many-hour flights and
 25-Hz data.
\end_layout

\begin_layout Standard

\change_deleted 1311305628 1586299866
Application to the HARCO sensor
\end_layout

\begin_layout Standard

\change_deleted 1311305628 1586299866
Because the heated HARCO sensor is much slower than the unheated Rosemount
 102E4AL sensor, the measurements from that slower sensor can't be corrected
 to the extent possible for the unheated sensor, but it is still useful
 to evaluate to what extent the measurements can be improved.
 The most straightforward correction is to apply 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:HARCOsoln"
plural "false"
caps "false"
noprefix "false"

\end_inset

, even though that is based on an inferior representation of the transfer
 function in comparison to 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:lfitH"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The solution from 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:HARCOsoln"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is very noisy if first-order finite-difference estimates of the derivatives
 are used, so some smoothing of the result was needed.
 Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:HARCOcorrection1}
\end_layout

\end_inset

 shows the result (as 
\begin_inset Quotes eld
\end_inset

RTHC, the dash-dot orange line) where a Butterworth low-pass filter with
 cutoff frequency of 2
\begin_inset space ~
\end_inset

Hz has smoothed the corrected measurements from a heated HARCO sensor.
 In comparison to the original measurement (labeled 
\begin_inset Quotes eld
\end_inset

RTH1
\begin_inset Quotes erd
\end_inset

), the response of the sensor is greatly improved by this correction procedure
 and it even provides a reasonable representation of the best measurement
 (labeled 
\begin_inset Quotes eld
\end_inset

RT
\begin_inset Quotes erd
\end_inset

).
 
\end_layout

\begin_layout Standard

\change_deleted 1311305628 1586299866
Alternately, the transfer function was calculated from 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:lfitH"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and the Fourier transform of the measured sequence was divided by this
 transfer function to obtain the Fourier transform of the corrected measurement.
 The result is shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:HARCOcorrection1}
\end_layout

\end_inset

 as the black line labeled 
\begin_inset Quotes eld
\end_inset

RTFFT
\begin_inset Quotes erd
\end_inset

.
 This is also a significant improvement over the original and reproduces
 many of the features of the best measurement (
\begin_inset Quotes eld
\end_inset

RT
\begin_inset Quotes erd
\end_inset

), but it appears to respond less quickly to changes in that reference measureme
nt.
 To obtain this result, it was necessary to attenuate frequencies above
 1
\begin_inset space ~
\end_inset

Hz in the Fourier transform representing the corrected measurement because
 there is a zero in the transfer function that otherwise invalidates the
 inversion.
 This attenuation was accomplished by multiplying the transfer function
 by 
\begin_inset Formula $e^{5\nu}$
\end_inset

above 1
\begin_inset space ~
\end_inset

Hz after setting values with modulus smaller than 0.05 to 1.
 This arbitrarily chosen attenuation gave reasonable results, although it
 is likely that better choices could be made with further exploration.
 One more general measure of the improvement, beyond the anecdotal evidence
 in that figure, is that either correction procedure reduced the standard
 deviation of the difference between the measured value (RTH1) and the estimated
 best value (RT) from 
\begin_inset Formula $0.06^{\circ}$
\end_inset

C before correction to 
\begin_inset Formula $0.03^{\circ}$
\end_inset

C after correction.
\end_layout

\begin_layout Standard

\change_deleted 1311305628 1586299866
The plot of variance spectra (Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:HARCOcorrection2}
\end_layout

\end_inset

) shows that the original spectrum (orange line labeled 
\begin_inset Quotes eld
\end_inset

RTH1
\begin_inset Quotes erd
\end_inset

 is seriously attenuated at high frequencies relative to the reference measureme
nt (
\begin_inset Quotes eld
\end_inset

RT
\begin_inset Quotes erd
\end_inset

) and that both correction procedures restore significant parts of the missing
 spectral variance and increase the apparent cutoff frequency to 1
\begin_inset space ~
\end_inset

Hz or, in the case of the first method, almost 2
\begin_inset space ~
\end_inset

Hz.
 It does not appear possible to restore the missing high-frequency fluctuations
 (above about 1 or 2
\begin_inset space ~
\end_inset

Hz) because the original measurement is so severely attenuated at these
 frequencies.
 This sensor and the similar heated Rosemount sensor are therefore unable
 to detect contributions to sensible-heat flux from this frequency range,
 even after corrections.
 It nevertheless appears useful to apply one of these correction approaches
 routinely to improve the quality of the measurements.
 
\end_layout

\begin_layout Standard

\change_deleted 1311305628 1586299866
\begin_inset ERT
status open

\begin_layout Plain Layout

<<HARCOcorrection, include=TRUE, fig.height=3.5, fig.cap=c('Corrected recovery
 temperature as measured by a heated HARCO sensor (
\begin_inset Quotes eld
\end_inset

RTHC
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

RTFFT
\begin_inset Quotes erd
\end_inset

), the uncorrected measurement (
\begin_inset Quotes eld
\end_inset

RTH1
\begin_inset Quotes erd
\end_inset

), and the best estimate of the true recovery temperature (
\begin_inset Quotes eld
\end_inset

RT
\begin_inset Quotes erd
\end_inset

) based on an unheated Rosemount sensor after correction.
 The time is seconds after 2018-02-24 5:59:00 UTC, SOCRATES flight 15.
 
\begin_inset Quotes eld
\end_inset

RTHC
\begin_inset Quotes erd
\end_inset

 is based on the approximate formula (20), while 
\begin_inset Quotes eld
\end_inset

RTFFT
\begin_inset Quotes erd
\end_inset

 results from Fourier transformation after correction using the transfer
 function determined from (13).
 Mean values have been subtracted from all to facilitate comparisons.', 'Variance
 spectra for some measurements of recovery temperature: 
\begin_inset Quotes eld
\end_inset

RT
\begin_inset Quotes erd
\end_inset

 (the best estimate resulting from correction of the measurements from the
 unheated Rosemount 102E4AL); 
\begin_inset Quotes eld
\end_inset

RTH1
\begin_inset Quotes erd
\end_inset

 (the uncorrected measurement from the heated HARCO); 
\begin_inset Quotes eld
\end_inset

RTFFT
\begin_inset Quotes erd
\end_inset

 (the corrected HARCO measurement based on Fourier transforms); and 
\begin_inset Quotes eld
\end_inset

RTHC
\begin_inset Quotes erd
\end_inset

 (the corrected HARCO measurement based on the correction formula (20)).')>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

a <- Param1$a
\end_layout

\begin_layout Plain Layout

tau1 <- Param1$tau1
\end_layout

\begin_layout Plain Layout

tau2 <- Param1$tau2
\end_layout

\begin_layout Plain Layout

## RT is the working solution; Ts is the support temperature
\end_layout

\begin_layout Plain Layout

DSX$Ts <- DSX$RTF1
\end_layout

\begin_layout Plain Layout

Rate <- attr (DSX, 'Rate')
\end_layout

\begin_layout Plain Layout

DSX$DTMDT <- c(0, diff(DSX$RTF1, 2), 0) * Rate / 2
\change_inserted 1311305628 1585845558

\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585847414

DSX$DTMDT <-  (c(0, 8*diff(DSX$RTF1, 2), 0) - 
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585847418

              c(0, 0, diff(DSX$RTF1, 4), 0, 0)) * Rate / 12
\change_unchanged

\end_layout

\begin_layout Plain Layout

# DT$DTMDT <- (DT$DTMDT + c(0, DT$DTMDT[1:(nrow(DT)-1)])) / 2
\end_layout

\begin_layout Plain Layout

# DT$DTMDT <- as.vector (signal::filter(signal::sgolay(1, 3, m=1),
\change_inserted 1311305628 1585845607

\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585845612

#             
\change_deleted 1311305628 1585845607
 
\change_unchanged
DT$TTRR)) * Rate
\end_layout

\begin_layout Plain Layout

fS <- function(y, i) {  # Eq.
 Ts3
\end_layout

\begin_layout Plain Layout

  ((1/a) * (tau1 * DSX$DTMDT[i] + DSX$RTF1[i] - (1-a) * y) - y) / (Rate
 * tau2)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DSX$Ts <- rk4.integrate (fS, DSX$Ts[1], 1:nrow(DSX))
\end_layout

\begin_layout Plain Layout

DSX$RT <- (1/a) * (tau1 * DSX$DTMDT + DSX$RTF1 - (1-a) * DSX$Ts)
\end_layout

\begin_layout Plain Layout

MRHO <- MachNumber(DSX$PSXC, DSX$QCXC) * DSX$PSXC * 100 /
\end_layout

\begin_layout Plain Layout

                  (287.05 * (273.15 + DSX$ATX)) / rhozero
\end_layout

\begin_layout Plain Layout

a <- bestSH[1]
\end_layout

\begin_layout Plain Layout

tau1 <- bestSH[2] * (MRHO / 0.3) ^ 0.6  ## Note that these are variable
\end_layout

\begin_layout Plain Layout

tau2 <- bestSH[3] * (MRHO / 0.3) ^ 0.6
\end_layout

\begin_layout Plain Layout

Rate <- attr (DSX, 'Rate')
\end_layout

\begin_layout Plain Layout

DSX$DTMDT <- c(0, diff(DSX$RTH1, 2), 0) * Rate / 2
\end_layout

\begin_layout Plain Layout

DSX$DTM2DT2 <- (c(diff(DSX$RTH1), 0) - c(0, diff(DSX$RTH1))) * Rate^2
\end_layout

\begin_layout Plain Layout

DSX$RTHC <- (tau1 + tau2) * DSX$DTMDT + DSX$RTH1 + tau1 * tau2 * DSX$DTM2DT2
\end_layout

\begin_layout Plain Layout

DSX$RTHC <- zoo::na.approx (as.vector(DSX$RTHC), maxgap=1000*Rate,
\end_layout

\begin_layout Plain Layout

      na.rm = FALSE, rule = 2)
\end_layout

\begin_layout Plain Layout

CutoffPeriod <- 12.5
\end_layout

\begin_layout Plain Layout

DSX$RTHC <- signal::filtfilt (signal::butter (3,
\end_layout

\begin_layout Plain Layout

      2/CutoffPeriod), DSX$RTHC)
\end_layout

\begin_layout Plain Layout

# DSX$RTHC <- SmoothInterp(DSX$RTHC, .Length=25)
\end_layout

\begin_layout Plain Layout

DSAP <- DSX
\end_layout

\begin_layout Plain Layout

DSAP$RTH1 <- DSAP$RTH1 - mean(DSAP$RTH1[setRange(DSAP, 55700, 60000)], na.rm=TRUE
)
\end_layout

\begin_layout Plain Layout

DSAP$RTF1P <- DSAP$RTF1 - mean(DSAP$RTF1[setRange(DSAP, 55700, 60000)],
 na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

DSAP$RTHC <- DSAP$RTHC - mean(DSAP$RTHC[setRange(DSAP, 55700, 60000)], na.rm=TRUE
)
\end_layout

\begin_layout Plain Layout

DSAP$RT <- DSAP$RT - mean(DSAP$RT[setRange(DSAP, 55700, 60000)], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

# DSAP %>% selectTime(55920, 55950) %>% 
\end_layout

\begin_layout Plain Layout

#          select(Time, RT, RTH1, RTHC) %>% 
\end_layout

\begin_layout Plain Layout

#         ggplotWAC(col=c('blue', 'forestgreen', 'black'), lty=c(1,4,1),
\end_layout

\begin_layout Plain Layout

#                   ylab=bquote('recovery temperature [' ~ degree * 'C]'),
 
\end_layout

\begin_layout Plain Layout

#                   lwd=c(0.8,1,1)) + xlab('time [s]') +
\end_layout

\begin_layout Plain Layout

#         theme_WAC(1) + theme(legend.position=c(0.75, 0.9))
\end_layout

\begin_layout Plain Layout

DSAX <- DSX %>% selectTime(55700, 60300)
\end_layout

\begin_layout Plain Layout

DSAX <- DSAX[1:2^13, ]
\end_layout

\begin_layout Plain Layout

ft <- fft(DSAX$RTH1)
\end_layout

\begin_layout Plain Layout

N <- length(ft)
\end_layout

\begin_layout Plain Layout

Rate <- attr(DSX, 'Rate')
\end_layout

\begin_layout Plain Layout

df <- Rate / N
\end_layout

\begin_layout Plain Layout

frq <- c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
\end_layout

\begin_layout Plain Layout

fr <- log(abs(frq))
\end_layout

\begin_layout Plain Layout

Gain  <- cfrHARCO[1] + fr * (cfrHARCO[2] + fr * fr * (cfrHARCO[3] + 
\end_layout

\begin_layout Plain Layout

         fr * (cfrHARCO[4] + fr * cfrHARCO[5])))
\end_layout

\begin_layout Plain Layout

Gain[abs(frq) < 0.024] <- 1
\end_layout

\begin_layout Plain Layout

Phase <- cfHARCO[1] + cfHARCO[2] * fr + cfHARCO[3] * fr^2 +
\end_layout

\begin_layout Plain Layout

         cfHARCO[4] * atan(frq)
\end_layout

\begin_layout Plain Layout

Phase[frq < 0] <- -Phase[frq < 0]
\end_layout

\begin_layout Plain Layout

Phase[1] <- 0
\end_layout

\begin_layout Plain Layout

Phase <- Phase * pi / 180
\end_layout

\begin_layout Plain Layout

TF <- complex(modulus=Gain, argument=Phase)
\change_inserted 1311305628 1585852113

\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585852123

tlmt <- 1.8
\change_unchanged

\end_layout

\begin_layout Plain Layout

TF[abs(frq) > 
\change_inserted 1311305628 1585852129
tlmt
\change_deleted 1311305628 1585852127
1
\change_unchanged
] <- TF[abs(frq) > 
\change_deleted 1311305628 1585852133
1
\change_inserted 1311305628 1585852138
tlmt
\change_unchanged
] * exp(
\change_inserted 1311305628 1585852143
5
\change_deleted 1311305628 1585852143
3
\change_unchanged
*abs(frq[abs(frq) > 
\change_inserted 1311305628 1585852150
tlmt
\change_deleted 1311305628 1585852148
1
\change_unchanged
])
\change_inserted 1311305628 1585852299
 / tlmt
\change_unchanged
)
\end_layout

\begin_layout Plain Layout

ftx <- ft / TF
\end_layout

\begin_layout Plain Layout

DSAX$RTFFT <- Re(fft(ftx, inverse = TRUE) / N)
\change_inserted 1311305628 1585849584

\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585849588

N <- 2^13 
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585849588

Nby2 <- N / 2
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585849732

RTH1 <- DSAX$RTH1
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585849588

ff1 <- fft(RTH1)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585849588

RTH <- Re(fft(ff1, inverse=TRUE)) / N
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585849588

df <- Rate / N
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585849757

frq <- c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585849588

fr <- log(frq[1:(Nby2+1)])
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585849588

## Get the transfer function from the fitted parameterized form:
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585849588

Ph <- cfHARCO[1] + cfHARCO[2] * fr + 
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585849588

           cfHARCO[3] * fr^2 + cfHARCO[4] * atan(frq[1:(Nby2+1)])
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585849588

Ph[1] <- 0
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585849588

G <- cfrHARCO[1] + fr * (cfrHARCO[2] + fr * fr * (cfrHARCO[3] + 
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585849588

           fr * (cfrHARCO[4] + fr * cfrHARCO[5])))
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585849588

G[frq[1:length(fr)] < 0.024] <- 1
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585849588

G[frq[1:length(fr)] > 2] <- G[which.min(abs(frq-2))]
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585849588

H <- rep(complex(modulus=0), N)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585849588

H[1:(Nby2+1)] <- complex(modulus=G, argument=Ph * pi / 180)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585849588

H[(Nby2+2):N] <- rev(Conj(H[2:Nby2]))
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585849588

RTC <- Re(fft(ff1 / H, inverse = TRUE)) / N
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585849831

DSAX$RTC <- RTC
\change_unchanged

\end_layout

\begin_layout Plain Layout

dfTF <- data.frame(
\end_layout

\begin_layout Plain Layout

  'Time' = frq,
\end_layout

\begin_layout Plain Layout

  'Amp' = Gain,
\end_layout

\begin_layout Plain Layout

  'Phase' = Phase
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  ggplotWAC(
\end_layout

\begin_layout Plain Layout

    dfTF,
\end_layout

\begin_layout Plain Layout

    panels = 2,
\end_layout

\begin_layout Plain Layout

    labelP = c('    Amplitude', 'Phase [degrees]')
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + ylab(bquote('transfer function H(' * nu
 ~ ')'))
\end_layout

\begin_layout Plain Layout

g <-
\end_layout

\begin_layout Plain Layout

  g + scale_x_log10(
\end_layout

\begin_layout Plain Layout

    breaks = trans_breaks("log10", function(x)
\end_layout

\begin_layout Plain Layout

      10 ^ x, n = 4),
\end_layout

\begin_layout Plain Layout

    labels = trans_format("log10", math_format(expr = 10 ^ .x))
\end_layout

\begin_layout Plain Layout

  ) + xlab('frequency [Hz]')
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides = 'tb')
\end_layout

\begin_layout Plain Layout

# g + theme_WAC(1) + theme(legend.position = c(0.3, 0.65))
\end_layout

\begin_layout Plain Layout

DSAP <- DSAX
\end_layout

\begin_layout Plain Layout

DSAP$RTH1 <- DSAP$RTH1 - mean(DSAP$RTH1[setRange(DSAP, 55700, 60000)], na.rm=TRUE
)
\end_layout

\begin_layout Plain Layout

DSAP$RTF1P <- DSAP$RTF1 - mean(DSAP$RTF1[setRange(DSAP, 55700, 60000)],
 na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

DSAP$RTHC <- DSAP$RTHC - mean(DSAP$RTHC[setRange(DSAP, 55700, 60000)], na.rm=TRUE
)
\end_layout

\begin_layout Plain Layout

DSAP$RT <- DSAP$RT - mean(DSAP$RT[setRange(DSAP, 55700, 60000)], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

DSAP$RTFFT <- DSAP$RTFFT - mean(DSAP$RTFFT[setRange(DSAP, 55700, 60000)],
\end_layout

\begin_layout Plain Layout

                                na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

DSAP %>% selectTime(55920, 55950) %>% 
\end_layout

\begin_layout Plain Layout

         select(Time, RT, RTH1, RTFFT, RTHC) %>% 
\end_layout

\begin_layout Plain Layout

         ggplotWAC(c('blue', 'forestgreen', 'black', 'darkorange'),
\end_layout

\begin_layout Plain Layout

                   ylab=bquote('recovery temperature [' ~ degree * 'C]'),
\end_layout

\begin_layout Plain Layout

                   lty=c(1,4,1,1), lwd=c(0.8,1.2,1,0.8)) + xlab('time [s]')
 +
\end_layout

\begin_layout Plain Layout

         theme_WAC(1) + 
\end_layout

\begin_layout Plain Layout

         theme(legend.position=c(0.715, 0.93))
\end_layout

\begin_layout Plain Layout

g <- DSAP %>% select(Time, TASX, RTFFT, RTHC, RT) %>% 
\end_layout

\begin_layout Plain Layout

        VSpec(
\change_inserted 1311305628 1585846445
xlim=c(5.e-3, 15), 
\change_unchanged
ylim=c(
\change_inserted 1311305628 1585848523
2
\change_deleted 1311305628 1585848523
1
\change_unchanged
.e-6, 1.e-2), 
\change_inserted 1311305628 1585846862

\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1585847098

        smoothBins = 100, 
\change_unchanged
method='MEM')
\end_layout

\begin_layout Plain Layout

VSpec(DSAP, 'RTH1', add=g, type='MEM') + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\change_deleted 1311305628 1586299866
\begin_inset Newpage clearpage
\end_inset


\change_unchanged

\end_layout

\begin_layout Section
Summary and Conclusions
\end_layout

\begin_layout Standard
Findings and conclusions of this investigation include these items:
\end_layout

\begin_layout Enumerate
The differential equations 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

, with appropriate parameters, provide an analytical representation of the
 transfer function for the recovery temperature measured by an unheated
 Rosemount 102E4AL sensor.
 That transfer function was shown to be consistent with measurements of
 the phase and amplitude ratio of the response to dynamic-heating fluctuations.
 This is good evidence that the equations provide a good representation
 of the time response for that sensor, although the consistency with the
 predictions of the equations is less satisfactory when applied to 
\change_inserted 1311305628 1586298652
a
\change_deleted 1311305628 1586298651
the
\change_unchanged
 heated HARCO sensor or 
\change_inserted 1311305628 1586298661
a
\change_deleted 1311305628 1586298662
the
\change_unchanged
 heated Rosemount sensor.
 
\end_layout

\begin_layout Enumerate
The three parameters in those equations, characterizing the two time constants
 and the fraction of heat transfer to the air vs.
\begin_inset space ~
\end_inset

that to the structure supporting the sensing wire, can be determined with
 small uncertainty by fitting the transfer function while varying those
 parameters to observations of dynamic heating.
 These parameters are thus constrained well and can be relied upon to make
 corrections to the measurements and otherwise to characterize the effects
 of time response of the sensors.
\change_inserted 1311305628 1586299154

\end_layout

\begin_layout Enumerate

\change_inserted 1311305628 1586299361
Some additional evidence supports the general magnitude of the parameters
 determined by reference to dynamic heating.
 The supplemental observations come from a sharp feature in the atmosphere
 or from the lag observed during flight while the airspeed varies at constant
 altitude, 
\change_unchanged

\end_layout

\begin_layout Enumerate
Once the transfer function for the unheated Rosemount sensor has been determined
, it can be used to estimate the true recovery temperature, and then transfer
 functions for other sensors can be determined by comparison to that estimate
 of the measurand to which they are responding.

\change_inserted 1311305628 1585853475
 This approach has been used here for the slower heated sensors and should
 provide a means of correcting other sensors slower than the reference unheated
 sensor.
\change_deleted 1311305628 1586299149

\end_layout

\begin_layout Enumerate

\change_inserted 1311305628 1586299498
Appendix A uses these results with standard methods to correct the measurements
 from airborne temperature sensors for their time response.
\change_deleted 1311305628 1586299507
Two correction schemes are suggested and verified, one based on integrating
 the derivatives provided by the differential equations and one based on
 taking the Fourier transform of the time series, correcting that transform
 as indicated by the transfer function, and then recovering the original
 signal from the inverse Fourier transform.
 Both could be used for routine processing to correct for the response character
istics of airborne temperature sensors.
 
\change_unchanged

\end_layout

\begin_layout Standard
This Part-
\change_inserted 1311305628 1586299522
1
\change_deleted 1311305628 1586299522
I
\change_unchanged
 paper has focused on the measured temperature, the 
\begin_inset Quotes eld
\end_inset

recovery
\begin_inset Quotes erd
\end_inset

 temperature.
 Part
\change_inserted 1311305628 1586299534

\begin_inset space ~
\end_inset


\change_deleted 1311305628 1586299535
 
\change_inserted 1311305628 1586299526
2
\change_deleted 1311305628 1586299526
II
\change_unchanged
 will consider how these results affect calculation of the actual air or
 ambient temperature, which requires subtraction of the contribution from
 dynamic heating.
 It will be argued there that the temperature sensor cannot respond to the
 rapid fluctuations in dynamic heating often present in a turbulent atmosphere,
 and therefore conventional data processing introduces errors by trying
 to compensate for fluctuations that do not appear in the measured recovery
 temperature.
 Because this error is so prevalent in almost all existing data from research
 aircraft, it is essential to determine how to remove these errors.
 Once this problem is addressed, Part
\change_inserted 1311305628 1586299562

\begin_inset space ~
\end_inset

3
\change_deleted 1311305628 1586299559
 III
\change_unchanged
 will then turn to the implications for measuring the flux of sensible heat.
\change_inserted 1311305628 1586299949

\end_layout

\begin_layout Section
\start_of_appendix

\change_inserted 1311305628 1586299922
Correcting the Temperature
\begin_inset CommandInset label
LatexCommand label
name "sec:Correcting-the-Temperature"

\end_inset


\end_layout

\begin_layout Standard

\change_inserted 1311305628 1586299922
The true recovery temperature 
\begin_inset Formula $T_{r}$
\end_inset

 can be retrieved from the measured temperature 
\begin_inset Formula $T_{m}$
\end_inset

 in two ways, either from the differential equations or by Fourier transformatio
n.
 These methods are illustrated here.
\end_layout

\begin_layout Subsection

\change_inserted 1311305628 1586299922
Integration of the differential equations
\begin_inset CommandInset label
LatexCommand label
name "subsec:Integration-of-the"

\end_inset


\end_layout

\begin_layout Standard

\change_inserted 1311305628 1586299922
The differential equations 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 provide a basis for correcting the measured temperature to account for
 the time response of the sensor.
 They should be applied to the recovery temperature 
\begin_inset Formula $T_{r}(t)$
\end_inset

, which is the measurand.
 The actual measurement is 
\begin_inset Formula $T_{m}(t)$
\end_inset

 and the temperature of the support is 
\begin_inset Formula $T_{s}(t)$
\end_inset

, so those equations, rearranged, are:
\end_layout

\begin_layout Standard

\change_inserted 1311305628 1586299922
\begin_inset Formula 
\begin{equation}
\frac{dT_{s}(t)}{dt}=\frac{T_{r}(t)-T_{s}(t)}{\tau_{2}}\label{eq:Ts2}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
T_{r}(t)=\frac{1}{a}\left\{ \tau_{1}\frac{dT_{m}(t)}{dt}+T_{m}(T)-(1-a)T_{s}(t)\right\} \label{eq:Tm2}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard

\change_inserted 1311305628 1586299922
There are two unknowns (
\begin_inset Formula $T_{r}(t)$
\end_inset

, the actual recovery temperature, and 
\begin_inset Formula $T_{s}(t)$
\end_inset

).
 Those unknowns are specified by the two preceding equations because all
 other terms are known, including 
\begin_inset Formula $dT_{m}/dt$
\end_inset

 which can be represented using the numerical derivative of the measurements
 
\begin_inset Formula $T_{m}(t)$
\end_inset

.
 The second equation can be used to eliminate 
\begin_inset Formula $T_{r}$
\end_inset

 from the first:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\frac{dT_{s}(t)}{dt}=\frac{\frac{1}{a}\left\{ \tau_{1}\frac{dT_{m}(t)}{dt}+T_{m}(T)-(1-a)T_{s}(t)\right\} -T_{s}(t)}{\tau_{2}}\label{eq:Ts3}
\end{equation}

\end_inset

From an initial value 
\begin_inset Formula $T_{s}(0)$
\end_inset

, assumed to be 
\begin_inset Formula $T_{m}(0)$
\end_inset

, this equation can be integrated to find the temperature of the support,
 
\begin_inset Formula $T_{s}(t)$
\end_inset

.
 Once that is known, 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 specifies the estimate of the true recovery temperature 
\begin_inset Formula $T_{r}(t)$
\end_inset

 without further integration.
 The only choices needed are the numerical method used to find the derivative
 
\begin_inset Formula $dT_{m}/dt$
\end_inset

 (e.g., here centered fourth-order) and the integration method applied to
 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts3"
plural "false"
caps "false"
noprefix "false"

\end_inset

, here fourth-order Runge-Kutta integration with Cash-Karp (
\begin_inset CommandInset citation
LatexCommand citet
key "cash1990variable"
literal "false"

\end_inset

) adjustment of the step size.
 If a centered second-order finite-difference expression is used for 
\begin_inset Formula $dT_{m}(t)/dt$
\end_inset

 and an Euler integration is used to integrate 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts3"
plural "false"
caps "false"
noprefix "false"

\end_inset

, this correction can be shown to be equivalent to that developed by 
\begin_inset CommandInset citation
LatexCommand citet
key "InverarityJTech2000"
literal "false"

\end_inset

; cf.
\begin_inset space ~
\end_inset

his Eqn.
\begin_inset space ~
\end_inset

(12).
\end_layout

\begin_layout Standard

\change_inserted 1311305628 1586300331
The HARCO presents a special case because the best-fit value is 
\begin_inset Formula $a=0$
\end_inset

 so 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 can't be used.
 However, in this case the differential equations can still be combined
 to give
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
T_{r}(t)=(\tau_{1}+\tau_{2})\frac{dT_{m}(t)}{dt}+T_{m}(t)+\tau_{2}\tau_{1}\frac{d^{2}T_{m}(t)}{dt^{2}}\label{eq:HARCOsoln}
\end{equation}

\end_inset

a form that can be used directly without integration because finite-difference
 expressions can be used for the derivatives of the measured 
\begin_inset Formula $T_{m}(t)$
\end_inset

.
 However, this is not as good a representation of the transfer function
 as is possible with the fitted representation shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922


\backslash
ref{fig:GVHARCO}
\end_layout

\end_inset

 and given by 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:lfitH"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 That fit can be used with the Fourier-transform approach to correction,
 as shown in the next subsection.
\end_layout

\begin_layout Standard

\change_inserted 1311305628 1586299922
\begin_inset Branch Extra
inverted 0
status open

\begin_layout Standard

\change_inserted 1311305628 1586299922
The heated Rosemount sensor presents a special case because the best-fit
 parameters included 
\begin_inset Formula $a=0$
\end_inset

 so it isn't possible to substitute 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 into 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 as for the other sensors.
 Instead, 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm"
plural "false"
caps "false"
noprefix "false"

\end_inset

 can be solved to find the support temperature 
\begin_inset Formula $T_{s}(t)$
\end_inset

:
\begin_inset Formula 
\begin{equation}
T_{s}(t)=\tau_{1}\frac{dT_{m}(t)}{dt}+T_{m}(t)\label{eq:Ts4}
\end{equation}

\end_inset

which can be solved for 
\begin_inset Formula $T_{s}(t)$
\end_inset

 because both 
\begin_inset Formula $T_{m}(t)$
\end_inset

 and 
\begin_inset Formula $dT_{m}(t)/dt$
\end_inset

 are measured.
 With this solution and the resulting derivative 
\begin_inset Formula $dT_{s}(t)/dt$
\end_inset

 of this solution, 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts2"
plural "false"
caps "false"
noprefix "false"

\end_inset

 leads to 
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
T_{r}(t)=T_{s}(t)+\tau_{2}\frac{dT_{s}(t)}{dt}\label{eq:Tm4}
\end{equation}

\end_inset

which gives the solution directly (without integration) because all terms
 on the right side are known.
 The result could also be written by combining 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm4"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Ts4"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to give
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
T_{r}(t)=(\tau_{1}+\tau_{2})\frac{dT_{m}(t)}{dt}+T_{m}(t)+\tau_{2}\tau_{1}\frac{d^{2}T_{m}(t)}{dt^{2}}\label{eq:Tm5}
\end{equation}

\end_inset

which, without the second-derivative term, would represent a first-order
 response with time constant 
\begin_inset Formula $\tau=\tau_{1}+\tau_{2}$
\end_inset

.
 The transfer function for the HARCO (Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922


\backslash
ref{fig:rfHARCO}
\end_layout

\end_inset

 shows that, contrary to first-order response, the phase lag can be negative
 for some frequencies, so the second-derivative term plays an important
 role.
 The second derivative in 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:HARCOsoln"
plural "false"
caps "false"
noprefix "false"

\end_inset

 can be represented, for example, by
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\frac{d^{2}T_{m}(t)}{dt^{2}}=\frac{T_{m}(t-\delta t)-2T_{m}(t)+T_{m}(t+\delta t)}{(\delta t)^{2}}\label{eq:deriv2nd}
\end{equation}

\end_inset

where all quantities on the right side are known from the measurement sequence.
 Equation 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:Tm5"
plural "false"
caps "false"
noprefix "false"

\end_inset

 thus provides the corrected recovery temperature 
\begin_inset Formula $T_{r}(t)$
\end_inset

 without any need to calculate the temperature of the support.
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\change_inserted 1311305628 1586299922
\begin_inset ERT
status open

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

<<method1, include=FALSE>>=
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

a <- Param1$a
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

tau1 <- Param1$tau1
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

tau2 <- Param1$tau2
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

## RT is the working solution; Ts is the support temperature
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

DT$Ts <- DT$RT
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

Rate <- attr (DT, 'Rate')
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

DT$DTMDT <- c(0, diff(DT$TTRR, 2), 0) * Rate / 2
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

DT$DTMDT <-  (c(0, 8*diff(DT$TTRR, 2), 0) - 
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

              c(0, 0, diff(DT$TTRR, 4), 0, 0)) * Rate / 12
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

# DT$DTMDT <- (DT$DTMDT + c(0, DT$DTMDT[1:(nrow(DT)-1)])) / 2
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

# DT$DTMDT <- as.vector (signal::filter(signal::sgolay(1, 3, m=1), DT$TTRR))
 * Rate
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

fS <- function(y, i) {
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

  # Eq.
 Ts3
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

  ((tau1 * DT$DTMDT[i] + DT$TTRR[i] - (1 - a) * y)/a - y) / (Rate * tau2)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

}
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

DT$Ts <- rk4.integrate (fS, DT$Ts[1], 1:nrow(DT))
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

DT$RT <- (1 / a) * (tau1 * DT$DTMDT + DT$TTRR - (1 - a) * DT$Ts)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

DT %>% select(Time, TTRR, RT, Ts) %>% 
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

  selectTime(114500, 114505) %>% 
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

  plotWAC()
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\change_inserted 1311305628 1586299922
\begin_inset ERT
status open

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

<<meth1Example, include=FALSE, fig.height=4, fig.cap=c('Example of the change
 produced by the correction procedure.
 The original measurement of recovery temperature is TTRR and the revised
 value is RT.
 The estimated temperature of the support (Ts) is also shown.
 The plotted time is seconds after 11:45:00 UTC for VOCALS flight 3.', 'Variance
 spectra for the original measurement of recovery temperature (TTRR) and
 for the corrected value (RT).')>>=
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

DT %>% select(Time, TTRR, RT, Ts) %>% 
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

  selectTime(114500, 114505) %>% 
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

  plotWAC(legend.position = 'topright')
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

g <- VSpec(DT, 'TTRR', ylim = c(1.e-5, 0.1))
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

VSpec(DT, 'RT', add = g) + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\change_inserted 1311305628 1586299922
An example of the corrected recovery temperature will be shown in the next
 subsection, where the two approaches to correction can be compared.
\end_layout

\begin_layout Subsection

\change_inserted 1311305628 1586299922
Inverse Fourier transformation
\end_layout

\begin_layout Standard

\change_inserted 1311305628 1586299922
An alternate approach is to use Fourier transforms:
\end_layout

\begin_layout Enumerate

\change_inserted 1311305628 1586299922
Calculate the Fourier transform of the measured time series: 
\begin_inset Formula $\hat{T}_{m}(\omega)=\mathcal{F}\left(T_{m}(t)\right)$
\end_inset

 where 
\begin_inset Formula $\omega$
\end_inset

 is the angular frequency and 
\begin_inset Formula $\mathcal{F}$
\end_inset

 denotes the Fourier transform.
\end_layout

\begin_layout Enumerate

\change_inserted 1311305628 1586299922
Divide the result by the complex representation of the transfer function:
 
\begin_inset Formula $\hat{T}_{r}(\omega)=\hat{T}_{m}(\omega)/H(\omega)$
\end_inset

.
 
\end_layout

\begin_layout Enumerate

\change_inserted 1311305628 1586299922
Use the inverse Fourier transform to find a retrieved estimate of the true
 recovery temperature: 
\begin_inset Formula $T_{r}(t)=\mathrm{Re}\left(\mathcal{F}^{-1}\left(\hat{T}_{r}(\omega)\right)\right)$
\end_inset

 where Re denotes the real part of the complex result.
\end_layout

\begin_layout Standard

\change_inserted 1311305628 1586299922
\begin_inset ERT
status open

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

<<setUpFFT, include=FALSE>>=
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

N <- length(DT$TTRR)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

if (N %% 2 == 1) {
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

  N <- N - 1
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

  DT  <- DT[-nrow(DT), ]
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

}
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

f <- fft (DT$TTRR)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

N <- length(f)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

df <- Rate / N
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

frq <- c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

N2 <- N %/% 2
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

fmax <- 2
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

nlim <- which(frq > fmax)[1]
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

# f[nlim:N2] <- f[nlim:N2] * (fmax / frq[nlim:(N2-1)])
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

# f[(N2+1):(N-nlim)] <- Conj(rev(f[nlim:N2]))
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

## Modify the spectrum by the inverse of the response function:
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

AFFT <- LTphase(frq, Param1)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

AFFT$frq <- frq
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

AFFT$Phase <- AFFT$Phase * pi / 180
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

H <- complex (modulus = AFFT$Amp, argument = AFFT$Phase)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

xn <- Re(fft(f / H, inverse = TRUE)) / N
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

DT$FFT <- xn
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

# g <- VSpec(DT, 'TTRR', ylim=c(1.e-5, 0.1))
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

# g <- VSpec(DT, 'FFT', add=g)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

# VSpec(DT, 'RT', add=g) + theme_WAC()
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

# DT %>% select(Time, TTRR, FFT) %>% selectTime(114500, 114505) %>% plotWAC()
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\change_inserted 1311305628 1586299922
\begin_inset ERT
status open

\begin_layout Plain Layout

\change_inserted 1311305628 1586378694

<<sampleFFT, include=TRUE, fig.height=4, fig.cap=c('Example of the change
 produced by the FFT correction procedure.
 The original measurement of recovery temperature is Tm, produced by an
 unheated Rosemount sensor, and the revised values are RT (from integration)
 and FFT (from Fourier transforms).
 The dashed green line labeled 
\begin_inset Quotes eld
\end_inset

Ts
\begin_inset Quotes erd
\end_inset

 is the calculated temperature of the support.
 The plotted time is seconds after 11:45:00 UTC for VOCALS flight 3.', 'Variance
 spectra for the original measurement of recovery temperature (Tm) and for
 the corrected values (RT and FFT).')>>=
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

DT$Tm <- DT$TTRR
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

DT %>% select(Time, Tm, FFT, RT, Ts) %>% 
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

  selectTime(114500, 114505) %>% 
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

  plotWAC(col=c('blue', 'black', 'darkorange', 'forestgreen'), 
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

          lty=c(1,1,2,2), lwd=c(2,2,2,1.5), legend.position='bottom')
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

# g <- VSpec(DT, 'TTRR', ylim = c(1.e-5, 0.1))
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

# VSpec(DT, 'FFT', add = g) + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

DT %>% select(Time, TASX, Tm, RT, FFT) %>% 
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

       VSpec(method='MEM', ylim=c(1.e-5, 0.1)) +
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

       theme_WAC(1)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\change_inserted 1311305628 1586299922
The result of this procedure is illustrated in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922


\backslash
ref{fig:sampleFFT1}
\end_layout

\end_inset

, where the result is shown along with that obtained by the preceding method.
 The agreement between the two correction methods is very good, and both
 show evidence of faster and higher-amplitude response to fluctuations.
 The Fourier-transform method provides some higher-amplitude changes and
 may be preferable.
 However, the resulting variance spectrum for the Fourier-transform method
 (Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922


\backslash
ref{fig:sampleFFT2}
\end_layout

\end_inset

)  has high variance above about 5
\begin_inset space ~
\end_inset

Hz that is above the variance for the corrected variable obtained from 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:HARCOsoln"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The increasing variance for the Fourier-transform method is is likely the
 fault of the measurement itself: The spectral variance for the original
 measurement (Tm) does not decrease at high frequency as expected from the
 transfer function, and the correction procedure amplifies this excess noise.
 The lower variance for the variable obtained from 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:HARCOsoln"
plural "false"
caps "false"
noprefix "false"

\end_inset

 at high frequency arises from the finite-difference representation of the
 term 
\begin_inset Formula $dT_{m}(t)/dt$
\end_inset

 (which is here fourth-order).
\end_layout

\begin_layout Standard

\change_inserted 1311305628 1586299922
Taking the Fourier transform of an entire 25-Hz measurement for a flight
 of several hours becomes impractical.
 However, it is possible to segment the time series, calculate Fourier transform
s for the segments, and then combine the results to represent the entire
 flight.
 Tests have shown that, for example, dividing into 
\begin_inset Formula $2^{16}$
\end_inset

-sample overlapping segments, using fast Fourier transforms, and combining
 the middle half of each segment is feasible with many-hour flights and
 25-Hz data.
\end_layout

\begin_layout Subsection

\change_inserted 1311305628 1586299922
Application to the HARCO sensor
\end_layout

\begin_layout Standard

\change_inserted 1311305628 1586378870
Because the heated HARCO sensor is much slower than the unheated Rosemount
 102E4AL sensor, the measurements from that slower sensor can't be corrected
 to the extent possible for the unheated sensor, but it is still useful
 to evaluate to what extent the measurements can be improved.
 The most straightforward correction is to apply 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:HARCOsoln"
plural "false"
caps "false"
noprefix "false"

\end_inset

, even though that is based on an inferior representation of the transfer
 function in comparison to 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:lfitH"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The solution from 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:HARCOsoln"
plural "false"
caps "false"
noprefix "false"

\end_inset

 is very noisy if second-order finite-difference estimates of the derivatives
 are used, so some smoothing of the result was needed.
 Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922


\backslash
ref{fig:HARCOcorrection1}
\end_layout

\end_inset

 shows the result (as 
\begin_inset Quotes eld
\end_inset

RTHC, the dash-dot orange line) where a Butterworth low-pass filter with
 cutoff frequency of 2
\begin_inset space ~
\end_inset

Hz has smoothed the corrected measurements from a heated HARCO sensor.
 This filtering is reasonable because the variance spectrum for this sensor
 shows very little real signal at frequencies above 2
\begin_inset space ~
\end_inset

Hz.
 In comparison to the original measurement (labeled 
\begin_inset Quotes eld
\end_inset

RTH1
\begin_inset Quotes erd
\end_inset

), the response of the sensor is greatly improved by this correction procedure
 and it even provides a reasonable representation of the corrected unheated
 Rosemount measurement (labeled 
\begin_inset Quotes eld
\end_inset

RT
\begin_inset Quotes erd
\end_inset

) for the same period.
\end_layout

\begin_layout Standard

\change_inserted 1311305628 1586299922
Alternately, the transfer function was calculated from 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:lfitH"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and the Fourier transform of the measured sequence was divided by this
 transfer function to obtain the Fourier transform of the corrected measurement.
 The result is shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922


\backslash
ref{fig:HARCOcorrection1}
\end_layout

\end_inset

 as the black line labeled 
\begin_inset Quotes eld
\end_inset

RTFFT
\begin_inset Quotes erd
\end_inset

.
 This is also a significant improvement over the original and reproduces
 many of the features of the best measurement (
\begin_inset Quotes eld
\end_inset

RT
\begin_inset Quotes erd
\end_inset

), but it appears to respond less quickly to changes in that reference measureme
nt.
 To obtain this result, it was necessary to attenuate frequencies above
 1.8
\begin_inset space ~
\end_inset

Hz in the Fourier transform solution because there is a zero in the transfer
 function as represented by 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:lfitH"
plural "false"
caps "false"
noprefix "false"

\end_inset

 that otherwise invalidates the inversion.
 This attenuation was accomplished by multiplying the transfer function
 by 
\begin_inset Formula $e^{5\nu}$
\end_inset

above 1.8
\begin_inset space ~
\end_inset

Hz.
  This arbitrarily chosen attenuation gave reasonable results, although
 it is likely that better choices could be made with further exploration.
 One more general measure of the improvement, beyond the anecdotal evidence
 in the preceding figures is that either correction procedure reduced the
 standard deviation of the difference between the measured value (RTH1)
 and the estimated best value (RT) from 
\begin_inset Formula $0.06^{\circ}$
\end_inset

C before correction to 
\begin_inset Formula $0.03^{\circ}$
\end_inset

C after correction.
\end_layout

\begin_layout Standard

\change_inserted 1311305628 1586299922
The plot of variance spectra (Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922


\backslash
ref{fig:HARCOcorrection2}
\end_layout

\end_inset

) shows that the original spectrum (orange line labeled 
\begin_inset Quotes eld
\end_inset

RTH1
\begin_inset Quotes erd
\end_inset

 is seriously attenuated at high frequencies relative to the reference measureme
nt (
\begin_inset Quotes eld
\end_inset

RT
\begin_inset Quotes erd
\end_inset

) and that both correction procedures restore significant parts of the missing
 spectral variance and increase the apparent cutoff frequency to 1
\begin_inset space ~
\end_inset

Hz or, in the case of the first method, almost 2
\begin_inset space ~
\end_inset

Hz.
 It does not appear possible to restore the missing high-frequency fluctuations
 (above about 1 or 2
\begin_inset space ~
\end_inset

Hz) because the original measurement is so severely attenuated at these
 frequencies.
 This sensor and the similar heated Rosemount sensor are therefore unable
 to detect contributions to sensible-heat flux from this frequency range,
 even after corrections.
 It nevertheless appears useful to apply one of these correction approaches
 routinely to improve the quality of the measurements.
 
\end_layout

\begin_layout Standard

\change_inserted 1311305628 1586299922
\begin_inset ERT
status open

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

<<HARCOcorrection, include=TRUE, fig.height=3.5, fig.cap=c('Corrected recovery
 temperature as measured by a heated HARCO sensor (
\begin_inset Quotes eld
\end_inset

RTHC
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

RTFFT
\begin_inset Quotes erd
\end_inset

), the uncorrected measurement (
\begin_inset Quotes eld
\end_inset

RTH1
\begin_inset Quotes erd
\end_inset

), and the best estimate of the true recovery temperature (
\begin_inset Quotes eld
\end_inset

RT
\begin_inset Quotes erd
\end_inset

) based on an unheated Rosemount sensor after correction.
 The time is seconds after 2018-02-24 5:59:00 UTC, SOCRATES flight 15.
 
\begin_inset Quotes eld
\end_inset

RTHC
\begin_inset Quotes erd
\end_inset

 is based on the approximate formula (20), while 
\begin_inset Quotes eld
\end_inset

RTFFT
\begin_inset Quotes erd
\end_inset

 results from Fourier transformation after correction using the transfer
 function determined from (13).
 Mean values have been subtracted from all to facilitate comparisons.', 'Variance
 spectra for some measurements of recovery temperature: 
\begin_inset Quotes eld
\end_inset

RT
\begin_inset Quotes erd
\end_inset

 (the best estimate resulting from correction of the measurements from the
 unheated Rosemount 102E4AL); 
\begin_inset Quotes eld
\end_inset

RTH1
\begin_inset Quotes erd
\end_inset

 (the uncorrected measurement from the heated HARCO); 
\begin_inset Quotes eld
\end_inset

RTFFT
\begin_inset Quotes erd
\end_inset

 (the corrected HARCO measurement based on Fourier transforms); and 
\begin_inset Quotes eld
\end_inset

RTHC
\begin_inset Quotes erd
\end_inset

 (the corrected HARCO measurement based on the correction formula (20)).')>>=
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

a <- Param1$a
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

tau1 <- Param1$tau1
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

tau2 <- Param1$tau2
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

## RT is the working solution; Ts is the support temperature
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

DSX$Ts <- DSX$RTF1
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

Rate <- attr (DSX, 'Rate')
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

DSX$DTMDT <- c(0, diff(DSX$RTF1, 2), 0) * Rate / 2
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

DSX$DTMDT <-  (c(0, 8*diff(DSX$RTF1, 2), 0) - 
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

              c(0, 0, diff(DSX$RTF1, 4), 0, 0)) * Rate / 12
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

# DT$DTMDT <- (DT$DTMDT + c(0, DT$DTMDT[1:(nrow(DT)-1)])) / 2
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

# DT$DTMDT <- as.vector (signal::filter(signal::sgolay(1, 3, m=1),
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

#             DT$TTRR)) * Rate
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

fS <- function(y, i) {  # Eq.
 Ts3
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

  ((1/a) * (tau1 * DSX$DTMDT[i] + DSX$RTF1[i] - (1-a) * y) - y) / (Rate
 * tau2)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

}
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

DSX$Ts <- rk4.integrate (fS, DSX$Ts[1], 1:nrow(DSX))
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

DSX$RT <- (1/a) * (tau1 * DSX$DTMDT + DSX$RTF1 - (1-a) * DSX$Ts)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

MRHO <- MachNumber(DSX$PSXC, DSX$QCXC) * DSX$PSXC * 100 /
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

                  (287.05 * (273.15 + DSX$ATX)) / rhozero
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

a <- bestSH[1]
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

tau1 <- bestSH[2] * (MRHO / 0.3) ^ 0.6  ## Note that these are variable
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

tau2 <- bestSH[3] * (MRHO / 0.3) ^ 0.6
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

Rate <- attr (DSX, 'Rate')
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

DSX$DTMDT <- c(0, diff(DSX$RTH1, 2), 0) * Rate / 2
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

DSX$DTM2DT2 <- (c(diff(DSX$RTH1), 0) - c(0, diff(DSX$RTH1))) * Rate^2
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

DSX$RTHC <- (tau1 + tau2) * DSX$DTMDT + DSX$RTH1 + tau1 * tau2 * DSX$DTM2DT2
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

DSX$RTHC <- zoo::na.approx (as.vector(DSX$RTHC), maxgap=1000*Rate,
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

      na.rm = FALSE, rule = 2)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

CutoffPeriod <- 12.5
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

DSX$RTHC <- signal::filtfilt (signal::butter (3,
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

      2/CutoffPeriod), DSX$RTHC)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

# DSX$RTHC <- SmoothInterp(DSX$RTHC, .Length=25)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

DSAP <- DSX
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

DSAP$RTH1 <- DSAP$RTH1 - mean(DSAP$RTH1[setRange(DSAP, 55700, 60000)], na.rm=TRUE
)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

DSAP$RTF1P <- DSAP$RTF1 - mean(DSAP$RTF1[setRange(DSAP, 55700, 60000)],
 na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

DSAP$RTHC <- DSAP$RTHC - mean(DSAP$RTHC[setRange(DSAP, 55700, 60000)], na.rm=TRUE
)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

DSAP$RT <- DSAP$RT - mean(DSAP$RT[setRange(DSAP, 55700, 60000)], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

# DSAP %>% selectTime(55920, 55950) %>% 
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

#          select(Time, RT, RTH1, RTHC) %>% 
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

#         ggplotWAC(col=c('blue', 'forestgreen', 'black'), lty=c(1,4,1),
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

#                   ylab=bquote('recovery temperature [' ~ degree * 'C]'),
 
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

#                   lwd=c(0.8,1,1)) + xlab('time [s]') +
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

#         theme_WAC(1) + theme(legend.position=c(0.75, 0.9))
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

DSAX <- DSX %>% selectTime(55700, 60300)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

DSAX <- DSAX[1:2^13, ]
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

ft <- fft(DSAX$RTH1)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

N <- length(ft)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

Rate <- attr(DSX, 'Rate')
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

df <- Rate / N
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

frq <- c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

fr <- log(abs(frq))
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

Gain  <- cfrHARCO[1] + fr * (cfrHARCO[2] + fr * fr * (cfrHARCO[3] + 
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

         fr * (cfrHARCO[4] + fr * cfrHARCO[5])))
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

Gain[abs(frq) < 0.024] <- 1
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

Phase <- cfHARCO[1] + cfHARCO[2] * fr + cfHARCO[3] * fr^2 +
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

         cfHARCO[4] * atan(frq)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

Phase[frq < 0] <- -Phase[frq < 0]
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

Phase[1] <- 0
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

Phase <- Phase * pi / 180
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

TF <- complex(modulus=Gain, argument=Phase)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

tlmt <- 1.8
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

TF[abs(frq) > tlmt] <- TF[abs(frq) > tlmt] * exp(5*abs(frq[abs(frq) > tlmt])
 / tlmt)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

ftx <- ft / TF
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

DSAX$RTFFT <- Re(fft(ftx, inverse = TRUE) / N)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

N <- 2^13 
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

Nby2 <- N / 2
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

RTH1 <- DSAX$RTH1
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

ff1 <- fft(RTH1)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

RTH <- Re(fft(ff1, inverse=TRUE)) / N
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

df <- Rate / N
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

frq <- c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

fr <- log(frq[1:(Nby2+1)])
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

## Get the transfer function from the fitted parameterized form:
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

Ph <- cfHARCO[1] + cfHARCO[2] * fr + 
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

           cfHARCO[3] * fr^2 + cfHARCO[4] * atan(frq[1:(Nby2+1)])
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

Ph[1] <- 0
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

G <- cfrHARCO[1] + fr * (cfrHARCO[2] + fr * fr * (cfrHARCO[3] + 
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

           fr * (cfrHARCO[4] + fr * cfrHARCO[5])))
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

G[frq[1:length(fr)] < 0.024] <- 1
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

G[frq[1:length(fr)] > 2] <- G[which.min(abs(frq-2))]
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

H <- rep(complex(modulus=0), N)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

H[1:(Nby2+1)] <- complex(modulus=G, argument=Ph * pi / 180)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

H[(Nby2+2):N] <- rev(Conj(H[2:Nby2]))
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

RTC <- Re(fft(ff1 / H, inverse = TRUE)) / N
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

DSAX$RTC <- RTC
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

dfTF <- data.frame(
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

  'Time' = frq,
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

  'Amp' = Gain,
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

  'Phase' = Phase
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

g <-
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

  ggplotWAC(
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

    dfTF,
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

    panels = 2,
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

    labelP = c('    Amplitude', 'Phase [degrees]')
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

  )
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

g <- g + xlab('frequency [Hz]') + ylab(bquote('transfer function H(' * nu
 ~ ')'))
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

g <-
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

  g + scale_x_log10(
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

    breaks = trans_breaks("log10", function(x)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

      10 ^ x, n = 4),
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

    labels = trans_format("log10", math_format(expr = 10 ^ .x))
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

  ) + xlab('frequency [Hz]')
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

g <- g + annotation_logticks(sides = 'tb')
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

# g + theme_WAC(1) + theme(legend.position = c(0.3, 0.65))
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

DSAP <- DSAX
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

DSAP$RTH1 <- DSAP$RTH1 - mean(DSAP$RTH1[setRange(DSAP, 55700, 60000)], na.rm=TRUE
)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

DSAP$RTF1P <- DSAP$RTF1 - mean(DSAP$RTF1[setRange(DSAP, 55700, 60000)],
 na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

DSAP$RTHC <- DSAP$RTHC - mean(DSAP$RTHC[setRange(DSAP, 55700, 60000)], na.rm=TRUE
)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

DSAP$RT <- DSAP$RT - mean(DSAP$RT[setRange(DSAP, 55700, 60000)], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

DSAP$RTFFT <- DSAP$RTFFT - mean(DSAP$RTFFT[setRange(DSAP, 55700, 60000)],
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

                                na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

DSAP %>% selectTime(55920, 55950) %>% 
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

         select(Time, RT, RTH1, RTFFT, RTHC) %>% 
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

         ggplotWAC(c('blue', 'forestgreen', 'black', 'darkorange'),
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

                   ylab=bquote('recovery temperature [' ~ degree * 'C]'),
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586379190

                   lty=c(1,2,1,1), lwd=c(0.8,1.2,1,0.8)) + xlab('time [s]')
 +
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

         theme_WAC(1) + 
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

         theme(legend.position=c(0.715, 0.93))
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

g <- DSAP %>% select(Time, TASX, RTFFT, RTHC, RT) %>% 
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

        VSpec(xlim=c(5.e-3, 15), ylim=c(2.e-6, 1.e-2), 
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

        smoothBins = 100, method='MEM')
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

VSpec(DSAP, 'RTH1', add=g, type='MEM') + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

\end_layout

\begin_layout Plain Layout

\change_inserted 1311305628 1586299922

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\change_inserted 1311305628 1586299922
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Section
Reproducibility
\end_layout

\begin_layout Standard
\begin_inset Index idx
status open

\begin_layout Plain Layout
reproducibility
\end_layout

\end_inset

This document is constructed in ways that support duplication of the study.
 The code that generates the plots and implements the correction procedure
 is incorporated into the same 
\begin_inset Index idx
status open

\begin_layout Plain Layout
program!file
\end_layout

\end_inset

file that generated this document via 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
LaTeX
\end_layout

\end_inset

, using principles and techniques described by 
\begin_inset CommandInset citation
LatexCommand citet
key "Xie2014a"
literal "true"

\end_inset

 as implemented in the R 
\begin_inset Index idx
status open

\begin_layout Plain Layout
R language!package!knitr
\end_layout

\end_inset

package
\begin_inset Index idx
status open

\begin_layout Plain Layout
knitr
\end_layout

\end_inset

 'knitr' (
\begin_inset CommandInset citation
LatexCommand citet
key "Xie2014b"
literal "true"

\end_inset

).
 The program, 'SensibleHeatFluxPaper1.Rnw', is archived on 'GitHub' 
\begin_inset Index idx
status open

\begin_layout Plain Layout
GitHub repository
\end_layout

\end_inset

in the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
repository!github
\end_layout

\end_inset

directory
\begin_inset Index idx
status open

\begin_layout Plain Layout
archive!for this document
\end_layout

\end_inset

 at 
\begin_inset CommandInset href
LatexCommand href
name "this URL"
target "https://github.com/WilliamCooper/KalmanFilter.git"
literal "false"

\end_inset

.
 There is some 
\begin_inset Index idx
status open

\begin_layout Plain Layout
supplemental material
\end_layout

\end_inset

supplemental material in that directory, including the workflow document
\begin_inset Index idx
status open

\begin_layout Plain Layout
workflow document
\end_layout

\end_inset

, the bibliography and some code segments saved in the 
\begin_inset Quotes eld
\end_inset

chunks
\begin_inset Quotes erd
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
R language!program chunks
\end_layout

\end_inset

 subdirectory, so the full directory should be downloaded in order to run
 the program.
 The calculations use the programming 
\begin_inset Index idx
status open

\begin_layout Plain Layout
R language
\end_layout

\end_inset

language 
\begin_inset Index idx
status open

\begin_layout Plain Layout
R language!program
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
RStudio
\end_layout

\end_inset

R (
\begin_inset CommandInset citation
LatexCommand citet
key "Rlanguage"
literal "true"

\end_inset

) and were run within 
\begin_inset Index idx
status open

\begin_layout Plain Layout
RStudio
\end_layout

\end_inset

RStudio (
\begin_inset CommandInset citation
LatexCommand citet
key "RStudio2012"
literal "true"

\end_inset

), so this is the most straightforward way to replicate the calculations
 and the generation of this 
\begin_inset Index idx
status open

\begin_layout Plain Layout
program!generating this document
\end_layout

\end_inset

document.
\end_layout

\begin_layout Standard
A 
\begin_inset Index idx
status open

\begin_layout Plain Layout
R language!package!Ranadu
\end_layout

\end_inset

package named Ranadu,
\begin_inset Index idx
status open

\begin_layout Plain Layout
R language!package!Ranadu
\end_layout

\end_inset

 containing auxillary 
\begin_inset Index idx
status open

\begin_layout Plain Layout
function!Ranadu
\end_layout

\end_inset

functions, is used extensively in the R code.
 It is available on GitHub
\begin_inset Index idx
status open

\begin_layout Plain Layout
GitHub repository
\end_layout

\end_inset

 as 
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/WilliamCooper/Ranadu.git"
literal "false"

\end_inset

.
 The version used for calculations in this technical note is included in
 the 'zip' archive listed below.
\end_layout

\begin_layout Standard
The 
\begin_inset Index idx
status open

\begin_layout Plain Layout
file!data
\end_layout

\end_inset

data files used are also preserved in the NCAR/EOL Data Archives and can
 be obtained via a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
data!requesting
\end_layout

\end_inset

request to 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

mailto:raf-dm@eol.ucar.edu
\end_layout

\end_inset

 or via the 
\begin_inset Quotes eld
\end_inset

Data Access
\begin_inset Quotes erd
\end_inset

 links at 
\begin_inset CommandInset href
LatexCommand href
name "this web site"
target "https://www.eol.ucar.edu/all-field-projects-and-deployments"
literal "false"

\end_inset

.
 The original files containing the data as produced by the NCAR Earth Observing
 Laboratory, Research Aviation Facility, were in 
\begin_inset Index idx
status open

\begin_layout Plain Layout
netCDF format
\end_layout

\end_inset

netCDF format (cf.
\begin_inset space ~
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "this URL"
target "http://www.unidata.ucar.edu/software/netcdf/"
literal "false"

\end_inset

), but in many cases data archives were reprocessed and the files may change
 after reprocessing so a separate archive
\begin_inset Index idx
status open

\begin_layout Plain Layout
archive!for this document!data
\end_layout

\end_inset

 is maintained for this document.
 The data files
\begin_inset Index idx
status open

\begin_layout Plain Layout
file!data!archive
\end_layout

\end_inset

 in this archive contain 
\begin_inset Index idx
status open

\begin_layout Plain Layout
R language!data.frames
\end_layout

\end_inset

R data.frames and are preserved as binary-format 'Rdata' files via R 'save'
 commands.
 The code in the GitHub archive has appropriate 'load' commands to read
 these data files from a subdirectory named 'Data' (/Data or ~/Data or /home/Dat
a) but this is not part of the GitHub repository because it is too large
 to be appropriate there.
 To reproduce this research, those data files have to be transferred separately
 from {??where??}
\end_layout

\begin_layout Standard
Extensive use has been made of 
\begin_inset Index idx
status open

\begin_layout Plain Layout
attributes!data.frame
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
attributes!variable
\end_layout

\end_inset

attributes assigned to the data.frames and the variables in those data.frames.
 All the attributes from the original netCDF 
\begin_inset Index idx
status open

\begin_layout Plain Layout
file!netCDF
\end_layout

\end_inset

files have been transferred, so there is a record of how the original data
 were processed, for example recording 
\begin_inset Index idx
status open

\begin_layout Plain Layout
calibration!coefficients!used in processing
\end_layout

\end_inset

calibration coefficients and processing chains for the variables.
 Once the data.frames are loaded into R, these attributes can be viewed and
 provide additional documentation of what data were used.
 Key information like the processing date, the program version that produced
 the archive, and the selection of primary variables for various measurements
 thus is preserved.
\end_layout

\begin_layout Standard
(See the related list of project components on the next page that are preserved
 to enhance reproducibility.)
\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Project:
\family default
\shape default
\color inherit
 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SensibleHeatFlux
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Archive package:
\family default
\shape default
\color inherit
 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "SensibleHeatFluxPaper1.zip"
target "https://github.com/WilliamCooper/SensibleHeatFlux/blob/master/SensibleHeatFluxPaper1.zip"
literal "false"

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Contains:
\family default
\shape default
\color inherit
 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
attachment list below
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Program:
\family default
\shape default
\color inherit
 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "SensibleHeatFluxPaper1.Rnw"
target "https://github.com/WilliamCooper/SensibleHeatFlux/blob/master/SensibleHeatFluxPaper1.Rnw"
literal "false"

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Original Data:
\family default
\shape default
\color inherit
 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset CommandInset citation
LatexCommand citet
key "VOCALS2011"
literal "false"

\end_inset

,
\begin_inset CommandInset citation
LatexCommand citet
key "SOCRATES2019"
literal "false"

\end_inset

, 
\begin_inset CommandInset citation
LatexCommand citet
key "CSET2017"
literal "false"

\end_inset

 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Special Data Files:
\family default
\shape default
\color inherit
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SensibleHeatFluxTechNote.Rdata, SensibleHeatFluxTechNote2.Rdata
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Workflow Document:
\family default
\shape default
\color inherit
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "WorkflowSensibleHeatFluxPaper1.pdf"
target "https://github.com/WilliamCooper/SensibleHeatFlux/blob/master/WorkflowSensibleHeatFluxPaper1.pdf"
literal "false"

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Git:
\family default
\shape default
\color inherit
 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Index idx
status open

\begin_layout Plain Layout
GitHub repository
\end_layout

\end_inset


\begin_inset CommandInset href
LatexCommand href
name "https://github.com/WilliamCooper/SensibleHeatFlux.git"
target "https://github.com/WilliamCooper/SensibleHeatFlux.git"
literal "false"

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
attachm{
\end_layout

\end_inset

SensibleHeatFluxPaper1.Rnw
\begin_inset Newline newline
\end_inset

SensibleHeatFluxPaper1.pdf
\begin_inset Newline newline
\end_inset

WorkflowSensibleHeatFluxPaper1.pdf
\begin_inset Newline newline
\end_inset

WAC.bib
\begin_inset Newline newline
\end_inset

chunks/*
\begin_inset Newline newline
\end_inset

SessionInfo
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\begin_layout Plain Layout


\backslash
phantomsection 
\backslash
addcontentsline{toc}{section}{List of Symbols}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset index_print
LatexCommand printindex
type "lis"
name "List of Symbols"
literal "true"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\begin_layout Plain Layout


\backslash
phantomsection 
\backslash
addcontentsline{toc}{section}{Variable Names and Acronyms}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset index_print
LatexCommand printindex
type "var"
name "Variable Names and Acronyms"
literal "true"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Variable Names
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\begin_layout Plain Layout


\backslash
phantomsection 
\backslash
addcontentsline{toc}{section}{Index}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
** indicates that many similar entries are omitted.
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset index_print
LatexCommand printindex
type "idx"
name "Index"
literal "true"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\begin_layout Plain Layout

%
\backslash
phantomsection 
\backslash
addcontentsline{toc}{section}{References}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:bibliography"

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "/home/cooperw/RStudio/WAC"
options "bibtotoc,plainnat"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% 
\backslash
centerline{-- Blank Page, End of this Technical Report --}
\end_layout

\begin_layout Plain Layout

% 
\backslash
vfill
\backslash
eject
\end_layout

\begin_layout Plain Layout

% 
\backslash
clearpage
\end_layout

\begin_layout Plain Layout

%
\backslash
addcontentsline{toc}{section}{End}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<make-zip-archive, INCLUDE=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

system (sprintf("zip KalmanFilterTechNote.zip KalmanFilterTechNote.Rnw KalmanFilte
rTechNote.pdf WorkflowKalmanFilter.pdf WAC.bib ./chunks/* SessionInfo"))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@ 
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
