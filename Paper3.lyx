#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\definecolor{fgcolor}{rgb}{0.345, 0.345, 0.345}\definecolor{messagecolor}{rgb}{0, 0, 0}\definecolor{warningcolor}{rgb}{1, 0, 1}\definecolor{errorcolor}{rgb}{1, 0, 0}\setlength{\headheight}{14.5pt}\usepackage{babel}


\definecolor{fgcolor}{rgb}{0.345, 0.345, 0.345}\definecolor{messagecolor}{rgb}{0, 0, 0}\definecolor{warningcolor}{rgb}{1, 0, 1}\definecolor{errorcolor}{rgb}{1, 0, 0}\usepackage{babel}
% macro for italic page numbers in the index
\newcommand{\IndexDef}[1]{\textit{#1}}
\newcommand{\IndexPrimary}[1]{\textbf{#1}}
% force a page break at the start of sections
\let\stdsection\section
\renewcommand{\section}{\newpage\stdsection}


% workaround for a makeindex bug,
% see sec. "Index Entry Order"
% only uncomment this when you are using makindex
%\let\OrgIndex\index 
%\renewcommand*{\index}[1]{\OrgIndex{#1}}
%\usepackage{splitidx}

% workaround for a makeindex bug,
% see sec. "Index Entry Order"
% only uncomment this when you are using makindex
\let\OrgIndex\index 
\renewcommand*{\index}[1]{\OrgIndex{#1}}
\usepackage{splitidx}
%\indexsetup{noclearpage}
\AtBeginDocument{
  \def\labelitemii{\(\circ\)}
  \def\labelitemiii{\(\triangleright\)}
}
\usepackage[font={normal,sl}]{caption}% set captions slanted

\IfFileExists{upquote.sty}{\usepackage{upquote}}{}

\newenvironment{lylist}[1]{\begin{list}{}
{\settowidth{\labelwidth}{#1}
\setlength{\leftmargin}{\labelwidth}
\addtolength{\leftmargin}{\labelsep}
\renewcommand{\makelabel}[1]{##1\hfil}}}{\end{list}}
\newcommand{\datetoday}{\number\day\space
     \ifcase\month\or January\or February\or March\or April\or May\or
     June\or July\or August\or September\or October\or November\or
     December\fi
     \space\number\year}
\newcommand{\EOLmemo}{\null \vskip-1.5truein
{\raggedright \textsf{\textsc{\large \textcolor{blue}{Earth Observing Laboratory}}}}\par
{\raggedright \textsf{\textsl{\textcolor{blue}{Memorandum:}}}} \par \vskip6pt
{\color{blue}{\hrule}}\par
\vskip0.3truein \leftline{\hskip \longindent \datetoday} \vskip0.2truein
\thispagestyle{empty}}
\newcommand{\attachm}[1]{\begin{lylist}{Attachments:00}
\item [Attachments:] {#1}
\end{lylist}}
\newcommand{\cc}[1]{\begin{lylist}{Attachments:00}
\item [cc:] {#1}
\end{lylist}}
\newcommand{\attach}[1]{\begin{lylist}{Attachments:00}
\item [Attachment:] {#1}
\end{lylist}}

\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\pagenumbering{gobble}
\end_preamble
\options 12pt,twoside,american
\use_default_options false
\begin_modules
knitr
hanging
\end_modules
\maintain_unincluded_children false
\language american
\language_package babel
\inputencoding default
\fontencoding global
\font_roman "times" "default"
\font_sans "helvet" "default"
\font_typewriter "lmtt" "default"
\font_math "auto" "auto"
\font_default_family rmdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format pdf2
\output_sync 0
\bibtex_command bibtex
\index_command makeindex
\paperfontsize 11
\spacing single
\use_hyperref true
\pdf_title "Technical Note: Measuring Sensible-Heat Flux"
\pdf_author "William A. Cooper"
\pdf_subject "Assessment of Measurements of Sensible-Heat Flux"
\pdf_keywords "sensible heat flux, temperature, time response of sensors, NCAR Research Aviation Facility, research aircraft, NCAR/EOL/RAF"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 2
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref section
\pdf_pdfusetitle false
\pdf_quoted_options " linkcolor=blue, citecolor={blue}"
\papersize letterpaper
\use_geometry true
\use_package amsmath 2
\use_package amssymb 0
\use_package cancel 0
\use_package esint 2
\use_package mathdots 0
\use_package mathtools 0
\use_package mhchem 0
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine natbib
\cite_engine_type authoryear
\biblio_style plainnat
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification false
\use_refstyle 0
\use_minted 0
\backgroundcolor #ffffff
\boxbgcolor #f7f7f7
\branch Extra
\selected 0
\filename_suffix 0
\color #faf0e6
\end_branch
\index Index
\shortcut idx
\color #008000
\end_index
\index Variable Names and Acronyms
\shortcut var
\color #00aaff
\end_index
\index List of Symbols
\shortcut lis
\color #ff0000
\end_index
\leftmargin 1.2in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 2
\paragraph_separation skip
\defskip medskip
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
The Delayed Response of Airborne Thermometers:
\begin_inset Newline newline
\end_inset

Part 3: Measuring the Flux of Sensible Heat
\end_layout

\begin_layout Author
William A.
 Cooper and others...
\end_layout

\begin_layout Date

\color red
DRAFT
\color inherit
 March 2020
\end_layout

\begin_layout Standard
National Center for Atmospheric Research
\begin_inset Newline newline
\end_inset

Earth Observing Laboratory
\begin_inset Newline newline
\end_inset

Research Aviation Facility
\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\begin_inset Newpage cleardoublepage
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{roman}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
contentsname}{Table of Contents} 
\end_layout

\end_inset


\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset

 
\begin_inset VSpace vfill
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
eject
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%% LyX 2.2.2 created this file.
  For more info, see http://www.lyx.org/.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\backslash
phantomsection 
\backslash
addcontentsline{toc}{section}{List of Figures}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
clearpage %
\backslash
phantomsection 
\backslash
addcontentsline{toc}{section}{List of Tables}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList table

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
abstractname}{Preface and Abstract}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{plain}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{abstract}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The predecessor papers in this series, Parts 1 and 2, characterized the
 time response of some airborne thermometers, developed correction procedures
 for those measurements based on their parameterized transfer functions,
 and developed a way to correct for the errors introduced when the standard
 dynamic-heating correction is applied without filtering that signal to
 match the time response of the sensors.
 This paper considers the implications of those results for measurements
 of the flux of sensible heat.
 In particular, it is showm that one sensor in common use, the unheated
 Rosemount 102E4AL sensor, will miss important parts of the flux if there
 are significant contributions above about 1
\begin_inset space ~
\end_inset

Hz, but the flux cospectrum can be corrected reliably to extend that limit
 to near 10
\begin_inset space ~
\end_inset

Hz.
 For examples of measured fluxes, the correction procedure indicates that
 without this correction the flux measurement would be too small by about
 25%.
 The correction procedure consists of dividing the Fourier transform of
 the temperature by the transfer function for the temperature sensor before
 calculating the cospectrum of temperature and vertical-wind fluctuations.
 Simulation results support the validity of the correction procedure.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{abstract}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Section*
Acknowledgments
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:acknowledgements"

\end_inset


\end_layout

\begin_layout Standard
This material is based upon work supported by the National Center for Atmospheri
c Research, which is a major facility sponsored by the National Science
 Foundation under Cooperative Agreement No.
 1852977.
 Any opinions, findings and conclusions or recom-mendations expressed in
 this publication are those of the author(s) and do not necessarily reflect
 the views of the National Science Foundation.
 The data used in the examples presented are from the VOCALS (VAMOS Ocean-Cloud-
Atmosphere-Land Study), SOCRATES (Southern Ocean Clouds, Radiation, Aerosol
 Transport Experimental Study) and the CSET (Cloud Systems Evolution in
 the Trades) experiment, 
\begin_inset Note Note
status open

\begin_layout Plain Layout
WE-CAN (Western wildfire Experiment for Cloud chemistry, Aerosol absorption
 and Nitrogen) projects, 
\end_layout

\end_inset

each described at 
\begin_inset CommandInset href
LatexCommand href
name "this URL"
target "https://www.eol.ucar.edu/field_projects/"
literal "false"

\end_inset

.
 Citations for the data sets are included in the references.
 Measurements (
\begin_inset CommandInset citation
LatexCommand citet
key "VOCALS2011"
literal "false"

\end_inset

, 
\begin_inset CommandInset citation
LatexCommand citet
key "SOCRATES2019"
literal "false"

\end_inset

, 
\begin_inset CommandInset citation
LatexCommand citet
key "WECAN2018"
literal "false"

\end_inset

) were collected by the project experiment teams, and flight operations
 and data acquisition and processing were performed by the Research Aviation
 Facility, Earth Observing Laboratory, National Center for Atmospheric Research
 (NCAR).
 The analyses reported here were mostly performed using R (
\begin_inset CommandInset citation
LatexCommand citet
key "Rlanguage"
literal "true"

\end_inset

), with 
\begin_inset Index idx
status open

\begin_layout Plain Layout
RStudio
\end_layout

\end_inset

RStudio (
\begin_inset CommandInset citation
LatexCommand citet
key "RStudio2012"
literal "true"

\end_inset

) and 
\begin_inset Index idx
status open

\begin_layout Plain Layout
knitr
\end_layout

\end_inset

knitr (
\begin_inset CommandInset citation
LatexCommand citet
key "Xie2014a,Xie2014b"
literal "true"

\end_inset

).
 Data files in netCDF format have been read and written using the R 
\begin_inset Index idx
status open

\begin_layout Plain Layout
R language!package!ncdf4
\end_layout

\end_inset

package 
\begin_inset Quotes eld
\end_inset

ncdf4
\begin_inset Quotes erd
\end_inset

; cf.
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand citet
key "ncdf4"
literal "true"

\end_inset

.
 Substantial use also was made of the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
ggplot2
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
R language!package!ggplot2
\end_layout

\end_inset


\begin_inset Quotes eld
\end_inset

ggplot2
\begin_inset Quotes erd
\end_inset

 package (
\begin_inset CommandInset citation
LatexCommand citet
key "wickham2009"
literal "true"

\end_inset

) for R, and some fits relied on the 
\begin_inset Quotes eld
\end_inset

nleqslv
\begin_inset Quotes erd
\end_inset

 package for R 
\begin_inset CommandInset citation
LatexCommand citet
key "hasselman-nleqslv"
literal "false"

\end_inset

.
 Extensive use was made of the 
\begin_inset Quotes eld
\end_inset

stats
\begin_inset Quotes erd
\end_inset

 package, part of Core R\SpecialChar endofsentence
 Some of the numerical integrations used the Runge-Kutta
 function from the 
\begin_inset Quotes eld
\end_inset

rmutil
\begin_inset Quotes erd
\end_inset

 package (
\begin_inset CommandInset citation
LatexCommand citet
key "runge.kutta"
literal "false"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{plain}
\end_layout

\end_inset


\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{arabic}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Subsection
Overview
\end_layout

\begin_layout Standard
As introduced in Part 1, the basis for eddy-correlation measurement of sensible-
heat flux (
\begin_inset Formula $F_{s}$
\end_inset

) is the following equation:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
F_{s}=\rho_{a}\thinspace C_{p}\left\langle w^{\prime}T^{\prime}\right\rangle \label{eq:heatFlux-1}
\end{equation}

\end_inset

where 
\begin_inset Formula $\rho_{a}$
\end_inset

 is the density of air, 
\begin_inset Formula $C_{p}$
\end_inset

 the specific heat of air at constant pressure, 
\begin_inset Formula $w$
\end_inset

 the vertical wind, and 
\begin_inset Formula $T$
\end_inset

 the temperature.
 Primes in this equation denote fluctuations from the mean and angle brackets
 denote an ensemble average.
 The measurement thus depends on having a temperature sensor that can respond
 to the range of fluctuations making significant contributions to the heat
 flux.
 This measurement requires that temperature be measured with sufficient
 response to resolve the spectrum of contributions to the flux, and most
 sensors in routine use are marginal or inadequate for this use.
 This third paper in a three-part series argues that application of a correction
 procedure improves this measurement sufficiently to make it reliable despite
 the response-characteristics of airborne thermometers, at least for one
 sensor in common use.
 This paper relies on information from the first two and will need to reference
 those results in many places.
 
\end_layout

\begin_layout Standard
A crucial characteristic of the temperature sensor is its transfer function,
 or the ratio of output to input.
 In particular, as represented as a frequency-dependent function, the transfer
 function specifies the amplitude and phase of the output for a unit magnitude
 sinusoidal input of a given frequency.
 In Part 1, this transfer function was determined by observing the sensor
 response to measured fluctuations in dynamic heating in regions where those
 fluctuations were the dominant source of variability in the recovery temperatur
e 
\begin_inset Formula $T_{r}$
\end_inset

, which is related to the ambient temperature 
\begin_inset Formula $T_{a}$
\end_inset

 and the dynamic heating 
\begin_inset Formula $Q$
\end_inset

 according to the equation 
\begin_inset Formula $T_{r}=T_{a}+Q$
\end_inset

.
 The focus in Part 1 was on the relationship between the measured recovery
 temperature 
\begin_inset Formula $T_{m}$
\end_inset

 and the true recovery temperature 
\begin_inset Formula $T_{r}$
\end_inset

, while Part 2 focused on correcting 
\begin_inset Formula $Q$
\end_inset

 for the response of the sensor to avoid the introduction of noise and false
 variations arising from fluctuations in dynamic heating to which the temperatur
e sensor cannot respond.
 Here the key results from those first two papers will be used: (i) the
 transfer function 
\begin_inset Formula $H(\nu)$
\end_inset

 as a function of frequency 
\begin_inset Formula $\nu$
\end_inset

; and (ii) the modified dynamic-heating term 
\begin_inset Formula $Q^{\prime}$
\end_inset

 obtained by filtering 
\begin_inset Formula $Q$
\end_inset

 according to the sensor response characteristics.
\end_layout

\begin_layout Subsection
Outline of the correction procedure
\begin_inset CommandInset label
LatexCommand label
name "subsec:Outline-correction"

\end_inset


\end_layout

\begin_layout Standard
Two approaches are presented.
 Both follow the steps below but differ in step 2:
\end_layout

\begin_layout Enumerate
Find the transfer function.
 The estimated air temperature is normally calculated from 
\begin_inset Formula $T_{a}=T_{m}-Q$
\end_inset

 where 
\begin_inset Formula $T_{m}$
\end_inset

 is the measured recovery temperature, but here it is desired to correct
 both 
\begin_inset Formula $T_{m}$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 on the basis of the known transfer function 
\begin_inset Formula $H(\nu)$
\end_inset

.
 The first step is therefore to determine an appropriate transfer function.
 In Part 1, it was argued that the result varies with Mach number and air
 density, so appropriate corrections to those characteristics as listed
 in Table 2 of Part 1 should be made.
 Alternately (and better), the transfer function can be determined for the
 actual flight conditions using the approach from Part 1.
 For a representative transfer function, see Fig.
\begin_inset space ~
\end_inset

1 from Part 1.
\end_layout

\begin_layout Enumerate
Calculate the air temperature 
\begin_inset Formula $T_{a}$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Enumerate
Method 1: Because the transfer function is the ratio between Fourier representat
ions of the output and the input, the Fourier transform ( 
\begin_inset Formula $(\hat{T}_{r}(\nu))$
\end_inset

 of the input recovery temperature (
\begin_inset Formula $T_{r}(t)$
\end_inset

) will be 
\begin_inset Formula $\hat{T}_{m}(\nu)/H(\nu)$
\end_inset

, where the circumflex (
\begin_inset Formula $\hat{}$
\end_inset

) denotes the Fourier transform, so the recovery temperature can be retrieved
 using the inverse Fourier transform of 
\begin_inset Formula $\hat{T}_{m}(\nu)/H(\nu)$
\end_inset

.
 The air temperature then is calculated from 
\begin_inset Formula $T_{r}-Q^{\prime}$
\end_inset

 where 
\begin_inset Formula $Q^{\prime}$
\end_inset

is the result of filtering the dynamic heating term 
\begin_inset Formula $Q$
\end_inset

 using the response characteristic of the sensor.
 
\begin_inset Formula $Q^{\prime}$
\end_inset

 can be found from the inverse Fourier transform of 
\begin_inset Formula $H(\nu)\hat{Q}(\nu)$
\end_inset

.
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Foot
status open

\begin_layout Plain Layout
Note, however, that the filtered dynamic-heating term 
\begin_inset Formula $Q^{\prime}$
\end_inset

 can be obtained also from the transfer function: 
\begin_inset Formula $Q^{\prime^{\dagger}}(\nu)=H(\nu)Q^{\dagger}(\nu)$
\end_inset

.
 Because the Fourier transform is a linear function, the Fourier transform
 of 
\begin_inset Formula $T_{a}=T_{r}-Q^{\prime}$
\end_inset

 is 
\begin_inset Formula $T_{r}^{\dagger}-Q^{\prime^{\dagger}}$
\end_inset

 = 
\begin_inset Formula $T_{m}^{\dagger}(\nu)/H(\nu)-H(\nu)Q^{\dagger}(\nu)$
\end_inset

 so this is the Fourier transform that should be multiplied by that for
 the updraft to obtain the cospectrum representing the flux.
 That approach can substitute for calculating 
\begin_inset Formula $T_{a}$
\end_inset

 and then using that to calculate the cospectrum.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Method 2: Use the differential equations to find 
\begin_inset Formula $T_{r}$
\end_inset

 from the measurements 
\begin_inset Formula $T_{m},$
\end_inset

 as in Sect.
\begin_inset space ~
\end_inset

4.1 of Part 1.
 Filter the dynamic heating to obtain 
\begin_inset Formula $Q^{\prime}$
\end_inset

 as specified in Part 2.
 Then 
\begin_inset Formula $T_{a}=T_{r}-Q^{\prime}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
The cospectrum then is calculated for the cross-spectrum of temperature
 and updraft, with a choice made regarding which frequency interval to include.
 This will normally exclude wavelengths longer than a few kilometers.
\end_layout

\begin_layout Enumerate
Finally, calculate the flux from the sum of the resulting cospectrum over
 the specified frequency interval.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<initialization, echo=FALSE,include=FALSE>>=
\end_layout

\begin_layout Plain Layout

## This chunk loads some needed R packages and defines a function
\end_layout

\begin_layout Plain Layout

## used for the Laplace-transform solution of the governing
\end_layout

\begin_layout Plain Layout

## differential equations.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

library(knitr)
\end_layout

\begin_layout Plain Layout

opts_chunk$set(echo = FALSE,
\end_layout

\begin_layout Plain Layout

               include = FALSE,
\end_layout

\begin_layout Plain Layout

               fig.lp = "fig:")
\end_layout

\begin_layout Plain Layout

# note that fig.pos="center" gave errors, changed to fig.align
\end_layout

\begin_layout Plain Layout

opts_chunk$set(
\end_layout

\begin_layout Plain Layout

  fig.width = 6,
\end_layout

\begin_layout Plain Layout

  fig.height = 3.5,
\end_layout

\begin_layout Plain Layout

  fig.align = "center",
\end_layout

\begin_layout Plain Layout

  digits = 4
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

thisFileName <- "SensibleHeatFluxTechNote"
\end_layout

\begin_layout Plain Layout

library(Ranadu, quietly = TRUE, warn.conflicts = FALSE)
\end_layout

\begin_layout Plain Layout

library(scales)
\end_layout

\begin_layout Plain Layout

require(numDeriv)    ## is this used?
\end_layout

\begin_layout Plain Layout

library(signal)      ## used for filtering
\end_layout

\begin_layout Plain Layout

library(reshape2)    ## used with ggplot facet plots
\end_layout

\begin_layout Plain Layout

library(grid)
\end_layout

\begin_layout Plain Layout

library(magrittr)    ## used for pipes (%>%)
\end_layout

\begin_layout Plain Layout

library(dplyr)
\end_layout

\begin_layout Plain Layout

library(rmutil)      ## provides the runge-kutta integration function
\end_layout

\begin_layout Plain Layout

options(stringsAsFactors = FALSE)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

CACHE <- FALSE
\end_layout

\begin_layout Plain Layout

setwd ('~/RStudio/SensibleHeatFlux') 
\end_layout

\begin_layout Plain Layout

Directory <- DataDirectory ()
\end_layout

\begin_layout Plain Layout

## standard values:
\end_layout

\begin_layout Plain Layout

frq <- seq(0.01, 25, by = 0.01)
\end_layout

\begin_layout Plain Layout

Phi <- rep(0, length(frq))
\end_layout

\begin_layout Plain Layout

H <- rep(0, length(frq))
\end_layout

\begin_layout Plain Layout

a <- 0.733 # 0.713
\end_layout

\begin_layout Plain Layout

tau1 <- 0.0308  # 0.0335
\end_layout

\begin_layout Plain Layout

tau2 <- 0.447
\end_layout

\begin_layout Plain Layout

Param1 <- list('a' = a, 'tau1' = tau1, 'tau2' = tau2)
\end_layout

\begin_layout Plain Layout

ParamSF <- Param1
\end_layout

\begin_layout Plain Layout

ParamSF$a <- 0.652
\end_layout

\begin_layout Plain Layout

ParamSF$tau1 <- 0.0295
\end_layout

\begin_layout Plain Layout

ParamSF$tau2 <- 1.04
\end_layout

\begin_layout Plain Layout

# The Laplace-transform solution:
\end_layout

\begin_layout Plain Layout

LTphase <- function(f, P) {
\end_layout

\begin_layout Plain Layout

  ## f=frequency; P=Param
\end_layout

\begin_layout Plain Layout

  tau1 <- P$tau1
\end_layout

\begin_layout Plain Layout

  tau2 <- P$tau2
\end_layout

\begin_layout Plain Layout

  a <- P$a
\end_layout

\begin_layout Plain Layout

  b <- sqrt(1 / (1 + (2 * pi * f * tau2) ^ 2))
\end_layout

\begin_layout Plain Layout

  zeta <- -atan(2 * pi * f * tau2)
\end_layout

\begin_layout Plain Layout

  C1 <- 1 / (1 + 4 * pi ^ 2 * f ^ 2 * tau1 ^ 2) *
\end_layout

\begin_layout Plain Layout

    (-(a + (1 - a) * b * cos(zeta)) * 2 * pi * f * tau1 +
\end_layout

\begin_layout Plain Layout

       (1 - a) * b * sin(zeta))
\end_layout

\begin_layout Plain Layout

  C2 <- 1 / (1 + 4 * pi ^ 2 * f ^ 2 * tau1 ^ 2) *
\end_layout

\begin_layout Plain Layout

    ((a + (1 - a) * b * cos(zeta)) +
\end_layout

\begin_layout Plain Layout

       (1 - a) * b * sin(zeta) * 2 * pi * f * tau1)
\end_layout

\begin_layout Plain Layout

  cTF <- sqrt(C1 ^ 2 + C2 ^ 2)
\end_layout

\begin_layout Plain Layout

  phiTF <- atan2(C1, C2) 
\end_layout

\begin_layout Plain Layout

  return(complex(modulus = cTF, argument = phiTF))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

source('./chunks/rk4.integrate.R')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Examples with Corrections Applied
\end_layout

\begin_layout Subsection
VOCALS example
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<TASX, include = FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

reviseDH <-
\end_layout

\begin_layout Plain Layout

  function (.data, P, alphaR) {
\end_layout

\begin_layout Plain Layout

    # P is Param1, e.g.; alphaR is recovery factor
\end_layout

\begin_layout Plain Layout

    .data$Q <- .data$TASX ^ 2 / 2010
\end_layout

\begin_layout Plain Layout

    aV <- P$a
\end_layout

\begin_layout Plain Layout

    tau1V <- P$tau1
\end_layout

\begin_layout Plain Layout

    tau2V <- P$tau2
\end_layout

\begin_layout Plain Layout

    Rate <- attr (.data, 'Rate')
\end_layout

\begin_layout Plain Layout

    fS <- function(y, i) {
\end_layout

\begin_layout Plain Layout

      (.data$Q[i] - y) / (tau2V * Rate)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    fM <- function (y, i) {
\end_layout

\begin_layout Plain Layout

      (aV * .data$Q[i] + (1 - aV) * TsQ[i] - y) / (Rate * tau1V)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    TsQ <- rk4.integrate (fS, .data$Q[1], 1:nrow(.data))
\end_layout

\begin_layout Plain Layout

    Qp <- rk4.integrate (fM, .data$Q[1], 1:nrow(.data))
\end_layout

\begin_layout Plain Layout

    return (.data$ATX + alphaR * (.data$Q - Qp))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

if (file.exists ('./DVOCALS.Rdata')) {
\end_layout

\begin_layout Plain Layout

  load (file = './DVOCALS.Rdata')
\end_layout

\begin_layout Plain Layout

  DVOCALS <- D
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  D <- getNetCDF(
\end_layout

\begin_layout Plain Layout

    file.path(DataDirectory(), 'VOCALS/VOCALSrf03h.nc'),
\end_layout

\begin_layout Plain Layout

    c(
\end_layout

\begin_layout Plain Layout

      'TASX',
\end_layout

\begin_layout Plain Layout

      'PALT',
\end_layout

\begin_layout Plain Layout

      'TTRR',
\end_layout

\begin_layout Plain Layout

      'ATRR',
\end_layout

\begin_layout Plain Layout

      'TTWH',
\end_layout

\begin_layout Plain Layout

      'WIC',
\end_layout

\begin_layout Plain Layout

      'ATX',
\end_layout

\begin_layout Plain Layout

      'PSXC',
\end_layout

\begin_layout Plain Layout

      'QCXC'
\end_layout

\begin_layout Plain Layout

    )
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

  D$DH <- D$TASX ^ 2 / 2010
\end_layout

\begin_layout Plain Layout

  ## For use later, "filter" the dynamic-heating term and revise the temperature
:
\end_layout

\begin_layout Plain Layout

  alphaR <- attr(D[, 'ATRR'], 'RecoveryFactor')
\end_layout

\begin_layout Plain Layout

  D$AT <- reviseDH(D, Param1, alphaR)
\end_layout

\begin_layout Plain Layout

  ## Find a corrected recovery temperature to use in the estimate of dynamic
 heating:
\end_layout

\begin_layout Plain Layout

  a <- Param1$a
\end_layout

\begin_layout Plain Layout

  tau1 <- Param1$tau1
\end_layout

\begin_layout Plain Layout

  tau2 <- Param1$tau2
\end_layout

\begin_layout Plain Layout

  ## RT is the working solution; Ts is the support temperature
\end_layout

\begin_layout Plain Layout

  D$Ts <- D$TTRR
\end_layout

\begin_layout Plain Layout

  Rate <- attr (D, 'Rate')
\end_layout

\begin_layout Plain Layout

  D$DTMDT <-
\end_layout

\begin_layout Plain Layout

    c(0, diff(D$TTRR, 2), 0) * Rate / 2  ## Average this and one-sample-advanced
\end_layout

\begin_layout Plain Layout

  # D$DTMDT <- (D$DTMDT + c(0, D$DTMDT[1:(nrow(D)-1)])) / 2
\end_layout

\begin_layout Plain Layout

  # DT$DTMDT <- as.vector (signal::filter(signal::sgolay(1, 3, m=1), DT$TTRR))
 * Rate
\end_layout

\begin_layout Plain Layout

  fS <- function(y, i) {
\end_layout

\begin_layout Plain Layout

    # Eq.
 Ts3
\end_layout

\begin_layout Plain Layout

    ((1 / a) * (tau1 * D$DTMDT[i] + D$TTRR[i] - (1 - a) * y) - y) / (Rate
 * tau2)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  D$Ts <- rk4.integrate (fS, D$Ts[1], 1:nrow(D))
\end_layout

\begin_layout Plain Layout

  D$RT <- (1 / a) * (tau1 * D$DTMDT + D$TTRR - (1 - a) * D$Ts)
\end_layout

\begin_layout Plain Layout

  # D %>% select(Time, TTRR, RT, Ts) %>% selectTime(114500, 114505) %>%
 plotWAC()
\end_layout

\begin_layout Plain Layout

  save(D, file = './DVOCALS.Rdata')
\end_layout

\begin_layout Plain Layout

  DVOCALS <- D
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

## Revise the calculation of dynamic heating to avoid dependence on AT:
\end_layout

\begin_layout Plain Layout

D$MACH <- MachNumber(D$PSXC, D$QCXC)
\end_layout

\begin_layout Plain Layout

XXA <- attr(D[, 'ATRR'], 'RecoveryFactor') * D$MACH ^ 2 / 5
\end_layout

\begin_layout Plain Layout

D$DH <- (D$TTRR + 273.15) * XXA / (1 + XXA)
\end_layout

\begin_layout Plain Layout

D$DH2 <- (D$RT + 273.15) * XXA / (1 + XXA)
\end_layout

\begin_layout Plain Layout

## temporary: shift D$AT later in time
\end_layout

\begin_layout Plain Layout

# D$AT <- ShiftInTime (D$AT, .rate=25, .shift=40)
\end_layout

\begin_layout Plain Layout

Tasm <- mean(D$TASX, na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

DT <- D %>% selectTime(113900, 115200)
\end_layout

\begin_layout Plain Layout

# select six boundary-layer segments of 10 min each:
\end_layout

\begin_layout Plain Layout

DT1 <- D %>% selectTime(65000, 70000)
\end_layout

\begin_layout Plain Layout

DT2 <- D %>% selectTime(73300, 74300)
\end_layout

\begin_layout Plain Layout

DT3 <- D %>% selectTime(104600, 105600)
\end_layout

\begin_layout Plain Layout

DT4 <- D %>% selectTime(114200, 115200)  ## 113900, 115200
\end_layout

\begin_layout Plain Layout

DT5 <- D %>% selectTime(124300, 125300)
\end_layout

\begin_layout Plain Layout

DT6 <- D %>% selectTime(133000, 134000)
\end_layout

\begin_layout Plain Layout

# omitting 832-841, 920-951, 955-1005 -- look problematic
\end_layout

\begin_layout Plain Layout

# g <- VSpec(DT, 'TTRR', spans=99, xlim=c(0.01,15), ylim=c(1.e-5, 1.e-1))
\end_layout

\begin_layout Plain Layout

# g <- VSpec(DT, 'ATRR', spans=99, add=g)
\end_layout

\begin_layout Plain Layout

# VSpec(DT, 'DH', spans=99, add=g) + theme_WAC()
\end_layout

\begin_layout Plain Layout

# VSpec(DT, 'TASX', spans = 99, ylim=c(1.e-3, 10)) + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

load(file='AR.Rdata')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The same flight segments from the VOCALS project that were used to characterize
 the transfer function in Part 1 are also used in this first example.
 A composite cospectrum for these measurements was constructed as before,
 averaging six 10-min boundary-layer flight segments of 25
\begin_inset space ~
\end_inset

Hz measurements of recovery temperature, updraft, and dynamic heating.
 This first calculation used the measurements directly, with no corrections
 for the response of the temperature sensor and no adjustment of the dynamic-hea
ting correction, so this would be the conventional measurement without any
 of the changes proposed in the present series of papers.
 The cospectrum for the cross-spectrum between temperature and updraft is
 shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:assembleCospec}
\end_layout

\end_inset

 for the average of the six flight segments.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<assembleCospec, include=TRUE, fig.pos='t', fig.cap='The cospectrum for temperatu
re and updraft, multiplied by the air density and specific heat to convert
 to a cospectrum for the sensible-heat flux, for six 10-min boundary-layer
 flight segments from the VOCALS project.
 The original uncorrected measurements have been used for temperature.
 Positive and negative values of the cospectrum are shown as blue and red,
 respectively, with the sign of the latter changed to permit plotting on
 a logarithmic axis.
 The mean values in logarithmically spaced bins in frequency are shown as
 black and dark red dots, and the shaded ribbon enclosing the dots represents
 a one-standard-deviation range for those bins.
 The brown line labeled 
\begin_inset Quotes eld
\end_inset

exceedance
\begin_inset Quotes erd
\end_inset

 is the complement of the cumulative distribution function for flux; i.e.,
 the flux from all frequencies higher than the plotted value.
 The dashed black line denotes the frequency that corresponds to a wavelength
 of 3 km.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Recalculate AT using the dynamic-heating filter:
\end_layout

\begin_layout Plain Layout

DVOCALS$TASX <- SmoothInterp(DVOCALS$TASX, .Length=0)
\end_layout

\begin_layout Plain Layout

DVOCALS$ATX <- SmoothInterp(DVOCALS$ATX, .Length=0)
\end_layout

\begin_layout Plain Layout

DVOCALS$PSXC <- SmoothInterp(DVOCALS$PSXC, .Length=0)
\end_layout

\begin_layout Plain Layout

DVOCALS$QCXC <- SmoothInterp(DVOCALS$QCXC, .Length=0)
\end_layout

\begin_layout Plain Layout

DVOCALS$MACH <- SmoothInterp(MachNumber(DVOCALS$PSXC, DVOCALS$QCXC), .Length=0)
\end_layout

\begin_layout Plain Layout

DVOCALS$alphaR <- RecoveryFactor(DVOCALS$MACH, 'UNHEATED') 
\end_layout

\begin_layout Plain Layout

## Alas, original processing used 0.95 so duplicate that:
\end_layout

\begin_layout Plain Layout

DVOCALS$alphaR <- rep(0.95, nrow(DVOCALS))
\end_layout

\begin_layout Plain Layout

DVOCALS$Q <- DVOCALS$TASX^2 / (2 * SpecificHeats()[1])
\end_layout

\begin_layout Plain Layout

DVOCALS$QF <- as.vector(signal::filter(AR, DVOCALS$Q))
\end_layout

\begin_layout Plain Layout

DVOCALS$QF <- ShiftInTime(DVOCALS$QF, .shift=-Lshift * 40, .rate=25)
\end_layout

\begin_layout Plain Layout

DVOCALS$AT <- DVOCALS$ATX + DVOCALS$alphaR * (DVOCALS$Q - DVOCALS$QF)
\end_layout

\begin_layout Plain Layout

# DVOCALS$WIC <- ShiftInTime(DVOCALS$WIC, .rate=25, .shift=-40)
\end_layout

\begin_layout Plain Layout

D <- DVOCALS
\end_layout

\begin_layout Plain Layout

DT1 <- D %>% selectTime(65000, 70000)
\end_layout

\begin_layout Plain Layout

DT2 <- D %>% selectTime(73300, 74300)
\end_layout

\begin_layout Plain Layout

DT3 <- D %>% selectTime(104600, 105600)
\end_layout

\begin_layout Plain Layout

DT4 <- D %>% selectTime(114200, 115200)  ## 113900, 115200
\end_layout

\begin_layout Plain Layout

DT5 <- D %>% selectTime(124300, 125300)
\end_layout

\begin_layout Plain Layout

DT6 <- D %>% selectTime(133000, 134000)
\end_layout

\begin_layout Plain Layout

Cp <- 1005    # mean(SpecificHeats(DDR$EWX/DDR$PSXC)[,1], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

DTC <- rbind(DT1, DT2, DT3, DT4, DT5, DT6)
\end_layout

\begin_layout Plain Layout

Rho <- mean (100 * DTC$PSXC / ((DTC$ATX + 273.15) * 287.05), na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

sBins <- 100
\end_layout

\begin_layout Plain Layout

# DTC$WIC <- ShiftInTime(DTC$WIC, .rate=25, .shift=-40)
\end_layout

\begin_layout Plain Layout

## The following replaces the 
\begin_inset Quotes eld
\end_inset

flux()
\begin_inset Quotes erd
\end_inset

 function:
\end_layout

\begin_layout Plain Layout

Units  <-  bquote("W" ~ m ^ -2)
\end_layout

\begin_layout Plain Layout

spans <-  49
\end_layout

\begin_layout Plain Layout

scaleFactor <- (Rho * Cp)
\end_layout

\begin_layout Plain Layout

smoothBins <- sBins
\end_layout

\begin_layout Plain Layout

wavelengthLimit <- 3000
\end_layout

\begin_layout Plain Layout

xlim <- c(0.01, 15)
\end_layout

\begin_layout Plain Layout

ylim <- c(1.e-3, 10)
\end_layout

\begin_layout Plain Layout

legend.position <- 'bottomleft'
\end_layout

\begin_layout Plain Layout

plot <- TRUE
\end_layout

\begin_layout Plain Layout

plotRibbon <- TRUE
\end_layout

\begin_layout Plain Layout

printTitle <- TRUE
\end_layout

\begin_layout Plain Layout

Par <- NA
\end_layout

\begin_layout Plain Layout

.A <- 'ATRR'
\end_layout

\begin_layout Plain Layout

CSprevious <- NA
\end_layout

\begin_layout Plain Layout

Rate <- attr(DVOCALS, 'Rate')
\end_layout

\begin_layout Plain Layout

Tasm <- mean(DTC$TASX, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

fL <- Tasm / wavelengthLimit
\end_layout

\begin_layout Plain Layout

N <- 2^14
\end_layout

\begin_layout Plain Layout

# Get the transfer function:
\end_layout

\begin_layout Plain Layout

Par <- Param1
\end_layout

\begin_layout Plain Layout

a <- Par$a
\end_layout

\begin_layout Plain Layout

tau1 <- Par$tau1
\end_layout

\begin_layout Plain Layout

tau2 <- Par$tau2
\end_layout

\begin_layout Plain Layout

df <- Rate / N
\end_layout

\begin_layout Plain Layout

frq <- c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
\end_layout

\begin_layout Plain Layout

zeta <- -atan(2*pi*frq*tau2)
\end_layout

\begin_layout Plain Layout

b <- cos(zeta)
\end_layout

\begin_layout Plain Layout

## Use the Laplace-transform solution
\end_layout

\begin_layout Plain Layout

C1 <- 1 / (1 + 4 * pi^2 * frq^2 * tau1^2) * 
\end_layout

\begin_layout Plain Layout

        (-(a + (1 - a) * b * cos(zeta)) * 2 * pi * frq * tau1 +
\end_layout

\begin_layout Plain Layout

           (1 - a) * b * sin(zeta)) 
\end_layout

\begin_layout Plain Layout

C2 <- 1 / (1 + 4 * pi^2 * frq^2 * tau1^2) * 
\end_layout

\begin_layout Plain Layout

        ((a + (1 - a) * b * cos(zeta)) + 
\end_layout

\begin_layout Plain Layout

           (1 - a) * b * sin(zeta) * 2 * pi * frq * tau1)
\end_layout

\begin_layout Plain Layout

cTC <- sqrt(C1^2 + C2^2)
\end_layout

\begin_layout Plain Layout

phiTC <- atan2(C1, C2)
\end_layout

\begin_layout Plain Layout

H <- complex(modulus=cTC, argument=phiTC)
\end_layout

\begin_layout Plain Layout

DTC <- data.frame()
\end_layout

\begin_layout Plain Layout

CoSp <- rep(0, N)
\end_layout

\begin_layout Plain Layout

for (.data in list(DT1, DT2, DT3, DT4, DT5, DT6)) {
\end_layout

\begin_layout Plain Layout

  N1 <- (N - nrow(.data)) %/% 2
\end_layout

\begin_layout Plain Layout

  N2 <- N - nrow(.data) - N1
\end_layout

\begin_layout Plain Layout

  WP <- c(rep(0, N1), detrend(.data[, c('Time', 'WIC')]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  TP <- c(rep(0, N1), detrend(.data[, c('Time', .A)]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  Q  <- c(rep(0, N1), detrend(.data[, c('Time', 'Q')]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  ff1 <- fft(TP)
\end_layout

\begin_layout Plain Layout

  ff2 <- fft(WP)
\end_layout

\begin_layout Plain Layout

  ffq <- fft(Q)
\end_layout

\begin_layout Plain Layout

  cs <- 2 * Re(ff1 * Conj(ff2)) / (Rate * N)
\end_layout

\begin_layout Plain Layout

  ## Estimate original recovery T and apply corrected dynamic heating:
\end_layout

\begin_layout Plain Layout

  alphaR <- mean(.data$alphaR, na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

  # cs <- 2 * Re((ff1 / H - alphaR * H * ffq) * Conj(ff2)) / (Rate * N)
\end_layout

\begin_layout Plain Layout

  CoSp <- CoSp + cs
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

CoSp <- CoSp * scaleFactor / 6
\end_layout

\begin_layout Plain Layout

Nby2 <- N %/% 2
\end_layout

\begin_layout Plain Layout

CS <- data.frame(freq = frq[2:(Nby2+1)], cospec = CoSp[2:(Nby2+1)])
\end_layout

\begin_layout Plain Layout

plotCS <- function(CS, Units, spans, fL, wavelengthLimit, smoothBins, 
\end_layout

\begin_layout Plain Layout

                   xlim, ylim, printTitle, CSprevious = NA) {
\end_layout

\begin_layout Plain Layout

  ylab <- bquote("f x flux cospectrum ["*.(Units)*"]")    
\end_layout

\begin_layout Plain Layout

  CSogive <- cumsum(CS$cospec) * CS$freq[1]
\end_layout

\begin_layout Plain Layout

  CSogive <- CSogive[length(CSogive)]-CSogive
\end_layout

\begin_layout Plain Layout

  CS$ogive <- CSogive
\end_layout

\begin_layout Plain Layout

  CS$cospec <- SmoothInterp(CS$cospec, .Length=0)  # treat NAs
\end_layout

\begin_layout Plain Layout

  s25 <- spans %/% 25; s10 <- spans %/% 10; s3 <- spans %/% 3
\end_layout

\begin_layout Plain Layout

  s25 <- s25 + (s25 + 1) %% 2
\end_layout

\begin_layout Plain Layout

  s10 <- s10 + (s10 + 1) %% 2
\end_layout

\begin_layout Plain Layout

  s3 <- s3 + (s3 + 1) %% 2
\end_layout

\begin_layout Plain Layout

  CS$cospec <- zoo::rollapply(CS$cospec, FUN = mean, fill='extend', width
 = s25)
\end_layout

\begin_layout Plain Layout

  CS$cospec[CS$freq > 0.01] <- zoo::rollapply(CS$cospec, FUN = mean, fill='extend
', width = s10)[CS$freq > 0.01]
\end_layout

\begin_layout Plain Layout

  CS$cospec[CS$freq > 0.1] <- zoo::rollapply(CS$cospec, FUN = mean, fill='extend'
, width = s3)[CS$freq > 0.1]
\end_layout

\begin_layout Plain Layout

  CS$cospec[CS$freq > 1] <- zoo::rollapply(CS$cospec, FUN = mean, fill='extend',
 width = spans)[CS$freq > 1]
\end_layout

\begin_layout Plain Layout

  FluxL <- CSogive[which(CS$freq > fL)[1]]
\end_layout

\begin_layout Plain Layout

  Flux <- CSogive[which(CS$freq > 0.01)[1]]
\end_layout

\begin_layout Plain Layout

  attr(CS, 'Flux') <- Flux
\end_layout

\begin_layout Plain Layout

  attr(CS, 'FluxL') <- FluxL
\end_layout

\begin_layout Plain Layout

  attr(CS, 'wavelengthLimit') <- wavelengthLimit
\end_layout

\begin_layout Plain Layout

  ## Construct the plot:
\end_layout

\begin_layout Plain Layout

  CS$ncospec <- -1 * CS$cospec
\end_layout

\begin_layout Plain Layout

  ## Weight by frequency for log-abscissa plot:
\end_layout

\begin_layout Plain Layout

  CS$cospec <- CS$cospec * CS$freq
\end_layout

\begin_layout Plain Layout

  CS$ncospec <- CS$ncospec * CS$freq
\end_layout

\begin_layout Plain Layout

  # plotWAC(CS, xlab='frequency [Hz]', ylab=ylab, log='xy',
\end_layout

\begin_layout Plain Layout

  #     col = c('skyblue', 'forestgreen', 'red'), lwd = c(2, 2, 2), 
\end_layout

\begin_layout Plain Layout

  #     lty = c(1, 2, 1),
\end_layout

\begin_layout Plain Layout

  #     xlim=c(0.05, 15), ylim=c(0.01,250), legend.position=NA)
\end_layout

\begin_layout Plain Layout

  if (smoothBins > 5) {
\end_layout

\begin_layout Plain Layout

    BS <- binStats(data.frame(CS$cospec, log(CS$freq)), bins = smoothBins)
\end_layout

\begin_layout Plain Layout

    # lines(exp(BS$xc), BS$ybar, lwd=2, col='brown')
\end_layout

\begin_layout Plain Layout

    BS$nybar <- -1 * BS$ybar
\end_layout

\begin_layout Plain Layout

    BS$ybar[BS$ybar < 0] <- NA
\end_layout

\begin_layout Plain Layout

    BS$nybar[BS$nybar < 0] <- NA
\end_layout

\begin_layout Plain Layout

    BS$xc <- exp(BS$xc)
\end_layout

\begin_layout Plain Layout

    # lines(exp(BS$xc), BS$nybar, lwd=2, col='magenta')
\end_layout

\begin_layout Plain Layout

    attr(CS, 'smoothed data.frame') <- BS
\end_layout

\begin_layout Plain Layout

    bse <- data.frame(x = BS$xc, ymin = BS$ybar - BS$sigma, ymax = BS$ybar
 + BS$sigma,
\end_layout

\begin_layout Plain Layout

                      yminN = BS$nybar - BS$sigma, ymaxN = BS$nybar + BS$sigma)
\end_layout

\begin_layout Plain Layout

    # lines(exp(BS$xc), BS$nybar, lwd=2, col='magenta')
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  if (smoothBins > 5) {
\end_layout

\begin_layout Plain Layout

    bse$ymin[bse$ymin < ylim[1]] <- ylim[1]
\end_layout

\begin_layout Plain Layout

    bse$yminN[bse$yminN < ylim[1]] <- ylim[1]
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  g <- ggplot(data = CS, aes(x=freq))
\end_layout

\begin_layout Plain Layout

  g <- g + geom_path(aes(y = cospec, colour='cospectrum', linetype='cospectrum')
)
\end_layout

\begin_layout Plain Layout

  g <- g + geom_path(aes(y = ncospec, colour='-cospectrum', linetype='-cospectru
m'))
\end_layout

\begin_layout Plain Layout

  g <- g + geom_path(aes(y = ogive, colour='exceedance', linetype='exceedance'),
 lwd=1.2)
\end_layout

\begin_layout Plain Layout

  if (is.data.frame(CSprevious)) {
\end_layout

\begin_layout Plain Layout

    g <- g + geom_path(data=CSprevious, aes(x = freq, y = ogive,
\end_layout

\begin_layout Plain Layout

                          colour='exceedance'), lty=2, lwd=1.2)
\end_layout

\begin_layout Plain Layout

    if ('ogive2' %in% names(CSprevious)) {
\end_layout

\begin_layout Plain Layout

      g <- g + geom_path(data=CSprevious, aes(x = freq, y = ogive2,
\end_layout

\begin_layout Plain Layout

                          colour='generated', linetype='generated'), lwd=1.3)
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  if (smoothBins > 5) {
\end_layout

\begin_layout Plain Layout

    # g <- g + geom_path(data = BS, aes(x=xc, y=ybar), colour='blue', lwd=1.2)
\end_layout

\begin_layout Plain Layout

    # g <- g + geom_path(data = BS, aes(x=xc, y=nybar), colour='deeppink3',
 lwd=1.2)
\end_layout

\begin_layout Plain Layout

    g <- g + geom_point(data = BS, aes(x=xc, y=ybar), colour='black', pch=19)
\end_layout

\begin_layout Plain Layout

    g <- g + geom_point(data = BS, aes(x=xc, y=nybar), colour='darkred',
 pch=19)
\end_layout

\begin_layout Plain Layout

    if (plotRibbon) {
\end_layout

\begin_layout Plain Layout

      # GeomRibbon$handle_na <- function(data, params) {  data }
\end_layout

\begin_layout Plain Layout

      g <- g + geom_ribbon(data=bse, aes(x=x, ymin=ymin, ymax=ymax),
\end_layout

\begin_layout Plain Layout

        fill='blue', alpha=0.2, show.legend=FALSE, inherit.aes=FALSE, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

      g <- g + geom_ribbon(data=bse, aes(x=x, ymin=yminN, ymax=ymaxN),
\end_layout

\begin_layout Plain Layout

                fill='red', alpha=0.2, show.legend=FALSE, inherit.aes=FALSE,
 na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

      # g <- g + geom_path(data=bse, aes(x=x, y=ymin), lty=1, lwd=0.5, col='magen
ta') +
\end_layout

\begin_layout Plain Layout

      #          geom_path(data=bse, aes(x=x, y=ymax), lty=1, lwd=0.5, col='magen
ta')
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  g <- g + geom_path(data=data.frame(x=rep(fL, 2), y=ylim), aes(x=x, y=y),
 linetype=2)
\end_layout

\begin_layout Plain Layout

  g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=4), #limits = xlim, 
\end_layout

\begin_layout Plain Layout

    labels = trans_format("log10", math_format(10^.x))) +
\end_layout

\begin_layout Plain Layout

    scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x, n=4),
 #limits = ylim,             
\end_layout

\begin_layout Plain Layout

      labels = trans_format("log10", math_format(10^.x))) +
\end_layout

\begin_layout Plain Layout

    annotation_logticks(sides='trbl') +
\end_layout

\begin_layout Plain Layout

    coord_cartesian(xlim=xlim, ylim=ylim)
\end_layout

\begin_layout Plain Layout

  g <- g + xlab('frequency [Hz]') + ylab(ylab)
\end_layout

\begin_layout Plain Layout

  g <- suppressWarnings(g + scale_colour_manual (name='', 
\end_layout

\begin_layout Plain Layout

    values=c('cospectrum'='blue', '-cospectrum'='red', 'exceedance'='brown',
\end_layout

\begin_layout Plain Layout

             'generated' = 'forestgreen')))
\end_layout

\begin_layout Plain Layout

  g <- g + scale_linetype_manual (name='', values=c('cospectrum'=1, '-cospectrum
'=1, 'exceedance'=1, 'generated' = 4))
\end_layout

\begin_layout Plain Layout

  g <- g + guides(col=guide_legend(reverse = TRUE), linetype=guide_legend(revers
e = TRUE))
\end_layout

\begin_layout Plain Layout

  ttl <- bquote('Total flux '~.(format(Flux, digits=3))~.(Units)*'; partial
 <'*.(format((wavelengthLimit/1000), digits=2))~'km:'~.(format(FluxL, digits=3))~.(
Units))
\end_layout

\begin_layout Plain Layout

  if (printTitle) {
\end_layout

\begin_layout Plain Layout

    g <- g + labs(title=ttl)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  suppressWarnings(print(g + theme_WAC(1) + theme(plot.title = element_text(size=
12)) +
\end_layout

\begin_layout Plain Layout

                             theme(legend.position=c(0.5, 0.91))))
\end_layout

\begin_layout Plain Layout

  g <<- g  ## Save for adding uncorrected cospec for debugging...
\end_layout

\begin_layout Plain Layout

  # par(bg = 'gray95')
\end_layout

\begin_layout Plain Layout

  # plotWAC(data.frame(exp(BSF1$xc), BSF1$ybar, BSF1$nybar), 
\end_layout

\begin_layout Plain Layout

  #   col = c('blue', 'red'), ylab = ylab,
\end_layout

\begin_layout Plain Layout

  #   xlab='frequency [Hz]', log='xy', xlim=c(0.05,15),
\end_layout

\begin_layout Plain Layout

  #   ylim=c(0.01,250), legend.position=NA)
\end_layout

\begin_layout Plain Layout

  # lines(CSF1, col='gray50')
\end_layout

\begin_layout Plain Layout

  # lines(exp(BSF1$xc), BSF1$ybar, col='blue', lwd=2)
\end_layout

\begin_layout Plain Layout

  # lines(exp(BSF1$xc), BSF1$ybar+BSF1$sigma, col='blue', lwd=1)
\end_layout

\begin_layout Plain Layout

  # lines(exp(BSF1$xc), BSF1$ybar-BSF1$sigma, col='blue', lwd=1)
\end_layout

\begin_layout Plain Layout

  return(CS)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

spans <- 51
\end_layout

\begin_layout Plain Layout

CS.orig <- plotCS(CS, Units, spans, fL, wavelengthLimit, smoothBins, 
\end_layout

\begin_layout Plain Layout

                   xlim, ylim, printTitle) 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# X <-
\end_layout

\begin_layout Plain Layout

#   flux(
\end_layout

\begin_layout Plain Layout

#     DTC,
\end_layout

\begin_layout Plain Layout

#     'ATX',
\end_layout

\begin_layout Plain Layout

#     Units = bquote("W" ~ m ^ -2),
\end_layout

\begin_layout Plain Layout

#     spans = 149,
\end_layout

\begin_layout Plain Layout

#     scaleFactor = (Rho * Cp),
\end_layout

\begin_layout Plain Layout

#     smoothBins = sBins,
\end_layout

\begin_layout Plain Layout

#     wavelengthLimit = 3000,
\end_layout

\begin_layout Plain Layout

#     xlim = c(0.01, 15),
\end_layout

\begin_layout Plain Layout

#     ylim = c(1.e-3, 10)
\end_layout

\begin_layout Plain Layout

#   )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

N <- 2^14
\end_layout

\begin_layout Plain Layout

Rate <- attr(DVOCALS, 'Rate')
\end_layout

\begin_layout Plain Layout

# Get the transfer function:
\end_layout

\begin_layout Plain Layout

Par <- Param1
\end_layout

\begin_layout Plain Layout

a <- Par$a
\end_layout

\begin_layout Plain Layout

tau1 <- Par$tau1
\end_layout

\begin_layout Plain Layout

tau2 <- Par$tau2
\end_layout

\begin_layout Plain Layout

df <- Rate / N
\end_layout

\begin_layout Plain Layout

frq <- c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
\end_layout

\begin_layout Plain Layout

zeta <- -atan(2*pi*frq*tau2)
\end_layout

\begin_layout Plain Layout

b <- cos(zeta)
\end_layout

\begin_layout Plain Layout

## Use the Laplace-transform solution
\end_layout

\begin_layout Plain Layout

C1 <- 1 / (1 + 4 * pi^2 * frq^2 * tau1^2) * 
\end_layout

\begin_layout Plain Layout

        (-(a + (1 - a) * b * cos(zeta)) * 2 * pi * frq * tau1 +
\end_layout

\begin_layout Plain Layout

           (1 - a) * b * sin(zeta)) 
\end_layout

\begin_layout Plain Layout

C2 <- 1 / (1 + 4 * pi^2 * frq^2 * tau1^2) * 
\end_layout

\begin_layout Plain Layout

        ((a + (1 - a) * b * cos(zeta)) + 
\end_layout

\begin_layout Plain Layout

           (1 - a) * b * sin(zeta) * 2 * pi * frq * tau1)
\end_layout

\begin_layout Plain Layout

cTC <- sqrt(C1^2 + C2^2)
\end_layout

\begin_layout Plain Layout

phiTC <- atan2(C1, C2)
\end_layout

\begin_layout Plain Layout

H <- complex(modulus=cTC, argument=phiTC)
\end_layout

\begin_layout Plain Layout

DTC <- data.frame()
\end_layout

\begin_layout Plain Layout

for (DTY in list(DT1, DT2, DT3, DT4, DT5, DT6)) {
\end_layout

\begin_layout Plain Layout

  N1 <- (N - nrow(DTY)) %/% 2
\end_layout

\begin_layout Plain Layout

  N2 <- N - nrow(DTY) - N1
\end_layout

\begin_layout Plain Layout

  TTRR <- c(rep(0, N1), detrend(DTY[, c('Time', 'TTRR')]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  WIC <- c(rep(0, N1), detrend(DTY[, c('Time', 'WIC')]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  Q <- c(rep(0, N1),detrend(DTY[, c('Time', 'Q')]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  ftq <- fft(Q)
\end_layout

\begin_layout Plain Layout

  ft1 <- fft(TTRR)
\end_layout

\begin_layout Plain Layout

  ft2 <- fft(WIC)
\end_layout

\begin_layout Plain Layout

  ## Estimate original recovery T and apply corrected dynamic heating:
\end_layout

\begin_layout Plain Layout

  alphaR <- mean(DTY$alphaR, na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

  ATC <- Re(fft(ft1 / H, inverse = TRUE) / length(ft1)) # -
\end_layout

\begin_layout Plain Layout

  #           alphaR * Re(fft(H * ftq, inverse = TRUE) / length(ftq))
\end_layout

\begin_layout Plain Layout

  DTY$ATC <- ATC[(N1+1):(N-N2)] - alphaR * DTY$QF
\end_layout

\begin_layout Plain Layout

  DTC <- rbind(DTC, DTY)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

Cp <- 1005    # mean(SpecificHeats(DDR$EWX/DDR$PSXC)[,1], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

Rho <-
\end_layout

\begin_layout Plain Layout

  mean (100 * DTC$PSXC / ((DTC$ATX + 273.15) * 287.05), na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

sBins <- 100
\end_layout

\begin_layout Plain Layout

DHC <- DTC$alphaR * DTC$TASX^2 / 2010
\end_layout

\begin_layout Plain Layout

DTC$WIC <- ShiftInTime(DTC$WIC, .rate=25, .shift=-40)
\end_layout

\begin_layout Plain Layout

X <-
\end_layout

\begin_layout Plain Layout

  flux(
\end_layout

\begin_layout Plain Layout

    DTC,
\end_layout

\begin_layout Plain Layout

    'ATC',
\end_layout

\begin_layout Plain Layout

    Units = bquote("W" ~ m ^ -2),
\end_layout

\begin_layout Plain Layout

    spans = 149,
\end_layout

\begin_layout Plain Layout

    scaleFactor = (Rho * Cp),
\end_layout

\begin_layout Plain Layout

    smoothBins = sBins,
\end_layout

\begin_layout Plain Layout

    wavelengthLimit = 3000,
\end_layout

\begin_layout Plain Layout

    xlim = c(0.01, 15),
\end_layout

\begin_layout Plain Layout

    ylim = c(1.e-3, 10)
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
This plot format is unconventional and so needs some explanation because
 it will be used as the primary display of the cospectrum in this paper.
 The cospectrum can be positive or negative, so it is often plotted using
 a linear scale for the abscissa.
 However, as the figure shows, the range of ordinate values is displayed
 better with a logarithmic scale, even after weighting the cospectrum by
 frequency.
 The compromise made in this plot is to use a logarithmic scale but plot
 negative values with sign reversed and with a different color, here red
 instead of blue.
 The values plotted in red therefore should be regarded as negative values
 of the plotted magnitude.
 There is then a dead-band at the bottom of the plot where spectral values
 with very small absolute value lie, here absolute values smaller than 
\begin_inset Formula $10^{-3}\thinspace\mathrm{W\,m^{-2}}$
\end_inset

.
 A plot weighted by frequency is used as is appropriate for a logarithmic
 abscissa.
 There are several other features of this plot:
\end_layout

\begin_layout Enumerate
The cospectrum (blue line) has been smoothed using Daniell smoothing, with
 consecutive smoothing using width-3 for frequencies above 0.01
\begin_inset space ~
\end_inset

Hz, then width-5 for frequencies above 0.1
\begin_inset space ~
\end_inset

Hz, then width-17 for frequencies above 1
\begin_inset space ~
\end_inset

Hz.
 For these 10-min flight legs and for 25
\begin_inset space ~
\end_inset

Hz measurements, the maximum smoothing interval corresponds to a smoother
 spanning about 0.025
\begin_inset space ~
\end_inset

Hz, so most spectral features are retained even with this strong smoothing.
 Additional smoothing results from averaging six cospectra to obtain the
 plotted values.
 
\end_layout

\begin_layout Enumerate
Further smoothing is included by binning the results into 100 logarithmically
 spaced intervals in frequency and averaging in those bins.
 That results in the blue dots (or dark red dots for negative points).
\end_layout

\begin_layout Enumerate
A shaded ribbon denotes the standard deviation of the values in the bins.
 In many cases it is too narrow to be visible.
\end_layout

\begin_layout Enumerate
The total flux indicated in the title is that arising from the part of the
 flux with frequency above 0.01
\begin_inset space ~
\end_inset

Hz.
 This corresponds to a wavelength of more than 10
\begin_inset space ~
\end_inset

km for the C-130 and more than 15
\begin_inset space ~
\end_inset

km for the GV\SpecialChar endofsentence
 In addition, there is another estimate of the contribution
 to the flux from wavelengths below a selected limit, here 3
\begin_inset space ~
\end_inset

km.
 That or a still smaller wavelength limit is often a reasonable estimate
 of the part of the flux contributed by turbulent air motions in the boundary
 layer, so that will be regarded as the primary measurement of sensible-heat
 flux.
\end_layout

\begin_layout Enumerate
One additional line is plotted brown and labeled 
\begin_inset Quotes eld
\end_inset

exceedance.
\begin_inset Quotes erd
\end_inset

 That is a cumulative distribution function for the cospectrum, called 
\begin_inset Quotes eld
\end_inset

exceedance
\begin_inset Quotes erd
\end_inset

 because it is the complement of the conventional cumulative distribution:
 It shows the contribution from all frequencies higher than the indicated
 value.
 That is more informative at high frequency on a logarithmic scale, where
 some of the most interesting variation is located.
 Unlike the other plotted values, its units are 
\begin_inset Formula $\mathrm{W\,m}^{-2}$
\end_inset

, not 
\begin_inset Formula $\mathrm{W\,m}^{-2}$
\end_inset

 per logarithmic interval as is the case for the weighted cospectrum.
\begin_inset Foot
status open

\begin_layout Plain Layout
The cumulative distribution termed 
\begin_inset Quotes eld
\end_inset

exceedance
\begin_inset Quotes erd
\end_inset

 here is sometimes called the ogive.
\begin_inset Note Note
status open

\begin_layout Plain Layout

\lang english
oh-jive
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Although the value measured for the sensible-heat flux is small, the plot
 indicates that there are positive contributions to the flux up to the highest
 frequencies measured.
 The adjustment in dynamic heating has only a minor (ca.
\begin_inset space ~
\end_inset


\begin_inset Formula $+10$
\end_inset

%) effect on the measured flux, but it is not negligible.
 It is an encouraging sign that there seems to be some consistent contribution
 to the flux even from the high-frequency range.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<correctedCospec, include=TRUE, fig.pos='t', fig.cap='The cospectrum for
 temperature and updraft, multiplied by the air density and specific heat
 to convert to a cospectrum for the sensible-heat flux, for six 10-min boundary-
layer flight segments from the VOCALS project.
 The measurements used in the preceding plot have been corrected for the
 time response of the temperature sensor, and the dynamic-heating correction
 has been filtered to compensate for the expected response of the temperature
 sensor.
 Further description of the plot is included in the caption for the preceding
 figure.
 An added line is the dashed brown line; it duplicates the exceedance plot
 from the uncorrected calculation of the cospectrum as shown in the previous
 figure.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DVOCALS$WIC <- ShiftInTime(DVOCALS$WIC, .rate=25, .shift=-40)
\end_layout

\begin_layout Plain Layout

D <- DVOCALS
\end_layout

\begin_layout Plain Layout

DT1 <- D %>% selectTime(65000, 70000)
\end_layout

\begin_layout Plain Layout

DT2 <- D %>% selectTime(73300, 74300)
\end_layout

\begin_layout Plain Layout

DT3 <- D %>% selectTime(104600, 105600)
\end_layout

\begin_layout Plain Layout

DT4 <- D %>% selectTime(114200, 115200)  ## 113900, 115200
\end_layout

\begin_layout Plain Layout

DT5 <- D %>% selectTime(124300, 125300)
\end_layout

\begin_layout Plain Layout

DT6 <- D %>% selectTime(133000, 134000)
\end_layout

\begin_layout Plain Layout

CoSp <- rep(0, N)
\end_layout

\begin_layout Plain Layout

for (.data in list(DT1, DT2, DT3, DT4, DT5, DT6)) {
\end_layout

\begin_layout Plain Layout

  N1 <- (N - nrow(.data)) %/% 2
\end_layout

\begin_layout Plain Layout

  N2 <- N - nrow(.data) - N1
\end_layout

\begin_layout Plain Layout

  WP <- c(rep(0, N1), detrend(.data[, c('Time', 'WIC')]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  TP <- c(rep(0, N1), detrend(.data[, c('Time', .A)]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  Q  <- c(rep(0, N1), detrend(.data[, c('Time', 'Q')]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  ff1 <- fft(TP)
\end_layout

\begin_layout Plain Layout

  ff2 <- fft(WP)
\end_layout

\begin_layout Plain Layout

  ffq <- fft(Q)
\end_layout

\begin_layout Plain Layout

  # cs <- 2 * Re(ff1 * Conj(ff2)) / (Rate * N)
\end_layout

\begin_layout Plain Layout

  ## Estimate original recovery T and apply corrected dynamic heating:
\end_layout

\begin_layout Plain Layout

  alphaR <- mean(.data$alphaR, na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

  cs <- 2 * Re((ff1 / H - alphaR * H * ffq) * Conj(ff2)) / (Rate * N)
\end_layout

\begin_layout Plain Layout

  CoSp <- CoSp + cs
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

CoSp <- CoSp * scaleFactor / 6
\end_layout

\begin_layout Plain Layout

Nby2 <- N %/% 2
\end_layout

\begin_layout Plain Layout

CS <- data.frame(freq = frq[2:(Nby2+1)], cospec = CoSp[2:(Nby2+1)])
\end_layout

\begin_layout Plain Layout

CS.corrected <- plotCS(CS, Units, spans, fL, wavelengthLimit, smoothBins,
 
\end_layout

\begin_layout Plain Layout

                   xlim, ylim, printTitle, CSprevious = CS.orig) 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The result after corrections for the time response of the sensor is shown
 in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:correctedCospec}
\end_layout

\end_inset

.
 The exceedance distributions for the original and corrected measurements
 of sensible-heat flux are both shown in this figure, the former as the
 dashed brown line.
 For this plot, the combination of the correction methods described in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Outline-correction"
plural "false"
caps "false"
noprefix "false"

\end_inset

 was used by correcting the measured temperature for dynamic heating using
 the digital filter but then using Fourier transforms to find the corrected
 flux as specified by the transfer function.
 Only minor differences arose when the other combinations of the methods
 were used.
 The estimated flux of sensible heat is increased by about 60%, from 1.93
 to 3.09
\begin_inset space ~
\end_inset

W
\begin_inset space \thinspace{}
\end_inset

m
\begin_inset Formula $^{-2}$
\end_inset

 for the contribution to the flux from wavelengths smaller than 3
\begin_inset space ~
\end_inset

km, and the flux attributable to frequencies above 1
\begin_inset space ~
\end_inset

Hz increased by 100%.
 
\end_layout

\begin_layout Standard
The VOCALS data led to very small sensible-heat flux.
 (For comparison, solar insolation provides a top-of-the-atmosphere flux
 of more than 1000
\begin_inset space ~
\end_inset

W
\begin_inset space \thinspace{}
\end_inset

m
\begin_inset Formula $^{-2}$
\end_inset

.
 The measured flux of sensible heat in this case is insignificant, although
 the measurement itself appears valid.) Therefore it is useful to extend
 these measurements to cases with more flux of sensible heat.
\end_layout

\begin_layout Subsection
SOCRATES example
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<SOCrf15, include=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DS <-
\end_layout

\begin_layout Plain Layout

  getNetCDF('/Data/SOCRATES/SOCRATESrf15h.nc',
\end_layout

\begin_layout Plain Layout

            standardVariables(c('ATF1')),
\end_layout

\begin_layout Plain Layout

            55500,
\end_layout

\begin_layout Plain Layout

            62000)
\end_layout

\begin_layout Plain Layout

Rate <- attr(DS, 'Rate')
\end_layout

\begin_layout Plain Layout

rhozero <- 1013.25 * 100 / (287.05 * 288.15)
\end_layout

\begin_layout Plain Layout

MRHO <- DS$MACHX * DS$PSXC * 100 / 
\end_layout

\begin_layout Plain Layout

        (287.05 * (273.15 + DS$ATX)) / rhozero
\end_layout

\begin_layout Plain Layout

ParamFS1 <- ParamSF
\end_layout

\begin_layout Plain Layout

ParamFS1$tau1 <- ParamFS1$tau1 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ -0.6
\end_layout

\begin_layout Plain Layout

ParamFS1$tau2 <- ParamFS1$tau2 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ -0.6
\end_layout

\begin_layout Plain Layout

DS$TASX <- SmoothInterp(DS$TASX, .Length = 0)
\end_layout

\begin_layout Plain Layout

DS$Q <- DS$TASX ^ 2 / 2010
\end_layout

\begin_layout Plain Layout

DS$ATX <- DS$ATF1
\end_layout

\begin_layout Plain Layout

# DS$AT <- reviseDH(DS, ParamFS1, rf)  # rf was calculated in an earlier
 code chunk
\end_layout

\begin_layout Plain Layout

## Replace this by the filtered result:
\end_layout

\begin_layout Plain Layout

## Recalculate AT using the dynamic-heating filter:
\end_layout

\begin_layout Plain Layout

DS$ATX <- SmoothInterp(DS$ATX, .Length=0)
\end_layout

\begin_layout Plain Layout

DS$PSXC <- SmoothInterp(DS$PSXC, .Length=0)
\end_layout

\begin_layout Plain Layout

DS$QCXC <- SmoothInterp(DS$QCXC, .Length=0)
\end_layout

\begin_layout Plain Layout

DS$MACH <- SmoothInterp(MachNumber(DS$PSXC, DS$QCXC), .Length=0)
\end_layout

\begin_layout Plain Layout

DS$alphaR <- RecoveryFactor(DS$MACH, 'UNHEATED') 
\end_layout

\begin_layout Plain Layout

DS$Q <- DS$TASX^2 / (2 * SpecificHeats()[1])
\end_layout

\begin_layout Plain Layout

DS$QF <- as.vector(signal::filter(ARG, DS$Q))
\end_layout

\begin_layout Plain Layout

DS$QF <- ShiftInTime(DS$QF, .shift=-Lshift * 40, .rate=25)
\end_layout

\begin_layout Plain Layout

DS$AT <- DS$ATX + DS$alphaR * (DS$Q - DS$QF)
\end_layout

\begin_layout Plain Layout

DS$AT <- SmoothInterp(DS$AT, .Length = 0)
\end_layout

\begin_layout Plain Layout

DS$RTF1 <-
\end_layout

\begin_layout Plain Layout

  DS$ATF1 + DS$alphaR * DS$Q  ## This variable isn't in the available file
\end_layout

\begin_layout Plain Layout

DS$RTF1 <- SmoothInterp(DS$RTF1, .Length = 0)
\end_layout

\begin_layout Plain Layout

## Estimate the corrected recovery temperature:
\end_layout

\begin_layout Plain Layout

aV <- ParamFS1$a
\end_layout

\begin_layout Plain Layout

tau1V <- ParamFS1$tau1
\end_layout

\begin_layout Plain Layout

tau2V <- ParamFS1$tau2
\end_layout

\begin_layout Plain Layout

DS$DTMDT <- c(0, diff(DS$RTF1, 2), 0) * Rate / 2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

fSS <- function(y, i) {  # Eq.
 Ts3
\end_layout

\begin_layout Plain Layout

    ((1/aV) * (tau1V * DS$DTMDT[i] + DS$RTF1[i] - (1-aV) * y) - y) / (Rate
 * tau2V)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DS$Ts <- rk4.integrate (fSS, DS$RTF1[1], 1:nrow(DS))
\end_layout

\begin_layout Plain Layout

DS$RTC <- (1/aV) * (tau1V * DS$DTMDT + DS$RTF1 - (1-aV) * DS$Ts)
\end_layout

\begin_layout Plain Layout

DS$ATC <- DS$RTC - DS$alphaR * DS$QF
\end_layout

\begin_layout Plain Layout

## Small time adjustment seems useful?
\end_layout

\begin_layout Plain Layout

# DS$Q <- ShiftInTime(DS$Q, .shift = -25, .rate = 25)
\end_layout

\begin_layout Plain Layout

DS$RHOCP <- 100 * DS$PSXC / (287.05 * 278) * 1005
\end_layout

\begin_layout Plain Layout

DS$RHOCP <- SmoothInterp(DS$RHOCP, .Length = 0)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Flight 15 from the 
\begin_inset Quotes eld
\end_inset

Southern Ocean Clouds, Radiation, Aerosol Transport Experimental Study
\begin_inset Quotes erd
\end_inset

 (SOCRATES), from 24 January 2018, 6:00:00 to 6:15:00 UTC, was another flight
 segment at low level over the ocean on which the unheated Rosemount sensor
 was used to measure temperature.
 The same procedure was followed as for VOCALS, with two changes: The flight
 was split into three 5-min flight segments and the results from those segments
 were averaged when the cospectrum was calculated, and the transfer function
 used was that determined based on GV measurements from this same project
 and flight, as listed in Part 1 Table 2.
 
\end_layout

\begin_layout Standard
Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:SOCp1}
\end_layout

\end_inset

 shows the measured cospectrum leading to the measured flux of sensible
 heat listed in the plot title.
 The exceedance distribution before correction, shown as the dashed brown
 line, was calculated using a dynamic-heating correction that was filtered
 to match the response of the sensor, but otherwise was not corrected.
 Without correction for the response as represented by the transfer function,
 about 30% of the flux of sensible heat would be missed.
 The underestimation is particularly serious at higher frequencies: The
 measured contribution from frequencies above 1
\begin_inset space ~
\end_inset

Hz is about twice as large after correction as it is without correction.
 
\begin_inset CommandInset citation
LatexCommand citet
key "LawsonRodi1992"
literal "false"

\end_inset

 estimated that, in comparison to their fast thermocouple sensor on a slower
 aircraft, the unheated Rosemount sensor underestimated the flux by about
 21% in their measurements.
 The magnitude of the correction applied here is thus reasonably consistent
 with expectations from their study.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<SOCp1, include=TRUE, fig.cap='The corrected flux of sensible heat for SOCRATES
 flight 15, 6:00:00 to 6:15:00, a low-level flight segment over the southern-hem
isphere ocean.
 The 
\begin_inset Quotes eld
\end_inset

exceedance
\begin_inset Quotes erd
\end_inset

 is the complement of the cumulative distribution function (i.e., the sum
 of contributions from frequencies above the plotted value), and the dashed
 brown exceedance line is that without transfer-function correction but
 with adjustment of the dynamic-heating term to incorporate the estimated
 response of the temperature sensor.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

N <- 2^13   ## 8192 covers the 5-min (7500-pt) segment
\end_layout

\begin_layout Plain Layout

# Get the transfer function:
\end_layout

\begin_layout Plain Layout

Par <- Param1
\end_layout

\begin_layout Plain Layout

a <- ParamFS1$a
\end_layout

\begin_layout Plain Layout

tau1 <- ParamFS1$tau1
\end_layout

\begin_layout Plain Layout

tau2 <- ParamFS1$tau2
\end_layout

\begin_layout Plain Layout

df <- Rate / N
\end_layout

\begin_layout Plain Layout

frq <- c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
\end_layout

\begin_layout Plain Layout

H <- LTphase(frq, ParamFS1) # complex(modulus=cTC, argument=phiTC)
\end_layout

\begin_layout Plain Layout

Tasm <- mean(DS$TASX[setRange(DS, 60000, 61500)], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

D <- DS
\end_layout

\begin_layout Plain Layout

D$RTF1 <- ShiftInTime(D$RTF1, .rate=25, .shift=40)
\end_layout

\begin_layout Plain Layout

# D$ATC <- ShiftInTime(D$ATC, .rate=25, .shift=0)
\end_layout

\begin_layout Plain Layout

# D$WIC <- ShiftInTime(D$WIC, .rate=25, .shift=-40)
\end_layout

\begin_layout Plain Layout

DS1 <- D %>% selectTime(60000, 60500)
\end_layout

\begin_layout Plain Layout

DS2 <- D %>% selectTime(60500, 61000)
\end_layout

\begin_layout Plain Layout

DS3 <- D %>% selectTime(61000, 61500)
\end_layout

\begin_layout Plain Layout

CoSp <- rep(0, N)
\end_layout

\begin_layout Plain Layout

CoSpUC <- rep(0, N)
\end_layout

\begin_layout Plain Layout

.A <- 'RTF1'
\end_layout

\begin_layout Plain Layout

.B <- 'ATC'
\end_layout

\begin_layout Plain Layout

.C <- 'AT'
\end_layout

\begin_layout Plain Layout

.D <- 'ATF1'
\end_layout

\begin_layout Plain Layout

for (.data in list(DS1, DS2, DS3)) {
\end_layout

\begin_layout Plain Layout

  N1 <- (N - nrow(.data)) %/% 2
\end_layout

\begin_layout Plain Layout

  N2 <- N - nrow(.data) - N1
\end_layout

\begin_layout Plain Layout

  WP <- c(rep(0, N1), detrend(.data[, c('Time', 'WIC')]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  TP <- c(rep(0, N1), detrend(.data[, c('Time', .A)]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  TPB <- c(rep(0, N1), detrend(.data[, c('Time', .B)]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  TPuc <- c(rep(0, N1), detrend(.data[, c('Time', .C)]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  TPO <- c(rep(0, N1), detrend(.data[, c('Time', .D)]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  Q  <- c(rep(0, N1), detrend(.data[, c('Time', 'Q')]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  ff1 <- fft(TP)
\end_layout

\begin_layout Plain Layout

  ff1uc <- fft(TPuc)
\end_layout

\begin_layout Plain Layout

  ffb <- fft(TPB)
\end_layout

\begin_layout Plain Layout

  ffo <- fft(TPO)
\end_layout

\begin_layout Plain Layout

  ff2 <- fft(WP)
\end_layout

\begin_layout Plain Layout

  ffq <- fft(Q)
\end_layout

\begin_layout Plain Layout

  cs.orig <- 2 * Re(ff1uc * Conj(ff2)) / (Rate * nrow(.data))
\end_layout

\begin_layout Plain Layout

  # cs <- 2 * Re(ff1 * Conj(ff2)) / (Rate * N)
\end_layout

\begin_layout Plain Layout

  ## Estimate original recovery T and apply corrected dynamic heating:
\end_layout

\begin_layout Plain Layout

  alphaR <- mean(.data$alphaR, na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

  cs <- 2 * Re((ff1 / H - alphaR * H * ffq) * Conj(ff2)) / (Rate * nrow(.data))
\end_layout

\begin_layout Plain Layout

  ## supercede with direct use of ATC:
\end_layout

\begin_layout Plain Layout

  cs <- 2 * Re((ff1uc / H) * Conj(ff2)) / (Rate * nrow(.data))
\end_layout

\begin_layout Plain Layout

  cs <- 1/(Mod(H)*cos(Arg(H))) * 2 * Re((ff1uc) * Conj(ff2)) / (Rate * nrow(.data
))
\end_layout

\begin_layout Plain Layout

  CoSp <- CoSp + cs
\end_layout

\begin_layout Plain Layout

  CoSpUC <- CoSpUC + cs.orig
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

CoSp <- CoSp * scaleFactor / 3
\end_layout

\begin_layout Plain Layout

CoSpUC <- CoSpUC * scaleFactor / 3
\end_layout

\begin_layout Plain Layout

Nby2 <- N %/% 2
\end_layout

\begin_layout Plain Layout

CS <- data.frame(freq = frq[2:(Nby2+1)], cospec = CoSp[2:(Nby2+1)])
\end_layout

\begin_layout Plain Layout

CS.orig <- data.frame(freq = frq[2:(Nby2+1)], cospec = CoSpUC[2:(Nby2+1)])
\end_layout

\begin_layout Plain Layout

CSogiveUC <- cumsum(CoSpUC[2:(Nby2+1)]) * CS$freq[1]
\end_layout

\begin_layout Plain Layout

CSogiveUC <- CSogiveUC[length(CSogiveUC)]-CSogiveUC
\end_layout

\begin_layout Plain Layout

CS.orig$ogive <- CSogiveUC
\end_layout

\begin_layout Plain Layout

wavelengthLimit <- 2000
\end_layout

\begin_layout Plain Layout

fL <- Tasm / wavelengthLimit
\end_layout

\begin_layout Plain Layout

ylim <- c(1.e-3, 80)
\end_layout

\begin_layout Plain Layout

CS.corrected <- plotCS(CS, Units, spans, fL, wavelengthLimit, smoothBins,
 
\end_layout

\begin_layout Plain Layout

                   xlim, ylim, printTitle, CSprevious = CS.orig) 
\end_layout

\begin_layout Plain Layout

CS.orig$cospec <- SmoothInterp(CS.orig$cospec, .Length=0)  # treat NAs
\end_layout

\begin_layout Plain Layout

  s25 <- spans %/% 25; s10 <- spans %/% 10; s3 <- spans %/% 3
\end_layout

\begin_layout Plain Layout

  s25 <- s25 + (s25 + 1) %% 2
\end_layout

\begin_layout Plain Layout

  s10 <- s10 + (s10 + 1) %% 2
\end_layout

\begin_layout Plain Layout

  s3 <- s3 + (s3 + 1) %% 2
\end_layout

\begin_layout Plain Layout

  CS.orig$cospec <- zoo::rollapply(CS.orig$cospec, FUN = mean, fill='extend',
 width = s25)
\end_layout

\begin_layout Plain Layout

  CS.orig$cospec[CS.orig$freq > 0.01] <- zoo::rollapply(CS.orig$cospec, FUN
 = mean, fill='extend', width = s10)[CS.orig$freq > 0.01]
\end_layout

\begin_layout Plain Layout

  CS.orig$cospec[CS.orig$freq > 0.1] <- zoo::rollapply(CS.orig$cospec, FUN =
 mean, fill='extend', width = s3)[CS.orig$freq > 0.1]
\end_layout

\begin_layout Plain Layout

  CS.orig$cospec[CS.orig$freq > 1] <- zoo::rollapply(CS.orig$cospec, FUN =
 mean, fill='extend', width = spans)[CS.orig$freq > 1]
\end_layout

\begin_layout Plain Layout

# g + geom_path(data=CS.orig, aes(x=freq, y=cospec*freq), col='forestgreen',
 size=1.3)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

XS <-
\end_layout

\begin_layout Plain Layout

  flux(
\end_layout

\begin_layout Plain Layout

    DS[setRange(DS, 60000, 61500), ],
\end_layout

\begin_layout Plain Layout

    'AT',
\end_layout

\begin_layout Plain Layout

    Units = bquote("W"~m^-2),
\end_layout

\begin_layout Plain Layout

    smoothBins = 50,
\end_layout

\begin_layout Plain Layout

    scaleFactor = scaleFactor,
\end_layout

\begin_layout Plain Layout

    wavelengthLimit = 2000,
\end_layout

\begin_layout Plain Layout

    .plot = FALSE,
\end_layout

\begin_layout Plain Layout

    Par = ParamFS1
\end_layout

\begin_layout Plain Layout

  )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
By obtaining a realistic measurement of the cospectrum at high frequency,
 it is possible to estimate how much of the otherwise unknown contribution
 above 1
\begin_inset space ~
\end_inset

Hz has been missed and therefore to judge if the frequency coverage is adequate.
 In this case, the exceedance curve is less than 2% at 10
\begin_inset space ~
\end_inset

Hz and falls rapidly above that frequency, so it appears likely that additional
 contributions from higher frequencies can go unmeasured without introducing
 serious errors into the measurement of flux.
\begin_inset Note Note
status open

\begin_layout Plain Layout
It is unexpected that there is so little difference between the corrected
 and uncorrected flux at high frequency, because the transfer function would
 suggest a significantly larger difference.
 For example, at 5
\begin_inset space ~
\end_inset

Hz the gain and phase of the transfer function are respectively 0.51 and
 
\begin_inset Formula $-40^{\circ},$
\end_inset

which would imply a correction of more than 2.5.
 Instead the ratio of the two cospectra at this frequency is only XXX.
 
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
The two variables leading to the solid and dashed exceedance variables in
 Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:SOCp1}
\end_layout

\end_inset

 were calculated as follows:
\end_layout

\begin_layout Enumerate
The solid line represents the results obtained by correcting the recovery-temper
ature measurement (RTF1) for its time response and then subtracting the
 estimated effect of dynamic heating as it affects that measurement.This
 was calculated in two ways, with almost equivalent results except at highest
 frequencies.
 First, the air temperature was calculated following the correction procedure
 of Sect.
\begin_inset space ~
\end_inset

4.1 of Part 1, by integration of the equation for the supporting structure,
 solving the remaining equation for the corrected recovery temperature,
 and then applying the filtered dynamic-heating term as in Part 2.
 The second used Fourier transforms to calculate the cospectrum.
 The formula for the cospectrum, in terms of the original measurement 
\begin_inset Formula $T_{m}(t)$
\end_inset

, the updraft 
\begin_inset Formula $w(t)$
\end_inset

 and the dynamic heating 
\begin_inset Formula $Q(t)$
\end_inset

 is:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
C(\nu)=\mathrm{Re}\left((\hat{T}_{m}(\nu)/\mathcal{H}(\nu)-\mathcal{H}(\nu)\hat{Q}(\nu))H(\nu)\hat{w}^{*}(\nu)\right)
\]

\end_inset

where 
\begin_inset Quotes eld
\end_inset

Re
\begin_inset Quotes erd
\end_inset

 denotes the real part, 
\begin_inset Formula $\mathcal{H}(\nu)$
\end_inset

 is the transfer function as a function of frequency 
\begin_inset Formula $\nu$
\end_inset

, the circumflex or 
\begin_inset Quotes eld
\end_inset

hat
\begin_inset Quotes erd
\end_inset

 denotes the Fourier transform of the original function of time and the
 asterisk denotes a complex conjugate.
 The inverse Fourier transform of 
\begin_inset Formula $(\hat{T_{m}}(\nu)/\mathcal{H}(\nu)-\mathcal{H}(\nu)\hat{Q}(\nu))$
\end_inset

 gives the air temperature 
\begin_inset Formula $T_{a}(t)$
\end_inset

 after correction for the time response of the sensor and for the (filtered)
 effect of dynamic heating.
 Both produced overlapping results when added to Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:SOCp1}
\end_layout

\end_inset

 except at frequencies above about 5
\begin_inset space ~
\end_inset

Hz, where the Fourier-transform method appeared to produce excess variance.
 For this reason, the first method was used.
\end_layout

\begin_layout Enumerate
The dashed line shows the result with correction only for dynamic heating,
 with appropriate filtering of the dynamic-heating term to correct for the
 response of the sensor.
 The transfer function was not otherwise used to correct the estimated air
 temperature.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Appendix A presents simulation results that support these methods used to
 calculate corrections to the flux.
 These results in combination with those presented in this section indicate
 that defensible measurements of the flux of sensible heat can be made using
 the unheated Rosemount 102E4AL sensor if the measurements are corrected
 for the time response of the sensor.
\end_layout

\begin_layout Subsection
CSET example
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

Cloud Systems Evolution in the Trades
\begin_inset Quotes erd
\end_inset

 (CSET) experiment included many low-level (150
\begin_inset space ~
\end_inset

m) flight segments over the Pacific Ocean between California and Hawaii,
 USA, and an unheated Rosemount 102E4AL sensor was flown on the NSF/NCAR
 GV during this project\SpecialChar endofsentence
 These measurements provide another opportunity to
 evaluate the measurements of sensible-heat flux.
 Three low-level flight segments were selected from research flight 5 (14
 July 2015): 17:52:00 to 18:02:00, 19:45:30 to 19:55:30, and 20:37:17 to
 20:47:17.
 The procedure was the same as used for the preceding SOCRATES example:
 Calculate the air temperature with a dynamic-heating correction filtered
 to match the sensor response, then average the cospectra of air temperature
 and updraft for the three segments so that the uncorrected and corrected
 measurements of flux can be compared..
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<CSET, include=TRUE, fig.cap='Cospectrum for the flux of sensible heat,
 for three 10-min flight segments from the CSET project.
 The dashed brown line is the exceedance distribution before correction,
 which gives a flux of 3.07 W m${-2}$ for wavelengths smaller than 2 km and
 2.06 W m$^{-2}$ for frequencies above 0.01 Hz.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DCX <- getNetCDF(file.path(DataDirectory(), 'CSET/rf05h.nc'),
\end_layout

\begin_layout Plain Layout

                 standardVariables(c('ATF1', 'ATH1', 'ATH2')), 175000, 205000)
\end_layout

\begin_layout Plain Layout

Rate <- attr(DCX, 'Rate')
\end_layout

\begin_layout Plain Layout

MRHO <- DCX$MACHX * DCX$PSXC * 100 / 
\end_layout

\begin_layout Plain Layout

        (287.05 * (273.15 + DCX$ATX)) / rhozero
\end_layout

\begin_layout Plain Layout

ParamFS1 <- ParamSF
\end_layout

\begin_layout Plain Layout

ParamFS1$tau1 <- ParamFS1$tau1 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ -0.6
\end_layout

\begin_layout Plain Layout

ParamFS1$tau2 <- ParamFS1$tau2 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ -0.6
\end_layout

\begin_layout Plain Layout

DCX$TASX <- SmoothInterp(DCX$TASX, .Length = 0)
\end_layout

\begin_layout Plain Layout

DCX$Q <- DCX$TASX ^ 2 / 2010
\end_layout

\begin_layout Plain Layout

DCX$ATX <- DCX$ATF1
\end_layout

\begin_layout Plain Layout

# DCX$AT <- reviseDH(DCX, ParamFS1, rf)  # rf was calculated in an earlier
 code chunk
\end_layout

\begin_layout Plain Layout

## Replace this by the filtered result:
\end_layout

\begin_layout Plain Layout

## Recalculate AT using the dynamic-heating filter:
\end_layout

\begin_layout Plain Layout

DCX$ATX <- SmoothInterp(DCX$ATX, .Length=0)
\end_layout

\begin_layout Plain Layout

DCX$PSXC <- SmoothInterp(DCX$PSXC, .Length=0)
\end_layout

\begin_layout Plain Layout

DCX$QCXC <- SmoothInterp(DCX$QCXC, .Length=0)
\end_layout

\begin_layout Plain Layout

DCX$MACH <- SmoothInterp(MachNumber(DCX$PSXC, DCX$QCXC), .Length=0)
\end_layout

\begin_layout Plain Layout

DCX$alphaR <- RecoveryFactor(DCX$MACH, 'UNHEATED') 
\end_layout

\begin_layout Plain Layout

DCX$Q <- DCX$TASX^2 / (2 * SpecificHeats()[1])
\end_layout

\begin_layout Plain Layout

DCX$QF <- as.vector(signal::filter(ARG, DCX$Q))
\end_layout

\begin_layout Plain Layout

DCX$QF <- ShiftInTime(DCX$QF, .shift=-Lshift * 40, .rate=25)
\end_layout

\begin_layout Plain Layout

DCX$AT <- DCX$ATX + DCX$alphaR * (DCX$Q - DCX$QF)
\end_layout

\begin_layout Plain Layout

DCX$AT <- SmoothInterp(DCX$AT, .Length = 0)
\end_layout

\begin_layout Plain Layout

DCX$RTF1 <-
\end_layout

\begin_layout Plain Layout

  DCX$ATF1 + DCX$alphaR * DCX$Q  ## This variable isn't in the available
 file
\end_layout

\begin_layout Plain Layout

DCX$RTF1 <- SmoothInterp(DCX$RTF1, .Length = 0)
\end_layout

\begin_layout Plain Layout

## Estimate the corrected recovery temperature:
\end_layout

\begin_layout Plain Layout

aV <- ParamFS1$a
\end_layout

\begin_layout Plain Layout

tau1V <- ParamFS1$tau1
\end_layout

\begin_layout Plain Layout

tau2V <- ParamFS1$tau2
\end_layout

\begin_layout Plain Layout

DCX$DTMDT <- c(0, diff(DCX$RTF1, 2), 0) * Rate / 2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

fSS <- function(y, i) {  # Eq.
 Ts3
\end_layout

\begin_layout Plain Layout

    ((1/aV) * (tau1V * DCX$DTMDT[i] + DCX$RTF1[i] - (1-aV) * y) - y) / (Rate
 * tau2V)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DCX$Ts <- rk4.integrate (fSS, DCX$RTF1[1], 1:nrow(DCX))
\end_layout

\begin_layout Plain Layout

DCX$RTC <- (1/aV) * (tau1V * DCX$DTMDT + DCX$RTF1 - (1-aV) * DCX$Ts)
\end_layout

\begin_layout Plain Layout

DCX$ATC <- DCX$RTC - DCX$alphaR * DCX$QF
\end_layout

\begin_layout Plain Layout

## Small time adjustment seems useful?
\end_layout

\begin_layout Plain Layout

# DCX$Q <- ShiftInTime(DCX$Q, .shift = -25, .rate = 25)
\end_layout

\begin_layout Plain Layout

DCX$RHOCP <- 100 * DCX$PSXC / (287.05 * 278) * 1005
\end_layout

\begin_layout Plain Layout

DCX$RHOCP <- SmoothInterp(DCX$RHOCP, .Length = 0)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

N <- 2^14   ## 16384 covers the 10-min (15000-pt) segments
\end_layout

\begin_layout Plain Layout

# Get the transfer function:
\end_layout

\begin_layout Plain Layout

a <- ParamFS1$a
\end_layout

\begin_layout Plain Layout

tau1 <- ParamFS1$tau1
\end_layout

\begin_layout Plain Layout

tau2 <- ParamFS1$tau2
\end_layout

\begin_layout Plain Layout

df <- Rate / N
\end_layout

\begin_layout Plain Layout

frq <- c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
\end_layout

\begin_layout Plain Layout

H <- LTphase(frq, ParamFS1)
\end_layout

\begin_layout Plain Layout

D <- DCX
\end_layout

\begin_layout Plain Layout

D$RTF1 <- ShiftInTime(D$RTF1, .rate=25, .shift=40)
\end_layout

\begin_layout Plain Layout

# D$ATC <- ShiftInTime(D$ATC, .rate=25, .shift=0)
\end_layout

\begin_layout Plain Layout

# D$WIC <- ShiftInTime(D$WIC, .rate=25, .shift=-40)
\end_layout

\begin_layout Plain Layout

DC1 <- D %>% selectTime(175200, 180200)
\end_layout

\begin_layout Plain Layout

DC2 <- D %>% selectTime(194530, 195530)
\end_layout

\begin_layout Plain Layout

DC3 <- D %>% selectTime(203717, 204717)
\end_layout

\begin_layout Plain Layout

CoSp <- rep(0, N)
\end_layout

\begin_layout Plain Layout

CoSpUC <- rep(0, N)
\end_layout

\begin_layout Plain Layout

.A <- 'RTF1'
\end_layout

\begin_layout Plain Layout

.B <- 'ATC'
\end_layout

\begin_layout Plain Layout

.C <- 'AT'
\end_layout

\begin_layout Plain Layout

.D <- 'ATF1'
\end_layout

\begin_layout Plain Layout

DCF <- data.frame()
\end_layout

\begin_layout Plain Layout

for (.data in list(DC1, DC2, DC3)) {
\end_layout

\begin_layout Plain Layout

  N1 <- (N - nrow(.data)) %/% 2
\end_layout

\begin_layout Plain Layout

  N2 <- N - nrow(.data) - N1
\end_layout

\begin_layout Plain Layout

  WP <- c(rep(0, N1), detrend(.data[, c('Time', 'WIC')]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  TP <- c(rep(0, N1), detrend(.data[, c('Time', .A)]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  TPB <- c(rep(0, N1), detrend(.data[, c('Time', .B)]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  TPuc <- c(rep(0, N1), detrend(.data[, c('Time', .C)]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  TPO <- c(rep(0, N1), detrend(.data[, c('Time', .D)]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  Q  <- c(rep(0, N1), detrend(.data[, c('Time', 'Q')]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  ff1 <- fft(TP)
\end_layout

\begin_layout Plain Layout

  ff1uc <- fft(TPuc)
\end_layout

\begin_layout Plain Layout

  ffb <- fft(TPB)
\end_layout

\begin_layout Plain Layout

  ffo <- fft(TPO)
\end_layout

\begin_layout Plain Layout

  ff2 <- fft(WP)
\end_layout

\begin_layout Plain Layout

  ffq <- fft(Q)
\end_layout

\begin_layout Plain Layout

  cs.orig <- 2 * Re(ff1uc * Conj(ff2)) / (Rate * nrow(.data))
\end_layout

\begin_layout Plain Layout

  # cs <- 2 * Re(ff1 * Conj(ff2)) / (Rate * N)
\end_layout

\begin_layout Plain Layout

  ## Estimate original recovery T and apply corrected dynamic heating:
\end_layout

\begin_layout Plain Layout

  alphaR <- mean(.data$alphaR, na.rm = TRUE)
\end_layout

\begin_layout Plain Layout

  cs <- 2 * Re((ff1 / H - alphaR * H * ffq) * Conj(ff2)) / (Rate * nrow(.data))
\end_layout

\begin_layout Plain Layout

  ## supercede with direct use of ATC:
\end_layout

\begin_layout Plain Layout

  cs <- 2 * Re((ff1uc / H) * Conj(ff2)) / (Rate * nrow(.data))
\end_layout

\begin_layout Plain Layout

  cs <- 1/(Mod(H)*cos(Arg(H))) * 2 * Re((ff1uc) * Conj(ff2)) / (Rate * nrow(.data
))
\end_layout

\begin_layout Plain Layout

  CoSp <- CoSp + cs
\end_layout

\begin_layout Plain Layout

  CoSpUC <- CoSpUC + cs.orig
\end_layout

\begin_layout Plain Layout

  DCF <- rbind(DCF, .data)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

Tasm <- mean(DCF$TASX, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

CoSp <- CoSp * scaleFactor / 3
\end_layout

\begin_layout Plain Layout

CoSpUC <- CoSpUC * scaleFactor / 3
\end_layout

\begin_layout Plain Layout

Nby2 <- N %/% 2
\end_layout

\begin_layout Plain Layout

CS <- data.frame(freq = frq[2:(Nby2+1)], cospec = CoSp[2:(Nby2+1)])
\end_layout

\begin_layout Plain Layout

CS.orig <- data.frame(freq = frq[2:(Nby2+1)], cospec = CoSpUC[2:(Nby2+1)])
\end_layout

\begin_layout Plain Layout

CSogiveUC <- cumsum(CoSpUC[2:(Nby2+1)]) * CS$freq[1]
\end_layout

\begin_layout Plain Layout

CSogiveUC <- CSogiveUC[length(CSogiveUC)]-CSogiveUC
\end_layout

\begin_layout Plain Layout

CS.orig$ogive <- CSogiveUC
\end_layout

\begin_layout Plain Layout

wavelengthLimit <- 2000
\end_layout

\begin_layout Plain Layout

fL <- Tasm / wavelengthLimit
\end_layout

\begin_layout Plain Layout

ylim <- c(1.e-3, 80)
\end_layout

\begin_layout Plain Layout

CS.corrected <- plotCS(CS, Units, spans, fL, wavelengthLimit, smoothBins,
 
\end_layout

\begin_layout Plain Layout

                   xlim, ylim, printTitle, CSprevious = CS.orig) 
\end_layout

\begin_layout Plain Layout

CS.orig$cospec <- SmoothInterp(CS.orig$cospec, .Length=0)  # treat NAs
\end_layout

\begin_layout Plain Layout

  s25 <- spans %/% 25; s10 <- spans %/% 10; s3 <- spans %/% 3
\end_layout

\begin_layout Plain Layout

  s25 <- s25 + (s25 + 1) %% 2
\end_layout

\begin_layout Plain Layout

  s10 <- s10 + (s10 + 1) %% 2
\end_layout

\begin_layout Plain Layout

  s3 <- s3 + (s3 + 1) %% 2
\end_layout

\begin_layout Plain Layout

  CS.orig$cospec <- zoo::rollapply(CS.orig$cospec, FUN = mean, fill='extend',
 width = s25)
\end_layout

\begin_layout Plain Layout

  CS.orig$cospec[CS.orig$freq > 0.01] <- zoo::rollapply(CS.orig$cospec, FUN
 = mean, fill='extend', width = s10)[CS.orig$freq > 0.01]
\end_layout

\begin_layout Plain Layout

  CS.orig$cospec[CS.orig$freq > 0.1] <- zoo::rollapply(CS.orig$cospec, FUN =
 mean, fill='extend', width = s3)[CS.orig$freq > 0.1]
\end_layout

\begin_layout Plain Layout

  CS.orig$cospec[CS.orig$freq > 1] <- zoo::rollapply(CS.orig$cospec, FUN =
 mean, fill='extend', width = spans)[CS.orig$freq > 1]
\end_layout

\begin_layout Plain Layout

# g + geom_path(data=CS.orig, aes(x=freq, y=cospec*freq), col='forestgreen',
 size=1.3)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The resulting cospectrum is shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:CSET}
\end_layout

\end_inset

.
 Without correction, the measured flux would be about 56% of the corrected
 flux for wavelengths smaller than 2 km, and for fluctuating frequencies
 above 1
\begin_inset space ~
\end_inset

Hz the measured flux would be only about 43% of that obtained from the corrected
 measurements.
 The indication from this example, as from the others, is that the correction
 can amount to a significant part of the measured flux and that, without
 correction, the flux would be underestimated by around 50%.
\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Section
Summary and Conclusions
\end_layout

\begin_layout Standard
Some key conclusions from Parts 1 and 2 are included briefly here so that
 this summary can encompass all three papers.
 The key findings are these:
\end_layout

\begin_layout Enumerate
In Part 1, a transfer function for an unheated Rosemount 102E4AL sensor
 was determined and shown to be consistent with constraining measurements.
 A parametric representation depending on three parameters was shown to
 lead to reasonable correction of the measurements of recovery temperature.
\end_layout

\begin_layout Enumerate
Part 2 argued that, because temperature sensors often do not respond fast
 enough to measure high-frequency components of the dynamic-heating correction,
 erroneous corrections are introduced by conventional data processing.
 Instead, the corrections should be filtered to match the response of the
 temperature sensor to avoid introduction of these errors.
\end_layout

\begin_layout Enumerate
In this Part 3, a correction procedure was proposed that consists of using
 the transfer function from Part 1 and the modified correction for dynamic
 heating developed in Part 2 to calculate the sensible-heat flux.
 Three cases are presented, all with significant correlation between temperature
 and updraft at a range of frequencies including those above 1
\begin_inset space ~
\end_inset

Hz.
 The measured values of sensible-heat flux would be underestimated significantly
 (by about 40%, 30%, and 44% in the three cases) without correction.
 
\end_layout

\begin_layout Enumerate
The cospectrum with correction appears to be represented reasonably at frequenci
es up to about 10
\begin_inset space ~
\end_inset

Hz, so the rapidly decreasing concentration to the cospectrum from these
 frequencies suggests that it is not necessary to measure contributions
 from frequencies above this limit.
 This conclusion is tentative and needs reconsideration when applied to
 new cases.
\end_layout

\begin_layout Enumerate
These results are reproducible using the document that generated this report,
 and this report is archived along with appropriate data sources so that
 they will be accessible to others who might want to apply these approaches
 to other sensors or use these correction schemes to improve measurements
 of the flux of sensible heat.
 Appendix B provides specific information to aid an analyst who might want
 to replicate or extend this study.
 In particular, an accompanying 
\begin_inset Quotes eld
\end_inset

workflow
\begin_inset Quotes erd
\end_inset

 statement provides additional details and documents some additional aspects
 of the study that are not included in this report, and methods to access
 the data used are included in that workflow document.
\end_layout

\begin_layout Section
\start_of_appendix
Appendix: Assessment Via Simulation
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<reinitialization,echo=FALSE,include=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Directory <- DataDirectory ()
\end_layout

\begin_layout Plain Layout

Flight <- 1 				
\end_layout

\begin_layout Plain Layout

Project = "SOCRATES"			
\end_layout

\begin_layout Plain Layout

ProjectDir <- "SOCRATES"
\end_layout

\begin_layout Plain Layout

fname = sprintf("%s%s/%srf%02d.nc", Directory, ProjectDir, Project, Flight)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
The Goal
\end_layout

\begin_layout Standard
This appendix uses simulated measurements with the analysis methods developed
 in this paper to demonstrate that those correction schemes can recover
 the assumed simulated conditions.
 Toward this end, it is useful to generate time series representing isotropic
 wind measurements that have a specified relationship to the eddy dissipation
 rate and the expected 
\begin_inset Formula $-5/3$
\end_inset

 slope of spectral variance vs.
\begin_inset space ~
\end_inset

frequency that is expected for an inertial sub-range.
 The code used here generates such a time series of duration 
\begin_inset Formula $T=30\,\mathrm{min}$
\end_inset

 by generating a Gaussian-noise spectrum, finding the Fourier transform,
 weighting the components to obtain a 
\begin_inset Formula $-5/3$
\end_inset

 slope, and then using an inverse Fourier transform to reconstruct a simulated
 measurement series representing an inertial subrange.
 To provide a more realistic representation of the variance spectra often
 observed, the spectral variance is attenuated a low frequency to produce
 a peak variance at several-kilometer wavelength.
\end_layout

\begin_layout Standard
The variance spectrum expected for an inertial sub-range has the following
 form:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
P(\nu)=C\left(\frac{2\pi}{V}\right)^{-2/3}\epsilon^{2/3}\nu^{-5/3}\label{eq:expectedSpectrum}
\end{equation}

\end_inset

where 
\begin_inset Formula $C=0.5$
\end_inset

 for the longitudinal component of the wind and 2/3 for a lateral component.
 An eddy dissipation rate of 
\begin_inset Formula $10^{-3}\,\mathrm{m}^{2}\mathrm{s^{-3}}$
\end_inset

 and a flight speed of 
\begin_inset Formula $V=200$
\end_inset


\begin_inset space ~
\end_inset

m/s were used with 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:expectedSpectrum"
plural "false"
caps "false"
noprefix "false"

\end_inset

 to specify the desired variance spectrum.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout

\lang english
for a lateral wind component is shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:varSpecISR}
\end_layout

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<varSpecISR, include=FALSE, echo=FALSE, fig.cap=
\begin_inset Quotes erd
\end_inset

Assumed spectral variance at periodogram points.
\begin_inset Quotes erd
\end_inset

>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

epsilon <- 1.e-3  ## mks
\end_layout

\begin_layout Plain Layout

e23 <- epsilon ^ (2 / 3)
\end_layout

\begin_layout Plain Layout

V <- 200   ## assumed flight speed, m/s
\end_layout

\begin_layout Plain Layout

duration <- 1800
\end_layout

\begin_layout Plain Layout

Rate <- 50
\end_layout

\begin_layout Plain Layout

Nyq <- Rate / 2
\end_layout

\begin_layout Plain Layout

C <- (2 / 3) * (2 * pi / V) ^ (-2 / 3)
\end_layout

\begin_layout Plain Layout

# freq <- seq(1/duration, Nyq, by=1/duration)  ## unaliased
\end_layout

\begin_layout Plain Layout

freq <- seq(1 / duration, Nyq * 5, by = 1 / duration)  ## aliased version
\end_layout

\begin_layout Plain Layout

p <-
\end_layout

\begin_layout Plain Layout

  C * e23 * freq ^ (-5 / 3)  ## This is variance per frequency interval,
\end_layout

\begin_layout Plain Layout

## normalized to be positive frequencies
\end_layout

\begin_layout Plain Layout

r <- freq > 0 & freq <= Nyq
\end_layout

\begin_layout Plain Layout

plotWAC(
\end_layout

\begin_layout Plain Layout

  data.frame (freq[r], p[r]),
\end_layout

\begin_layout Plain Layout

  log = 'xy',
\end_layout

\begin_layout Plain Layout

  xlab = 'frequency [Hz]',
\end_layout

\begin_layout Plain Layout

  ylab = bquote('P(frequency) [m' ^ 2 ~ 's' ^ -2 ~ 'Hz' ^ -1 ~ ']'),
\end_layout

\begin_layout Plain Layout

  col = 'blue',
\end_layout

\begin_layout Plain Layout

  lwd = 2
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch Extra
inverted 0
status open

\begin_layout Standard

\lang english
\begin_inset ERT
status open

\begin_layout Plain Layout

<<originalGenerate, include = FALSE, eval = FALSE, fig.cap = ''>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## This is the first try, replaced by the method in the next chumk
\end_layout

\begin_layout Plain Layout

if (file.exists('./DF.Rdata')) {
\end_layout

\begin_layout Plain Layout

  load(file = './DF.Rdata') # load data.frame DF
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  Time <- seq(0, duration * Rate - 1) / Rate
\end_layout

\begin_layout Plain Layout

  u <- v <- w <- rep(0, length(Time))
\end_layout

\begin_layout Plain Layout

  nf <- length(freq)
\end_layout

\begin_layout Plain Layout

  rnu <- runif(nf)
\end_layout

\begin_layout Plain Layout

  rnv <- runif(nf)
\end_layout

\begin_layout Plain Layout

  rnw <- runif(nf)
\end_layout

\begin_layout Plain Layout

  a <- sqrt(2 * p / duration)   ## 2 for normalization convention
\end_layout

\begin_layout Plain Layout

  for (i in 1:nf) {
\end_layout

\begin_layout Plain Layout

    fT <- freq[i] * Time
\end_layout

\begin_layout Plain Layout

    u <-
\end_layout

\begin_layout Plain Layout

      u + sqrt(3 / 4) * a[i] * sin(2 * pi * (fT + rnu[i]))  ## random phase
\end_layout

\begin_layout Plain Layout

    v <- v + a[i] * sin(2 * pi * (fT + rnv[i]))
\end_layout

\begin_layout Plain Layout

    w <- w + a[i] * sin(2 * pi * (fT + rnw[i]))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  DF <-
\end_layout

\begin_layout Plain Layout

    data.frame(
\end_layout

\begin_layout Plain Layout

      Time = Time,
\end_layout

\begin_layout Plain Layout

      TASX = rep(V, length(Time)),
\end_layout

\begin_layout Plain Layout

      u = u,
\end_layout

\begin_layout Plain Layout

      v = v,
\end_layout

\begin_layout Plain Layout

      w = w
\end_layout

\begin_layout Plain Layout

    )
\end_layout

\begin_layout Plain Layout

  attr(DF, 'Rate') <- Rate
\end_layout

\begin_layout Plain Layout

  save(DF, file = './DF.Rdata')
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

g <- VSpec(DF, 'w', xlim = c(0.01, 30))
\end_layout

\begin_layout Plain Layout

g <- VSpec(DF, 'v', ADD = g)
\end_layout

\begin_layout Plain Layout

VSpec(DF, 'u', ADD = g) + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

DF$w <- DF$w * 100^0.33333
\end_layout

\begin_layout Plain Layout

DF$v <- DF$v * 100^0.33333
\end_layout

\begin_layout Plain Layout

DF$u <- DF$u * 100^0.33333
\end_layout

\begin_layout Plain Layout

g <- VSpec(DF, 'w', xlim = c(0.01, 30), type = 'MEM')
\end_layout

\begin_layout Plain Layout

if (file.exists('./EDR.Rdata')) {
\end_layout

\begin_layout Plain Layout

  # loads data.frame DF2
\end_layout

\begin_layout Plain Layout

  load(file = './EDR.Rdata')
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  ## now filter and reduce rate to Rate2
\end_layout

\begin_layout Plain Layout

  Rate2 <- 25
\end_layout

\begin_layout Plain Layout

  Time2 <- seq(0, duration * Rate2 - 1) / Rate2
\end_layout

\begin_layout Plain Layout

  wf <- signal::decimate(DF$w, Rate / Rate2, n = 25, ftype = 'fir')
\end_layout

\begin_layout Plain Layout

  uf <- signal::decimate(DF$u, Rate / Rate2, n = 25, ftype = 'fir')
\end_layout

\begin_layout Plain Layout

  vf <- signal::decimate(DF$v, Rate / Rate2, n = 25, ftype = 'fir')
\end_layout

\begin_layout Plain Layout

  DF2 <-
\end_layout

\begin_layout Plain Layout

    data.frame(
\end_layout

\begin_layout Plain Layout

      Time = Time2,
\end_layout

\begin_layout Plain Layout

      TASX = rep(V, length(Time2)) + uf,
\end_layout

\begin_layout Plain Layout

      u = uf,
\end_layout

\begin_layout Plain Layout

      v = vf,
\end_layout

\begin_layout Plain Layout

      w = wf
\end_layout

\begin_layout Plain Layout

    )
\end_layout

\begin_layout Plain Layout

  attr(DF2, 'Rate') <- Rate2
\end_layout

\begin_layout Plain Layout

  save(DF2, file = './EDR.Rdata')
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

load('../SocratesQA/Time_units.Rdata')
\end_layout

\begin_layout Plain Layout

attr(DF2$Time, 'units') <- Time_units$value
\end_layout

\begin_layout Plain Layout

tref <- sub ('seconds since ', '', attr (DF2$Time, 'units'))
\end_layout

\begin_layout Plain Layout

DF2$Time <- as.POSIXct(DF2$Time, tz = 'UTC', origin = tref)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<generate, include=TRUE, echo=FALSE, fig.cap='The variance spectrum of the
 generated time series.
 Three wind components are shown: $u$ longitudinal; $v$ side lateral; $w$
 upward.
 The simulated eddy dissipation rate was $10^{-3}$ m$^2s^{-3}$.
 The generated longitudinal spectral density (u) is 3/4 the lateral spectral
 densities (v and w), as expected in an inertial subrange.
 The dashed orange lines indicated the expected slope ($-2/3$ for this distribut
ion because it is weighted by frequency), with the large-dot line representing
 $10^{-4}$ m$^2s^{-3}$ and other lines representing eddy dissipation rates
  factors of 10 higher or lower.
 The spectral variance has been attenuated at low frequency to simulate
 the shapes that are often observed.
 The displayed wavelength scale was determined from the average flight speed.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if (file.exists('DF2.Rdata')) {  ## This is to avoid having this change every
 run
\end_layout

\begin_layout Plain Layout

  load(file = 'DF2.Rdata')
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  Rate <- 25
\end_layout

\begin_layout Plain Layout

  duration <- 2^16 / Rate
\end_layout

\begin_layout Plain Layout

  epsilon <- 1.e-3  ## Specify the eddy dissipation rate, mks units
\end_layout

\begin_layout Plain Layout

  V <- 200   ## assumed flight speed, m/s
\end_layout

\begin_layout Plain Layout

  ## Spectral variance amplitude, lateral component
\end_layout

\begin_layout Plain Layout

  C <- (2 / 3) * (2 * pi / V) ^ (-2 / 3) * epsilon ^ (2 / 3) 
\end_layout

\begin_layout Plain Layout

  Time <- seq(0, duration * Rate - 1) / Rate
\end_layout

\begin_layout Plain Layout

  N <- length(Time)
\end_layout

\begin_layout Plain Layout

  A <- sqrt(C * Rate / 2)
\end_layout

\begin_layout Plain Layout

  u <- rnorm(N, 0, A) * sqrt(3/4)  ## sqrt(3/4) to get 3:4 ratio, spectra
\end_layout

\begin_layout Plain Layout

  v <- rnorm(N, 0, A)
\end_layout

\begin_layout Plain Layout

  w <- rnorm(N, 0, A)
\end_layout

\begin_layout Plain Layout

  DF2 <- data.frame(Time = Time, TASX = V + u, u = u, v = v, w = w)
\end_layout

\begin_layout Plain Layout

  attr(DF2, 'Rate') <- Rate
\end_layout

\begin_layout Plain Layout

  f1 <- fft(DF2$u)
\end_layout

\begin_layout Plain Layout

  f2 <- fft(DF2$v)
\end_layout

\begin_layout Plain Layout

  f3 <- fft(DF2$w)
\end_layout

\begin_layout Plain Layout

  df <- Rate / N
\end_layout

\begin_layout Plain Layout

  frq <- c(seq(0, Rate/2, by = df), seq(-Rate/2+df, -df, by = df))
\end_layout

\begin_layout Plain Layout

  f1[2:N] <- f1[2:N] * abs(frq[2:N]) ^ (-5/6)  ## Force -5/3 slope
\end_layout

\begin_layout Plain Layout

  f2[2:N] <- f2[2:N] * abs(frq[2:N]) ^ (-5/6)
\end_layout

\begin_layout Plain Layout

  f3[2:N] <- f3[2:N] * abs(frq[2:N]) ^ (-5/6)
\end_layout

\begin_layout Plain Layout

  rf <- (abs(frq) < 0.02)
\end_layout

\begin_layout Plain Layout

  rf[1] <- TRUE
\end_layout

\begin_layout Plain Layout

  f1[rf] <- f1[rf] * exp(-5*0.02 / abs(frq[rf]))  ## Truncate low-frequency
\end_layout

\begin_layout Plain Layout

                                          ## (improves high-f accuracy)
\end_layout

\begin_layout Plain Layout

  f2[rf] <- f2[rf] * exp(-5*0.02 / abs(frq[rf]))
\end_layout

\begin_layout Plain Layout

  f3[rf] <- f3[rf] * exp(-5*0.02 / abs(frq[rf]))
\end_layout

\begin_layout Plain Layout

  DF2$u <- Re(fft(f1, inverse = TRUE) / N)
\end_layout

\begin_layout Plain Layout

  DF2$v <- Re(fft(f2, inverse = TRUE) / N)
\end_layout

\begin_layout Plain Layout

  DF2$w <- Re(fft(f3, inverse = TRUE) / N)
\end_layout

\begin_layout Plain Layout

  ## Modify time to get a POSIXct value as expected by Ranadu:
\end_layout

\begin_layout Plain Layout

  load('chunks/Time_units.Rdata')  ## Saved from a conventional file
\end_layout

\begin_layout Plain Layout

  attr(DF2$Time, 'units') <- Time_units$value
\end_layout

\begin_layout Plain Layout

  tref <- sub ('seconds since ', '', attr (DF2$Time, 'units'))
\end_layout

\begin_layout Plain Layout

  DF2$Time <- as.POSIXct(DF2$Time, tz = 'UTC', origin = tref)
\end_layout

\begin_layout Plain Layout

  DF2 <- DF2 %>% selectTime(500, 3500)  # Select subset to avoid end effects
\end_layout

\begin_layout Plain Layout

  save(DF2, file='DF2.Rdata')
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

DF2 %>% select(Time, TASX, u, v, w) %>% 
\end_layout

\begin_layout Plain Layout

        VSpec(xlim=c(0.01,15), ylim=c(1.e-3, 10), type='MEM') + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The result for one realization of the time series is shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:generate}
\end_layout

\end_inset

.
 The match to the assumed eddy dissipation rate (
\begin_inset Formula $10^{-3}m^{2}s^{-3})$
\end_inset

 is good.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
This time series can then be written to a netCDF file (preferably with the
 Time variable converted to RAF convention) to use as input to studies of
 how missing values and other problems will affect the resulting variance
 spectrum.
 Because the amplitude of the variations is proportional to 
\begin_inset Formula $\epsilon^{1/3}$
\end_inset

, a time series for a different eddy dissipation rate can be obtained by
 scaling these by (
\begin_inset Formula $\epsilon^{\prime}/\epsilon^{*})^{1/3}$
\end_inset

 where 
\begin_inset Formula $\epsilon^{\prime}$
\end_inset

 is the desired eddy dissipation rate and 
\begin_inset Formula $\epsilon^{*}$
\end_inset

 is 
\begin_inset Formula $10^{-5}\,\mathrm{m}^{2}\mathrm{s}^{-3}$
\end_inset

.
 
\end_layout

\end_inset

When calculating the simulated flux, the very-long-wavelength components
 (with frequency below 0.02
\begin_inset space ~
\end_inset

Hz) were attenuated before the series was used.
 This seemed to improve the accuracy of the high-frequency simulation, which
 otherwise exhibited some variability for different random sequences but
 became more consistent with this adjustment.
\end_layout

\begin_layout Subsection
Simulated Flux 
\end_layout

\begin_layout Standard
To determine how a simulated time series would be measured, it was necessary
 to generate two realistic time series for the updraft and the temperature.
 To produce a flux, there should be some correlation between these so that
 the measurement based on 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:heatFlux-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

 will be non-zero.
 Therefore, the two time series were generated as follows:
\end_layout

\begin_layout Enumerate
A time series for 
\begin_inset Formula $w^{\prime}$
\end_inset

 was generated that has eddy dissipation rate of 
\begin_inset Formula $10^{-3}\mathrm{m}^{2}\mathrm{s}^{-3}$
\end_inset

, as shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:generate}
\end_layout

\end_inset

.
\end_layout

\begin_layout Enumerate
A second independent time series 
\begin_inset Formula $T$
\end_inset

 with fluctuations 
\begin_inset Formula $T^{\prime}$
\end_inset

 scaled smaller by a factor of five was generated to represent the 
\emph on
air 
\emph default
temperature.
\end_layout

\begin_layout Enumerate
Correlation between the two time series was then introduced by defining
 a new temperature time series with the fluctuations 
\begin_inset Formula $T_{c}^{\prime}=(1-r)T^{\prime}+rw^{\prime}/5$
\end_inset

 where 
\begin_inset Formula $r=0.3$
\end_inset

.
 The result will be 
\begin_inset Formula $<w^{\prime}T_{c}^{\prime}>=r\sqrt{\sigma_{w}\sigma_{T_{c}}}$
\end_inset

, which will lead to a flux of sensible heat specified as
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
F_{s}=\rho_{a}C_{p}r\sqrt{\sigma_{w}\sigma_{T_{c}}}
\]

\end_inset


\end_layout

\begin_layout Standard
An example is shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:simF1}
\end_layout

\end_inset

.
 In this simulation, the correlation is the same at all frequencies so the
 contribution to the measured flux also extends over all frequencies, with
 decreasing contributions as frequency increases.
 In this case, about 10% of the 
\begin_inset Formula $<5\,\mathrm{km}$
\end_inset

 flux is contributed at frequencies above 1
\begin_inset space ~
\end_inset

Hz, where there is danger that the real sensor will respond incompletely
 to the fluctuations.
 The potential effects of the sensor response and possibly incorrect adjustment
 for dynamic heating can then be determined by replacing the dynamic-heating
 term with the filtered version as specified in Part 2 and then by calculating
 the expected measurement by filtering the recovery temperature in the same
 way.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<genF, include=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

rc <- 0.3
\end_layout

\begin_layout Plain Layout

DF2$T <- DF2$v / 5
\end_layout

\begin_layout Plain Layout

DF2$T <- (1 - rc) * DF2$T + rc * DF2$w / 5 + 10
\end_layout

\begin_layout Plain Layout

DF2$WIC <- DF2$w
\end_layout

\begin_layout Plain Layout

DF2$Q <- 0.985 * DF2$TASX ^ 2 / 2010
\end_layout

\begin_layout Plain Layout

DF2$RT <- DF2$T + DF2$Q  ## The conventional calculation of the recovery
 temperature
\end_layout

\begin_layout Plain Layout

a <- Param1$a
\end_layout

\begin_layout Plain Layout

tau1 <- Param1$tau1
\end_layout

\begin_layout Plain Layout

tau2 <- Param1$tau2
\end_layout

\begin_layout Plain Layout

DF2$TsQ <- DF2$RT
\end_layout

\begin_layout Plain Layout

DF2$Qp <- DF2$Q
\end_layout

\begin_layout Plain Layout

Rate <- attr (DF2, 'Rate')
\end_layout

\begin_layout Plain Layout

fS <- function(y, i) {
\end_layout

\begin_layout Plain Layout

  (DF2$Q[i] - y) / (Rate * tau2)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

fM <- function (y, i) {
\end_layout

\begin_layout Plain Layout

  (a * DF2$Q[i] + (1 - a) * DF2$TsQ[i] - y) / (Rate * tau1)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

# DF2$TsQ <- rk4.integrate (fS, DF2$Q[1], 1:nrow(DF2))
\end_layout

\begin_layout Plain Layout

# DF2$Qp <- rk4.integrate (fM, DF2$Q[1], 1:nrow(DF2))
\end_layout

\begin_layout Plain Layout

DF2$QF <- as.vector(signal::filter(AR, DF2$Q))
\end_layout

\begin_layout Plain Layout

DF2$QF <- ShiftInTime(DF2$QF, .shift=-Lshift * 40, .rate=25)
\end_layout

\begin_layout Plain Layout

## Find the measured recovery temperature Tm responding to RT
\end_layout

\begin_layout Plain Layout

fS <- function(y, i) {
\end_layout

\begin_layout Plain Layout

  (DF2$RT[i] - y) / (Rate * tau2)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

fM <- function (y, i) {
\end_layout

\begin_layout Plain Layout

  (a * DF2$RT[i] + (1 - a) * DF2$Ts[i] - y) / (Rate * tau1)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

# DF2$Ts <- rk4.integrate (fS, DF2$RT[1], 1:nrow(DF2))
\end_layout

\begin_layout Plain Layout

# DF2$Tm <- rk4.integrate (fM, DF2$RT[1], tv = 1:nrow(DF2))
\end_layout

\begin_layout Plain Layout

# DF2$Tm <- rk4.integrate (fM, DF2$RT[1], 1:nrow(DF2))
\end_layout

\begin_layout Plain Layout

DF2$TF <- as.vector(signal::filter(AR, DF2$RT))
\end_layout

\begin_layout Plain Layout

DF2$TF <- ShiftInTime(DF2$TF, .shift=-Lshift * 40, .rate=25) ## The simulated
 measurement
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# DF2$ATm <-
\end_layout

\begin_layout Plain Layout

  # DF2$Tm - DF2$Q  ## The erroneous measured ambient temperature
\end_layout

\begin_layout Plain Layout

# DF2$ATM <-
\end_layout

\begin_layout Plain Layout

  # DF2$Tm - DF2$Qp  # and application of the corrected dynamic-heating
\end_layout

\begin_layout Plain Layout

DF2$ATF <- 
\end_layout

\begin_layout Plain Layout

  DF2$TF - DF2$QF  # Subtract the filtered version
\end_layout

\begin_layout Plain Layout

SF <- 100 * 850 / (287 * 283) * 1005
\end_layout

\begin_layout Plain Layout

A <- flux(    ## This is the 
\begin_inset Quotes eld
\end_inset

true
\begin_inset Quotes erd
\end_inset

 flux
\end_layout

\begin_layout Plain Layout

  DF2,
\end_layout

\begin_layout Plain Layout

  'T',
\end_layout

\begin_layout Plain Layout

  Units = bquote("W" ~ m ^ -2),
\end_layout

\begin_layout Plain Layout

  smoothBins = 100,
\end_layout

\begin_layout Plain Layout

  scaleFactor = rep(SF, nrow(DF2)),
\end_layout

\begin_layout Plain Layout

  wavelengthLimit = 2500,
\end_layout

\begin_layout Plain Layout

  .plot = FALSE
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Application of corrections
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<simF, include=TRUE, fig.height=4, fig.cap=c('The cospectrum for the flux
 of sensible heat for the simulated data generated as described in the text.
 Three 10-min segments of simulated 25 Hz data, with 0.3 correlation coefficient
 between fluctuations in temperature and updraft and the correlated fluctuations
 in temperature scaled to have amplitude 20
\backslash

\backslash
% of those in updraft.','The cospectrum for the flux of sensible heat for
 the simulated measurement of a realistic sensor (here, the unheated Rosemount
 102E4AL sensor) with the revised dynamic-heating correction ($Q^
\backslash

\backslash
prime$) and the measurement calculated by applying the digital filter from
 Part 2 to the assumed recovery-temperature history as simulated.
 The correction procedure from Sect.
 1.2 was used to estimate the corrected flux shown as the plotted spectrum
 and the solid brown exceedance distribution.
 The dashed exceedance line is the uncorrected result, for which the contributio
ns from frequencies above 1 Hz are only 3.4 W m$^{-2}$ vs.
\backslash

\backslash
 5.9 W m$^{-2}$ for the cospectrum as generated.')>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# A <- flux(
\end_layout

\begin_layout Plain Layout

#   DF2,
\end_layout

\begin_layout Plain Layout

#   'ATF',
\end_layout

\begin_layout Plain Layout

#   Units = bquote("W" ~ m ^ -2),
\end_layout

\begin_layout Plain Layout

#   smoothBins = 100,
\end_layout

\begin_layout Plain Layout

#   scaleFactor = rep(SF, nrow(DF2)),
\end_layout

\begin_layout Plain Layout

#   wavelengthLimit = 2500
\end_layout

\begin_layout Plain Layout

# )
\end_layout

\begin_layout Plain Layout

AF <- flux(
\end_layout

\begin_layout Plain Layout

  DF2,
\end_layout

\begin_layout Plain Layout

  'ATF',
\end_layout

\begin_layout Plain Layout

  Units = bquote("W" ~ m ^ -2),
\end_layout

\begin_layout Plain Layout

  smoothBins = 100,
\end_layout

\begin_layout Plain Layout

  scaleFactor = rep(SF, nrow(DF2)),
\end_layout

\begin_layout Plain Layout

  Par = Param1,
\end_layout

\begin_layout Plain Layout

  .plot = FALSE,
\end_layout

\begin_layout Plain Layout

  wavelengthLimit = 2500
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

N <- 2^14   ## 16384 covers the 10-min (15000-pt) segments
\end_layout

\begin_layout Plain Layout

# Get the transfer function:
\end_layout

\begin_layout Plain Layout

a <- Param1$a
\end_layout

\begin_layout Plain Layout

tau1 <- Param1$tau1
\end_layout

\begin_layout Plain Layout

tau2 <- Param1$tau2
\end_layout

\begin_layout Plain Layout

df <- Rate / N
\end_layout

\begin_layout Plain Layout

frq <- c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
\end_layout

\begin_layout Plain Layout

H <- LTphase(frq, Param1)
\end_layout

\begin_layout Plain Layout

D <- DF2
\end_layout

\begin_layout Plain Layout

# D$RTF1 <- ShiftInTime(D$RTF1, .rate=25, .shift=40)
\end_layout

\begin_layout Plain Layout

# D$ATC <- ShiftInTime(D$ATC, .rate=25, .shift=0)
\end_layout

\begin_layout Plain Layout

# D$WIC <- ShiftInTime(D$WIC, .rate=25, .shift=-40)
\end_layout

\begin_layout Plain Layout

DX1 <- D %>% selectTime(500, 1500)
\end_layout

\begin_layout Plain Layout

DX2 <- D %>% selectTime(1500, 2500)
\end_layout

\begin_layout Plain Layout

DX3 <- D %>% selectTime(2500, 3500)
\end_layout

\begin_layout Plain Layout

CoSp <- rep(0, N)
\end_layout

\begin_layout Plain Layout

CoSpG <- rep(0, N)  ## cospectrum of generated T
\end_layout

\begin_layout Plain Layout

CoSpUC <- rep(0, N)
\end_layout

\begin_layout Plain Layout

.A <- 'ATF'
\end_layout

\begin_layout Plain Layout

.B <- 'TF'
\end_layout

\begin_layout Plain Layout

.C <- 'ATF'
\end_layout

\begin_layout Plain Layout

.D <- 'T'
\end_layout

\begin_layout Plain Layout

DCF <- data.frame()
\end_layout

\begin_layout Plain Layout

for (.data in list(DX1, DX2, DX3)) {
\end_layout

\begin_layout Plain Layout

  N1 <- (N - nrow(.data)) %/% 2
\end_layout

\begin_layout Plain Layout

  N2 <- N - nrow(.data) - N1
\end_layout

\begin_layout Plain Layout

  WP <- c(rep(0, N1), detrend(.data[, c('Time', 'WIC')]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  TP <- c(rep(0, N1), detrend(.data[, c('Time', .A)]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  TPB <- c(rep(0, N1), detrend(.data[, c('Time', .B)]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  TPuc <- c(rep(0, N1), detrend(.data[, c('Time', .C)]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  TPO <- c(rep(0, N1), detrend(.data[, c('Time', .D)]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  Q  <- c(rep(0, N1), detrend(.data[, c('Time', 'Q')]), rep(0, N2))
\end_layout

\begin_layout Plain Layout

  ff1 <- fft(TP)
\end_layout

\begin_layout Plain Layout

  ff1uc <- fft(TPuc)
\end_layout

\begin_layout Plain Layout

  ffb <- fft(TPB)
\end_layout

\begin_layout Plain Layout

  ffo <- fft(TPO)
\end_layout

\begin_layout Plain Layout

  ff2 <- fft(WP)
\end_layout

\begin_layout Plain Layout

  ffq <- fft(Q)
\end_layout

\begin_layout Plain Layout

  cs.G <- 2 * Re(ffo * Conj(ff2)) / (Rate * nrow(.data))
\end_layout

\begin_layout Plain Layout

  cs.orig <- 2 * Re(ff1uc * Conj(ff2)) / (Rate * nrow(.data))
\end_layout

\begin_layout Plain Layout

  # cs <- 2 * Re(ff1 * Conj(ff2)) / (Rate * N)
\end_layout

\begin_layout Plain Layout

  ## Estimate original recovery T and apply corrected dynamic heating:
\end_layout

\begin_layout Plain Layout

  cs <- 2 * Re((ffb / H - H * ffq) * Conj(ff2)) / (Rate * nrow(.data))
\end_layout

\begin_layout Plain Layout

  # cs <- 2 * Re((ffo) * Conj(ff2)) / (Rate * nrow(.data))
\end_layout

\begin_layout Plain Layout

  ## supercede with direct use of ATF:
\end_layout

\begin_layout Plain Layout

  cs <- 2 * Re((ff1uc / H) * Conj(ff2)) / (Rate * nrow(.data))
\end_layout

\begin_layout Plain Layout

  # cs <- 1/(Mod(H)*cos(Arg(H))) * 2 * Re((ff1uc) * Conj(ff2)) / (Rate *
 nrow(.data))
\end_layout

\begin_layout Plain Layout

  CoSp <- CoSp + cs
\end_layout

\begin_layout Plain Layout

  CoSpG <- CoSpG + cs.G
\end_layout

\begin_layout Plain Layout

  CoSpUC <- CoSpUC + cs.orig
\end_layout

\begin_layout Plain Layout

  DCF <- rbind(DCF, .data)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

Tasm <- mean(DCF$TASX, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

CoSp <- CoSp * scaleFactor / 3
\end_layout

\begin_layout Plain Layout

CoSpG <- CoSpG * scaleFactor / 3
\end_layout

\begin_layout Plain Layout

CoSpUC <- CoSpUC * scaleFactor / 3
\end_layout

\begin_layout Plain Layout

Nby2 <- N %/% 2
\end_layout

\begin_layout Plain Layout

CS <- data.frame(freq = frq[2:(Nby2+1)], cospec = CoSp[2:(Nby2+1)])
\end_layout

\begin_layout Plain Layout

CS.G <- data.frame(freq = frq[2:(Nby2+1)], cospec = CoSpG[2:(Nby2+1)])
\end_layout

\begin_layout Plain Layout

CS.orig <- data.frame(freq = frq[2:(Nby2+1)], cospec = CoSpUC[2:(Nby2+1)])
\end_layout

\begin_layout Plain Layout

CSogiveUC <- cumsum(CoSpUC[2:(Nby2+1)]) * CS$freq[1]
\end_layout

\begin_layout Plain Layout

CSogiveUC <- CSogiveUC[length(CSogiveUC)]-CSogiveUC
\end_layout

\begin_layout Plain Layout

CS.orig$ogive <- CSogiveUC
\end_layout

\begin_layout Plain Layout

wavelengthLimit <- 2500
\end_layout

\begin_layout Plain Layout

fL <- Tasm / wavelengthLimit
\end_layout

\begin_layout Plain Layout

ylim <- c(1.e-3, 800)
\end_layout

\begin_layout Plain Layout

CS.G <- plotCS(CS.G, Units, spans, fL, wavelengthLimit, smoothBins, 
\end_layout

\begin_layout Plain Layout

                   xlim, ylim, printTitle)
\end_layout

\begin_layout Plain Layout

CS.orig$ogive2 <- CS.G$ogive
\end_layout

\begin_layout Plain Layout

CS.corrected <- plotCS(CS, Units, spans, fL, wavelengthLimit, smoothBins,
 
\end_layout

\begin_layout Plain Layout

                   xlim, ylim, printTitle, CSprevious = CS.orig) 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure uncorrected measurement of temperature used to generate Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:simF2}
\end_layout

\end_inset

 results from digital filtering to correct the dynamic heating term but
 otherwise without correction based on the transfer function.
 To be specific:
\end_layout

\begin_layout Enumerate
A true recovery temperature 
\begin_inset Formula $T_{r}$
\end_inset

 was calculated by adding the dynamic-heating term 
\begin_inset Formula $Q$
\end_inset

 to the simulated air temperature 
\begin_inset Formula $T$
\end_inset

.
\end_layout

\begin_layout Enumerate
The digital filter for the unheated Rosemount sensor as determined from
 measurements on th GV, with response characteristics as listed in Table
 2 of Part 1, was applied to 
\begin_inset Formula $T_{r}$
\end_inset

 to obtain an estimate of the time series that would be measured, 
\begin_inset Formula $T_{m}$
\end_inset

.
\end_layout

\begin_layout Enumerate
The same digital filter was applied to the dynamic-heating term 
\begin_inset Formula $Q$
\end_inset

 to obtain an estimate of how the sensor should respond to that dynamic
 heating, denoted here as 
\begin_inset Formula $Q^{\prime}$
\end_inset

.
\end_layout

\begin_layout Enumerate
That estimate of the probe response to dynamic heating was subtracted from
 
\begin_inset Formula $T_{m}$
\end_inset

 to obtain a prediction of the air temperature that would be measured, 
\begin_inset Formula $T_{a}=T_{m}-Q^{\prime}$
\end_inset

.
\end_layout

\begin_layout Enumerate
The flux was then calculated from 
\begin_inset CommandInset ref
LatexCommand eqref
reference "eq:heatFlux-1"
plural "false"
caps "false"
noprefix "false"

\end_inset

 using 
\begin_inset Formula $T_{a}$
\end_inset

 and the simulated updraft.
 That produced the uncorrected flux characterized by the dashed brown line
 in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:simF2}
\end_layout

\end_inset

.
\end_layout

\begin_layout Enumerate
The correction procedure from Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Outline-correction"
plural "false"
caps "false"
noprefix "false"

\end_inset

 was then used to correct for the flux of sensible heat that would be missed
 because the temperature sensor does not respond instantly.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<fluxEx, include=FALSE, fig.cap='The exceedance functions for flux as functions
 of frequency, for the cospectra of the simulated variables for temperature
 and updraft and for the calculated cospectrum that would be measured after
 correction as described in Sect.
\backslash

\backslash
 5.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

dP <- data.frame(freq = A$freq, Flux = A$ogive, Measured = AF$ogive)
\end_layout

\begin_layout Plain Layout

g <- ggplot (data = dP, aes(x = freq))
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(aes(y = Flux, col = 'Simulated', 
\end_layout

\begin_layout Plain Layout

                       linetype = 'Simulated'), lwd = 1.5)
\end_layout

\begin_layout Plain Layout

g <- g + geom_path(aes(y = Measured, col = 'Corrected Measurement',
\end_layout

\begin_layout Plain Layout

                       linetype = 'Corrected Measurement'))
\end_layout

\begin_layout Plain Layout

g <- g + xlab('frequency [Hz]') + 
\end_layout

\begin_layout Plain Layout

         ylab(bquote('Flux Exceedance [W' ~ m ^ -2 ~ ']'))
\end_layout

\begin_layout Plain Layout

g <- g + scale_x_log10(breaks = trans_breaks("log10", 
\end_layout

\begin_layout Plain Layout

         function(x) 10^x, n=4),
\end_layout

\begin_layout Plain Layout

         labels = trans_format("log10", math_format(expr = 10^.x)))
\end_layout

\begin_layout Plain Layout

g <- g + scale_y_log10(breaks = trans_breaks("log10", 
\end_layout

\begin_layout Plain Layout

         function(x) 10^x, n=4),
\end_layout

\begin_layout Plain Layout

         labels = trans_format("log10", math_format(expr = 10^.x)))
\end_layout

\begin_layout Plain Layout

g <- g + coord_cartesian(xlim=c(0.01, 15))  
\end_layout

\begin_layout Plain Layout

g <- g + annotation_logticks(sides='trbl')
\end_layout

\begin_layout Plain Layout

g <- suppressWarnings(g + scale_colour_manual (name='', 
\end_layout

\begin_layout Plain Layout

                      values=c('Simulated'='blue', 
\end_layout

\begin_layout Plain Layout

                               'Corrected Measurement'='forestgreen')))
\end_layout

\begin_layout Plain Layout

g <- g + scale_linetype_manual (name='', values=c('Simulated' = 4,
\end_layout

\begin_layout Plain Layout

                                            'Corrected Measurement' = 1))
\end_layout

\begin_layout Plain Layout

g <- g + theme_WAC(1)
\end_layout

\begin_layout Plain Layout

suppressWarnings(print(g + theme_WAC(1) + 
\end_layout

\begin_layout Plain Layout

                       theme(legend.position=c(0.3, 0.7))))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The result was remarkable consistency between the generated flux (39.8
\begin_inset space ~
\end_inset

W
\begin_inset space \thinspace{}
\end_inset

m
\begin_inset Formula $^{-2}$
\end_inset

) shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:simF1}
\end_layout

\end_inset

 and the flux estimated after the correction procedure (40.6
\begin_inset space ~
\end_inset

W
\begin_inset space \thinspace{}
\end_inset

m
\begin_inset Formula $^{-2}$
\end_inset

) as shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:simF2}
\end_layout

\end_inset

.
 The representation of the high-frequency contribution is improved significantly
 by the correction procedure, and the exceedance distributions are almost
 identical for the generated and corrected cospectra, as shown by the agreement
 between the corrected exceedance distribution (solid brown line) and the
 generated exceedance distribution (dashed green line) in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:simF2}
\end_layout

\end_inset

.
 Thus, the simulation supports both the correction procedure from Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Outline-correction"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and the proposed treatment of dynamic heating in Part 2.
 Of course, this does not demonstrate that the fitted transfer function
 is correct as determined in this document, only that the use of that transfer
 function and the digital filter derived from it are consistent.
\end_layout

\begin_layout Section
Reproducibility
\end_layout

\begin_layout Standard
\begin_inset Index idx
status open

\begin_layout Plain Layout
reproducibility
\end_layout

\end_inset

This document is constructed in ways that support duplication of the study.
 The code that generates the plots and implements the correction procedure
 is incorporated into the same 
\begin_inset Index idx
status open

\begin_layout Plain Layout
program!file
\end_layout

\end_inset

file that generated this document via 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
LaTeX
\end_layout

\end_inset

, using principles and techniques described by 
\begin_inset CommandInset citation
LatexCommand citet
key "Xie2014a"
literal "true"

\end_inset

 as implemented in the R 
\begin_inset Index idx
status open

\begin_layout Plain Layout
R language!package!knitr
\end_layout

\end_inset

package
\begin_inset Index idx
status open

\begin_layout Plain Layout
knitr
\end_layout

\end_inset

 'knitr' (
\begin_inset CommandInset citation
LatexCommand citet
key "Xie2014b"
literal "true"

\end_inset

).
 The program, 'SensibleHeatFluxPaper1.Rnw', is archived on 'GitHub' 
\begin_inset Index idx
status open

\begin_layout Plain Layout
GitHub repository
\end_layout

\end_inset

in the 
\begin_inset Index idx
status open

\begin_layout Plain Layout
repository!github
\end_layout

\end_inset

directory
\begin_inset Index idx
status open

\begin_layout Plain Layout
archive!for this document
\end_layout

\end_inset

 at 
\begin_inset CommandInset href
LatexCommand href
name "this URL"
target "https://github.com/WilliamCooper/KalmanFilter.git"
literal "false"

\end_inset

.
 There is some 
\begin_inset Index idx
status open

\begin_layout Plain Layout
supplemental material
\end_layout

\end_inset

supplemental material in that directory, including the workflow document
\begin_inset Index idx
status open

\begin_layout Plain Layout
workflow document
\end_layout

\end_inset

, the bibliography and some code segments saved in the 
\begin_inset Quotes eld
\end_inset

chunks
\begin_inset Quotes erd
\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
R language!program chunks
\end_layout

\end_inset

 subdirectory, so the full directory should be downloaded in order to run
 the program.
 The calculations use the programming 
\begin_inset Index idx
status open

\begin_layout Plain Layout
R language
\end_layout

\end_inset

language 
\begin_inset Index idx
status open

\begin_layout Plain Layout
R language!program
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
RStudio
\end_layout

\end_inset

R (
\begin_inset CommandInset citation
LatexCommand citet
key "Rlanguage"
literal "true"

\end_inset

) and were run within 
\begin_inset Index idx
status open

\begin_layout Plain Layout
RStudio
\end_layout

\end_inset

RStudio (
\begin_inset CommandInset citation
LatexCommand citet
key "RStudio2012"
literal "true"

\end_inset

), so this is the most straightforward way to replicate the calculations
 and the generation of this 
\begin_inset Index idx
status open

\begin_layout Plain Layout
program!generating this document
\end_layout

\end_inset

document.
\end_layout

\begin_layout Standard
A 
\begin_inset Index idx
status open

\begin_layout Plain Layout
R language!package!Ranadu
\end_layout

\end_inset

package named Ranadu,
\begin_inset Index idx
status open

\begin_layout Plain Layout
R language!package!Ranadu
\end_layout

\end_inset

 containing auxillary 
\begin_inset Index idx
status open

\begin_layout Plain Layout
function!Ranadu
\end_layout

\end_inset

functions, is used extensively in the R code.
 It is available on GitHub
\begin_inset Index idx
status open

\begin_layout Plain Layout
GitHub repository
\end_layout

\end_inset

 as 
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/WilliamCooper/Ranadu.git"
literal "false"

\end_inset

.
 The version used for calculations in this technical note is included in
 the 'zip' archive listed below.
\end_layout

\begin_layout Standard
The 
\begin_inset Index idx
status open

\begin_layout Plain Layout
file!data
\end_layout

\end_inset

data files used are also preserved in the NCAR/EOL Data Archives and can
 be obtained via a 
\begin_inset Index idx
status open

\begin_layout Plain Layout
data!requesting
\end_layout

\end_inset

request to 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

mailto:raf-dm@eol.ucar.edu
\end_layout

\end_inset

 or via the 
\begin_inset Quotes eld
\end_inset

Data Access
\begin_inset Quotes erd
\end_inset

 links at 
\begin_inset CommandInset href
LatexCommand href
name "this web site"
target "https://www.eol.ucar.edu/all-field-projects-and-deployments"
literal "false"

\end_inset

.
 The original files containing the data as produced by the NCAR Earth Observing
 Laboratory, Research Aviation Facility, were in 
\begin_inset Index idx
status open

\begin_layout Plain Layout
netCDF format
\end_layout

\end_inset

netCDF format (cf.
\begin_inset space ~
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "this URL"
target "http://www.unidata.ucar.edu/software/netcdf/"
literal "false"

\end_inset

), but in many cases data archives were reprocessed and the files may change
 after reprocessing so a separate archive
\begin_inset Index idx
status open

\begin_layout Plain Layout
archive!for this document!data
\end_layout

\end_inset

 is maintained for this document.
 The data files
\begin_inset Index idx
status open

\begin_layout Plain Layout
file!data!archive
\end_layout

\end_inset

 in this archive contain 
\begin_inset Index idx
status open

\begin_layout Plain Layout
R language!data.frames
\end_layout

\end_inset

R data.frames and are preserved as binary-format 'Rdata' files via R 'save'
 commands.
 The code in the GitHub archive has appropriate 'load' commands to read
 these data files from a subdirectory named 'Data' (/Data or ~/Data or /home/Dat
a) but this is not part of the GitHub repository because it is too large
 to be appropriate there.
 To reproduce this research, those data files have to be transferred separately
 from {??where??}
\end_layout

\begin_layout Standard
Extensive use has been made of 
\begin_inset Index idx
status open

\begin_layout Plain Layout
attributes!data.frame
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
attributes!variable
\end_layout

\end_inset

attributes assigned to the data.frames and the variables in those data.frames.
 All the attributes from the original netCDF 
\begin_inset Index idx
status open

\begin_layout Plain Layout
file!netCDF
\end_layout

\end_inset

files have been transferred, so there is a record of how the original data
 were processed, for example recording 
\begin_inset Index idx
status open

\begin_layout Plain Layout
calibration!coefficients!used in processing
\end_layout

\end_inset

calibration coefficients and processing chains for the variables.
 Once the data.frames are loaded into R, these attributes can be viewed and
 provide additional documentation of what data were used.
 Key information like the processing date, the program version that produced
 the archive, and the selection of primary variables for various measurements
 thus is preserved.
\end_layout

\begin_layout Standard
(See the related list of project components on the next page that are preserved
 to enhance reproducibility.)
\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Project:
\family default
\shape default
\color inherit
 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SensibleHeatFlux
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Archive package:
\family default
\shape default
\color inherit
 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "SensibleHeatFluxPaper3.zip"
target "https://github.com/WilliamCooper/SensibleHeatFlux/blob/master/SensibleHeatFluxPaper3.zip"
literal "false"

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Contains:
\family default
\shape default
\color inherit
 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
attachment list below
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Program:
\family default
\shape default
\color inherit
 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "SensibleHeatFluxPaper3.Rnw"
target "https://github.com/WilliamCooper/SensibleHeatFlux/blob/master/SensibleHeatFluxPaper3.Rnw"
literal "false"

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Original Data:
\family default
\shape default
\color inherit
 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset CommandInset citation
LatexCommand citet
key "VOCALS2011"
literal "false"

\end_inset

, 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset CommandInset citation
LatexCommand citet
key "SOCRATES2019"
literal "false"

\end_inset

,
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset CommandInset citation
LatexCommand citet
key "CSET2017"
literal "false"

\end_inset

 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Special Data Files:
\family default
\shape default
\color inherit
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SensibleHeatFluxTechNote.Rdata, SensibleHeatFluxTechNote2.Rdata
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Workflow Document:
\family default
\shape default
\color inherit
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "WorkflowSensibleHeatFluxPaper3.pdf"
target "https://github.com/WilliamCooper/SensibleHeatFlux/blob/master/WorkflowSensibleHeatFluxPaper3.pdf"
literal "false"

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Git:
\family default
\shape default
\color inherit
 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Index idx
status open

\begin_layout Plain Layout
GitHub repository
\end_layout

\end_inset


\begin_inset CommandInset href
LatexCommand href
name "https://github.com/WilliamCooper/SensibleHeatFlux.git"
target "https://github.com/WilliamCooper/SensibleHeatFlux.git"
literal "false"

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
attachm{
\end_layout

\end_inset

SensibleHeatFluxPaper3.Rnw
\begin_inset Newline newline
\end_inset

SensibleHeatFluxPaper3.pdf
\begin_inset Newline newline
\end_inset

WorkflowSensibleHeatFluxPaper3.pdf
\begin_inset Newline newline
\end_inset

WAC.bib
\begin_inset Newline newline
\end_inset

chunks/*
\begin_inset Newline newline
\end_inset

SessionInfo
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\begin_layout Plain Layout


\backslash
phantomsection 
\backslash
addcontentsline{toc}{section}{List of Symbols}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset index_print
LatexCommand printindex
type "lis"
name "List of Symbols"
literal "true"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\begin_layout Plain Layout


\backslash
phantomsection 
\backslash
addcontentsline{toc}{section}{Variable Names and Acronyms}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset index_print
LatexCommand printindex
type "var"
name "Variable Names and Acronyms"
literal "true"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Variable Names
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\begin_layout Plain Layout


\backslash
phantomsection 
\backslash
addcontentsline{toc}{section}{Index}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
** indicates that many similar entries are omitted.
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset CommandInset index_print
LatexCommand printindex
type "idx"
name "Index"
literal "true"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\begin_layout Plain Layout

%
\backslash
phantomsection 
\backslash
addcontentsline{toc}{section}{References}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:bibliography"

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "/home/cooperw/RStudio/WAC"
options "bibtotoc,plainnat"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% 
\backslash
centerline{-- Blank Page, End of this Technical Report --}
\end_layout

\begin_layout Plain Layout

% 
\backslash
vfill
\backslash
eject
\end_layout

\begin_layout Plain Layout

% 
\backslash
clearpage
\end_layout

\begin_layout Plain Layout

%
\backslash
addcontentsline{toc}{section}{End}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<make-zip-archive, INCLUDE=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

system (sprintf("zip KalmanFilterTechNote.zip KalmanFilterTechNote.Rnw KalmanFilte
rTechNote.pdf WorkflowKalmanFilter.pdf WAC.bib ./chunks/* SessionInfo"))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@ 
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
