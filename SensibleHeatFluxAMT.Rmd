---
title: On Measuring Sensible-Heat Flux With Airborne Thermometers
journal: "`r rticles::copernicus_journal_abbreviations(journal_name = 'Atmospheric Measurement Techniques')`"
author:
  - given_name: William
    surname: Cooper
    affiliation: 1
    email: cooperw@ucar.edu
    corresponding: true
  - given_name: Adriana
    surname: Bailey
    affiliation: 1
    email: abailey@ucar.edu
  - given_name: Joshua
    surname: Carnes
    affiliation: 1
    email: jcarnes@ucar.edu
# If you have more than one corresponding author, add them manually using the following structure:
# Two authors: \correspondence{Daniel Nüst (daniel.nuest@uni-muenster.de) and Josiah Carberry (j.carberry@orcid.org)}
# Three authors or more: \correspondence{Daniel Nüst (daniel.nuest@uni-muenster.de), Josiah Carberry j.carberry@orcid.org), and Markus Konkol (m.konkol@wwu.de)}
# If the following line is uncommented, the "corresponding: true" above are ignored
#correspongdingauthors: Daniel Nüst (daniel.nuest@uni-muenster.de) and Josiah Carberry (j.carberry@orcid.org)
affiliation:
  - code: 1
    address: Earth Observing Laboratory, National Center for Atmospheric Research 80307-3000 Boulder, CO, United States
abstract: |
  Most measurements of temperature from research aircraft rely 
  on sensors that have inadequate response for demanding applications,
  including especially measuring the flux density of
  sensible heat. In order to improve that measurement, this paper 
  uses in-flight measurements to determine the frequency-domain
  transfer function that 
  characterizes the time response of standard airborne temperature 
  sensors. 
  Those thermometers sense the
  "recovery temperature" produced when air is compressed on 
  approach to the sensor. The change in temperature produced by 
  that compression, termed "dynamic heating" in this paper, 
  fluctuates as the airspeed changes, and those changes in
  airspeed are measured so the expected fluctuations in
  recovery temperature are known. 
  In this study, flight segments were used where such turbulent
  fluctuations were the dominant cause of fluctuations in the
  recovery temperature so that the sensor response could be used
  to find the transfer function.
  <!-- Suggested differential equations for the response are consistent with -->
  <!-- the observed transfer function, and the observations constrain the -->
  <!-- parameters in those equations with low uncertainty.  -->
  Examples
  and a simulation illustrate that, without correction, measurements
  of sensible-heat flux with a standard sensor can be more than 30\%
  too low, while the proposed correction procedure removes this error.
  <!-- and results in reliable measurements with only minor error -->
  <!-- attributable to the response time of the sensor. An additional  -->
  An additional
  result of the study is the identification of a source of error,
  prevalent in most archived temperature measurements from research
  aircraft, that results when conventional treatments of dynamic
  heating do not take into account the time response of the sensor.  
bibliography: WAC.bib
running:
  title: Measuring Sensible-Heat Flux
  author: Cooper
competinginterests: |
  The authors declare no competing interests.
# OPTIONAL:
algorithms: true
# See https://publications.copernicus.org/for_authors/licence_and_copyright.html, normally used for transferring the copyright, if needed.
availability:
  #  use this to add a statement when having only software code available
  #  use this to add a statement when having only data sets available
  #code: |
  #data: |
  codedata: |
    The data files used in this analysis are curated as indicated by
    the following references and are publicly available. They can be requested
    from the National Center for Atmospheric Research, Earth Observing
    Laboratory, at this web site:
    \href{https://data.eol.ucar.edu}{https://data.eol.ucar.edu}.
    The files with references are as follows:
    \begin{center}
    \begin{tabular}{|c|c|}
    \hline 
    Research Project & Citation (see References)\tabularnewline
    \hline 
    \hline 
    VOCALS & \citet{VOCALS2011}\tabularnewline
    \hline 
    CSET & \citet{CSET2017}\tabularnewline
    \hline 
    SOCRATES & \citet{SOCRATES2019}\tabularnewline
    \hline 
    \end{tabular}
    \par\end{center}
    
    This document is constructed in ways that support duplication of the
    study. The code that generates the plots and implements the correction
    procedure is incorporated into the same file that generated this document
    via \LaTeX, using principles and techniques described by @Xie2014a
    as implemented in the R package "knitr" [@Xie2014b]. The
    program, "SensibleHeatFluxAMT.Rmd" is archived on "GitHub"
    in the directory at
    \href{https://github.com/WilliamCooper/SensibleHeatFlux.git}{this URL}.
    There is some supplemental material in that directory, including a
    workflow document and some code segments saved in
    the "chunks" subdirectory. The full directory should be downloaded
    in order to run the program. The calculations use the programming
    language R [@Rlanguage] and were run within RStudio [@RStudio2012].
    A package named Ranadu [@Ranadu2.6],
    containing auxillary functions, was used extensively in the R code
    and can be downloaded from that reference.
authorcontribution: |
  The first author wrote the processing code and developed the general
  idea for the paper. The second author contributed
  significantly to the manuscript and the presentation, and the third
  author provided Laplace-transform solutions and a digital filter based
  on them while also contributing to the presentation. 
acknowledgements: |
  This material is based upon work supported by the National Center
  for Atmospheric Research, which is a major facility sponsored by the
  National Science Foundation under Cooperative Agreement No. 1852977.
  Data provided by NCAR/EOL under the sponsorship of the National 
  Science Foundation. (https://data.eol.ucar.edu/)
  Measurements used here (\citet{VOCALS2011}, \citet{SOCRATES2019},
  \citet{WECAN2018}) were collected in research projects
  (\citet{wood2011vamos},
  \citet{albrecht2019CSET}, \citet{mcfarquhar2014southern}) that used
  the NSF/NCAR research aircraft. Project descriptions and additional
  The referenced project teams conducted the experiments, with flight
  operations, data acquisition and processing, and other project support
  by the Research Aviation Facility, Earth Observing Laboratory, National
  Center for Atmospheric Research (NCAR). The analyses reported here
  were mostly performed using R (\citet{Rlanguage}), with RStudio
  (\citet{RStudio2012})
  and knitr (\citet{Xie2014a,Xie2014b}). Data files in netCDF format
  have been read and written using the R package "ncdf4" cf.\ \citet{ncdf4}.
  Substantial use also was made of the "ggplot2" package (\citet{wickham2009})
  for R, and extensive use was made of the "stats" package, part
  of Core R\. Some of the numerical integrations used the Runge-Kutta
  function from the "rmutil" package (\citet{runge.kutta}).
  The Copernicus template provided by Daniel Nüst, which uses 
  the “rticles” package for R (\citet{rticles}), was used with "RMarkdown"
  (\citet{XieEtAl2018RMarkdown}) to
  generate this paper.
output:
  rticles::copernicus_article: default
  bookdown::pdf_book:
    base_format: rticles::copernicus_article # for using bookdown features like \@ref()
editor_options: 
  chunk_output_type: console
---

\introduction

<!-- header-includes: -->
<!--   - \usepackage[running]{lineno} -->
<!--   - \linenumbers -->
<!-- Introduction text goes here. You can change the name of the section if -->
<!-- neccessary using `\introduction[modified heading]`. -->
<!-- The following settings can or must be configured in the header of this file and -->
<!-- are bespoke for Copernicus manuscripts: -->
<!-- - The `journal` you are submitting to using the official abbreviation. You can -->
<!-- use the function `rticles::copernicus_journal_abbreviations(name = '...')` to -->
<!-- search the existing journals. -->
<!-- - Specific sections of the manuscript: -->
<!-- - `running` with `title` and `author` -->
<!-- - `competinginterests` -->
<!-- - `copyrightstatement` (optional) -->
<!-- - `availability` (strongly recommended if any used), one of `code`, `data`, or -->
<!-- `codedata` -->
<!-- - `authorcontribution` -->
<!-- - `disclaimer` -->
<!-- - `acknowledgements` -->
<!-- See the defaults and examples from the skeleton and the official Copernicus -->
<!-- documentation for details. -->
<!-- **Important**: Always double-check with the official manuscript preparation -->
<!-- guidelines at -->
<!-- [https://publications.copernicus.org/for_authors/manuscript_preparation.html](https://publications.copernicus.org/for_authors/manuscript_preparation.html), -->
<!-- especially the sections "Technical instructions for LaTeX" and "Manuscript -->
<!-- composition". Please contact Daniel Nüst, `daniel.nuest@uni-muenster.de`, with -->
<!-- any problems. -->
Research aircraft routinely measure air temperature, but standard
sensors do not respond fast enough to meet many scientific needs.
In particular, measurements of the flux of sensible heat require faster
response than is typically available, as do measurements of near-discontinuous
changes such as those at the top of boundary layers or at cloud boundaries.
The measurement of sensible-heat flux requires, for the standard eddy-correlation
measurement, that temperature be measured with sufficient response
to resolve the spectrum of contributions to the flux. 

The eddy-correlation measurement of the flux density of sensible heat ($F_{s}$) is evaluated from the mean value of this expression (c.f., e.g., @hartmann201695):
\begin{equation}
F_{s}=\rho_{a}\thinspace C_{p}\left\langle w^{\prime}T^{\prime}\right\rangle \label{eq:heatFlux}
\end{equation}
where $\rho_{a}$ is the density of air, $C_{p}$ the specific heat
of air at constant pressure, $w$ the vertical wind, and $T$ the
temperature. Primes in this equation denote fluctuations from the
mean and angle brackets denote an ensemble average. Additional
information regarding measuring fluxes by eddy correlation is contained in, e.g., \citet{lenschow95micro}. 

The measurement
thus depends on having a temperature sensor that can respond to the
range of fluctuations making significant contributions to the
flux. @FrieheKhelif1992 suggested that 4--5\unit{\,Hz} is "just
adequate" (for flight at around \unit{125\,m\,s^{-1}}) and that \unit{25\,Hz} would
be desirable. If the response of the temperature sensor is incomplete or
shifted in phase at a particular frequency, an error will be introduced
into the measurement of sensible-heat flux. To avoid significant
errors, it therefore is essential to characterize
the time response of the temperature sensor used and, where necessary,
to apply corrections to compensate for that response.


# Determining the Transfer Function \label{sec:theTransferFn}

The time response of an airborne thermometer can be characterized by
a frequency-domain transfer function that relates the 
measurement (the sensor output) to the measurand (the temperature). This section
presents the transfer functions for some standard sensors.
Two coupled differential equations with three parameters are proposed
as the basis for this characterization, but the frequency-domain 
transfer function
is determined independent of those equations. When the equations
predict a transfer function matching the observations, they provide
a useful generalization. Furthermore, the parameters in those equations 
can be constrained with low uncertainty
by fitting to the observed transfer functions. The transfer functions
then are used in the sections that follow to access how measurements
of temperature are affected.

Because airborne thermometers respond to the temperature of the air
after it is compressed upon entering the sensor housing,
the measurand is the "recovery temperature" ($T_{r}$), which
exceeds the ambient air temperature ($T_{a}$) by the amount of dynamic heating ($Q$):
\begin{equation}
T_{r}=T_{a}+Q\,\,\,.{\label{eq:recoveryTemperature}}
\end{equation}
The transfer functions determined in this section
apply to the recovery temperature rather than the calculated air temperature
after correction for dynamic heating. In this regard, this study differs
from earlier ones. The justification, developed in later sections, is that this approach is required so that the correction for dynamic heating can
be applied with proper treatment of the sensor response.

```{r initialization, echo=FALSE, include=FALSE}
## This chunk loads some needed R packages and defines a function
## used for the Laplace-transform solution of the governing
## differential equations.

# setwd('~/RStudio/SensibleHeatFlux')
source('chunks/initialize.R')
# source('chunks/theme_WAC.R')
# source('chunks/VSpec.R')
opts_chunk$set(fig.height = 3.5, digits = 3)
generateFigures = FALSE  ## set this TRUE to regenerate all figures;
                         ## with it FALSE, previously generated figures
                         ## are used. 
opts_chunk$set(cache = TRUE, cache.path = 'newcache/')
thisFileName <- "SensibleHeatFluxAMT"
library(rmutil)      ## provides the runge-kutta integration function
Directory <- DataDirectory ()
## standard values:
frq <- seq(0.01, 25, by = 0.01)
Phi <- rep(0, length(frq))
H <- rep(0, length(frq))
a <- 0.733 # 0.713
tau1 <- 0.0308  # 0.0335
tau2 <- 0.447
# The Laplace-transform solution, given the parameters in P:
LTphase <- function(f, P) {
  ## f=frequency; P=Param
  tau1 <- P$tau1
  tau2 <- P$tau2
  a <- P$a
  b <- sqrt(1 / (1 + (2 * pi * f * tau2) ^ 2))
  zeta <- -atan(2 * pi * f * tau2)
  C1 <- 1 / (1 + 4 * pi ^ 2 * f ^ 2 * tau1 ^ 2) *
    (-(a + (1 - a) * b * cos(zeta)) * 2 * pi * f * tau1 +
       (1 - a) * b * sin(zeta))
  C2 <- 1 / (1 + 4 * pi ^ 2 * f ^ 2 * tau1 ^ 2) *
    ((a + (1 - a) * b * cos(zeta)) +
       (1 - a) * b * sin(zeta) * 2 * pi * f * tau1)
  cTF <- sqrt(C1 ^ 2 + C2 ^ 2)
  phiTF <- atan2(C1, C2) * 180 / pi
  return(list('Amp' = cTF, 'Phase' = phiTF))
}

```

## Theory \label{subsec:Theory}

Previous studies have demonstrated that a simple first-order exponential
equation with one time constant does not represent the time response
of airborne temperature sensors. The suggested explanation [@NCAR_OpenSky_TECH-NOTE-000-000-000-064]
is that heat is transferred to the sensing wire of standard sensors
not only from the air but also from the supporting structure that
is in contact with the wire. @FrieheKhelif1992,
following other prior work including that of @rodi1972analysis
and @mccarthy1973method, suggested representing the
response with two time constants:
\begin{equation}\Theta(t)=A_{1}e^{-t/\tau_{1}}+A_{2}e^{-t/\tau_{2}}{\label{eq:FrieheKhelif}}\end{equation}
where $\Theta(t)$ is the normalized history of the measured temperature
decaying from an initial value of one to a final value of zero.
The sum of the coefficients $A_{1}$ and $A_{2}$ must then be one.
The values for \{$A_{1},\,A_{2},\,\tau_{1},\,\tau_{2}$\} suggested
by @FrieheKhelif1992 were \{0.65, 0.35, \unit{0.09\,s}, \unit{0.5\,s}\}.

This work, following the approach of @PayneEtAl1994, represents the time response of the sensor by two coupled differential equations,
one that describes the response of the support on which
the sensing wire is wound to the air temperature and a second that
describes the response of the sensing wire to two inputs, one from
the support and one from the air. No attempt is made here to determine
the parameters from first principles as in @PayneEtAl1994,
however; instead, parameters entering the equations are determined
empirically. The equations are:
\begin{align}
\frac{dT_{s}(t)}{dt} & =\frac{T_{r}(t)-T_{s}(t)}{\tau_{2}}{\label{eq:Ts}} \\
\frac{dT_{m}(t)}{dt} & =\frac{a(T_{r}(t)-T_{m}(t))+(1-a)(T_{s}(t)-T_{m}(t))}{\tau_{1}}\\
& = \frac{\left\{ aT_{r}(t)+(1-a)T_{s}(t)\right\} -T_{m}(t)}{\tau_{1}}{\label{eq:Tm}}
\end{align}
where $T_{s}(t)$ is the temperature of the \uline{s}upport, $T_{m}(t)$
the \uline{m}easured temperature of the sensing wire, and $T_{r}(t)$
the true \uline{r}ecovery temperature that is the measurand. For
heat transfer to or from the wire, the parameter $a$ then represents
the fraction of the heat transferred by the air, while $(1-a)$ is
transferred to or from the support. The wire responds to the combined
transfers of heat with characteristic time constant $\tau_{1}$ while
the support structure responds to the air temperature more slowly,
with time constant $\tau_{2}$. It is straightforward to apply Eq.\ \eqref{eq:Ts}
and Eq.\ \eqref{eq:Tm} to changing but not necessarily discrete conditions,
so a general response to a given air-temperature history can be predicted
by numerical integration of these equations. Furthermore, the equations
are linear and, for constant values of the parameters, they are also
time-invariant (i.e., "LTI") descriptions of the response. As
a result, a particular signal for $T_{r}(t)$ can be decomposed into
its sinusoidal Fourier components and each will satisfy these equations
independently. 

The first equation does not involve the measurement,
so for a particular history of recovery temperature $T_{r}(t)$ the
support temperature can be determined solely by integration of Eq.\ \eqref{eq:Ts}.
Then, with $T_{s}(t)$ determined, Eq.\ \eqref{eq:Tm} can be integrated
to find the expected measurement $T_{m}(t)$ for a specified measurand
history $T_{r}(t)$. The inverse process, finding $T_{r}(t)$ from
the measurements $T_{m}(t)$, is also straightforward and only slightly
more complicated, as discussed in Appendix\ \ref{sec:Correcting-the-Temperature}. These equations have analytic solutions that are sinusoidal functions if the measurand is sinusoidal.
For example, if the
actual recovery temperature is $T_{r}(t)=\sin\omega t$ where $\omega$
is the angular frequency, then the solutions for $T_{s}(t)$ and $T_{m}(t)$
are given by the following equations:
\begin{align}
T_{s}(t)= & b\sin(\omega t+\zeta){\label{eq:TsSolved}} \\
T_{m}(t)= & c\sin(\omega t+\phi)=C_{1}\cos\omega t+C_{2}\sin\omega t{\label{eq:TmSolved}}
\end{align}
where $b=(1+\omega^2\tau_2^2)^{-1/2}$, \ $\zeta=-\arctan(\omega\tau_2)$, and
the amplitude and phase of the response are given by
\begin{align}
c= & \sqrt{C_{1}^{2}+C_{2}^{2}}{\label{eq:responseAmp}} \\
\phi= & \arctan(C_{1}/C_{2}){\label{eq:responsePhase}}
\end{align}
with
\begin{align}
C_{1}= & \frac{-\omega}{(1+\omega^{2}\tau_{1}^{2})}\left(\tau_{1}a+\frac{(1-a)(\tau_{1}+\tau_{2})}{(1+\omega^{2}\tau_{2}^{2})}\right){\label{eq:C1}} \\
C_{2}= & \left(\frac{1}{1+\omega^{2}\tau_{1}^{2}}\right)\left(a+\frac{(1-a)(1-\omega^{2}\tau_{1}\tau_{2})}{(1+\omega^{2}\tau_{2}^{2})}\right){\label{eq:C2}}
\end{align}

@mccarthy1973method used the derivative of the step-function
response (Eq.\ \eqref{eq:FrieheKhelif}) to find the impulse response function and, from its Fourier
transform, the sensor transfer function. That leads to the following
alternate expressions for $C_{1}$ and $C_{2}$:
\begin{align}
C_{1}= & -\omega\left(\frac{A_{1}\tau_{1}}{1+\omega^{2}\tau_{1}^{2}}+\frac{A_{2}\tau_{2}}{1+\omega^{2}\tau_{2}^{2}}\right){\label{eq:C1M}} \\
C_{2}= & \left(\frac{A_{1}}{1+\omega^{2}\tau_{1}^{2}}+\frac{A_{2}}{1+\omega^{2}\tau_{2}^{2}}\right){\label{eq:C2M}}
\end{align}
With $A_{2}=(1-a)/(1-\tau_{1}/\tau_{2})$ and $A_{1}=1-A_{2},$ these
are equivalent to the expressions for the same coefficients given by 
Eq.\ \eqref{eq:C1} and
Eq.\ \eqref{eq:C2}. This demonstrates that
Eq.\ \eqref{eq:Ts} and Eq.\ \eqref{eq:Tm} are consistent with the step-function response given by Eq.\ \eqref{eq:FrieheKhelif} and with the equations used by
@mccarthy1973method and @InverarityJTech2000, among
others.

The transfer function $H(\omega)=c(\omega)e^{i\phi(\omega)}$ then
characterizes how the sensor will respond to a unit-amplitude sine
wave with angular frequency $\omega=2\pi\nu$ where $\nu$ is the
frequency. For a particular set of parameters ($a$=`r round(a, 3)`,
$\tau_{1}$=`r round(tau1, 4)`\unit{\,s}, $\tau_{2}$=`r round(tau2, 3)`\unit{\,s}), characteristic of an unheated Rosemount
102E4AL sensor (hereafter called the "unheated sensor"),
the amplitude response and phase delay of the transfer function are
shown in Fig.\ \ref{fig:LTsolution}. Similar plots of the amplitude
(but not the phase) have been shown by @mccarthy1973method
and @nicholls1978measurements. Modified transfer functions
for two small changes to these parameters are also shown to illustrate
the sensitivity of the solution to these parameters. This figure illustrates
that serious errors will enter estimates of the sensible heat flux
if temperature fluctuations at frequencies above \unit{1\,Hz} make a significant
contribution to the flux. The contribution to the cospectrum of temperature
and vertical wind will be reduced by the product of the amplitude
and the cosine of the phase such that at \unit{10\,Hz} the error is about 86\%,
but even at \unit{1\,Hz} the error is about 28\%. 

\begin{figure}
```{r LTsolution, include = TRUE, fig.height = 4, out.width = "8.3cm"}

zeta <- -atan(2 * pi * frq * tau2)
b <- cos(zeta)
Param <- list(
  a = a,
  tau1 = tau1,
  tau2 = tau2,
  b = b,
  zeta = zeta,
  frq = frq
)
Param1 <- Param
Param3 <- Param
Param4 <- Param
Param3$tau1 <- 0.05
Param4$tau2 <- 0.6

## Use the Laplace-transform solution
H1 <- LTphase(frq, Param1)
cTF <- H1$Amp
phiTF <- H1$Phase
H3 <- LTphase(frq, Param3)
cTF3 <- H3$Amp
phiTF3 <- H3$Phase
H4 <- LTphase(frq, Param4)
cTF4 <- H4$Amp
phiTF4 <- H4$Phase
dfAP <- data.frame(
  'Time' = frq,
  'Amp' = cTF,
  'Amp3' = cTF3,
  'Amp4' = cTF4,
  'Phase' = phiTF,
  'Phase3' = phiTF3,
  'Phase4' = phiTF4
)
Panel2Label <- bquote('   Phase [' * degree ~ ']')
g <-
  ggplotWAC(
    dfAP,
    panels = 2,
    labelP = c(bquote('    ' ~ 'Amplitude'), Panel2Label),
    labelL = c('best', 't1=0.05', 't2=0.6'),
    lty = c(1, 1, 2)
  )
g <-
  g + xlab('frequency [Hz]') + ylab(bquote('transfer function H(' * nu ~ ')'))
g <-
  g + scale_x_log10(
    breaks = trans_breaks("log10", function(x)
      10 ^ x, n = 4),
    labels = trans_format("log10", math_format(expr = 10 ^ .x))
  ) + xlab('frequency [Hz]')
g <- g + annotation_logticks(sides = 'tb')
g <- g + theme_WAC(1) + theme(legend.position = c(0.3, 0.65))
suppressMessages(ggsave('figure/fig1.pdf', plot = g))
include_graphics('figure/fig1.pdf')

```
\caption{The amplitude and phase for the frequency-domain transfer function of an unheated temperature sensor. The parameters representing that sensor, labeled "best," are $a$=0.733, $\tau_1$=\unit{0.0308\,s} and $\tau_2$=\unit{0.447\,s}. To illustrate sensitivity,  the curves labeled "t1=0.05" and "t2=0.6" use instead $\tau_1$=\unit{0.05\,s} and $\tau_2$=\unit{0.6\,s}, respectively.\label{fig:LTsolution}}
\end{figure}

These equations and their solution provide a basis for correcting
either the measured temperature or the sensible-heat flux calculated
from the cospectrum in Eq.\ \eqref{eq:heatFlux}. Corrected values can
be obtained by several methods including integration of the equations
for the derivatives or by dividing the Fourier transform of the time
series by the transfer function and then using inverse Fourier transformation
to recover the corrected time series. Those correction schemes are
discussed in Appendix\ A. To support such corrections, the next section
determines the transfer function experimentally. 

## The response to dynamic heating\label{subsec:Dynamic-heating}

The evaluation of the time response that follows relies on the dynamic
heating produced by airspeed fluctuations. These fluctuations are often significantly
larger than real fluctuations in the ambient temperature. @BangeEtAl2013.ch2
(cf.\ their Eq.\ 2.23) give the relationship between dynamic heating ($Q$) and measurable quantities as the second equality in
the following equation:
\begin{equation}
Q=\alpha_{r}\frac{V^{2}}{2C_{p}}=T_{r}\left(\frac{\alpha_{r}M^{2}R_{a}/(2C_{v})}{1+\alpha_{r}M^{2}R_{a}/(2C_{v})}\right){\label{eq:DHterm}}
\end{equation}
where $\alpha_{r}$ is the "recovery factor" characterizing the
extent to which the air is brought to rest relative to the sensor,
$V$ is the airspeed, $C_{p}$ and $C_{v}$ are respectively the specific
heat of air at constant pressure and constant volume. $T_{r}$ is
the (true) recovery temperature expressed in absolute units, $M$
the Mach number, and $R_{a}$ the gas constant for air. 
Because dynamic heating can exceed \unit{20^{\circ}C} at jet-aircraft
flight speeds, it is often the dominant cause of fluctuations in the
recovery temperature. If the fluctuations in dynamic heating are higher
in frequency than those to which the sensor can respond, corresponding
fluctuations will be attenuated in the measured spectrum and the phase
of the measured response relative to the imposed signal will vary,
from near $0^{\circ}$ for fluctuations slow compared to sensor response
to near $90^{\circ}$ or even more for fluctuations fast compared
to that response. The amplitude and phase of the recovery temperature
relative to the dynamic-heating forcing therefore can be used as sensitive
indicators of the response characteristics of the sensor and can constrain
parameters like $a$, $\tau_{1}$ and $\tau_{2}$ that fit the 
differential equations
to the observations. The evaluation in terms of the amplitude ratio
and phase shift of the recovery temperature in response to dynamic
heating will be used to characterize the transfer function and to
determine if it is represented adequately by the parameterized form
given by Eq.\ \eqref{eq:responseAmp} and Eq.\ \eqref{eq:responsePhase}.

## Data sources

The present investigation uses measurements from two NSF/NCAR (National
Science Foundation / National Center for Atmospheric Research) research
aircraft, a Gulfstream V (hereafter, GV) and a Hercules C-130. The
temperature sensors producing the measurements are in widespread use
so these results should have broad applicability. Some aspects of
the uncertainty limits associated with these measurements of temperature
are included in an NCAR Technical Note [@Cooper2016ncartn], where it was
estimated that the standard uncertainty in measurements
of temperature from the GV is about \unit{0.3^{\circ}C}.
However, this estimate does not
apply when the temperature changes rapidly. @FrieheKhelif1992
and @LawsonRodi1992, among others, provide reviews of the
evidence for delayed response of the standard sensors. In particular,
the unheated sensor referenced above has been used widely as a fast-responding
sensor so it will be a focus of this study.

This research used the data archives of three research projects,
the VOCALS (VAMOS Ocean-Cloud-Atmosphere-Land Study), CSET (Cloud
Systems Evolution in the Trades) and SOCRATES (Southern Ocean Clouds,
Radiation, Aerosol Transport Experimental Study) experiments. Those
field projects, described by @wood2011vamos, @albrecht2019CSET
and @mcfarquhar2014southern respectively, each included low-level
flight segments in the boundary layer over the Pacific Ocean.

## Fits to the measurements

Because the airspeed $V$ is itself conventionally determined using
the processed air temperature $T_{a}$, via $V=M\sqrt{\gamma R_{a}T_{a}}$
where $\gamma=C_{p}/C_{v}$, the second expression in Eq.\ \eqref{eq:DHterm}
provides the advantage that it does not rely on prior calculation
of the air temperature $T_{a}$ but can be calculated from only the
recovery temperature $T_{r}$ and the Mach number. The Mach number
in turn depends only on measurements of the dynamic and ambient pressures,
with a small adjustment for the water vapor pressure. However, the
available measurement is not the true recovery temperature $T_{r}$
but instead the measured temperature $T_{m}$, which may not include
high-frequency fluctuations in $T_{r}$. This in turn affects the
estimated fluctuations determined from Eq.\ \eqref{eq:DHterm}. To minimize
this problem, regions were sought where the fluctuations in dynamic
heating were the dominant cause of fluctuations in recovery temperature.
Temporarily consider these approximations: $\alpha_{r}\approx1$,
$R_{a}/(2C_{v})\approx1/5$, and $M$ small enough that the denominator
of the right side of Eq.\ \eqref{eq:DHterm} can be assumed equal to unity.
Dynamic heating then is approximately $Q\approx T_{r}M^{2}/5$ and
fluctuations in $Q$ are related to those in $T_{r}$ and $M$ according
to
\begin{equation}
\frac{\delta Q}{Q}\approx\frac{\delta T_{r}}{T_{r}}+\frac{2}{5}\frac{\delta M}{M}{\label{eq:QprimeOverQ}}
\end{equation}
The measured phase and
amplitude of the response to the dynamic-heating term may be distorted
from the correct value at frequencies where $\delta T_{m}/T_{m}$
differs from $\delta T_{r}/T_{r}$. For a representative low-level 
flight segment with moderate turbulence
where the airspeed fluctuations were approximately consistent with
an eddy dissipation rate of \unit{3\times10^{-4}\,m^{2}\,s^{-3}},
the variance of the second term in Eq.\ \eqref{eq:QprimeOverQ} is more
than 100 times that of the first, indicating that the fluctuations
in the first term are less than 10\% of those in the second term.
Therefore the right side of Eq.\ \eqref{eq:DHterm} with $T_{m}$ in place
of $T_{r}$ was used initially to represent dynamic heating, and
flight segments were used where the fluctuations in the first term
were relatively small. Once
a set of parameters was determined, $T_{r}(t)$ was calculated using
the correction procedure discussed in 
Appendix\ \ref{sec:Correcting-the-Temperature}.
Using this revised estimate of $T_{r}(t)$ in place of $T_{m}(t)$
led to a small change in the fitted values of the parameters, but
the estimate was stable after only one iteration.

```{r TASX, include = FALSE, fig.height = 3.4, fig.cap = 'Spectral variance $P(\\nu)$ for airspeed ($V$) as a function of frequency $\\nu$ from a segment from VOCALS C-130 flight 3, 11:39:00 -- 11:52:00 UTC. The dotted orange lines show the spectral variance for various values of the eddy dissipation rate, with the heavy-dotted line representing $10^{-4}$ m$^2$ s$^{-3}$. The wavelength scale shows the correspondence between frequency and wavelength at the average airspeed.'}

reviseDH <-
  function (.data, P, alphaR) {
    # P is Param1, e.g.; alphaR is recovery factor
    .data$Q <- .data$TASX ^ 2 / 2010
    aV <- P$a
    tau1V <- P$tau1
    tau2V <- P$tau2
    Rate <- attr (.data, 'Rate')
    fS <- function(y, i) {
      (.data$Q[i] - y) / (tau2V * Rate)
    }
    fM <- function (y, i) {
      (aV * .data$Q[i] + (1 - aV) * TsQ[i] - y) / (Rate * tau1V)
    }
    TsQ <- rk4.integrate (fS, .data$Q[1], 1:nrow(.data))
    Qp <- rk4.integrate (fM, .data$Q[1], 1:nrow(.data))
    return (.data$ATX + alphaR * (.data$Q - Qp))
  }
if (file.exists ('./DVOCALS.Rdata')) {
  load (file = './DVOCALS.Rdata')
  DVOCALS <- D
} else {
  D <- getNetCDF(
    file.path(DataDirectory(), 'VOCALS/VOCALSrf03h.nc'),
    c(
      'TASX',
      'PALT',
      'TTRR',
      'ATRR',
      'TTWH',
      'WIC',
      'ATX',
      'PSXC',
      'QCXC'
    )
  )
  D$DH <- D$TASX ^ 2 / 2010
  ## For use later, "filter" the dynamic-heating term and revise the temperature:
  alphaR <- attr(D[, 'ATRR'], 'RecoveryFactor')
  D$AT <- reviseDH(D, Param1, alphaR)
  ## Find a corrected recovery temperature to use in the estimate of dynamic heating:
  a <- Param1$a
  tau1 <- Param1$tau1
  tau2 <- Param1$tau2
  ## RT is the working solution; Ts is the support temperature
  D$Ts <- D$TTRR
  Rate <- attr (D, 'Rate')
  D$DTMDT <-
    c(0, diff(D$TTRR, 2), 0) * Rate / 2  ## Average this and one-sample-advanced
  # D$DTMDT <- (D$DTMDT + c(0, D$DTMDT[1:(nrow(D)-1)])) / 2
  # DT$DTMDT <- as.vector (signal::filter(signal::sgolay(1, 3, m=1), DT$TTRR)) * Rate
  fS <- function(y, i) {
    # Eq. Ts3
    ((1 / a) * (tau1 * D$DTMDT[i] + D$TTRR[i] - (1 - a) * y) - y) / (Rate * tau2)
  }
  D$Ts <- rk4.integrate (fS, D$Ts[1], 1:nrow(D))
  D$RT <- (1 / a) * (tau1 * D$DTMDT + D$TTRR - (1 - a) * D$Ts)
  # D %>% select(Time, TTRR, RT, Ts) %>% selectTime(114500, 114505) %>% plotWAC()
  save(D, file = './DVOCALS.Rdata')
  DVOCALS <- D
}
## Revise the calculation of dynamic heating to avoid dependence on AT:
D$MACH <- MachNumber(D$PSXC, D$QCXC)
XXA <- attr(D[, 'ATRR'], 'RecoveryFactor') * D$MACH ^ 2 / 5
D$DH <- (D$TTRR + 273.15) * XXA / (1 + XXA)
D$DH2 <- (D$RT + 273.15) * XXA / (1 + XXA)
## temporary: shift D$AT later in time
# D$AT <- ShiftInTime (D$AT, .rate=25, .shift=40)
Tasm <- mean(D$TASX, na.rm = TRUE)
DT <- D %>% selectTime(113900, 115200)
## Save it for use in the workflow document:
save(DT, file='DT.Rdata')
# select six boundary-layer segments of 10 min each:
DT1 <- D %>% selectTime(65000, 70000)
DT2 <- D %>% selectTime(73300, 74300)
DT3 <- D %>% selectTime(104600, 105600)
DT4 <- D %>% selectTime(114200, 115200)  ## 113900, 115200
DT5 <- D %>% selectTime(124300, 125300)
DT6 <- D %>% selectTime(133000, 134000)
DZV <- rbind(DT1, DT2, DT3, DT4, DT5, DT6)
rhozero <- 1013.25 * 100 / (287.05 * 288.15)
# omitting 832-841, 920-951, 955-1005 -- look problematic
# g <- VSpec(DT, 'TTRR', spans=99, xlim=c(0.01,15), ylim=c(1.e-5, 1.e-1))
# g <- VSpec(DT, 'ATRR', spans=99, add=g)
# VSpec(DT, 'DH', spans=99, add=g) + theme_WAC()
DT$V <- DT$TASX
VSpec(DT, 'V', VLabel='V=airspeed', spans = 99, ylim=c(1.e-3, 10)) + theme_WAC(1)

```

```{r extra2, include=FALSE, echo=FALSE}

## This is a special version with features not in the standard Ranadu version
CohP <-
  function (.data,
            .Var1,
            .Var2,
            col = 'blue',
            spans = 25,
            smoothBins = 50,
            plotType = 'ggplot',
            showErrors = 0,
            returnCospectrum = FALSE) {
    if (is.data.frame(.data)) {
      if (.Var1 %in% names(.data)) {
        Z <-
          capture.output (Vr <-
                            SmoothInterp(detrend (.data[, 
                              c('Time', .Var1)]), .Length = 0))
      } else {
        print(sprintf(
          'CohPhase ERROR: Variable %s is not in the supplied data.frame',
          .Var1
        ))
        return (NA)
      }
      if (.Var2 %in% names(.data)) {
        Z <-
          capture.output (VrC <-
                            SmoothInterp(detrend (.data[, 
                              c('Time', .Var2)]), .Length = 0))
      } else {
        print(sprintf(
          'CohPhase ERROR: Variable %s is not in the supplied data.frame',
          .Var2
        ))
        return (NA)
      }
    } else {
      print('CohPhase ERROR: first argument is not a data.frame.')
      return (NA)
    }
    if (is.null(attr(.data, 'Rate'))) {
      print ('CohPhase warning: Rate attribute missing from data.frame, so using Rate=1')
      Rate <- 1
    } else {
      Rate <- attr(.data, 'Rate')
    }
    vcv <- cbind(ts(Vr, frequency = Rate), ts(VrC, frequency = Rate))
    P <-
      spec.pgram(
        vcv,
        detrend = FALSE,
        fast = TRUE,
        plot = FALSE,
        spans = spans
      )
    df1 <- data.frame(P$coh, log(P$freq))
    df2 <- data.frame (P$phase, log(P$freq))
    df3 <- data.frame (P$spec[, 1], log(P$freq))
    df4 <- data.frame (P$spec[, 2], log(P$freq))
    pf1 <- binStats (df1, bins = smoothBins)
    pf2 <- binStats (df2, bins = smoothBins)
    pf3 <- binStats (df3, bins = smoothBins)
    pf4 <- binStats (df4, bins = smoothBins)
    pf1 <- pf1[!is.na (pf1$ybar), ]
    pf2 <- pf2[!is.na (pf2$ybar), ]
    pf3 <- pf3[!is.na (pf3$ybar), ]
    pf4 <- pf4[!is.na (pf4$ybar), ]
    # pf1$sigma[pf1$nb > 1] <- pf1$sigma[pf1$nb > 1] / sqrt(pf1$nb[pf1$nb > 2])
    pf1$sigma[pf1$nb <= 1] <- NA # pf1$ybar[pf1$nb <= 1] * 0.5
    # pf2$sigma[pf2$nb > 1] <- pf2$sigma[pf2$nb > 1] / sqrt(pf2$nb[pf2$nb > 2])
    pf2$sigma[pf2$nb <= 1] <- NA # pf2$ybar[pf2$nb <= 1] * 0.5is
    if (plotType != 'ggplot') {
      pf1 <- binStats (df1, bins = smoothBins, addBin = TRUE)
      pf2 <- binStats (df2, bins = smoothBins, addBin = TRUE)
      pf3 <- binStats (df3, bins = smoothBins, addBin = TRUE)
      pf4 <- binStats (df4, bins = smoothBins, addBin = TRUE)
      return(cbind(pf1, pf2, pf3, pf4)[, c(2, 1, 3, 4, 6, 7, 10)])
    } else {
      d2 <-
        data.frame(
          Time = exp(pf1$xc),
          coherence = pf1$ybar,
          phase = pf2$ybar * 180 / pi,
          clo = (pf1$ybar - showErrors * pf1$sigma),
          chi = pf1$ybar + showErrors * pf1$sigma,
          plo = (pf2$ybar - showErrors * pf2$sigma) * 180 / pi,
          phi = (pf2$ybar + showErrors * pf2$sigma) * 180 / pi
        )
      d2$clo[!is.na(d2$clo) & (d2$clo < 0)] <- 0
      labelP <- c('coherence', 'phase [degrees]')
      g <- ggplotWAC(
        d2[, c(1, 2, 3)],
        panels = 2,
        labelP = labelP,
        col = col,
        lwd = c(1.0),
        lty = c(1),
        xlab = 'freq'
      )
      g <-
        g + xlab('frequency [Hz]') + ylab (sprintf ('%s x %s', .Var1, .Var2))
      g <-
        g + scale_x_log10(
          breaks = trans_breaks("log10", function(x)
            10 ^ x, n = 4),
          labels = trans_format("log10", math_format(expr = 10 ^ .x))
        ) + xlab('frequency [Hz]')
      if (showErrors > 0 && smoothBins > 5) {
        da <- data.frame(d2[, c(1, 4, 5)])
        db <- data.frame(d2[, c(1, 6, 7)])
        names(da) <- c('Time', 'ymin', 'ymax')
        names(db) <- c('Time', 'ymin', 'ymax')
        da$PanelGroup <- labelP[1]
        db$PanelGroup <- labelP[2]
        d <- rbind(db, da)
        g <-
          g + geom_ribbon(
            data = d,
            aes(
              x = Time,
              ymin = ymin,
              ymax = ymax
            ),
            colour = 'grey',
            alpha = 0.15,
            inherit.aes = FALSE
          )
      }
      g <- g + theme_WAC(1) + theme(legend.position = 'none')
      if (returnCospectrum) {
        CS <-
          sqrt(P$coh[, 1] * P$spec[, 1] * P$spec[, 2] / (1 + tan(P$phase[, 1]) ^
                                                           2))
        v1 <- SmoothInterp(.data[, .Var1], .Length = 0)
        v2 <- SmoothInterp(.data[, .Var2], .Length = 0)
        v1 <- detrend(data.frame(Time = .data$Time, v1))
        v2 <- detrend(data.frame(Time = .data$Time, v2))
        ff1 <- fft(v1)
        ff2 <- fft(v2)
        G <- Re(ff1 * Conj(ff2)) / nrow(.data)
        GQ <- Im(ff1 * Conj(ff2)) / nrow(.data)
        N <- nrow(.data) %/% 2
        S1 <- Re(ff1 * Conj(ff1) / nrow(.data))
        S2 <- Re(ff2 * Conj(ff2) / nrow(.data))
        G <- G[2:(N + 1)]
        GQ <- GQ[2:(N + 1)]
        S1 <- S1[2:(N + 1)]
        S2 <- S2[2:(N + 1)]
        frq <- c(1:N) * Rate / nrow(.data)
        spec1 <- 2 * S1 / Rate
        spec2 <- 2 * S2 / Rate
        cospec <- 2 * G / Rate
        quad <- 2 * GQ / Rate
        # cospectrum - i * quadrature = (gain spectrum) * exp(i*(phase spectrum))
        # sqrt(cospectrum^2 + quadrature^2) is the amplitude or gain spectrum
        return(data.frame(
          freq = frq,
          cospec = cospec,
          quad = quad,
          spec1 = spec1,
          spec2 = spec2
        ))
      } else {
        return(g)
      }
    }
  }
RX <- CohPhase(DT, 'TTRR', 'DH', plotType = 'Ranadu')
SB <- 200
RXX <- CohPhase(DT1, 'TTRR', 'DH', plotType = 'Ranadu', smoothBins = SB)
Z <-
  capture.output (Vr <-
                    SmoothInterp(detrend (DT1[, c('Time', 'TTRR')]), .Length = 0))
Z <-
  capture.output (VrC <-
                    SmoothInterp(detrend (DT1[, c('Time', 'DH')]), .Length = 0))
Rate <- attr(DT1, 'Rate')
vcv <- cbind(ts(Vr, frequency = Rate), ts(VrC, frequency = Rate))
P <- spec.pgram(
  vcv,
  detrend = FALSE,
  fast = TRUE,
  plot = FALSE,
  spans = 25
)
df1 <- data.frame(P$coh, log(P$freq))
df2 <- data.frame (P$phase, log(P$freq))
pf1 <- binStats (df1, bins = SB)
pf2 <- binStats (df2, bins = SB)
## Use DH2 to get the time-response-corrected-RT Q
RX1 <- CohP(DT1, 'TTRR', 'DH', plotType = 'Ranadu', smoothBins = SB)
RX2 <- CohP(DT2, 'TTRR', 'DH', plotType = 'Ranadu', smoothBins = SB)
RX3 <- CohP(DT3, 'TTRR', 'DH', plotType = 'Ranadu', smoothBins = SB)
RX4 <- CohP(DT4, 'TTRR', 'DH', plotType = 'Ranadu', smoothBins = SB)
RX5 <- CohP(DT5, 'TTRR', 'DH', plotType = 'Ranadu', smoothBins = SB)
RX6 <- CohP(DT6, 'TTRR', 'DH', plotType = 'Ranadu', smoothBins = SB)
phase <- rep(0, SB)
nphase <- rep(0, SB)
phase2 <- rep(0, SB)
ar <- rep(0, SB)
ar2 <- rep(0, SB)
nar <- rep(0, SB)
for (RX in list(RX1, RX2, RX3, RX4, RX5, RX6)) {
  for (i in 2:nrow(RX)) {
    phase[RX$BIN.1[i]] <- phase[RX$BIN.1[i]] + RX$P.phase[i]
    nphase[RX$BIN.1[i]] <- nphase[RX$BIN.1[i]] + 1
    phase2[RX$BIN.1[i]] <- phase2[RX$BIN.1[i]] + RX$P.phase[i] ^ 2
    ar[RX$BIN.1[i]] <-
      ar[RX$BIN.1[i]] + sqrt(RX$P.spec...1.[i] / RX$P.spec...2.[i])
    ar2[RX$BIN.1[i]] <-
      ar2[RX$BIN.1[i]] + (RX$P.spec...1.[i] / RX$P.spec...2.[i])
    nar[RX$BIN.1[i]] <- nar[RX$BIN.1[i]] + 1
  }
}
nphase[nphase == 0] <- 1
nar[nar == 0] <- 1
mphase <- phase / nphase
mphase2 <- phase2 / nphase
sdp <- sqrt(mphase2 - mphase ^ 2)
mphase <- mphase * 180 / pi
sdp <- sdp * 180 / pi
sdp <- sdp * 2 / sqrt(nphase)
ar <- ar / nar
ar2 <- ar2 / nar
sdr <- sqrt(ar2 - ar ^ 2)
sdr <- sdr * 2 / sqrt(nar)


```

### An unheated temperature sensor\label{subsec:The-unheated-Rosemount}

\begin{table}[t]
\caption{Flight segments from flight 3 of the VOCALS project, 21 October 2008.}
%\begin{centering}
\begin{tabular}{|c|c|c|}
\hline 
\bf{Segment} & \bf{start [UTC]}& \bf{end [UTC]}\tabularnewline
\hline 
\hline 
1 & 6:50:00 & 7:00:00\tabularnewline
\hline 
2 & 7:33:00 & 7:43:00\tabularnewline
\hline 
3 & 10:46:00 & 10:56:00\tabularnewline
\hline 
4 & 11:42:00 & 11:52:00\tabularnewline
\hline 
5 & 12:43:00 & 12:53:00\tabularnewline
\hline 
6 & 13:30:00 & 13:40:00\tabularnewline
\hline 
\end{tabular}
%\par\end{centering}
\end{table}

To characterize the frequency-domain transfer function of the
unheated sensor, six
ten-minute flight segments in the marine boundary layer
from one flight of the NCAR/NSF C-130 in the "VOCALS" project
[@wood2011vamos] were selected that had similar flight conditions
including the intensity of turbulence. The time intervals are
listed in Table\ 1. For each flight segment, the phase and amplitude
ratio between the measurement and the dynamic heating term were calculated
and the results for all six segments were averaged in `r round(SB,0)`
logarithmically spaced intervals in frequency. The results for the
average phase are shown in Fig.\ \ref{fig:Vphase}a. The theoretical
curve is based on best-fit parameters as determined from these measurements
and those of the amplitude ratio, discussed next.

\begin{figure}
```{r Vphase, include=TRUE, echo=FALSE, fig.height = 4, out.width = "12cm"}

df <- data.frame(frq = exp(pf2$xc),
                 mphase = mphase,
                 sdp = sdp)
df <- df[df$frq > 0.01,]
df <- df[df$sdp > 0,]
df <- df[df$frq < 12,]
frq <- exp(pf2$xc[nar > 0])

Param5 <- Param1
Param5$tau2 <- 0.6
H5 <- LTphase(df$frq, Param5)
cTF5 <- H5$Amp
phiTF5 <- H5$Phase
# df$Amp5 <- cTF5
# plot(df$frq, df$mphase, type='p', pch=20, col='blue', log='x', xlim=c(1.e-2, 15),
#   xlab='frequency [Hz]', ylab='phase, RTRR x Q [degrees]', ylim=c(-80, 9))
# arrows(df$frq, df$mphase-df$sdp, df$frq, df$mphase+df$sdp, length=0.05, angle=90, code=3)
g <- ggplot(df, aes(x = frq, y = mphase)) + geom_point()
g <-
  g + xlab('frequency [Hz]') + ylab (bquote('phase [' ~ degree * ']'))
g <-
  g + scale_x_log10(
    breaks = trans_breaks("log10", function(x)
      10 ^ x, n = 4),
    labels = trans_format("log10", math_format(expr = 10 ^ .x))
  ) + xlab('frequency [Hz]')
g <- g + annotation_logticks(sides = "bt") 
g <-
  g + geom_errorbar(aes(ymin = mphase - sdp, ymax = mphase + sdp), width = 0.06)
g <-
  g + geom_path(data = dfAP,
                aes(x = Time, y = Phase),
                col = 'forestgreen',
                lwd = 1.5)
g <- g + annotate('text', x = 10, y = 0, label = '(a)', size = 8)
g1 <- g + theme_WAC(1)
frq <- seq(0.01, 25, by = 0.01)
dfr <- data.frame(frq = exp(pf2$xc),
                  mrspec = ar,
                  sdr = sdr)
dfr <- dfr[dfr$frq > 0.04,]
dfr <- dfr[dfr$sdr > 0,]
dfr <- dfr[dfr$frq < 12,]
frq <- exp(pf2$xc[nar > 0])
# spec1 <- spec1[nspec1 > 0]
# spec2 <- spec2[nspec1 > 0]
# rspec <- spec1 / spec2
# plotWAC(data.frame(frq, mrspec), xlab='frequency [Hz]', ylab='amplitude ratio RTRR/Q', type='p',
#         col='blue', log='x', pch=20, xlim=c(0.1,15), ylim=c(0,1.2))
# HR <- LTphase(frq, Param1)
# P <- Param1
# P$tau2 <- 0.84
# HR2 <- LTphase(frq, P)
# lines(frq, (HR2$Amp)^2, col='forestgreen', lwd=2)
# lines(frq, (HR$Amp)^2, col='darkorange', lwd=2, lty=2)
Param5 <- Param1
Param5$tau2 <- 0.6
H5 <- LTphase(dfr$frq, Param5)
cTF5 <- H5$Amp
phiTF5 <- H5$Phase
dfr$Amp5 <- cTF5
g <- ggplot(dfr, aes(x = frq, y = mrspec)) + geom_point()
g <- g + xlab('frequency [Hz]') + ylab ('amplitude ratio')
g <-
  g + scale_x_log10(
    breaks = trans_breaks("log10", function(x)
      10 ^ x, n = 4),
    labels = trans_format("log10", math_format(expr = 10 ^ .x))
  ) + xlab('frequency [Hz]')
g <- g + annotation_logticks(sides = "bt")
g <-
  g + geom_errorbar(aes(ymin = mrspec - sdr, ymax = mrspec + sdr), width =
                      0.06)
g <-
  g + geom_path(data = dfAP,
                aes(
                  x = Time,
                  y = Amp,
                  col = 'best',
                  lty = 'best'
                ),
                lwd = 1.5)
g <-
  g + geom_path(data = dfr,
                aes(
                  x = frq,
                  y = Amp5,
                  col = 'tau2=0.6',
                  lty = 'tau2=0.6'
                ),
                lwd = 1.2)
g <-
  g + scale_colour_manual (
    name = 'fit: ',
    values = c("best" = "forestgreen", "tau2=0.6" = "darkorange")
  )
g <- g + scale_linetype_manual (name = 'fit: ',
                                values = c('best' = 1, 'tau2=0.6' = 2))
g <- g + annotate('text', x = 10, y = 1.05, label = '(b)', size = 8)
g2 <- g + ylim(0, 1.3) + theme_WAC(1)

grid.newpage()
position <- c(1, 2)
h <- 0.9 / position[2]
yp <- 0.05 + (position[1] - 0.5) * h
if (position[1] == 1) {
  hh <- h + 0.1
} else {
  hh <- h
  yp <- yp + 0.05
}
vp1 <- viewport(
  width = 1,
  height = hh,
  x = 0.5,
  y = yp
)
position <- c(2, 2)
h <- 0.9 / position[2]
yp <- 0.05 + (position[1] - 0.5) * h
if (position[1] == 1) {
  hh <- h + 0.1
} else {
  hh <- h + 0.125
  yp <- yp - 0.07
}
vp2 <- viewport(
  width = 1,
  height = hh,
  x = 0.5,
  y = yp
)
g2 <- g2 + theme(plot.margin = unit(c(0.3, 0.3, 1.1, 1.7), "lines"))
if (generateFigures) {
  suppressWarnings(print(g1, vp = vp2))
  suppressWarnings(print(g2, vp = vp1))
} else {
  include_graphics(
    'figure/fig2.pdf'
  )
}

```

\caption[Phase and amplitude ratio (or gain) for the measured recovery temperature
relative to dynamic heating.]{(a): Phase of measured recovery temperature relative to dynamic
heating, for the measurements (with error bars) and for the theoretical
response for the best-fit parameters (green line). The error bars
indicate two-standard-deviation ranges in the mean at each plotted
point. Data from the  flight segments listed in Table\ 1.\protect \\
(b): The ratio of the spectral amplitude for the measurement
of recovery temperature ($T_{m}(t)$) to that for dynamic heating
($Q$), shown as the plotted data points. There are additional data
points at frequencies below about 0.04 Hz that do not appear in this
plot because they lie above the upper limit for the ordinate. The
green line is the prediction from the transfer function determined
from the best-fit values matching the phase lag between these variables,
and the dashed orange line is a similar result with the second time
constant $\tau_{2}$ increased from 0.447 to \unit{0.6\,s} to illustrate
sensitivity to this parameter.{\label{fig:Vphase}}}
\end{figure}

```{r checkAmplitude, include=FALSE, fig.pos='t', fig.height = 3.5, fig.cap='The ratio of the spectral amplitude for the measurement of recovery temperature ($T_m(t)$) to that for dynamic heating ($Q$), shown as the plotted data points. There are additional data points at frequencies below about 0.04 Hz that do not appear in this plot because they lie above the upper limit for the ordinate. The green line is the prediction from the transfer function determined from the best-fit values matching the phase lag between these variables, and the dashed orange line is a similar result with the second time constant $\\tau_2$ increased from 0.447 to 0.6 s to illustrate sensitivity to this parameter.'}

dfr <- data.frame(frq = exp(pf2$xc),
                  mrspec = ar,
                  sdr = sdr)
dfr <- dfr[dfr$frq > 0.01,]
dfr <- dfr[dfr$sdr > 0,]
dfr <- dfr[dfr$frq < 12,]
frq <- exp(pf2$xc[nar > 0])
Param5 <- Param1
Param5$tau2 <- 0.6
H5 <- LTphase(dfr$frq, Param5)
cTF5 <- H5$Amp
phiTF5 <- H5$Phase
dfr$Amp5 <- cTF5
g <- ggplot(dfr, aes(x = frq, y = mrspec)) + geom_point()
g <- g + xlab('frequency [Hz]') + ylab ('amplitude ratio')
g <-
  g + scale_x_log10(
    breaks = trans_breaks("log10", function(x)
      10 ^ x, n = 4),
    labels = trans_format("log10", math_format(expr = 10 ^ .x))
  ) + xlab('frequency [Hz]')
g <- g + annotation_logticks(sides = "bt")
g <-
  g + geom_errorbar(aes(ymin = mrspec - sdr, ymax = mrspec + sdr), width =
                      0.06)
g <-
  g + geom_path(data = dfAP, aes(
    x = Time,
    y = Amp,
    col = 'best',
    lty = 'best'
  ))
g <-
  g + geom_path(data = dfr, aes(
    x = frq,
    y = Amp5,
    col = 'tau2=0.6',
    lty = 'tau2=0.6'
  ))
g <-
  g + scale_colour_manual (
    name = 'fit: ',
    values = c("best" = "forestgreen", "tau2=0.6" = "darkorange")
  )
g <- g + scale_linetype_manual (name = 'fit: ',
                                values = c('best' = 1, 'tau2=0.6' = 2))
suppressWarnings(print(g + ylim(0, 1.3) + theme_WAC(1)))

```

The ratio of the amplitude of the response to that of the dynamic-heating
signal, used as an estimate of the gain of the transfer function,
is shown in Fig.\ \ref{fig:Vphase}b. It is useful to consider both
the amplitude and phase when determining the response parameters because,
as shown in Fig.\ \ref{fig:LTsolution}, the amplitude of the transfer
function is more sensitive to $\tau_{2}$ than the phase but $\tau_{1}$
is a very sensitive predictor of the phase at high frequency. For
the set of favored parameters, Fig.\ \ref{fig:Vphase}b shows the
standard prediction and another with $\tau_{2}$ set to \unit{0.6\,s} instead,
to show the sensitivity of this result to that parameter. The best
prediction based on the measured phases consistently underestimates
the ratio of spectra for frequencies below about \unit{0.1\,Hz} and above
about \unit{3\,Hz} but is reasonably consistent with the observed ratio between
those limits. Below \unit{0.1\,Hz} variance spectra indicate that the sensor
is responding to real fluctuations in temperature not attributable
to dynamic heating, as would be expected at these low frequencies.
Above \unit{3\,Hz} the prediction is much too low, probably because there
is noise or other spurious variance in $T_{m}(t)$ not caused by dynamic
heating. 

```{r fitCoefs, include=TRUE, echo=FALSE}

Param2 <- Param1
## Restrict dfr frequencies:
dfr <- dfr[dfr$frq > 0.1 & dfr$frq < 3, ]
minFn <- function(V) {
  Param2$a <<- V[1]
  Param2$tau1 <<- V[2]
  Param2$tau2 <<- V[3]
  Chisq <- 0
  for (i in 1:nrow(df)) {
    Chisq <- Chisq + (df$mphase[i] - LTphase(df$frq[i], Param2)$Phase)^2 / df$sdp[i]^2
  }
  for (i in 1:nrow(dfr)) {
    Chisq <- Chisq + (dfr$mrspec[i] - LTphase(dfr$frq[i], Param2)$Amp)^2 / dfr$sdr[i]^2
  }
  return (Chisq)
}
A <- optim (c(Param2$a, Param2$tau1, Param2$tau2), minFn, hessian=TRUE)
best <- A$par
# factor of 4 because 2-sigma errors were used?
Herror <- solve(A$hessian / 4)  
uncLimits <- sqrt(diag(Herror))
## Save best-fit Param:
Param2$a <- best[1]
Param2$tau1 <- best[2]
Param2$tau2 <- best[3]

```

The fit procedure used Eq.\ \eqref{eq:responseAmp} and 
Eq.\ \eqref{eq:responsePhase}
to find the theoretical value of the amplitude ratio and phase at
each frequency represented in the observations. For assumed values
of the three parameters $a$, $\tau_{1}$ and $\tau_{2}$, a chi-square
was calculated from the differences between these theoretical values
and the observed values. The frequencies used for the fit were 0.01
to \unit{12\,Hz} for the measurements of phase and 0.1 to \unit{3\,Hz} for the measurements
of amplitude ratio, to avoid regions where effects other than dynamic
heating appear to bias the measurements. Then a search procedure varied
these parameters to seek the minimum value of the chi-square. The
resulting values were $a$= `r round(best[1], 2)`, $\tau_{1}$=
`r round(best[2], 3)` and $\tau_{2}$= `r round(best[3], 2)`.
The chi-square for the fit is about 18 times larger than expected
if the fit represents the measurements to measurement uncertainty,
so it is difficult to assign uncertainty limits to this result on
the basis of this fit because of this not-understood excess chi-square,
but the fit minimum distinguished nearby values to about three significant
digits in all three parameters. The Hessian from the fit implies that
the results with standard uncertainties 
are $a$= `r round(best[1], 3)` $\pm$ `r round(uncLimits[1], 3)`,
$\tau_{1}$=`r round(best[2], 4)`$\pm$`r round(uncLimits[2], 4)`\unit{\,s}
and $\tau_{2}$=`r round(best[3], 2)` $\pm$ `r round(uncLimits[3], 2)`\unit{\,s}.

```{r correctRT, include=FALSE}

## Integrate to find the support temperature Ts:
a <- Param1$a
tau1 <- Param1$tau1
tau2 <- Param1$tau2
## RT is the working solution; Ts is the support temperature
DT$Ts <- DT$RT
Rate <- attr (DT, 'Rate')
DT$DTMDT <- c(0, diff(DT$TTRR, 2), 0) * Rate / 2
fS <- function(y, i) {
  # Eq. Ts3
  ((1 / a) * (tau1 * DT$DTMDT[i] + DT$TTRR[i] - (1 - a) * y) - y) / (Rate * tau2)
}

DT$Ts <- rk4.integrate (fS, DT$Ts[1], 1:nrow(DT))
DT$RT <- (1 / a) * (tau1 * DT$DTMDT + DT$TTRR - (1 - a) * DT$Ts)
DT %>% select(Time, TTRR, RT, Ts) %>%
  selectTime(114500, 114505) %>%
  plotWAC()

```

To complete the iteration discussed earlier, the measured recovery
temperature was then corrected as described in Appendix\ A, using
the parameters from this first fit, to find a prediction for the actual
recovery temperature $T_{r}(t)$. After recalculating $Q$ using 
Eq.\ \eqref{eq:DHterm}
with that estimate of $T_{r}(t)$ in place of $T_{m}(t)$, the calculation
of phase and amplitude was repeated and the results were fitted again
by adjusting the fit parameters. Only insignificant changes, much smaller 
than the quoted uncertainties, resulted from this iteration. 

```{r GVcheck}

## This chunk checks GV measurements for consistency with the previous 
## results from the C-130, with results reasonably consistent with those
## results. It also analyzes the corresponding results for the heated
## sensor. The best-fit parameters are determined, but they are not
## scaled using MRHO; that is left for later so that the unscaled
## results can be quoted. At present, the results for the unheated
## sensor from these projects are not included in the manuscript.
DSX <- getNetCDF(
  file.path(DataDirectory(), 'SOCRATES/rf15h.nc'),
  standardVariables(c('ATF1', 'ATH1', 'ATH2')),
  54700, 62000)
DCX <- getNetCDF(file.path(DataDirectory(), 'CSET/rf05h.nc'),
                 standardVariables(c('ATF1', 'ATH1', 'ATH2')),
                 175000, 205000)
## The recovery temperatures are not in these archived files, so
## reconstruct them:
rf.txt <- attr(DSX$ATF1, 'RecoveryFactor')
rf <- gsub('mach', 'MACHX', rf.txt)
rf <- gsub(' log', ' * log', rf)
rf <- gsub(' \\(', ' * \\(', rf)
rf <- with(DSX, eval(parse(text = rf)))
rf[is.na(rf)] <- mean(rf, na.rm=TRUE)
rf2.txt <- attr(DSX$ATH1, 'RecoveryFactor')
rf2 <- gsub('mach', 'MACHX', rf2.txt)
rf2 <- gsub(' log', ' * log', rf2)
rf2 <- gsub(' \\(', ' * \\(', rf2)
rf2 <- with(DSX, eval(parse(text = rf2)))
rf2[is.na(rf2)] <- mean(rf2, na.rm=TRUE)
DSX$RTF1 <- DSX$ATF1 + rf * DSX$TASX ^ 2 / 2010
DSX$RTF1 <- SmoothInterp(DSX$RTF1, .Length = 0)
DSX$RTH1 <- DSX$ATH1 + rf2 * DSX$TASX ^ 2 / 2010
DSX$RTH1 <- SmoothInterp(DSX$RTH1, .Length = 0)
XXA <- rf * DSX$MACHX ^ 2 / 5
DSX$Q <- (DSX$RTF1 + 273.15) * XXA / (1 + XXA)
DSX$Q <- SmoothInterp(DSX$Q, .Length = 0)
DSX$Q <- ShiftInTime(DSX$Q, .rate = 25, .shift = -10)
## repeat for the CSET file:
rf.txt <- attr(DCX$ATF1, 'RecoveryFactor')
rf <- gsub('mach', 'MACHX', rf.txt)
rf <- gsub(' log', ' * log', rf)
rf <- gsub(' \\(', ' * \\(', rf)
rf <- with(DCX, eval(parse(text = rf)))
rf2.txt <- attr(DCX$ATH1, 'RecoveryFactor')
rf2 <- gsub('mach', 'MACHX', rf2.txt)
rf2 <- gsub(' log', ' * log', rf2)
rf2 <- gsub(' \\(', ' * \\(', rf2)
rf2 <- with(DCX, eval(parse(text = rf2)))
DCX$RTF1 <- DCX$ATF1 + rf * DCX$TASX ^ 2 / 2010
## SmoothInterp is used to guard against NA values:
DCX$RTF1 <- SmoothInterp(DCX$RTF1, .Length = 0)
DCX$RTH1 <- DCX$ATH1 + rf2 * DCX$TASX ^ 2 / 2010
DCX$RTH1 <- SmoothInterp(DCX$RTH1, .Length = 0)
XXA <- rf * DCX$MACHX ^ 2 / 5
DCX$Q <- (DCX$RTF1 + 273.15) * XXA / (1 + XXA)
DCX$Q <- SmoothInterp(DCX$Q, .Length = 0)
DCX$Q <- ShiftInTime(DCX$Q, .rate = 25, .shift = -10)
## May need to revise this with corrected RT in second iteration
# RX <- CohPhase(DSA, 'RTF1', 'Q', plotType='Ranadu')
SB <- 100
DSX$RT <- DSX$RTF1
DCX$RT <- DCX$RTF1
## Correct RT for time response:
a <- Param1$a
tau1 <- Param1$tau1
tau2 <- Param1$tau2
## RT is the working solution; Ts is the support temperature
DSX$Ts <- DSX$RT
DCX$Ts <- DCX$RT
Rate <- attr (DSX, 'Rate')
# DSX$DTMDT <- c(0, diff(DSX$RT, 2), 0) * Rate / 2
DSX$DTMDT <-  (c(0, 8 * diff(DSX$RT, 2), 0) -
                    c(0, 0, diff(DSX$RT, 4), 0, 0)) * Rate / 12
DCX$DTMDT <-  (c(0, 8 * diff(DCX$RT, 2), 0) -
                    c(0, 0, diff(DCX$RT, 4), 0, 0)) * Rate / 12
fS <- function(y, i) {
      ((tau1 * DSX$DTMDT[i] + DSX$RT[i] - (1 - a) * y) / a - y) / (Rate * tau2)
    }
DSX$Ts <- rk4.integrate (fS, DSX$Ts[1], 1:nrow(DSX))
DSX$RT <- (1 / a) * (tau1 * DSX$DTMDT + DSX$RT - (1 - a) * DSX$Ts)
fS <- function(y, i) {
      ((tau1 * DCX$DTMDT[i] + DCX$RT[i] - (1 - a) * y) / a - y) / (Rate * tau2)
    }
DCX$Ts <- rk4.integrate (fS, DCX$Ts[1], 1:nrow(DCX))
DCX$RT <- (1 / a) * (tau1 * DCX$DTMDT + DCX$RT - (1 - a) * DCX$Ts)
## Next is for Z adjustment later
DZ <- rbind(
  DSX %>% selectTime(55200, 60200),
  DSX %>% selectTime(60500, 61500),
  DCX %>% selectTime(175200, 180200),
  DCX %>% selectTime(194530, 195530),
  DCX %>% selectTime(203717, 204717)
)
DSA <- DSX %>% selectTime(55200, 60200)
## Select five 10-min intervals for averaging:
RXA <- DSX %>% 
  selectTime(55200, 60200) %>% 
  CohP('RT', 'Q', plotType = 'Ranadu', smoothBins = SB)
RXB <- DSX %>% 
  selectTime(60500, 61500) %>% 
  CohP('RT', 'Q', plotType = 'Ranadu', smoothBins = SB)
RXC <- DCX %>% 
  selectTime(175200, 180200) %>%
  CohP('RT', 'Q', plotType = 'Ranadu', smoothBins = SB)
RXD <- DCX %>% 
  selectTime(194530, 195530) %>% 
  CohP('RT', 'Q', plotType = 'Ranadu', smoothBins = SB)
RXE <- DCX %>% 
  selectTime(203717, 204717) %>% 
  CohP('RT', 'Q', plotType = 'Ranadu', smoothBins = SB)
## May need to revise this with corrected RT in second iteration
Z <- capture.output (
  Vr <- SmoothInterp(detrend (DSA[, c('Time', 'RT')]), .Length = 0))
Z <- capture.output (
  VrC <- SmoothInterp(detrend (DSA[, c('Time', 'Q')]), .Length = 0))
Rate <- attr(DSA, 'Rate')
vcv <- cbind(ts(Vr, frequency = Rate), ts(VrC, frequency = Rate))
P <- spec.pgram(
  vcv,
  detrend = FALSE,
  fast = TRUE,
  plot = FALSE,
  spans = 25
)
## These lines aren't used; they are left over from earlier testing:
df1SF <- data.frame(P$coh, log(P$freq))
df2SF <- data.frame (P$phase, log(P$freq))
pf1SF <- binStats (df1SF, bins = SB)
## ----------
pf2SF <- binStats (df2SF, bins = SB)  ## This is used later to set frq
phaseSF <- rep(0, SB)
nphaseSF <- rep(0, SB)
phase2SF <- rep(0, SB)
arSF <- rep(0, SB)
ar2SF <- rep(0, SB)
narSF <- rep(0, SB)
for (RX in list(RXA, RXB, RXC, RXD, RXE)) {
  for (i in 2:nrow(RX)) {
    phaseSF[RX$BIN.1[i]] <- phaseSF[RX$BIN.1[i]] + RX$P.phase[i]
    nphaseSF[RX$BIN.1[i]] <- nphaseSF[RX$BIN.1[i]] + 1
    phase2SF[RX$BIN.1[i]] <- phase2SF[RX$BIN.1[i]] + RX$P.phase[i] ^ 2
    arSF[RX$BIN.1[i]] <-
      arSF[RX$BIN.1[i]] + sqrt(RX$P.spec...1.[i] / RX$P.spec...2.[i])
    ar2SF[RX$BIN.1[i]] <-
      ar2SF[RX$BIN.1[i]] + (RX$P.spec...1.[i] / RX$P.spec...2.[i])
    narSF[RX$BIN.1[i]] <- narSF[RX$BIN.1[i]] + 1
  }
}
nphaseSF[nphaseSF == 0] <- 1
narSF[narSF == 0] <- 1
mphaseSF <- phaseSF / nphaseSF
mphase2SF <- phase2SF / nphaseSF
sdpSF <- sqrt(mphase2SF - mphaseSF ^ 2)
mphaseSF <- mphaseSF * 180 / pi
sdpSF <- sdpSF * 180 / pi
sdpSF <- sdpSF * 2 / sqrt(nphaseSF)
arSF <- arSF / narSF
ar2SF <- ar2SF / narSF
b <- ar2SF - arSF ^ 2
b[near(b, 0)] <- 0
sdrSF <- sqrt(b)
sdrSF <- sdrSF * 2 / sqrt(narSF)
dfSF <- data.frame(frq = exp(pf2SF$xc),
                   mphase = mphaseSF,
                   sdp = sdpSF)
dfSF <- dfSF[dfSF$frq > 0.3,]
dfSF <- dfSF[dfSF$sdp > 0,]
dfSF <- dfSF[dfSF$frq < 6,]
dfrSF <- data.frame(frq = exp(pf2SF$xc),
                    mrspec = arSF,
                    sdr = sdrSF)
dfrSF <- dfrSF[dfrSF$frq > 0.5,]
dfrSF <- dfrSF[dfrSF$sdr > 0,]
dfrSF <- dfrSF[dfrSF$frq < 5,]
frq <- exp(pf2SF$xc)
Parm <- Param1  ## Used to initiate fit
minFn <- function(V) {
  Parm$a <<- V[1]
  Parm$tau1 <<- V[2]
  Parm$tau2 <<- V[3]
  Chisq <- 0
  for (i in 1:nrow(dfSF)) {
    Chisq <-
      Chisq + (dfSF$mphase[i] - LTphase(dfSF$frq[i], Parm)$Phase) ^ 2 / dfSF$sdp[i] ^
      2
  }
  for (i in 1:nrow(dfrSF)) {
    Chisq <-
      Chisq + (dfrSF$mrspec[i] - LTphase(dfrSF$frq[i], Parm)$Amp) ^ 2 / dfrSF$sdr[i] ^
      2
  }
  return (Chisq)
}
ASF <- optim (c(Parm$a, Parm$tau1, Parm$tau2), minFn, hessian = TRUE)
bestSF <- ASF$par
HerrorSF <-
  solve(ASF$hessian / 4)  # factor of 4 because 2-sigma errors were used?
uncLimitsSF <- sqrt(diag(HerrorSF))
# print(bestSF)
ParamSF <- Param2
ParamSF$a <- bestSF[1]
ParamSF$tau1 <- bestSF[2]
ParamSF$tau2 <- bestSF[3]
ParamSF$a <- 0.734
ParamSF$tau1 <- 0.0296
ParamSF$tau2 <- 0.36
HSF <- LTphase(dfrSF$frq, ParamSF)
dfrSF$Amp <- HSF$Amp
dfrSF$Phase <- HSF$Phase
rhozero <- 1013.25 * 100 / (287.05 * 288.15)
MRHO <- MachNumber(DZ$PSXC, DZ$QCXC) * DZ$PSXC * 100 /
  (287.05 * (273.15 + DZ$ATX)) / rhozero
# Leave this scaling for later:
# ParamSF$tau1 <- ParamSF$tau1 * (0.3 / mean(MRHO, na.rm = TRUE)) ^ -0.68
# ParamSF$tau2 <- ParamSF$tau2 * (0.3 / mean(MRHO, na.rm = TRUE)) ^ -0.68

g <- ggplot(dfSF, aes(x = frq, y = mphase)) + geom_point()
g <- g + xlab('frequency [Hz]') + ylab ('phase RTF1 x Q [degrees]')
g <-
  g + scale_x_log10(
    breaks = trans_breaks("log10", function(x)
      10 ^ x, n = 4),
    labels = trans_format("log10", math_format(expr = 10 ^
                                                 .x))
  ) + xlab('frequency [Hz]')
g <- g + annotation_logticks(sides = "bt")
g <-
  g + geom_errorbar(aes(ymin = mphase - sdp, ymax = mphase + sdp), 
                    width = 0.06)
g <-
  g + geom_path(data = dfrSF, aes(x = frq, y = Phase), col = 'forestgreen')
# g <- g + geom_path(data=dfAPSF, aes(x=Time, y=Phase), col='darkorange')
g + theme_WAC(1)

frq <- exp(pf2SF$xc[narSF > 0])
g <- ggplot(dfrSF, aes(x = frq, y = mrspec)) + geom_point()
g <- g + xlab('frequency [Hz]') + ylab ('amplitude ratio RTF1 / Q')
g <-
  g + scale_x_log10(
    breaks = trans_breaks("log10", function(x)
      10 ^ x, n = 2),
    labels = trans_format("log10", math_format(expr = 10 ^
                                                 .x))
  ) + xlab('frequency [Hz]')
g <- g + annotation_logticks(sides = "bt")
g <-
  g + geom_errorbar(aes(ymin = mrspec - sdr, ymax = mrspec + sdr), width =
                      0.06)
# g <- g + geom_path(data=dfAPSF, aes(x=Time, y=Amp), col='darkorange')
g <- g + geom_path(data = dfrSF, aes(x = frq, y = Amp), col = 'forestgreen')
suppressWarnings(print(g + ylim(0, 1.3) + theme_WAC(1)))
# CohPhase(DSA, 'RTF1', 'Q')
# DSA %>% select(Time, TASX, RTF1, Q, ATF1) %>% 
#         VSpec()
# print(bestSF)

```

<!-- The airflow and typical flow angles approaching a sensor can affect -->
<!-- its response, so the results might change when installed on a different -->
<!-- location or a different aircraft. Therefore a similar evaluation examined -->
<!-- the response of this same sensor when flown on the NSF/NCAR GV, which -->
<!-- flies significantly faster than the C-130. The results of a study -->
<!-- using a combined low-level dataset from the SOCRATES [@mcfarquhar2014southern] -->
<!-- and CSET [@albrecht2019CSET] experiments, which were flown -->
<!-- over the Pacific Ocean, were similar to but slightly different from -->
<!-- the coefficients determined on the C-130, with both time constants -->
<!-- smaller than found for the C-130 ($\tau_{1}$=`r round(bestSF[2], 3)`\unit{\,s} -->
<!-- and $\tau_{2}$=`r round(bestSF[3], 2)`\unit{\,s}). This might be expected -->
<!-- at greater airspeed, as discussed in Sect.\ \ref{subsec:Expected-dependence-on}. -->


### Heated sensors\label{subsec:Heated-sensors}

<!-- A chunk has been omitted here; see earlier versions. -->
Measurements from two slower sensors, a heated Goodrich/Rosemount
102 sensor and a similar Harco Model 100009-1 Deiced TAT
sensor, have also been evaluated, but only the latter (hereafter called
the "heated sensor") is discussed
here because they have similar response. The spectral variance for
both these measurements has apparent rapid attenuation beginning at
about \unit{0.1\,Hz}, as shown in Fig.\ \ref{fig:HARCOSpec}, and the response
is attenuated seriously above about \unit{1\,Hz}. 
To find the transfer function for this sensor, 
boundary-layer flight segments from the SOCRATES and CSET projects
were compiled
into one data set from the flight periods shown in Table\ 2. 

Attempts to use the same three-parameter representation of the transfer
function relative to dynamic heating led to unsatisfactory fits, 
apparently because fluctuations caused by dynamic heating were not
as dominating a cause of the temperature fluctuations as they were
in the measurements used for the unheated sensor. Therefore
a different approach was used here. Because the evaluation in Sect.\ \ref{subsec:The-unheated-Rosemount}
provides a good representation of the unheated sensor,
the measurements from that sensor, corrected as described in Appendix\ A,
were used as the reference for the assumed-correct recovery temperature.
Then the phase and amplitude ratio were found for the transfer function
required to produce the heated-probe measurements from the unheated-probe
measurements. This did not require any assumptions about equations
or parameters determining the transfer function.

```{r extraUHR, include=FALSE, echo=FALSE}

# SB <- 30
Z <- capture.output (
       Vr <- SmoothInterp(detrend (DT1[, c('Time', 'TTWH')]), .Length = 0))
Z <- capture.output (
       VrC <- SmoothInterp(detrend (DT1[, c('Time', 'DH')]), .Length = 0))
Rate <- attr(DT1, 'Rate')
vcv <- cbind(ts(Vr, frequency = Rate), ts(VrC, frequency = Rate))
P <- spec.pgram(
  vcv,
  detrend = FALSE,
  fast = TRUE,
  plot = FALSE,
  spans = 25
)
df1W <- data.frame(P$coh, log(P$freq))
pf1W <- binStats (df1W, bins = SB)
RX1W <- CohP(DT1, 'TTWH', 'RT', plotType = 'Ranadu', smoothBins = SB)
RX2W <- CohP(DT2, 'TTWH', 'RT', plotType = 'Ranadu', smoothBins = SB)
RX3W <- CohP(DT3, 'TTWH', 'RT', plotType = 'Ranadu', smoothBins = SB)
RX4W <- CohP(DT4, 'TTWH', 'RT', plotType = 'Ranadu', smoothBins = SB)
RX5W <- CohP(DT5, 'TTWH', 'RT', plotType = 'Ranadu', smoothBins = SB)
# RX6W <- CohP(DT6, 'TTWH', 'DH', plotType='Ranadu', smoothBins=SB)
phaseW <- rep(0, SB)
nphaseW <- rep(0, SB)
phase2W <- rep(0, SB)
arW <- rep(0, SB)
ar2W <- rep(0, SB)
narW <- rep(0, SB)
for (RX in list(RX1W, RX2W, RX3W, RX4W, RX5W)) {
  for (i in 2:nrow(RX)) {
    phaseW[RX$BIN.1[i]] <- phaseW[RX$BIN.1[i]] + RX$P.phase[i]
    nphaseW[RX$BIN.1[i]] <- nphaseW[RX$BIN.1[i]] + 1
    phase2W[RX$BIN.1[i]] <- phase2W[RX$BIN.1[i]] + RX$P.phase[i] ^ 2
    arW[RX$BIN.1[i]] <-
      arW[RX$BIN.1[i]] + sqrt(RX$P.spec...1.[i] / RX$P.spec...2.[i])
    ar2W[RX$BIN.1[i]] <-
      ar2W[RX$BIN.1[i]] + (RX$P.spec...1.[i] / RX$P.spec...2.[i])
    narW[RX$BIN.1[i]] <- narW[RX$BIN.1[i]] + 1
  }
}
nphaseW[nphaseW == 0] <- 1
mphaseW <- phaseW / nphaseW
mphase2W <- phase2W / nphaseW
sdpW <- sqrt(mphase2W - mphaseW ^ 2)
mphaseW <- mphaseW * 180 / pi
sdpW <- sdpW * 180 / pi
sdpW <- sdpW * 2 / sqrt(nphaseW)
arW <- arW / narW
ar2W <- ar2W / narW
sdrW <- sqrt(ar2W - arW ^ 2)
sdrW <- sdrW * 2 / sqrt(narW)

```

```{r RTH1Spec, include=FALSE, echo=FALSE, fig.pos='t', fig.height=4, fig.cap='Spectral variance $P(\\nu)$ weighted by frequency ($\\nu$) for the recovery temperature measured by a heated and an unheated sensor. The background includes orange dotted lines denoting $-2/3$ slope and the wavelength scale is determined from the average airspeed.'}

# g <- VSpec(DT, 'TTWH', spans=99, ylim=c(1.e-6, 1))
# suppressWarnings(print(VSpec(DT, 'TTRR', add=g, spans=99) + theme_WAC(1)))
DT$temperature <- DT$TTWH
DT %>% select(Time, TASX, TTWH, TTRR) %>%
  VSpec(
    spans = 199,
    VLabel = c('heated', 'unheated'),
    xlim = c(0.03, 12),
    ylim = c(4.e-7, 0.01),
    method = 'MEM',
    poles = 100,
    smoothBins = 200
  ) +
  theme_WAC(1)

```

\begin{figure}
```{r HARCOSpec, include = TRUE, fig.height = 3.5, out.width = "8.3cm"}

DCX$temperature <- DCX$RT
gH <- DCX %>% selectTime(175200, 180200) %>% 
  select(Time, TASX, RT, RTH1) %>%
    VSpec(VLabel=c('unheated', 'heated'), ylim=c(1.e-6, 0.1)) +
    ylab(bquote('spectral variance ' ~ nu * 'P(' * nu * ')')) +    
    theme_WAC(1) + 
    theme(legend.position=c(0.7, 0.9))
if (generateFigures) {
  print(gH)
} else {
  include_graphics('figure/fig3.pdf')
}

```
\caption{Spectral variance $P(\nu)$ weighted by frequency ($\nu$) for the recovery temperature measured by a heated and an unheated temperature sensor.\label{fig:HARCOSpec}}
\end{figure}



\begin{table}[t]
%\begin{centering}
\caption{Flight segments used to determine the response characteristics of
a heated sensor.}
\begin{tabular}{|c|c|c|}
\hline 
\bf{Project / Flight} & \bf{start [UTC]} & \bf{end [UTC}\tabularnewline
\hline 
\hline 
CSET / 5 & 2015-07-14 17:52:00 & 18:02:00\tabularnewline
\hline 
CSET / 5 & 2015-07-14 19:45:30 & 19:55:30\tabularnewline
\hline 
CSET / 5 & 2015-07-14 20:37:17 & 20:47:17\tabularnewline
\hline 
SOCRATES / 15 & 2018-02-24 5:52:00 & 6:02:00\tabularnewline
\hline 
SOCRATES / 15 & 2018-02-24 6:05:00 & 6:15:00\tabularnewline
\hline 
\end{tabular}
%\par\end{centering}
\end{table}

\begin{figure}
```{r GVHARCO, include = TRUE, fig.height = 4, out.width = "12cm"}

SB <- 50
RXA <- DSX %>% 
  selectTime(55200, 60200) %>% 
  CohP('RTH1', 'RT', plotType = 'Ranadu', smoothBins = SB)
RXB <- DSX %>% 
  selectTime(60500, 61500) %>% 
  CohP('RTH1', 'RT', plotType = 'Ranadu', smoothBins = SB)
RXC <- DCX %>% 
  selectTime(175200, 180200) %>% 
  CohP('RTH1', 'RT', plotType = 'Ranadu', smoothBins = SB)
RXD <- DCX %>% 
  selectTime(194530, 195530) %>% 
  CohP('RTH1', 'RT', plotType = 'Ranadu', smoothBins = SB)
RXE <- DCX %>% 
  selectTime(203717, 204717) %>% 
  CohP('RTH1', 'RT', plotType = 'Ranadu', smoothBins = SB)
## May need to revise this with corrected RT in second iteration
Z <- capture.output (
       Vr <- SmoothInterp(detrend (DSA[, c('Time', 'RTH1')]), .Length = 0))
Z <- capture.output (
       VrC <- SmoothInterp(detrend (DSA[, c('Time', 'RT')]), .Length = 0))
Rate <- attr(DSA, 'Rate')
vcv <- cbind(ts(Vr, frequency = Rate), ts(VrC, frequency = Rate))
P <- spec.pgram(
  vcv,
  detrend = FALSE,
  fast = TRUE,
  plot = FALSE,
  spans = 25
)
df1SH <- data.frame(P$coh, log(P$freq))
df2SH <- data.frame (P$phase, log(P$freq))
pf1SH <- binStats (df1SH, bins = SB)
pf2SH <- binStats (df2SH, bins = SB)
phaseSH <- rep(0, SB)
nphaseSH <- rep(0, SB)
phase2SH <- rep(0, SB)
arSH <- rep(0, SB)
ar2SH <- rep(0, SB)
narSH <- rep(0, SB)
for (RX in list(RXA, RXB, RXC, RXD, RXE)) {
  for (i in 2:nrow(RX)) {
    phaseSH[RX$BIN.1[i]] <- phaseSH[RX$BIN.1[i]] + RX$P.phase[i]
    nphaseSH[RX$BIN.1[i]] <- nphaseSH[RX$BIN.1[i]] + 1
    phase2SH[RX$BIN.1[i]] <- phase2SH[RX$BIN.1[i]] + RX$P.phase[i] ^ 2
    arSH[RX$BIN.1[i]] <-
      arSH[RX$BIN.1[i]] + sqrt(RX$P.spec...1.[i] / RX$P.spec...2.[i])
    ar2SH[RX$BIN.1[i]] <-
      ar2SH[RX$BIN.1[i]] + (RX$P.spec...1.[i] / RX$P.spec...2.[i])
    narSH[RX$BIN.1[i]] <- narSH[RX$BIN.1[i]] + 1
  }
}
nphaseSH[nphaseSH == 0] <- 1
narSH[narSH == 0] <- 1
mphaseSH <- phaseSH / nphaseSH
mphase2SH <- phase2SH / nphaseSH
sdpSH <- sqrt(mphase2SH - mphaseSH ^ 2)
mphaseSH <- mphaseSH * 180 / pi
sdpSH <- sdpSH * 180 / pi
sdpSH <- sdpSH * 2 / sqrt(nphaseSH)
arSH <- arSH / narSH
ar2SH <- ar2SH / narSH
b <- ar2SH - arSH ^ 2
b[near(b, 0)] <- 0
sdrSH <- sqrt(b)
sdrSH <- sdrSH * 2 / sqrt(narSH)
dfSH <- data.frame(frq = exp(pf2SH$xc),
                   mphase = mphaseSH,
                   sdp = sdpSH)
dfSH <- dfSH[dfSH$frq > 0.01,]
dfSH <- dfSH[dfSH$sdp > 0,]
dfSH <- dfSH[dfSH$frq < 2,]
dfrSH <- data.frame(frq = exp(pf2SH$xc),
                    mrspec = arSH,
                    sdr = sdrSH)
dfrSH <- dfrSH[dfrSH$frq > 0.01,]
dfrSH <- dfrSH[dfrSH$sdr > 0,]
dfrSH <- dfrSH[dfrSH$frq < 2,]
frq <- exp(pf2SH$xc)
Parm <- Param1
Parm$a <- 0.1
Parm$tau1 <- 0.1
Parm$tau2 <- 1.5
minFn <- function(V) {
  Parm$a <<- V[1]
  Parm$tau1 <<- V[2]
  Parm$tau2 <<- V[3]
  Chisq <- 0
  for (i in 1:nrow(dfSH)) {
    Chisq <- Chisq + 
             (dfSH$mphase[i] - LTphase(dfSH$frq[i], Parm)$Phase)^2 /
                 dfSH$sdp[i]^2
  }
  for (i in 1:nrow(dfrSH)) {
    Chisq <- Chisq + 
             (dfrSH$mrspec[i] - LTphase(dfrSH$frq[i], Parm)$Amp)^2 /
                 dfrSH$sdr[i]^2
  }
  return (Chisq)
}
ASH <-
  optim (
    c(Parm$a, Parm$tau1, Parm$tau2),
    minFn,
    method = 'L-BFGS-B',
    lower = 0,
    hessian = TRUE
  )
bestSH <- ASH$par
HerrorSH <-
  solve(ASH$hessian / 4)  
uncLimitsSH <- sqrt(diag(HerrorSH))
# print(bestSH)
ParamSH <- Parm
ParamSH$a <- bestSH[1]
ParamSH$tau1 <- bestSH[2]
ParamSH$tau2 <- bestSH[3]
HSH <- LTphase(dfrSH$frq, ParamSH)
dfrSH$Amp <- HSH$Amp
dfrSH$Phase <- HSH$Phase

g <- ggplot(dfSH, aes(x = frq, y = mphase)) + geom_point(size = 1.3)
g <- g +
  xlab('frequency [Hz]') + ylab (bquote('phase [' * degree * ']'))
g <- g +
  scale_x_log10(
    breaks = trans_breaks("log10", function(x)
      10 ^ x, n = 2),
    labels = trans_format("log10", math_format(expr = 10^.x))
  ) + xlab('frequency [Hz]')
g <- g + annotation_logticks(sides = "bt")
g <- g +
  geom_errorbar(aes(ymin = mphase - 2 * sdp, ymax = mphase + 2 * sdp),
                    width = 0.08)
g <- g +
  geom_path(data = dfrSH, aes(x = frq, y = Phase), col = 'forestgreen')
cf <-
  coef(lm(data = dfSH, mphase ~ log(frq) + I(log(frq) ^ 2) + I(atan(frq))))
dfSH$Ph <- cf[1] + cf[2] * log(dfSH$frq) + cf[3] * log(dfSH$frq) ^ 2 +
           cf[4] * atan(dfSH$frq)
dfSH$PhLT <- LTphase(dfSH$frq, ParamSH)$Phase
g <- g +
  geom_path(data = dfSH,
            aes(
              x = frq,
              y = Ph,
              col = 'lfit',
              lty = 'lfit'
            ),
            lwd = 1.2)
g <- g +
  geom_path(data = dfSH,
            aes(
              x = frq,
              y = PhLT,
              col = '3-par',
              lty = '3-par'
            ),
            lwd = 1.2)
# g <- g + geom_path(data=dfAPSH, aes(x=Time, y=Phase), col='darkorange')
g <- g + 
  scale_colour_manual (name = 'fit: ',
                values = c("lfit" = "forestgreen", "3-par" = "blue"))
g <- g + 
  scale_linetype_manual (name = 'fit: ',
                values = c('lfit' = 4, '3-par' = 1))
g1 <- g + theme_WAC(1) + theme(legend.position = c(0.75, 0.75),
                               legend.direction = 'vertical')

frq <- exp(pf2SH$xc[narSH > 0])
g <- ggplot(dfrSH, aes(x = frq, y = mrspec)) + geom_point(size = 1.3)
g <- g + xlab('frequency [Hz]') + ylab ('amplitude ratio')
g <-
  g + scale_x_log10(
    breaks = trans_breaks("log10", function(x)
      10 ^ x, n = 2),
    labels = trans_format("log10", math_format(expr = 10^.x))
  ) + xlab('frequency [Hz]')
g <- g + annotation_logticks(sides = "bt")
g <-
  g + geom_errorbar(aes(ymin = mrspec - 2 * sdr, ymax = mrspec + 2 * sdr),
                    width = 0.08)
# g <- g + geom_path(data=dfAPSH, aes(x=Time, y=Amp), col='darkorange')
cfr <- coef(lm(data = dfrSH, mrspec ~ log(frq) + I(log(frq) ^ 3) +
                 I(log(frq) ^ 5)))
cfr <- coef(lm(data = dfrSH, mrspec ~ log(frq) + I(log(frq) ^ 3) +
                 I(log(frq) ^ 4) + I(log(frq) ^ 5)))
fr <- log(dfrSH$frq)
dfrSH$G <-
  cfr[1] + fr * (cfr[2] + fr * fr * (cfr[3] + 
  fr * (cfr[4] + fr * cfr[5])))
dfrSH$G[dfrSH$frq < 0.024] <- 1
dfrSH$GLT <- LTphase(dfrSH$frq, ParamSH)$Amp
g <- g + 
  geom_path(data = dfrSH,
            aes(
              x = frq,
              y = G,
              col = 'lfit',
              lty = 'lfit'
            ),
            lwd = 1.2)
g <- g + 
  geom_path(data = dfrSH,
            aes(
              x = frq,
              y = GLT,
              col = '3-par',
              lty = '3-par'
            ),
            lwd = 1.2)
g <- g + 
  scale_colour_manual (name = 'fit: ',
              values = c("lfit" = "forestgreen", "3-par" = "blue"))
g <- g + 
  scale_linetype_manual (name = 'fit: ',
              values = c('lfit' = 4, '3-par' = 1))
g2 <- g + 
      ylim(0, 1.1) + 
      theme_WAC(1) + 
      theme(legend.position = 'none')
## small adjustment for alignment
g2 <- g2 + 
      theme(plot.margin = unit(c(0.3, 0.3, 1.1, 2.15), "lines"))
g2 <- g2 + theme(axis.title.y = element_text(vjust = 4))
g1 <- g1 + theme(axis.title.y = element_text(vjust = 0))
if (generateFigures) grid.newpage()
vp2 <-
  viewport(
    y = unit(0.57, 'npc'),
    height = unit(0.53, 'npc'),
    layout.pos.row = 2
  )
vp1 <-
  viewport(
    y = unit(0.25, 'npc'),
    height = unit(0.5, 'npc'),
    layout.pos.row = 1
  )
if(generateFigures) {
  print(g1, vp = vp2)
  print(g2, vp = vp1)
  grid.newpage()
} else {
  include_graphics('figure/fig4.pdf')
}
## Save for later use:
cfHARCO <- cf
cfrHARCO <- cfr

```

\caption[The phase and gain for the transfer function characterizing a heated temperature sensor. ]{The phase (top) and gain (bottom) for the transfer function characterizing
a heated temperature sensor. The measurements are indicated
by error bars that show two-standard-deviation limits from the mean
value). Two fits to the measurements, one based on the three-parameter
representation ("3-par") and one on a polynomial fit ("lfit"),
are described in the text.{\label{fig:GVHARCO}}}
\end{figure}

The measured phase and amplitude ratio for this data set are shown
in Fig.\ \ref{fig:GVHARCO}. The fits for the response function defined
by Eq.\ \eqref{eq:responseAmp} and Eq.\ \eqref{eq:responsePhase} are shown
as the blue lines labeled "3-par" in that figure. The fitted values
for \{$a,\,\tau_{1},\,\tau_{2}$\} were \{0, `r round(bestSH[2], 3)`\unit{\,s},
`r round(bestSH[3], 2)`\unit{\,s}\}, and to obtain this result the fit
had to be constrained to keep $a$ non-negative. A value of zero for
the parameter $a$ would indicate that no heat is transferred from
the sensing wire to the air, but instead all is transferred to the
support which has a relatively slow characteristic response. 

The three-parameter fit is not consistent with the measurement errors
even though it provides an approximate representation of the transfer
function. The apparent reason is that there is conflict between the
constraints imposed by the amplitude ratio and the phase, such that
either could be represented reasonably but not both. 
<!-- The amplitude decreases to $e^{-1}$ at about \unit{0.34\,Hz}, -->
<!-- as would be the case for a first-order time constant of about \unit{1.3\,s}, -->
<!-- so this could be considered one measure of the response. However, the -->
<!-- phase shift at \unit{0.34\,Hz} is approximately $-73^{\circ}$, which would -->
<!-- indicate that the measurement of a real contribution to sensible-heat -->
<!-- flux at this frequency would be only about 10\% of the correct value. -->
Because the three-parameter fit distorted the measured result, fits
in the logarithm of the frequency were used to provide a better representation
of the measurements, as shown by the dashed green lines labeled "lfit".
Those fits are given by these equations and coefficients, with $x=\log_{e}(\nu/\nu_{0})$
where $\nu$ is the frequency, $\omega=2\pi\nu$ and $\nu_{0}$=\unit{1\,Hz}:
\begin{align}
\mathrm{for}\ \nu>0.024\,\mathrm{Hz},\quad H(\omega)= & (h_{0}+h_{1}x+h_{2}x^{3}+h_{3}x^{4}+h_{4}x^{5})e^{i\phi(\omega)}{\label{eq:lfitH}} \\
\mathrm{for}\ \nu\leq0.024\,\mathrm{Hz},\quad H(\omega)= & 1 \\
\mathrm{for}\ all\ \nu,\quad\phi(\omega)= & p_{0}+p_{1}x+p_{2}x^{2}+p_{3}\arctan(\nu/\nu_{0})
\end{align}
The coefficients obtained by fitting to the observations are $h_{0-4}$=\{$`r   round(cfr[1], 3)`$,
$`r round(cfr[2], 3)`$, $`r format(cfr[3], digits=3, nsmall=4)`$,
$`r round(cfr[4], 4)`$, $`r round(cfr[5], 5)`$\} and $p_{0-3}$= \{$`r round(cf[1], 1)`$,
$`r round(cf[2], 1)`$, $`r round(cf[3], 2)`$, $`r round(cf[4], 1)`$\}.
This fit (with negative-frequency values defined as
the complex conjugate of the values at the corresponding positive
frequency) represents the transfer function better than
the three-parameter fit, although the fit must be modified above about \unit{2\,Hz}
because those values were not constrained by the measurements. A suggested
modification is to duplicate the value at \unit{2\,Hz} to higher frequencies;
this appears to be adequate because there is so little variance measured
by this sensor at these frequencies, as shown by Fig.\ \ref{fig:HARCOSpec}.


### Expected dependence on flight conditions\label{subsec:Expected-dependence-on}

```{r adjustP, include=FALSE}

rhozero <- 1013.25 * 100 / (287.05 * 288.15)
MRHO <- MachNumber(DZV$PSXC, DZV$QCXC) * 
          DZV$PSXC * 100 / (287.05 * (273.15 + DZV$ATX)) / rhozero
Param1$tau1 <- Param1$tau1 * (0.3 / mean(MRHO, na.rm = TRUE)) ^ -0.68
# Param1$tau2 <- Param1$tau2 * (0.3 / mean(MRHO, na.rm = TRUE)) ^ -0.68
MRHO <- MachNumber(DZ$PSXC, DZ$QCXC) * DZ$PSXC * 100 / 
        (287.05 * (273.15 + DZ$ATX)) / rhozero
# ParamHS$tau1 <- ParamHS$tau1 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ 0.68
# ParamHS$tau2 <- ParamHS$tau2 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ 0.68
# ParamHSB$tau1 <- ParamHSB$tau1 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ 0.68
# ParamHSB$tau2 <- ParamHSB$tau2 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ 0.68
ParamSH$tau1 <- ParamSH$tau1 * (0.3 / mean(MRHO, na.rm = TRUE)) ^ -0.68
ParamSF$tau1 <- ParamSF$tau1 * (0.3 / mean(MRHO, na.rm = TRUE)) ^ -0.68
# bestSH[3] <- bestSH[3] * (0.3 / mean(MRHO, na.rm = TRUE)) ^ 0.68
save(Param1, ParamSF, ParamSH, file = 'PAR.Rdata')

```


Based on measurements in a wind tunnel, @GoodrichTR5755 indicated
that the fast-response characteristic time $\tau_{1}$ for the unheated
sensor varies approximately as $\log(Z^{-0.68})$
where $Z=M\rho_{a}/\rho_{s}$ with $M$ the Mach number, $\rho_{a}$
the air density and $\rho_{s}$ the air density under standard conditions.
The mean value of $Z$ for the flight segments used to find the best-fit
parameters for the unheated sensor on the C-130 was $Z=0.3$, so this suggests that the first characteristic
time for that sensor is best represented by
\begin{equation}
\tau_{1}^{\prime}(Z)=\tau_{1}\left(\frac{0.3}{Z}\right)^{0.68}\,\,\,.{\label{eq:tau1prime}}
\end{equation}
For a flight segment at about \unit{11.5\,km} altitude, where the mean value
of $Z$ was 0.228, $\tau_1$ was found to
be \unit{0.037\,s}, exactly matching the prediction of \eqref{eq:tau1prime}, so 
this provides some limited support for that equation. 
For these reasons, the values of $\tau_1$ found in preceding sections
have been adjusted to a reference value of $Z=0.3$ in Table\ \ref{tab:Parameters}. 
For other conditions, it is suggested that the best estimate will
be to multiply $\tau_{1}$ by $(0.3/Z)^{0.68}$. 
\begin{table}[t]
\caption{Parameters for the time response of available temperature sensors
on the NSF/NCAR aircraft, adjusted to $Z=0.3$. For other conditions,
scale as represented for $\tau_{1}^{\prime}$ in 
Eq.\ \eqref{eq:tau1prime}. Parameters for the unheated sensor were also determined for measurements on the GV, with the result {0.73, 0.035, 0.36},
but the fit was less satisfactory than the one for the C-130 
so the fit in the table has been used in this paper for measurements from both aircraft.{\label{tab:Parameters}}}
\begin{tabular}{|c|c|c|c|}
\hline 
\bf{sensor} & $a$ & $\tau_{1}$ [s] & $\tau_{2}$ [s]\tabularnewline
\hline 
\hline 
"unheated" (Rosemount 102E4AL) & `r round(Param1$a, 2)` & `r format(Param1$tau1, digits=2, nsmall=3)` & `r round(Param1$tau2,2)`\tabularnewline
\hline 
"heated" (HARCO Model 100009-1 Deiced TAT)& `r format(ParamSH$a, digits=1, nsmall=1)` & `r format(ParamSH$tau1, digits=2, nsmall=2)` & `r format(ParamSH$tau2, digits=2, nsmall=2)`\tabularnewline
\hline 
\end{tabular}
\end{table}



## Response to a step change

```{r VOCALSrf03, include=FALSE, echo=FALSE, fig.height=4, fig.cap='Temperature measured during descent through an inversion capping the marine boundary layer, from VOCALS flight 3, starting at 8:13:50 UTC. The descent rate was approximately 5 m/s. The dashed red line shows a dry-adiabatic lapse rate in the marine boundary layer, and the dashed blue line is a reference line indicating the location of the top of the boundary layer.'}

Data <-
  getNetCDF(
    file.path(DataDirectory(), 'VOCALS/VOCALSrf03h.nc'),
    c(
      'PALT',
      'GGALT_NTL',
      'ATX',
      'ATRL',
      'ATRR',
      'ATWH',
      'DPXC',
      'PSXC',
      'QCXC',
      'TTRR'
    )
  )
Data %>% select(Time, PALT, ATRR) %>% 
  selectTime(81350, 81358) %>%
  select(ATRR) %>% 
  plot(
    type = 'b',
    pch = 20,
    ylab = bquote('ATRR [' * degree ~ 'C]'),
    xlab = 'sample number',
    col = 'blue'
  )
x <- 0:250
y <- 6.9 - x * 5 / 25 * 10 / 1000
lines(x, y, col = 'red', lty = 2)
abline(v = 10, col = 'black', lty = 2)
## Get Z for scaling the time constants:
rhozero <- 1013.25 * 100 / (287.05 * 288.15)
Z <- MachNumber(Data$PSXC, Data$QCXC) * 100 * Data$PSXC /
  (287.05 * (273.15 + Data$ATRR)) / rhozero
ParamS <- Param1
ParamS$tau1 <- ParamS$tau1 * (mean(Z, na.rm = TRUE) / 0.3) ^ -0.68
# ParamS$tau2 <- ParamS$tau2 * (mean(Z, na.rm = TRUE) / 0.3) ^ 0.68

```

\begin{figure}
```{r tfit, include=TRUE, echo=FALSE, fig.height=3.5, out.width = "8.3cm"}

## The code below was used to generate fig5.pdf:
if (generateFigures) {
  Data %>% select(Time, PALT, ATRR) %>%
    selectTime(81350, 81358) %>%
    select(ATRR) %>%
    plot(
      type = 'b',
      pch = 20,
      # ylab = bquote('temperature [' * degree ~ 'C]'),
      ylab = '',
      xlab = 'sample number @ 25 Hz',
      col = 'blue'
    )
  title(ylab = bquote('temperature [' * degree ~ 'C]'), line = 2.5, cex.lab = 1.2)
  x <- 0:200
  y <- 6.9 - x * 5 / 25 * 10 / 1000
  lines(x[11:200], y[11:200], col = 'red', lty = 2)
  lines(c(10, 10), c(y[11], 14.3), col = 'black', lty = 2)
  xx <- 0:2000
  yy <- 6.9 - xx * 5 / 250 * 10 / 1000
  yy[1:110] <- 14.30
  # calculate the response, given tau:
  tau <- 0.05
  taua <- 0.09
  tau2 <- 0.90
  tau2a <- 1.0
  a <- 0.62
  aa <- 0.65
  tau <- Param1$tau1
  # tau2 <- Param1$tau2
  tau2a <- 1.1
  taua <- 0.05
  a <- Param1$a
  a <- ParamS$a
  tau1 <- ParamS$tau1
  tau2 <- ParamS$tau2
  tau1a <- 0.06
  tau2a <- 1.3
  aa <- a - 0.02
  ym <- yy
  ymf <- ym
  yr <- yy
  yra <- yy
  for (i in 2:2000) {
    yr[i] <- yr[i - 1] + (yy[i] - yr[i - 1]) * 0.004 / tau2
    yra[i] <- yra[i - 1] + (yy[i] - yra[i - 1]) * 0.004 / tau2a
  }
  for (i in 2:2000) {
    ym[i] <-
      ym[i - 1] + (a * yy[i] + (1 - a) * yr[i] - ym[i - 1]) * 0.004 / tau1
    ymf[i] <-
      ymf[i - 1] + (aa * yy[i] + (1 - aa) * yra[i] - ymf[i - 1]) * 0.004 / tau1a
  }
  lines(xx / 10, ym, col = 'magenta', lwd = 2, lty = 1)
  # lines(xx / 10, ymf, col = 'darkorange', lwd = 2)
  lines(xx / 10,
        yr,
        col = 'brown',
        lwd = 2,
        lty = 2)
  legend('topright', legend=c('measured', 'predicted', 'support'),
         lwd=c(2, 2, 2), lty=c(1, 1, 2),
         col=c('blue', 'magenta', 'brown'),
         pch = c(19, NA, NA))
  box('outer', col = 'grey', lwd = 2.5)
} else {
  include_graphics('figure/fig5.pdf')
}

```
\caption{(blue dots): Temperature measured at \unit{25\,Hz} during descent through an inversion capping the marine boundary layer, from VOCALS flight\ 3, starting at 8:13:50 UTC. The dashed red line shows a dry-adiabatic lapse rate in the marine boundary layer, and the dashed black line is a reference line indicating the location of the top of the boundary layer. The  prediction using the parameters listed in the text is shown as the magenta line, mostly over the blue dots representing the measurements. The dashed brown line is the calculated temperature of the support that contacts the sensing wire.\label{fig:tfit}}
\end{figure}

Most prior studies 
have used sharp temperature changes in the
atmosphere, for example from climbs through the inversion at the top
of a boundary layer, to study the time response 
of airborne thermometers. A search of available 
climbs and descents through inversions capping the marine boundary
layer found that almost all have measurable structure and are not
discrete transitions, but there was one near-ideal example. 
Figure\ \ref{fig:tfit} shows the time history of the measured temperature
for \unit{8\,s} from VOCALS flight 3, when the aircraft
descended through the top of the marine boundary layer at approximately
\unit{5\,m\,s^{-1}}. The temperature structure in this case
was remarkably consistent with a near-constant temperature above the
inversion and a near-adiabatic lapse rate below the inversion. 
The suggested measurand history, if the discontinuity at the inversion
is discrete, is that shown by the dashed black and red lines.

The predicted time response from Eq.\ \eqref{eq:Tm} for the time constants listed in Table\ \ref{tab:Parameters}
for the unheated sensor (adjusted for air density
and flight speed) is shown as the magenta line in Fig.\ \ref{fig:tfit}.
The predicted response is consistent with the observations and supports
the approximate validity of the parameters determined from fits to
the response to dynamic heating.

```{r specialVSpec, cache = FALSE}

## Special version to show transfer-fn mod and delay setting scale_x
source('chunks/VSpecC.R')

```

## Uses of the transfer functions

The transfer functions have two potential uses: (i) to predict how
airborne thermometers will respond; and (ii) to correct measurements
to compensate for the time response of the sensors. The two sections
that follow are examples of these two uses. In the next section, the
transfer functions are used to assess how sensors respond to dynamic
heating and to develop appropriate correction schemes. Then the following
section applies the transfer functions to improve measurements of
the flux of sensible heat.

# Correcting for Dynamic Heating\label{sec:Correcting-for-Dynamic}

In conventional processing to calculate the ambient air temperature, 
an independently determined estimate of
dynamic heating is subtracted from the measured temperature, As
described in Sect.\ \ref{subsec:Dynamic-heating}. When the sensor
cannot respond to fluctuations in dynamic heating, this procedure
introduces errors and excess noise into the resulting air temperature.
Data processing should instead apply a correction that represents
how dynamic heating affects the measurement from the sensor,
not how it affects the recovery temperature. 

The approach followed here is to filter the dynamic-heating term so that only the actual sensor response to dynamic heating is subtracted from the measurement. This is made possible by the assumed linearity in response
of the sensor, which is required if this part of the response is to
be separated from the more general response to the combination of
dynamic heating and true fluctuations in temperature. This filtering
removes a significant source of erroneous fluctuations
present in many temperature measurements made from research aircraft.

```{r reinit, echo = FALSE, include = FALSE}

## This is a special version of CohPhase with features 
## not in the standard Ranadu version
source('chunks/CohP.R')
## The following commented statements are remnants from an earlier
## program, and should be deleted eventually.
# a <- 0.733 # 0.713
# tau1 <- 0.0308  # 0.0335
# tau2 <- 0.447
# Param <- list(
#   a = a,
#   tau1 = tau1,
#   tau2 = tau2
# )
# Param1 <- Param
# ParamSH <- Param
# ParamSH$a <- 0
# ParamSH$tau1 <- 0.05681167 
# ParamSH$tau2 <- 1.25078040
# ParamSF <- Param
# ParamSF$a <- 0.652
# ParamSF$tau1 <- 0.0295
# ParamSF$tau2 <- 1.04

```

\begin{figure}
```{r S15, include=TRUE, out.width = "8.3cm"}

DS <-
  getNetCDF('/Data/SOCRATES/SOCRATESrf15h.nc',
            standardVariables(c('ATF1', 'UXC')),
            60000,
            61500)
## Get the recovery factor from the attribute:
rf.txt <- attr(DS$ATF1, 'RecoveryFactor')
rf <- gsub('mach', 'MACHX', rf.txt)
rf <- gsub(' log', ' * log', rf)
rf <- gsub(' \\(', ' * \\(', rf)
rf <- with(DS, eval(parse(text=rf)))
rf <- SmoothInterp(rf, .Length = 0)
## RTF1 is not in the netCDF file so recalculate it:
DS$RTF1 <- DS$ATF1 + rf * DS$TASX^2 / 2010
DS$TASX <- SmoothInterp(DS$TASX, .Length = 0)
DS$Q <- rf * DS$TASX ^ 2 / 2010
DS$ATX <- DS$ATF1  ## Replace ATX, based on ATH1 in netCDF file

DS$RT <- DS$RTF1
DS$AT <- DS$ATF1
xlim <- c(0.08, 12)
## Using VSpecC only because it doesn't set scale_x and want to 
## set it specially here:
if (generateFigures) {
  DS %>% Rmutate(Tr = RT, Ta = AT) %>%
       select(Time, TASX, Tr, Ta, Q) %>%
       VSpecC(VLabel = c('recovery temp.', 'air temp.', 'dynamic heating'),
             spans = 99, xlim = xlim, ylim=c(1.e-5, 0.03)) +
       suppressWarnings(
       scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x, n = 2), 
                     labels = trans_format("log10", math_format(10^.x)))) +
      theme_WAC(1) +
      theme(legend.position=c(0.75, 0.75),
      plot.margin = unit(c(0.6, 0.6, 0.8, 0.6), "lines"),
      legend.background=element_rect(colour = 'black', size = 0.3,
                                     fill = "ivory"),
      legend.direction = "vertical", 
      legend.key.width = unit(1.3, 'lines'), 
      legend.key.height = unit(0.7, 'lines'),
      legend.text = element_text(size = 12)) +
      guides(colour = guide_legend(reverse = TRUE, '  legend:')) +
      ylab(bquote('spectral variance ' * nu * 'P(' * nu * ')'))
} else {
  include_graphics('figure/fig6.pdf')
}
DS$AT <- reviseDH(DS, Param1, rf)
DS$AT <- SmoothInterp(DS$AT, .Length = 0)

```
\caption{The weighted variance spectrum as a function of frequency $\nu$ for the recovery temperature measured by an unheated sensor. The spectra for the dynamic-heating term and for the calculated air temperature after this correction is applied are also shown.i\label{fig:S15}}
\end{figure}

Figure\ \ref{fig:S15} illustrates the problem. The measurements are
from a low-level flight segment over the ocean where other indications
are reasonably consistent with an inertial subrange. The slope of
the temperature variance spectrum (log spectral variance vs log frequency)
would be expected to be -5/3 (or
-2/3 in this plot where the spectrum is multiplied by the frequency).
The variance spectrum of the measured recovery temperature has a steeper
slope than this, as expected if the time response attenuates
the signal at higher frequencies. However, the variance spectrum for
the estimated ambient temperature appears to have a substantial amount
of high-frequency contamination. This matches the high-frequency portion
of the spectrum for dynamic heating. If the sensor measured the correct
recovery temperature, its spectrum should exceed that of the ambient
temperature (as is the case around 0.1 to \unit{0.5\,Hz}) so that the subtraction
of dynamic heating would produce smaller variance in the measured
ambient temperature. 

<!-- The transfer function shown in Fig.\ \ref{fig:LTsolution} indicates -->
<!-- that the response to fluctuations at \unit{5\,Hz} is only about 50\% of the -->
<!-- imposed amplitude, and at \unit{10\,Hz} the response is only about 35\%. -->
<!-- Furthermore, the phase at \unit{10\,Hz} is shifted by about $62^{\circ}$. -->
<!-- Subtracting the measured dynamic heating $Q$ as specified by Eq.\ \eqref{eq:DHterm} -->
<!-- to the measured recovery temperature will therefore over-correct -->
<!-- and produce erroneous fluctuations in the measured air temperature -->
<!-- unless $Q$ is filtered to represent the sensor response. -->



```{r LT, include = FALSE, fig.height=3.7, fig.cap = 'The amplitude and phase for the frequency domain transfer function of an unheated temperature sensor.'}

frq <- seq(0.01, 25, by = 0.01)
Phi <- rep(0, length(frq))
H <- rep(0, length(frq))
a <- 0.733 # 0.713
tau1 <- 0.0308  # 0.0335
tau2 <- 0.447
zeta <- -atan(2 * pi * frq * tau2)
b <- cos(zeta)
Param <- list(
  a = a,
  tau1 = tau1,
  tau2 = tau2,
  b = b,
  zeta = zeta,
  frq = frq
)
Param1 <- Param
Param3 <- Param
Param4 <- Param
Param3$tau1 <- 0.05
Param4$tau2 <- 0.6

## Use the Laplace-transform solution
H1 <- LTphase(frq, Param1)
cTF <- H1$Amp
phiTF <- H1$Phase
H3 <- LTphase(frq, Param3)
cTF3 <- H3$Amp
phiTF3 <- H3$Phase
H4 <- LTphase(frq, Param4)
cTF4 <- H4$Amp
phiTF4 <- H4$Phase
dfAP <- data.frame(
  'Time' = frq,
  'Amp' = cTF,
  'Phase' = phiTF
)
Panel2Label <- bquote('   Phase [' * degree ~ ']')
g <-
  ggplotWAC(
    dfAP,
    panels = 2,
    labelP = c(bquote('    ' ~ 'Amplitude'), Panel2Label)
  )
g <- g + xlab('frequency [Hz]') + ylab(bquote('transfer function H(' * nu ~ ')'))
g <-
  g + scale_x_log10(
    breaks = trans_breaks("log10", function(x) 10^x, n = 4),
    labels = trans_format("log10", math_format(expr = 10^.x))
  ) + xlab('frequency [Hz]')
g <- g + annotation_logticks(sides = 'tb')
g + theme_WAC(1) + theme(legend.position = c(0.3, 0.65))

```

The filtered response
has been obtained from the transfer function in three ways, by
integration of the differential equations applied to $Q$, by Fourier transforms using the transfer function, and by applying a digital filter designed from the transfer function. All produce almost equivalent results. 
The filtered dynamic-heating adjustment will be denoted $Q^{\prime}$, and the calculated air temperature then becomes
\begin{equation}
T^{\prime}_{a}(t)=T_{m}(t)-Q^{\prime}(t){\label{eq:QprimeCorr}}
\end{equation}
instead of Eq.\ \eqref{eq:recoveryTemperature}. 

<!-- One aspect of this correction needs emphasis, though. The correction -->
<!-- only removes the erroneous signal from dynamic heating and does not otherwise -->
<!-- correct for the response of the sensor. If the sensor response is corrected -->
<!-- as described in Appendix A, that correction adjust for the sensor response -->
<!-- to the recovery temperature, so in that case the unfiltered dynamic-heating -->
<!-- correction should be subtracted to obtain the measured air temperature. -->
<!-- That approach addresses the full response of the sensor, while the intent -->
<!-- of the present section is to emphasize the errors that result from -->
<!-- conventional processing. -->

<!-- The inverse Fourier -->
<!-- transform of the transfer function in the impulse function, and appropriate -->
<!-- moving-average coefficients can be found from the impulse response. -->
<!-- Those coefficients define a digital filter that represents the -->
<!-- sensor response. The filter used here for 25-Hz measurements -->
<!-- was determined at a frequency -->
<!-- resolution of \unit{(1/600)\,Hz}, from which only the initial 101 and trailing -->
<!-- 100 coefficients were retained and all other were set to zero. (For the slower heated sensor, a length of 301 samples was used.) Shifting -->
<!-- the negative-frequency components to the start of the array gave an -->
<!-- eight-second (or 12-s) moving-average filter that represents the response of the sensor. -->
<!-- After filtering, the result was then shifted forward in time by four seconds to compensate -->
<!-- for the delay. The arbitrary filter used here is not optimal, but this filter functions -->
<!-- reasonably for \unit{25\,Hz} measurements, as shown in ... -->

```{r designFilter, include=FALSE}

P <- Param1
NP <- 15000  ## Assume 10-min segment
df <- 25 / NP
df1 <- 1 / NP
frq <- c(seq(0, 12.5, by = df), seq(-12.5 + df,-df, by = df))
frq1 <- c(seq(0, 0.5, by = df1), seq(-0.5 + df1,-df1, by = df1))
NP <- length(frq)
NP1 <- length(frq1)
E <- LTphase(frq, P)
EH <- LTphase(frq, ParamSH)
EHB <- LTphase(frq, ParamSH)
EG <- LTphase(frq, ParamSF)
E1 <- LTphase(frq1, P)
EH1 <- LTphase(frq1, ParamSH)
EHB1 <- LTphase(frq1, ParamSH)
EG1 <- LTphase(frq1, ParamSF)
## --------------------------
G <- complex(modulus = E$Amp, argument = E$Phase * pi / 180)
NG <- length(G)
GT <- fft(G, inverse = TRUE) / NG  # get the impulse function
## Limit to 200 coefficients (8 s at 25 Hz)
Lshift <- 100
GT[(Lshift + 2):(NP - Lshift)] <- complex(modulus = 0)
GTT <- GT[GT != complex(modulus = 0)]
## Reorder:
GTT <- c(GTT[(Lshift + 2):length(GTT)], GTT[1:(Lshift + 1)])
AR <-
  signal::Arma(Re(GTT) / sum(Re(GTT)), 1) # Normalize to avoid <1% bias
## --------------------------
GG <- complex(modulus = EG$Amp, argument = EG$Phase * pi / 180)
GTG <- fft(GG, inverse = TRUE) / NG  # get the impulse function
GTG[(Lshift + 2):(NP - Lshift)] <- complex(modulus = 0)
GTTG <- GTG[GTG != complex(modulus = 0)]
## Reorder:
GTTG <- c(GTTG[(Lshift + 2):length(GTTG)], GTTG[1:(Lshift + 1)])
ARG <-
  signal::Arma(Re(GTTG) / sum(Re(GTTG)), 1) # Normalize to avoid <1% bias
## --------------------------
GH <- complex(modulus = EH$Amp, argument = EH$Phase * pi / 180)
NG <- length(GH)
GTH <- fft(GH, inverse = TRUE) / NG  # get the impulse function
## Limit to 300 coefficients (12 s at 25 Hz)
LshiftH <- 150
GTH[(LshiftH + 2):(NP - LshiftH)] <- complex(modulus = 0)
GTTH <- GTH[GTH != complex(modulus = 0)]
## Reorder:
GTTH <- c(GTTH[(LshiftH + 2):length(GTTH)], GTTH[1:(LshiftH + 1)])
ARH <- signal::Arma(Re(GTTH) / sum(Re(GTTH)), 1)
## --------------------------
GHB <- complex(modulus = EHB$Amp, argument = EHB$Phase * pi / 180)
NG <- length(GHB)
GTHB <- fft(GHB, inverse = TRUE) / NG  # get the impulse function
## Limit to 300 coefficients (12 s at 25 Hz)
LshiftH <- 150
GTHB[(LshiftH + 2):(NP - LshiftH)] <- complex(modulus = 0)
GTTHB <- GTHB[GTHB != complex(modulus = 0)]
## Reorder:
GTTHB <-
  c(GTTHB[(LshiftH + 2):length(GTTHB)], GTTHB[1:(LshiftH + 1)])
ARHB <- signal::Arma(Re(GTTHB) / sum(Re(GTTHB)), 1)
## --------------------------
G1 <- complex(modulus = E1$Amp, argument = E1$Phase * pi / 180)
NG1 <- length(G1)
GT1 <- fft(G1, inverse = TRUE) / NG1  # get the impulse function
## Limit to 20 coefficients (20 s at 1 Hz)
Lshift1 <- 10
GT1[(Lshift1 + 2):(NP1 - Lshift1)] <- complex(modulus = 0)
GTT1 <- GT1[GT1 != complex(modulus = 0)]
## Reorder:
GTT1 <- c(GTT1[(Lshift1 + 2):length(GTT1)], GTT1[1:(Lshift1 + 1)])
AR1 <- signal::Arma(Re(GTT1) / sum(Re(GTT1)), 1)
## --------------------------
GH1 <- complex(modulus = EH1$Amp, argument = EH1$Phase * pi / 180)
NG1 <- length(GH1)
GTH1 <- fft(GH1, inverse = TRUE) / NG1  # get the impulse function
LshiftH1 <- 10
GTH1[(LshiftH1 + 2):(NP1 - LshiftH1)] <- complex(modulus = 0)
GTTH1 <- GTH1[GTH1 != complex(modulus = 0)]
GTTH1 <-
  c(GTTH1[(LshiftH1 + 2):length(GTTH1)], GTTH1[1:(LshiftH1 + 1)])
ARH1 <- signal::Arma(Re(GTTH1) / sum(Re(GTTH1)), 1)
## --------------------------
GHB1 <- complex(modulus = EHB1$Amp, argument = EHB1$Phase * pi / 180)
NG1 <- length(GHB1)
GTHB1 <- fft(GHB1, inverse = TRUE) / NG1  # get the impulse function
LshiftH1 <- 10
GTHB1[(LshiftH1 + 2):(NP1 - LshiftH1)] <- complex(modulus = 0)
GTTHB1 <- GTHB1[GTHB1 != complex(modulus = 0)]
GTTHB1 <-
  c(GTTHB1[(LshiftH1 + 2):length(GTTHB1)], GTTHB1[1:(LshiftH1 + 1)])
ARHB1 <- signal::Arma(Re(GTTHB1) / sum(Re(GTTHB1)), 1)
## --------------------------
GG1 <- complex(modulus = EG1$Amp, argument = EG1$Phase * pi / 180)
NG1 <- length(GG1)
GTG1 <- fft(GG1, inverse = TRUE) / NG1  # get the impulse function
LshiftH1 <- 10
GTG1[(LshiftH1 + 2):(NP1 - LshiftH1)] <- complex(modulus = 0)
GTTG1 <- GTG1[GTG1 != complex(modulus = 0)]
GTTG1 <-
  c(GTTG1[(LshiftH1 + 2):length(GTTG1)], GTTG1[1:(LshiftH1 + 1)])
ARG1 <- signal::Arma(Re(GTTG1) / sum(Re(GTTG1)), 1)
save(AR,
     ARH,
     ARHB,
     ARG,
     AR1,
     ARH1,
     ARHB1,
     ARG1,
     Lshift,
     LshiftH,
     Lshift1,
     LshiftH1,
     file = 'AR.Rdata')
## --------------------------
# DF2$QF <- as.vector(signal::filter(AR, DF2$Q))
# DF2$QF <- ShiftInTime(DF2$QF, .shift=(-(Lshift + 1) * 40), .rate = 25)

```


<!-- ## Other filtering methods -->

<!-- Two other calculations can produce the appropriately filtered response -->
<!-- to dynamic heating $Q^{\prime}(t)$: -->

<!-- (1). Section\ \ref{sec:theTransferFn} showed that the transfer function -->
<!-- is represented reasonably by the solution to two coupled differential -->
<!-- equations. Numerical integration of those equations can then produce -->
<!-- the predicted response of the sensor to dynamic heating. The equations -->
<!-- from Sect.\ \ref{subsec:Theory}, revised to apply to dynamic heating, -->
<!-- are these: -->
<!-- \begin{equation} -->
<!-- \frac{dQ_{qs}(t)}{dt}=\frac{Q(t)-Q_{qs}(t)}{\tau_{2}}{\label{eq:Ts-1}} -->
<!-- \end{equation} -->
<!-- \begin{equation} -->
<!-- \frac{dQ^{\prime}(t)}{dt}=\frac{\left\{ aQ(t)+(1-a)Q_{qs}(t)\right\} -Q^{\prime}(t)}{\tau_{1}}{\label{eq:Tm-1}} -->
<!-- \end{equation} -->
<!-- where the first equation describes the effect of dynamic heating on -->
<!-- the support structure of the temperature sensor, leading to support-structure -->
<!-- variations in temperature of $Q_{qs}(t)$, and the second describes -->
<!-- the response of the sensing wire to the combined effects of this influence -->
<!-- on the support temperature and the dynamic-heating term. This separation -->
<!-- relies on the linearity of the underlying equations, which makes it -->
<!-- possible to represent the effect of dynamic heating in isolation from -->
<!-- real fluctuations in temperature. Euler integration of these differential -->
<!-- equations led to erroneous results at high frequency arising from -->
<!-- inadequate resolution in the integration, so a fourth-order Runge-Kutta -->
<!-- integration with dynamic adjustment of the time step, as described -->
<!-- by @cash1990variable, was used. -->

<!-- (2). The response specified by the frequency-domain transfer function $H(\nu)$ -->
<!-- can be realized by Fourier transforms, by first calculating the Fourier -->
<!-- transform of the dynamic-heating signal (here denoted $\hat{Q}(\nu)=\mathcal{F}(Q(t))$ -->
<!-- where $\mathcal{F}$ denotes the Fourier transform) and then using -->
<!-- the inverse Fourier transform ($\mathcal{F}^{-1}$) to estimate the -->
<!-- sensor response from $Q^{\prime}(t)=\mathcal{F}^{-1}(H(\nu)\hat{Q}(\nu))$. -->

\begin{figure}
```{r Integration, include=TRUE, echo=FALSE, fig.height = 3, out.width = "12cm", messages = FALSE}

# DS is the data.frame, which includes Q
ParamSF <- Param1  ## Use the C-130 values for the rest of this paper
a <- ParamSF$a
tau1 <- ParamSF$tau1
tau2 <- ParamSF$tau2
DS$RT <- DS$RTF1
DS$TsQ <- DS$RT
DS$Qp <- DS$Q
Rate <- attr (DS, 'Rate')
fS <- function(y, i) {
  (DS$Q[i] - y) / (Rate * tau2)
}
fM <- function (y, i) {
  (a * DS$Q[i] + (1 - a) * DS$TsQ[i] - y) / (Rate * tau1)
}
DS$TsQ <- rk4.integrate (fS, DS$Q[1], 1:nrow(DS))
DS$Qp <- rk4.integrate (fM, DS$Q[1], 1:nrow(DS))
DS$QF <- as.vector(signal::filter(ARG, DS$Q))
DS$QF <- ShiftInTime(DS$QF, .shift = -Lshift * 40, .rate = 25)
ft <- fft(DS$Q[1:(nrow(DS) - 1)])
df <- 25 / length(ft)
frq <- c(0, seq(df, 12.5, by = df), seq(-12.5 + df,-df, by = df))
ATF <- LTphase(frq, ParamSF)
H <- complex(modulus = ATF$Amp, argument = ATF$Phase * pi / 180)
ftq <- ft * H
DS$Qft <- c(Re(fft(ftq, inverse = TRUE) / length(ft)), 0)
DS$Qft[nrow(DS)] <- mean(DS$Qft, na.rm = TRUE)
g <- DS %>% selectTime(60200, 61300) %>%
  select(Time, TASX, Q, QF, Qft, Qp) %>%
  VSpecC(
    VLabel = c('Q', 'filter', 'FFT', 'DiffEq'),
    spans = 151,
    xlim = xlim,
    ylim = c(1.e-5, 0.01),
    lwd = c(1, 2.5, 1, 1),
    ltyp = c(1, 3, 1, 1)
  )
g <- g + theme_WAC(1) +
  # VSpecC(DS,
  #        'Qp',
  #        VLabel = 'DiffEq',
  #        spans = 151,
  #        add = g) + theme_WAC(1) +
  annotate(
    'text',
    x = 0.12,
    y = 0.005,
    label = '(a)',
    size = 5
  ) +
  suppressWarnings(scale_x_log10(
    breaks = trans_breaks("log10", function(x) 10^x, n = 2),
    labels = trans_format("log10", math_format(10^.x))
  )) +
  theme(
    legend.position = c(0.70, 0.80),
    plot.margin = unit(c(0.6, 0.6, 0.8, 0.6), "lines"),
    legend.background = element_rect(
      colour = 'black',
      size = 0.3,
      fill = "ivory"
    ),
    legend.direction = "vertical",
    legend.key.width = unit(2.5, 'lines'),
    legend.key.height = unit(0.5, 'lines'),
    legend.text = element_text(size = 8)
  ) +
  guides(size = guide_legend(reverse = TRUE, 'variable:')) +
  guides(linetype = guide_legend(reverse = TRUE, 'variable:')) +
  guides(colour = guide_legend(reverse = TRUE, 'variable:')) +
  ylab(bquote('spectral variance ' * nu * 'P(' * nu * ')')) +
  guides(colour = guide_legend('variable:'),
         linetype = guide_legend('variable:', 
                                 override.aes = list(size = c(1, 1, 2.5, 1))))
# suppressWarnings(print(g))
g1 = g
grid.newpage()
vp2 <-
  viewport(
    x = unit(0.75, 'npc'),
    width = unit(0.5, 'npc'),
    layout.pos.col = 2
  )
vp1 <-
  viewport(
    x = unit(0.25, 'npc'),
    width = unit(0.5, 'npc'),
    layout.pos.col = 1
  )
if (generateFigures) {
  print(g1, vp = vp1)
}
DS$AT <- DS$RT - DS$QF
## Save for other uses...
save(DS, file='DS.Rdata')
g2 <- DS %>% select(Time, TASX, AT, RT, ATF1) %>%
  VSpecC(
    VLabel = c(
      'air temp. with filt. Q',
      'msrd recovery temp.',
      'air temp. with std. Q'
    ),
    spans = 151,
    xlim = xlim,
    ylim = c(1.e-5, 0.05)
  ) +
  annotate(
    'text',
    x = 0.12,
    y = 0.02,
    label = '(b)',
    size = 5
  ) +
  suppressWarnings(scale_x_log10(
    breaks = trans_breaks("log10", function(x) 10^x, n = 2),
    labels = trans_format("log10", math_format(10^.x))
  )) +
  theme_WAC(1) +
  theme(
    legend.position = c(0.62, 0.75),
    plot.margin = unit(c(0.6, 0.6, 0.8, 0.6), "lines"),
    legend.background = element_rect(
      colour = 'black',
      size = 0.3,
      fill = "ivory"
    ),
    legend.direction = "vertical",
    legend.key.width = unit(0.8, 'lines'),
    legend.key.height = unit(0.5, 'lines'),
    legend.text = element_text(size = 8)
  ) +
  guides(colour = guide_legend(reverse = TRUE, 'variable:')) +
  guides(linetype = guide_legend(reverse = TRUE, 'variable:')) +
  ylab(bquote('spectral variance ' * nu * 'P(' * nu * ')'))
if (generateFigures) {
  print(g2, vp = vp2)
} else {
  include_graphics('figure/fig7.pdf')
}
grid.newpage()

```

\caption[For an unheated sensor, variance spectra for the
dynamic-heating term after application of three different filters.
Also, variance spectra for the measurement of recovery temperature
and ambient temperature calculated using the filtered dynamic-heating
term. ]{Variance spectra for an unheated sensor, for the
same flight segment used for Fig.\ \ref{fig:S15}.\protect \\
(a): The dynamic-heating term ("Q") and the filtered term
obtained by integrating the differential equations for the derivatives
("DiffEq"), by Fourier transformation with application of the
transfer function ("FFT"), or applying the digital filter ("filter").
The result for the latter is so close to that for "FFT" that it
is obscured in this plot.\protect \\ 
(b): The measurement of recovery temperature and ambient temperature
calculated using the filtered dynamic-heating term. The original
variable for ambient temperature based on standard processing 
("with std Q") is also shown.{\label{fig:Integration}}}

\end{figure}

Figure\ \ref{fig:Integration}a shows the variance spectra that result
from all three methods when applied to measurements from an unheated
sensor. The modified variance spectrum obtained
by integration of the underlying differential equations is shown as
the orange line labelled "DiffEq". The
dynamic-heating correction is appropriately attenuated at high frequency
after this integration. The results obtained after application of a
digital filter representing the transfer function, labeled "filter", or
after Fourier transformation, labelled "FFT", are overlapping so
as to be indistinguishable in this plot. These corrected estimates
of the dynamic heating are attenuated even more than the result from
numerical integration and are in better agreement with the predicted
effect of the transfer function, which for example predicts attenuation
of the variance spectrum by a factor of 0.096 for the component with
frequency \unit{10\,Hz}. The numerical integration was closer to the results
of the filter after the measurements were interpolated to \unit{125\,Hz} with
\unit{25\,Hz} smoothing, integrated, and then resampled to obtain \unit{25\,Hz} measurements, so the high-frequency discrepancy appears
to result from accumulating numerical errors in the integration. The equivalence
of the results from the digital filter and from Fourier transformation
with application of the transfer function supports the validity of
these results and suggests that these are preferable and equivalent
methods for filtering dynamic heating to match the response of the
temperature sensor.

A revised estimate of the ambient air temperature was calculated using
Eq.\ \eqref{eq:QprimeCorr} and the corrected dynamic-heating term $Q^{\prime}$.
The spectral variance for this air temperature, shown in Fig.\ \ref{fig:Integration}b
as the blue line, is improved considerably at high frequency vs.\ that
using the standard correction.

```{r WECANX, include=TRUE, echo=FALSE}

DWECAN <- getNetCDF('/Data/WECAN/WECANrf17h.nc', standardVariables(c('RTH1',
                    'ATH1', 'RTF1', 'ATF1')), 180400, 183500) # 182600,182900)
DWECAN$Q <- DWECAN$TASX^2 / 2010
SB <- 50
Z <- capture.output (
       Vr <- SmoothInterp(detrend (DWECAN[, c('Time', 'RTH1')]), .Length = 0))
Z <- capture.output (
       VrC <- SmoothInterp(detrend (DWECAN[, c('Time', 'Q')]), .Length = 0))
Rate <- attr(DWECAN, 'Rate')
vcv <- cbind(ts(Vr, frequency = Rate), ts(VrC, frequency = Rate))
P <- spec.pgram(vcv, detrend = FALSE, fast = TRUE, plot = FALSE, spans = 25)
dfH <- data.frame(P$coh, log(P$freq))
pfH <- binStats (dfH, bins = SB)
RXH <- CohP(DWECAN, 'RTH1', 'Q', plotType = 'Ranadu', smoothBins = SB)
phaseH <- rep(0, SB)
nphaseH <- rep(0, SB)
phase2H <- rep(0, SB)
arH <- rep(0, SB)
ar2H <- rep(0, SB)
narH <- rep(0, SB)
RXH$P.spec...1.[RXH$P.spec...1. < 0] <- 0
for (i in 2:nrow(RXH)) {
  phaseH[RXH$BIN.1[i]] <- phaseH[RXH$BIN.1[i]] + RXH$P.phase[i]
  nphaseH[RXH$BIN.1[i]] <- nphaseH[RXH$BIN.1[i]] + 1
  phase2H[RXH$BIN.1[i]] <- phase2H[RXH$BIN.1[i]] + RXH$P.phase[i]^2 
  arH[RXH$BIN.1[i]] <- arH[RXH$BIN.1[i]] + 
             sqrt(RXH$P.spec...1.[i] / RXH$P.spec...2.[i])
  ar2H[RXH$BIN.1[i]] <- ar2H[RXH$BIN.1[i]] + 
             (RXH$P.spec...1.[i] / RXH$P.spec...2.[i])
  narH[RXH$BIN.1[i]] <- narH[RXH$BIN.1[i]] + 1
}
narH[narH <= 0] <- 1
nphaseH[nphaseH == 0] <- 1
mphaseH <- phaseH / nphaseH
mphase2H <- phase2H / nphaseH
sdpH <- sqrt(mphase2H - mphaseH^2)
mphaseH <- mphaseH * 180 / pi
sdpH <- sdpH * 180 / pi
sdpH <- sdpH * 2 / sqrt(nphaseH)
arH <- arH / narH
ar2H <- ar2H / narH
sdrH <- ar2H - arH^2
sdrH[sdrH < 0] <- 0
sdrH <- sqrt(sdrH) * 2 / sqrt(narH)

```

In the case of the heated sensors, the revision is still more significant
because they respond more slowly. Figure\ \ref{fig:HarcoQ}a shows
the result of filtering the dynamic-heating term for a heated
sensor. The result of integration ("DiffEq") and the digital filter
("filter") are almost identical so there is no evidence of the
numerical problems that were encountered with the integration for
the unheated sensor. The difference vs.\ the original is
quite dramatic even at \unit{1\,Hz}, and the errors are significant for all
frequencies above about \unit{0.1\,Hz}. Because either corrected variance
spectrum represents how the temperature sensor responds to the actual
fluctuations, subtracting the actual fluctuations in dynamic heating
instead of the filtered fluctuations introduces substantial erroneous
variability into the calculated air temperature.

\begin{figure}
```{r HarcoQ, include=TRUE, echo=FALSE, fig.height = 3, out.width = "12cm", messages = FALSE}

a <- 0.733
tau1 <- 0.299
tau2 <- 0.433
DWECAN$RT <- SmoothInterp(DWECAN$RTH1, .Length = 0)
DWECAN$TsQ <- DWECAN$RT
DWECAN$Q <-
  SmoothInterp(DWECAN$Q, .Length = 0)  ## avoid missing values
Rate <- attr (DWECAN, 'Rate')
rhozero <- 1013.25 * 100 / (287.05 * 288.15)
MRHO <- MachNumber(DWECAN$PSXC, DWECAN$QCXC) * 
        DWECAN$PSXC * 100 / (287.05 * (273.15 + DWECAN$ATX)) / rhozero
MRHO <- SmoothInterp(MRHO, .Length = 0)
a <- ParamSH$a
## Note that these are variable:
tau1 <- ParamSH$tau1 * (MRHO / 0.3) ^ 0.68
tau2 <- rep(ParamSH$tau2, length(MRHO))
# tau2 <- ParamSH$tau2 * (MRHO / 0.3) ^ 0.68
Rate <- attr (DWECAN, 'Rate')
DWECAN$TsQ <- DWECAN$Q
DWECAN$Qp <- DWECAN$Q
fS <- function(y, i) {
  (DWECAN$Q[i] - y) / (Rate * tau2[i])
}
fM <- function (y, i) {
  (a * DWECAN$Q[i] + (1 - a) * DWECAN$TsQ[i] - y) / (Rate * tau1[i])
}
DWECAN$TsQ <- rk4.integrate (fS, DWECAN$Q[1], 1:nrow(DWECAN))
DWECAN$Qp <- rk4.integrate (fM, DWECAN$Q[1], 1:nrow(DWECAN))
DWECAN$QF <- as.vector(signal::filter(ARH, DWECAN$Q))
DWECAN$QF <- ShiftInTime(DWECAN$QF, .shift = -LshiftH * 40, .rate = 25)
g1 <- DWECAN %>% select(Time, TASX, Q, QF, Qp) %>%
  VSpecC(
    VLabel = c('Q', 'filter', 'DiffEq'),
    xlim = xlim,
    ylim = c(1.e-6, 0.4),
    lwd = c(1, 2.5, 1),
    ltyp = c(1, 3, 1)
  ) +
  annotate(
    'text',
    x = 0.18,
    y = 0.05,
    label = '(a)',
    size = 5
  ) +
  suppressWarnings(scale_x_log10(
    breaks = trans_breaks("log10", function(x)
      10 ^ x, n = 2),
    labels = trans_format("log10", math_format(10 ^ .x))
  )) +
  theme_WAC(1) + theme(legend.text = element_text(size = 12)) +
  theme(
    legend.position = c(0.70, 0.80),
    plot.margin = unit(c(0.6, 0.6, 0.8, 0.6), "lines"),
    legend.background = element_rect(
      colour = 'black',
      size = 0.3,
      fill = "ivory"
    ),
    legend.direction = "vertical",
    legend.key.width = unit(2.5, 'lines'),
    legend.key.height = unit(0.5, 'lines'),
    legend.text = element_text(size = 8)
  ) +
  guides(size = guide_legend(reverse = TRUE, 'variable:')) +
  guides(linetype = guide_legend(reverse = TRUE, 'variable:')) +
  guides(colour = guide_legend(reverse = TRUE, 'variable:')) +
  guides(colour = guide_legend('variable:'),
         linetype = guide_legend('variable:', 
                                 override.aes = list(size = c(1, 2.5, 1)))) +
  ylab(bquote('spectral variance ' * nu * 'P(' * nu * ')'))
grid.newpage()
vp2 <-
  viewport(
    x = unit(0.75, 'npc'),
    width = unit(0.5, 'npc'),
    layout.pos.col = 2
  )
vp1 <-
  viewport(
    x = unit(0.25, 'npc'),
    width = unit(0.5, 'npc'),
    layout.pos.col = 1
  )

if (generateFigures) {
  print(g1, vp = vp1)
}

DWECAN$AT <- DWECAN$RT - DWECAN$QF
save(DWECAN, file = 'DWECAN.Rdata')
g2 <- DWECAN %>% select(Time, TASX, AT, RTH1, ATH1) %>%
  VSpecC(
    VLabel = c(
      'air temp. with filt. Q',
      'msrd recovery temp.',
      'air temp. with std. Q'
    ),
    xlim = xlim,
    ylim = c(1.e-6, 0.8)
  ) +
  annotate(
    'text',
    x = 0.15,
    y = 0.1,
    label = '(b)',
    size = 5
  ) +
  suppressWarnings(scale_x_log10(
    breaks = trans_breaks("log10", function(x) 10^x, n = 2),
    labels = trans_format("log10", math_format(10 ^ .x))
  )) +
  theme_WAC(1) +
  theme(
    legend.position = c(0.60, 0.8),
    plot.margin = unit(c(0.6, 0.6, 0.8, 0.6), "lines"),
    legend.background = element_rect(
      colour = 'black',
      size = 0.3,
      fill = "ivory"
    ),
    legend.direction = "vertical",
    legend.key.width = unit(1, 'lines'),
    legend.key.height = unit(0.5, 'lines'),
    legend.text = element_text(size = 8)
  ) +
  guides(colour = guide_legend('variable:'),
         linetype = guide_legend('variable:')) +
  ylab(bquote('spectral variance ' * nu * 'P(' * nu * ')'))

if (generateFigures) {
  suppressWarnings(print(g2, vp = vp2))
} else {
  include_graphics('figure/fig8.pdf')
}

grid.newpage()

```

\caption[Variance spectra for the heated temperature sensor: The unmodified dynamic-heating
term and two filtered terms. Also, the air temperature as modified
by filtering the dynamic-heating term.]{Variance spectra for a heated temperature sensor.\protect \\
Left, (a): The unmodified dynamic-heating term ("Q") and the two
filtered terms. The results from solving the differential equations
("DiffEq") or from application of the digital filter ("filter")
are overlapping and indistiguishable in this figure.\protect \\
Right, (b): The air temperature as modified by filtering the dynamic-heating
term (blue line). The other plotted spectra are for the measured recovery
temperature and the air temperature with the conventional dynamic-heating
correction.{\label{fig:HarcoQ}}}
\end{figure}

Figure\ \ref{fig:HarcoQ}b shows how this affects the spectral variance
of the measured air temperature. The slow response of this sensor
causes the measured recovery temperature (green line) to have very
low spectral variance when the frequency is above \unit{1\,Hz}, so the variance
in the standard air-temperature measurement in this frequency range
is almost entirely caused by erroneous adjustment for fluctuations
in dynamic heating to which the sensor does not respond. The correction
procedure using a filtered dynamic-heating correction removes this
excess spectral variance and produces a signal where the variance
for frequencies above about \unit{0.1\,Hz} arises primarily from variance
in the measured recovery temperature. The variance spectrum for the
conventionally processed temperature looks approximately as might
be expected in an inertial subrange, but the variance above about
\unit{0.5\,Hz} is a false signal that does not arise from real variance in
temperature. It therefore becomes very important to use this revised
processing scheme to avoid erroneous measurements even for changes
occurring over \unit{5\,s} or more. The reasonable appearance of the variance
spectrum for the standard result is misleading because the measurement
is not responding to real fluctuations in air temperature at high
frequency. The measurement with filtered dynamic heating is a better
indication of the measured fluctuations. 

\begin{figure}
```{r ATATF, include=TRUE, echo=FALSE, fig.height=3,  out.width = "12cm", messages = FALSE}

generateSave <- generateFigures
# generateFigures <- TRUE  ## temporary; reset below
if (file.exists ('./DVOCALS.Rdata')) {
  load (file = './DVOCALS.Rdata')
  DVOCALS <- D
  DVOCALS$ATC <- DVOCALS$AT
  DVOCALS$original <- DVOCALS$ATRR
  DVOCALS$corrected <- DVOCALS$ATC
  ga <- DVOCALS %>% select(Time, original, corrected) %>%
    selectTime(80100, 80104) %>%
    ggplotWAC(col = c('red', 'black'), lwd = c(0.5, 1.0)) +
    theme_WAC(1) +
    ylab(bquote('temperature [' * degree * 'C]')) +
    xlab('time [s]') +
    theme(legend.direction = "vertical",
          legend.position = c(0.5, 0.25),
          legend.key.width = unit(1, 'lines'),
          legend.key.height = unit(0.5, 'lines'),
          legend.text = element_text(size = 8),
          plot.margin = unit(c(0.6, 0.6, 0.8, 0.6), "lines")) +
    guides(
      color = guide_legend("air T:"),
      size = guide_legend("air T:"),
      linetype = guide_legend("air T:")
    )
  grid.newpage()
  vp2 <-
    viewport(
      x = unit(0.75, 'npc'),
      width = unit(0.5, 'npc'),
      layout.pos.col = 2
    )
  vp1 <-
    viewport(
      x = unit(0.25, 'npc'),
      width = unit(0.5, 'npc'),
      layout.pos.col = 1
    )
  
  if (generateFigures) {
    print (ga + annotate(
      'text',
      x = DVOCALS$Time[getIndex(DVOCALS, 80100)] + 0.55,
      y = 15.092,
      label = '(a)',
      size = 5
    ), vp = vp1)
  }
}
DWECAN$MACHX <- SmoothInterp (DWECAN$MACHX, .Length = 0)
DWECAN$ATH1 <- SmoothInterp (DWECAN$ATH1, .Length = 0)
alphaR2 <-
  0.988 + 0.053 * log10(DWECAN$MACHX) +
  0.090 * (log10(DWECAN$MACHX)) ^ 2 +
  0.091 * (log10(DWECAN$MACHX)) ^ 3
DWECAN$corrected <- DWECAN$ATH1 + alphaR2 * (DWECAN$Q - DWECAN$Qp)
DWECAN$original <- DWECAN$ATH1
gb <- DWECAN %>% select(Time, original, corrected) %>%
  selectTime(181300, 181320) %>%
  ggplotWAC(col = c('red', 'black'), lwd = c(0.5, 1.0)) +
  theme_WAC(1) +
  ylab(bquote('temperature [' * degree * 'C]')) +
  xlab('time [s]') + 
  theme(legend.direction = 'vertical',
        legend.position = c(0.65, 0.85),
        legend.key.width = unit(1, 'lines'),
        legend.key.height = unit(0.5, 'lines'),
        legend.text = element_text(size = 8),
        axis.title.y = element_blank(),
        plot.margin = unit(c(0.6, 0.6, 0.8, 0.6), "lines")) +
  guides(
    color = guide_legend("air T:"),
    size = guide_legend("air T:"),
    linetype = guide_legend("air T:")
  )
if (generateFigures) {
  print(gb + annotate(
    'text',
    x = DWECAN$Time[getIndex(DWECAN, 181300)] + 4.2,
    y = 17.12,
    label = '(b)',
    size = 5
  ), vp = vp2)
} else {
  include_graphics('figure/fig9.pdf')
}
generateFigures <- generateSave

```

\caption[Comparison of the original calculated air temperature and the same temperature
after filtering the dynamic-heating correction, for an unheated sensor and a heated sensor. ]{Comparison of the original calculated air temperature and the same temperature
after filtering the dynamic-heating correction:\protect \\
(left): An unheated sensor; (right): A heated sensor. {\label{fig:ATATF}}}
\end{figure}

Fig.\ \ref{fig:ATATF}a
illustrates the removal of erroneous structure by filtering for
the unheated sensor, and Fig.\ \ref{fig:ATATF}b
shows a similar example for the heated sensor. These figures
illustrate that the erroneous fluctuations in the uncorrected measurements
can be important in many potential uses of these measurements and
should be removed as part of standard processing. The effect is particularly
significant for the heated sensor, for which 
the conventionally processed temperature has
large fluctuations
that are caused by subtraction of fluctuations in dynamic
heating to which the sensor does not respond. These do not arise 
from real fluctuations in ambient air temperature.

# The Flux Density of Sensible Heat
## Outline of the correction procedure\label{subsec:Outline-correction}

<!-- The measured air temperature $T_{a}$ is normally calculated by subtracting -->
<!-- a dynamic-heating correction $Q$ from the measurement: $T_{a}=T_{m}-Q$ -->
<!-- where $T_{m}$ is the measured recovery temperature. However, here -->
<!-- it is desired to correct the resulting measurement on the basis of -->
<!-- a known transfer function $H(\nu)$ that describes how the sensor -->
<!-- responds to the input. That input (the measurand) is the recovery -->
<!-- temperature $T_{r}=T_{a}+Q$, which differs from the measurement $T_{m}$ -->
<!-- when the sensor output lags behind the input. The correction procedure -->
<!-- therefore should correct the measurement $T_{m}$ to obtain an improved -->
<!-- estimate of the recovery temperature and then use that corrected estimate -->
<!-- of the recovery temperature to find the air temperature. -->

Most past studies of temperature-sensor response (e.g., @mccarthy1973method,
@nicholls1978measurements, @InverarityJTech2000) applied
corrections to the air temperature after correction for dynamic
heating. That applies the full correction for dynamic heating $Q$
without considering that the sensor may respond only partly to high-frequency
fluctuations in $Q$, which was shown in Sect.\ \ref{sec:Correcting-for-Dynamic}
to lead to erroneous noise in the air temperature. Then that noise
is amplified by the correction procedure. These errors are avoided
if corrections are applied instead to the measurement of the recovery
temperature. The amplification of signals by application of the 
transfer function restores
the fluctuations produced by dynamic heating, and those fluctuations
are then removed by subtracting the measured (unfiltered) dynamic heating
term from the corrected recovery temperature. 

The eddy-correlation calculation used here starts with the Fourier
representation of the measured recovery temperature. (Fourier transforms are
denoted here by the symbol "\ $\widehat{~}$\ " over variables.)
The measurement is related to the true recovery temperature via
$\hat{T}_{m}(\nu)=H(\nu)\hat{T}_{r}(\nu)$ where $H(\nu)$ is the
frequency-domain transfer function.
The true recovery temperature will be the
inverse Fourier transform of $\hat{T}_{r}=\hat{T}_{m}(\nu)/H(\nu)$. The Fourier representation of the air temperature is then
$\hat{T}_{a}=\hat{T}_{m}(\nu)/H(\nu)-\hat{Q}(\nu)$, 
which includes both the correction for time response and the subtraction of dynamic heating.
Multiplication
by the complex conjugate of the Fourier representation of the updraft
gives the cospectrum representing the flux of sensible heat, with
an appropriate scale factor as specified in Eq.\ \eqref{eq:heatFlux}.
The resulting cospectrum is then integrated over an appropriate wavelength
range to produce the measured flux density of sensible heat. This will normally exclude wavelengths greater
than a few kilometers so that the estimate represents 
the turbulent contribution.


```{r initial3, echo=FALSE, include=FALSE}

plotRibbon <- TRUE
xlim <- c(0.01, 15)
ylim <- c(0.001, 80)

plotCS <- function(CS,
                   Units,
                   spans = 149,
                   fL,
                   wavelengthLimit = 2000,
                   smoothBins = 100,
                   xlim = c(0.01, 15),
                   ylim = c(0.001, 80),
                   printTitle = TRUE,
                   CSprevious = NA,
                   plotRibbon = TRUE,
                   vwp = NA,
                   project = NA) {
  ylab <- bquote(nu * " x flux cospectrum [" * .(Units) * "]")
  CSogive <- cumsum(CS$cospec) * CS$freq[1]
  CSogive <- CSogive[length(CSogive)] - CSogive
  CS$ogive <- CSogive
  CS$cospec <- SmoothInterp(CS$cospec, .Length = 0)  # treat NAs
  s25 <- spans %/% 25
  s10 <- spans %/% 10
  s3 <- spans %/% 3
  s25 <- s25 + (s25 + 1) %% 2
  s10 <- s10 + (s10 + 1) %% 2
  s3 <- s3 + (s3 + 1) %% 2
  CS$cospec <-
    zoo::rollapply(CS$cospec,
                   FUN = mean,
                   fill = 'extend',
                   width = s25)
  CS$cospec[CS$freq > 0.01] <-
    zoo::rollapply(CS$cospec,
                   FUN = mean,
                   fill = 'extend',
                   width = s10)[CS$freq > 0.01]
  CS$cospec[CS$freq > 0.1] <-
    zoo::rollapply(CS$cospec,
                   FUN = mean,
                   fill = 'extend',
                   width = s3)[CS$freq > 0.1]
  CS$cospec[CS$freq > 1] <-
    zoo::rollapply(CS$cospec,
                   FUN = mean,
                   fill = 'extend',
                   width = spans)[CS$freq > 1]
  FluxL <- CSogive[which(CS$freq > fL)[1]]
  Flux <- CSogive[which(CS$freq > 0.01)[1]]
  attr(CS, 'Flux') <- Flux
  attr(CS, 'FluxL') <- FluxL
  attr(CS, 'wavelengthLimit') <- wavelengthLimit
  ## Construct the plot:
  CS$ncospec <- -1 * CS$cospec
  ## Weight by frequency for log-abscissa plot:
  CS$cospec <- CS$cospec * CS$freq
  CS$ncospec <- CS$ncospec * CS$freq
  if (smoothBins > 5) {
    BS <-
      binStats(data.frame(CS$cospec, log(CS$freq)), bins = smoothBins)
    BS$nybar <- -1 * BS$ybar
    BS$ybar[BS$ybar < 0] <- NA
    BS$nybar[BS$nybar < 0] <- NA
    BS$xc <- exp(BS$xc)
    attr(CS, 'smoothed data.frame') <- BS
    bse <-
      data.frame(
        x = BS$xc,
        ymin = BS$ybar - BS$sigma,
        ymax = BS$ybar + BS$sigma,
        yminN = BS$nybar - BS$sigma,
        ymaxN = BS$nybar + BS$sigma
      )
  }
  if (smoothBins > 5) {
    bse$ymin[bse$ymin < ylim[1]] <- ylim[1]
    bse$yminN[bse$yminN < ylim[1]] <- ylim[1]
  }
  g <- ggplot(data = CS, aes(x = freq))
  g <-
    g + geom_path(aes(
      y = cospec,
      colour = 'cospectrum',
      linetype = 'cospectrum'
    ))
  g <-
    g + geom_path(aes(
      y = ncospec,
      colour = '-cospectrum',
      linetype = '-cospectrum'
    ))
  g <-
    g + geom_path(aes(
      y = ogive,
      colour = 'exceedance',
      linetype = 'exceedance'
    ),
    lwd = 1.2)
  if (is.data.frame(CSprevious)) {
    g <- g + geom_path(
      data = CSprevious,
      aes(x = freq, y = ogive,
          colour = 'exceedance'),
      lty = 2,
      lwd = 1.2
    )
    if ('ogive2' %in% names(CSprevious)) {
      g <- g + geom_path(
        data = CSprevious,
        aes(
          x = freq,
          y = ogive2,
          colour = 'generated',
          linetype = 'generated'
        ),
        lwd = 1.3
      )
    }
  }
  if (smoothBins > 5) {
    g <-
      g + geom_point(
        data = BS,
        aes(x = xc, y = ybar),
        colour = 'black',
        pch = 19
      )
    g <-
      g + geom_point(
        data = BS,
        aes(x = xc, y = nybar),
        colour = 'darkred',
        pch = 19
      )
    if (plotRibbon) {
      # GeomRibbon$handle_na <- function(data, params) {  data }
      g <- g + geom_ribbon(
        data = bse,
        aes(
          x = x,
          ymin = ymin,
          ymax = ymax
        ),
        fill = 'blue',
        alpha = 0.2,
        show.legend = FALSE,
        inherit.aes = FALSE,
        na.rm = FALSE
      )
      g <-
        g + geom_ribbon(
          data = bse,
          aes(
            x = x,
            ymin = yminN,
            ymax = ymaxN
          ),
          fill = 'red',
          alpha = 0.2,
          show.legend = FALSE,
          inherit.aes = FALSE,
          na.rm = FALSE
        )
    }
  }
  g <-
    g + geom_path(data = data.frame(x = rep(fL, 2), y = ylim),
                  aes(x = x, y = y),
                  linetype = 2)
  g <-
    g + scale_x_log10(
      breaks = trans_breaks("log10", function(x)
        10 ^ x, n = 4),
      #limits = xlim,
      labels = trans_format("log10", math_format(10 ^ .x))
    ) +
    scale_y_log10(
      breaks = trans_breaks("log10", function(x)
        10 ^ x, n = 4),
      #limits = ylim,
      labels = trans_format("log10", math_format(10 ^ .x))
    ) +
    annotation_logticks(sides = 'trbl') +
    coord_cartesian(xlim = xlim, ylim = ylim)
  g <- g + xlab('frequency [Hz]') + ylab(ylab)
  g <- suppressWarnings(g + scale_colour_manual (
    name = '',
    values = c(
      'cospectrum' = 'blue',
      '-cospectrum' = 'red',
      'exceedance' = 'brown',
      'generated' = 'forestgreen'
    )
  ))
  g <-
    g + scale_linetype_manual (
      name = '',
      values = c(
        'cospectrum' = 1,
        '-cospectrum' = 1,
        'exceedance' = 1,
        'generated' = 4
      )
    )
  g <-
    g + guides(col = guide_legend(reverse = TRUE),
               linetype = guide_legend(reverse = TRUE))
  ttl <-
    bquote(
      'Total flux ' ~ .(format(Flux, digits = 3)) ~ .(Units) * '; partial <' *
        .(format((
          wavelengthLimit / 1000
        ), digits = 2)) ~ 'km:' ~ .(format(FluxL, digits = 3)) ~ .(Units)
    )
  if (printTitle) {
    g <- g + labs(title = ttl)
  }
  if (!is.na(project)) {
    g <-
      g + annotate(
        'text',
        x = 4,
        y = 7,
        label = paste0('(', project, ')'),
        size = 4
      )
  }
  if (is.na(vwp[1])) {
    suppressWarnings(print(
      g + theme_WAC(1) + theme(plot.title = element_text(size = 12)) +
        theme(legend.position = c(0.5, 0.91))
    ))
  } else {
    suppressWarnings(print(
      g + theme_WAC(1) + 
        theme(
        plot.margin = unit(c(0.6, 0.6, 0.8, 0.6), "lines"),
          plot.title = element_text(size = 12),
          axis.title.y = 
          element_text (face='plain', size=11, color='blue', 
                        margin=margin(0,10,0,0), angle=90),
        legend.position = c(0.55, 0.90)), vp = vwp)
    )
  }
  g <<- g  ## Save for adding uncorrected cospec for debugging...
  return(CS)
}

```

## Examples of Measured Cospectra and Fluxes

```{r SOCrf15, include=FALSE}

load(file = 'AR.Rdata')  ## get ARG, etc. (remnant; not needed)
DS <-
  getNetCDF('/Data/SOCRATES/SOCRATESrf15h.nc',
            standardVariables(c('ATF1')),
            55500,
            62000)
Rate <- attr(DS, 'Rate')
rhozero <- 1013.25 * 100 / (287.05 * 288.15)
MRHO <- DS$MACHX * DS$PSXC * 100 /
  (287.05 * (273.15 + DS$ATX)) / rhozero
ParamFS1 <- ParamSF
ParamFS1$tau1 <-
  ParamFS1$tau1 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ -0.68
ParamFS1$tau2 <-
  ParamFS1$tau2 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ -0.68
DS$TASX <- SmoothInterp(DS$TASX, .Length = 0)
DS$Q <- DS$TASX ^ 2 / 2010
DS$ATX <- DS$ATF1
# DS$AT <- reviseDH(DS, ParamFS1, rf)  # rf was calculated in an earlier code chunk
## Replace this by the filtered result:
## Recalculate AT using the dynamic-heating filter:
DS$ATX <- SmoothInterp(DS$ATX, .Length = 0)
DS$PSXC <- SmoothInterp(DS$PSXC, .Length = 0)
DS$QCXC <- SmoothInterp(DS$QCXC, .Length = 0)
DS$MACH <- SmoothInterp(MachNumber(DS$PSXC, DS$QCXC), .Length = 0)
DS$alphaR <- RecoveryFactor(DS$MACH, 'UNHEATED')
DS$Q <- DS$TASX ^ 2 / (2 * SpecificHeats()[1])
DS$QF <- as.vector(signal::filter(ARG, DS$Q))
DS$QF <- ShiftInTime(DS$QF, .shift = -Lshift * 40, .rate = 25)
DS$AT <- DS$ATX + DS$alphaR * (DS$Q - DS$QF)
DS$AT <- SmoothInterp(DS$AT, .Length = 0)
DS$RTF1 <-
  DS$ATF1 + DS$alphaR * DS$Q  ## This variable isn't in the available file
DS$RTF1 <- SmoothInterp(DS$RTF1, .Length = 0)
## Estimate the corrected recovery temperature:
aV <- ParamFS1$a
tau1V <- ParamFS1$tau1
tau2V <- ParamFS1$tau2
DS$DTMDT <- c(0, diff(DS$RTF1, 2), 0) * Rate / 2
# Eq. Ts3
fSS <- function(y, i) {
  ((1 / aV) * (tau1V * DS$DTMDT[i] + DS$RTF1[i] - (1 - aV) * y) - y) / 
  (Rate * tau2V)
}

DS$Ts <- rk4.integrate (fSS, DS$RTF1[1], 1:nrow(DS))
DS$RTC <- (1 / aV) * (tau1V * DS$DTMDT + DS$RTF1 - (1 - aV) * DS$Ts)
DS$ATC <- DS$RTC - DS$alphaR * DS$QF
## Small time adjustment seems useful?
# DS$Q <- ShiftInTime(DS$Q, .shift = -25, .rate = 25)
DS$RHOCP <- 100 * DS$PSXC / (287.05 * 278) * 1005
DS$RHOCP <- SmoothInterp(DS$RHOCP, .Length = 0)

```

Two examples of measured cospectra illustrate the effect of the correction.
The first example is from the SOCRATES project, 24 January
2018, 6:00:00 to 6:15:00\ UTC, and the second is from the CSET project,
1 August 2015, from various segments from 16:00:00 to 19:15:00\ UTC\. 
The flight segments were all at low level (\unit{150\,m}) in the marine
boundary layer over the Pacific Ocean. An unheated
sensor was used to measure temperature on these flights. In each case,
the cospectra from three flight segments of \unit{5\,min} (SOCRATES) or \unit{10\,min}
(CSET) duration were averaged to produce the measured cospectra.
Uncertainties in this measurement
and common features of the atmospheric boundary layer are discussed by
\citet{lenschow95micro}. 
\citet{lenschow1986length} suggested that, for 10\% uncertainty in a measurement of
scalar flux, an averaging distance
of 100--500 times the boundary-layer height is required. (See also \citet{lenschow1994long}.) The flight segments in these two
cases span about 80--150 times the boundary-layer height, so they are marginal by this criterion,
but the measurements still serve to illustrate the effect of the proposed correction. 


\begin{figure}
```{r SOCp1, include=TRUE, fig.height = 5, out.width = "12cm"}

LTphaseC <- function(f, P) {
  ## f=frequency; P=Param
  tau1 <- P$tau1
  tau2 <- P$tau2
  a <- P$a
  b <- sqrt(1 / (1 + (2 * pi * f * tau2) ^ 2))
  zeta <- -atan(2 * pi * f * tau2)
  C1 <- 1 / (1 + 4 * pi ^ 2 * f ^ 2 * tau1 ^ 2) *
    (-(a + (1 - a) * b * cos(zeta)) * 2 * pi * f * tau1 +
       (1 - a) * b * sin(zeta))
  C2 <- 1 / (1 + 4 * pi ^ 2 * f ^ 2 * tau1 ^ 2) *
    ((a + (1 - a) * b * cos(zeta)) +
       (1 - a) * b * sin(zeta) * 2 * pi * f * tau1)
  cTF <- sqrt(C1 ^ 2 + C2 ^ 2)
  phiTF <- atan2(C1, C2) 
  return(complex(modulus = cTF, argument = phiTF))
}
N <- 2^13   ## 8192 covers the 5-min (7500-pt) segment
# Get the transfer function:
Par <- Param1
a <- ParamFS1$a
tau1 <- ParamFS1$tau1
tau2 <- ParamFS1$tau2
df <- Rate / N
frq <- c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
H <- LTphaseC(frq, ParamFS1) # complex(modulus=cTC, argument=phiTC)
ir <- setRange(DS, 60000, 61500)
Tasm <- mean(DS$TASX[ir], na.rm=TRUE)
D <- DS
RHO <- D$PSXC * 100 / (SpecificHeats()[3] * (D$ATX + 273.15))
scaleFactor <- mean(RHO[ir], na.rm=TRUE) * SpecificHeats()[1]
D$RTF1 <- ShiftInTime(D$RTF1, .rate=25, .shift=40)
# D$ATC <- ShiftInTime(D$ATC, .rate=25, .shift=0)
# D$WIC <- ShiftInTime(D$WIC, .rate=25, .shift=-40)
DS1 <- D %>% selectTime(60000, 60500)
DS2 <- D %>% selectTime(60500, 61000)
DS3 <- D %>% selectTime(61000, 61500)
CoSp <- rep(0, N)
CoSpUC <- rep(0, N)
.A <- 'RTF1'
.B <- 'ATC'
.C <- 'AT'
.D <- 'ATF1'
for (.data in list(DS1, DS2, DS3)) {
  N1 <- (N - nrow(.data)) %/% 2
  N2 <- N - nrow(.data) - N1
  WP <- c(rep(0, N1), detrend(.data[, c('Time', 'WIC')]), rep(0, N2))
  TP <- c(rep(0, N1), detrend(.data[, c('Time', .A)]), rep(0, N2))
  TPB <- c(rep(0, N1), detrend(.data[, c('Time', .B)]), rep(0, N2))
  TPuc <- c(rep(0, N1), detrend(.data[, c('Time', .C)]), rep(0, N2))
  TPO <- c(rep(0, N1), detrend(.data[, c('Time', .D)]), rep(0, N2))
  Q  <- c(rep(0, N1), detrend(.data[, c('Time', 'Q')]), rep(0, N2))
  ff1 <- fft(TP)
  ff1uc <- fft(TPuc)
  ffb <- fft(TPB)
  ffo <- fft(TPO)
  ff2 <- fft(WP)
  ffq <- fft(Q)
  cs.orig <- 2 * Re(ff1uc * Conj(ff2)) / (Rate * nrow(.data))
  # cs <- 2 * Re(ff1 * Conj(ff2)) / (Rate * N)
  ## Estimate original recovery T and apply corrected dynamic heating:
  alphaR <- mean(.data$alphaR, na.rm = TRUE)
  cs <- 2 * Re((ff1 / H - alphaR * H * ffq) * Conj(ff2)) / (Rate * nrow(.data))
  ## supercede with direct use of ATC:
  cs <- 2 * Re((ff1uc / H) * Conj(ff2)) / (Rate * nrow(.data))
  cs <- 1/(Mod(H)*cos(Arg(H))) * 2 * Re((ff1uc) * Conj(ff2)) / (Rate * nrow(.data))
  CoSp <- CoSp + cs
  CoSpUC <- CoSpUC + cs.orig
}
CoSp <- CoSp * scaleFactor / 3
CoSpUC <- CoSpUC * scaleFactor / 3
Nby2 <- N %/% 2
CS <- data.frame(freq = frq[2:(Nby2 + 1)], cospec = CoSp[2:(Nby2 + 1)])
CS.orig <- data.frame(freq = frq[2:(Nby2 + 1)], cospec = CoSpUC[2:(Nby2 + 1)])
CSogiveUC <- cumsum(CoSpUC[2:(Nby2 + 1)]) * CS$freq[1]
CSogiveUC <- CSogiveUC[length(CSogiveUC)] - CSogiveUC
CS.orig$ogive <- CSogiveUC
wavelengthLimit <- 2000
fL <- Tasm / wavelengthLimit
ylim <- c(1.e-2, 120)
Units = bquote("W" ~ m ^ -2)
spans = 49
sBins <- 100
grid.newpage()
position <- c(1, 2)
h <- 0.9 / position[2]
yp <- 0.05 + (position[1] - 0.5) * h
if (position[1] == 1) {
  hh <- h + 0.1
} else {
  hh <- h
  yp <- yp + 0.05
}
vp1 <- viewport(
  width = 1,
  height = hh,
  x = 0.5,
  y = yp
)
position <- c(2, 2)
h <- 0.9 / position[2]
yp <- 0.05 + (position[1] - 0.5) * h
if (position[1] == 1) {
  hh <- h + 0.1
} else {
  hh <- h + 0.125
  yp <- yp - 0.03
}
vp2 <- viewport(
  width = 1,
  height = hh,
  x = 0.5,
  y = yp
)
if (generateFigures) {
  CS.corrected <- plotCS(CS, Units, spans, fL,
                     wavelengthLimit, smoothBins=sBins,
                     xlim, ylim, CSprevious = CS.orig,
                     printTitle = FALSE,
                     project = 'SOCRATES', vwp = vp2)
}
CS.orig$cospec <- SmoothInterp(CS.orig$cospec, .Length=0)  # treat NAs
  s25 <- spans %/% 25; s10 <- spans %/% 10; s3 <- spans %/% 3
  s25 <- s25 + (s25 + 1) %% 2
  s10 <- s10 + (s10 + 1) %% 2
  s3 <- s3 + (s3 + 1) %% 2
  CS.orig$cospec <- zoo::rollapply(CS.orig$cospec, FUN = mean, 
                                   fill = 'extend', width = s25)
  CS.orig$cospec[CS.orig$freq > 0.01] <- zoo::rollapply(CS.orig$cospec, 
      FUN = mean, fill='extend', width = s10)[CS.orig$freq > 0.01]
  CS.orig$cospec[CS.orig$freq > 0.1] <- zoo::rollapply(CS.orig$cospec, 
      FUN = mean, fill='extend', width = s3)[CS.orig$freq > 0.1]
  CS.orig$cospec[CS.orig$freq > 1] <- zoo::rollapply(CS.orig$cospec, 
      FUN = mean, fill='extend', width = spans)[CS.orig$freq > 1]

XS <-
  flux(
    DS[setRange(DS, 60000, 61500), ],
    'AT',
    Units = bquote("W"~m^-2),
    smoothBins = 50,
    scaleFactor = scaleFactor,
    wavelengthLimit = 2000,
    .plot = FALSE,
    Par = ParamFS1
  )
DCX <- getNetCDF(file.path(DataDirectory(), 'CSET/rf12h.nc'),
                 standardVariables(c('ATF1', 'ATH1', 'ATH2')), 
                 153000, 
                 193000)
Rate <- attr(DCX, 'Rate')
MRHO <- DCX$MACHX * DCX$PSXC * 100 / 
        (287.05 * (273.15 + DCX$ATX)) / rhozero
ParamFS1 <- ParamSF
ParamFS1$tau1 <- ParamFS1$tau1 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ -0.68
ParamFS1$tau2 <- ParamFS1$tau2 * (mean(MRHO, na.rm = TRUE) / 0.3) ^ -0.68
DCX$TASX <- SmoothInterp(DCX$TASX, .Length = 0)
DCX$Q <- DCX$TASX ^ 2 / 2010
DCX$ATX <- DCX$ATF1
# DCX$AT <- reviseDH(DCX, ParamFS1, rf)  # rf from an earlier code chunk
## Replace this by the filtered result:
## Recalculate AT using the dynamic-heating filter:
DCX$ATX <- SmoothInterp(DCX$ATX, .Length=0)
DCX$PSXC <- SmoothInterp(DCX$PSXC, .Length=0)
DCX$QCXC <- SmoothInterp(DCX$QCXC, .Length=0)
DCX$MACH <- SmoothInterp(MachNumber(DCX$PSXC, DCX$QCXC), .Length=0)
DCX$alphaR <- RecoveryFactor(DCX$MACH, 'UNHEATED') 
DCX$Q <- DCX$TASX^2 / (2 * SpecificHeats()[1])
DCX$QF <- as.vector(signal::filter(ARG, DCX$Q))
DCX$QF <- ShiftInTime(DCX$QF, .shift = -Lshift * 40, .rate = 25)
DCX$AT <- DCX$ATX + DCX$alphaR * (DCX$Q - DCX$QF)
DCX$AT <- SmoothInterp(DCX$AT, .Length = 0)
DCX$RTF1 <-
  DCX$ATF1 + DCX$alphaR * DCX$Q  ## This variable isn't in the available file
DCX$RTF1 <- SmoothInterp(DCX$RTF1, .Length = 0)
## Estimate the corrected recovery temperature:
aV <- ParamFS1$a
tau1V <- ParamFS1$tau1
tau2V <- ParamFS1$tau2
DCX$DTMDT <- c(0, diff(DCX$RTF1, 2), 0) * Rate / 2

fSS <- function(y, i) {  # Eq. Ts3
    ((1/aV) * (tau1V * DCX$DTMDT[i] + DCX$RTF1[i] - (1-aV) * y) - y) / 
    (Rate * tau2V)
  }

DCX$Ts <- rk4.integrate (fSS, DCX$RTF1[1], 1:nrow(DCX))
DCX$RTC <- (1 / aV) * (tau1V * DCX$DTMDT + DCX$RTF1 - (1 - aV) * DCX$Ts)
DCX$ATC <- DCX$RTC - DCX$alphaR * DCX$QF
## Small time adjustment seems useful?
# DCX$Q <- ShiftInTime(DCX$Q, .shift = -25, .rate = 25)
DCX$RHOCP <- 100 * DCX$PSXC / (287.05 * 278) * 1005
DCX$RHOCP <- SmoothInterp(DCX$RHOCP, .Length = 0)

N <- 2^14   ## 16384 covers the 10-min (15000-pt) segments
# Get the transfer function:
a <- ParamFS1$a
tau1 <- ParamFS1$tau1
tau2 <- ParamFS1$tau2
df <- Rate / N
frq <- c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
H <- LTphaseC(frq, ParamFS1)
D <- DCX
D$RTF1 <- ShiftInTime(D$RTF1, .rate = 25, .shift = 40)
# D$ATC <- ShiftInTime(D$ATC, .rate = 25, .shift = 0)
# D$WIC <- ShiftInTime(D$WIC, .rate = 25, .shift = -40)
DC1 <- D %>% selectTime(160452, 161452)
DC2 <- D %>% selectTime(182635, 183625)
DC3 <- D %>% selectTime(191435, 192435)
CoSp <- rep(0, N)
CoSpUC <- rep(0, N)
.A <- 'RTF1'
.B <- 'ATC'
.C <- 'AT'
.D <- 'ATF1'
DCF <- data.frame()
for (.data in list(DC1, DC2, DC3)) {
  N1 <- (N - nrow(.data)) %/% 2
  N2 <- N - nrow(.data) - N1
  WP <- c(rep(0, N1), detrend(.data[, c('Time', 'WIC')]), rep(0, N2))
  TP <- c(rep(0, N1), detrend(.data[, c('Time', .A)]), rep(0, N2))
  TPB <- c(rep(0, N1), detrend(.data[, c('Time', .B)]), rep(0, N2))
  TPuc <- c(rep(0, N1), detrend(.data[, c('Time', .C)]), rep(0, N2))
  TPO <- c(rep(0, N1), detrend(.data[, c('Time', .D)]), rep(0, N2))
  Q  <- c(rep(0, N1), detrend(.data[, c('Time', 'Q')]), rep(0, N2))
  ff1 <- fft(TP)
  ff1uc <- fft(TPuc)
  ffb <- fft(TPB)
  ffo <- fft(TPO)
  ff2 <- fft(WP)
  ffq <- fft(Q)
  cs.orig <- 2 * Re(ff1uc * Conj(ff2)) / (Rate * nrow(.data))
  # cs <- 2 * Re(ff1 * Conj(ff2)) / (Rate * N)
  ## Estimate original recovery T and apply corrected dynamic heating:
  alphaR <- mean(.data$alphaR, na.rm = TRUE)
  cs <- 2 * Re((ff1 / H - alphaR * H * ffq) * Conj(ff2)) / 
           (Rate * nrow(.data))
  ## supercede with direct use of ATC:
  cs <- 2 * Re((ff1uc / H) * Conj(ff2)) / (Rate * nrow(.data))
  cs <- 1 / (Mod(H) * cos(Arg(H))) * 2 * Re((ff1uc) * Conj(ff2)) / 
          (Rate * nrow(.data))
  CoSp <- CoSp + cs
  CoSpUC <- CoSpUC + cs.orig
  DCF <- rbind(DCF, .data)
}
Tasm <- mean(DCF$TASX, na.rm=TRUE)
CoSp <- CoSp * scaleFactor / 3
CoSpUC <- CoSpUC * scaleFactor / 3
Nby2 <- N %/% 2
CS <- data.frame(freq = frq[2:(Nby2+1)], cospec = CoSp[2:(Nby2+1)])
CS.orig <- data.frame(freq = frq[2:(Nby2+1)], cospec = CoSpUC[2:(Nby2+1)])
CSogiveUC <- cumsum(CoSpUC[2:(Nby2+1)]) * CS$freq[1]
CSogiveUC <- CSogiveUC[length(CSogiveUC)] - CSogiveUC
CS.orig$ogive <- CSogiveUC
wavelengthLimit <- 2000
fL <- Tasm / wavelengthLimit
ylim <- c(1.e-2, 50)

if (generateFigures) {
  CS.corrected <- plotCS(CS, Units, spans, fL, wavelengthLimit,
                    smoothBins = sBins,
                    xlim, ylim, CSprevious = CS.orig,
                    printTitle = FALSE,
                    project = 'CSET', vwp = vp1)
} else {
  include_graphics('figure/fig10.pdf')
}

CS.orig$cospec <- SmoothInterp(CS.orig$cospec, .Length = 0)  # treat NAs
  s25 <- spans %/% 25; s10 <- spans %/% 10; s3 <- spans %/% 3
  s25 <- s25 + (s25 + 1) %% 2
  s10 <- s10 + (s10 + 1) %% 2
  s3 <- s3 + (s3 + 1) %% 2
  CS.orig$cospec <- zoo::rollapply(CS.orig$cospec, FUN = mean, 
                                   fill = 'extend', width = s25)
  CS.orig$cospec[CS.orig$freq > 0.01] <- zoo::rollapply(CS.orig$cospec, 
            FUN = mean, fill = 'extend', width = s10)[CS.orig$freq > 0.01]
  CS.orig$cospec[CS.orig$freq > 0.1] <- zoo::rollapply(CS.orig$cospec, 
            FUN = mean, fill = 'extend', width = s3)[CS.orig$freq > 0.1]
  CS.orig$cospec[CS.orig$freq > 1] <- zoo::rollapply(CS.orig$cospec, 
            FUN = mean, fill = 'extend', width = spans)[CS.orig$freq > 1]

```

\caption{The corrected flux of sensible heat, weighted by the frequency $\nu$,
for low-level flight segments over the Pacific Ocean. The "exceedance"
is the complement of the cumulative distribution function (i.e., the
sum of contributions from frequencies above the plotted value), and
the dashed brown exceedance line is that without transfer-function
correction but with adjustment of the dynamic-heating term to incorporate
the estimated response of the temperature sensor. For the SOCRATES example,
the total flux is \unit{23.6\,W\,m^{-2}} and the flux contributed from wavelengths smaller than \unit{2\,km} is \unit{23.5\,W\,m^{-1}}, while the corresponding numbers for the CSET example are 16.0 and \unit{15.4\,W\,m^{-2}}. The dashed black
line shows the frequency limit that corresponds to a wavelength of
\unit{2\,km}.{\label{fig:SOCp1}}}
\end{figure}

The corrected cospectra are shown in Fig.\ \ref{fig:SOCp1}.
This plot format
is unconventional so some explanation is provided here. The cospectrum can be positive or negative, so it is usually
plotted using a linear ordinate scale. However, 
the range of ordinate values is displayed better with a logarithmic
scale, even after weighting the cospectrum by frequency. The compromise
made in this plot is to use a logarithmic scale but plot negative
values with sign reversed and with a different color, here red instead
of blue. 
<!-- There is then a dead-band -->
<!-- at the bottom of the plot where spectral values with very small absolute -->
<!-- value lie, here absolute values smaller than \unit{10^{-2}\,W\,m^{-2}}. -->
<!-- Weighting by frequency is used as is appropriate for a logarithmic -->
<!-- abscissa.  -->
Other features of this plot and computation conventions
include the following:

1. The cospectra have been smoothed using Daniell smoothing,
with consecutive smoothing using width-3 for frequencies above \unit{0.01\,Hz},
then width-5 for frequencies above \unit{0.1\,Hz}, then width-17 for frequencies
above \unit{1\,Hz}. For these \unit{5\,min} flight legs and for \unit{25\,Hz} measurements,
the maximum smoothing interval is
about \unit{0.05\,Hz} so most spectral features are retained even with this
strong smoothing. Additional smoothing results from averaging three
cospectra to obtain the plotted values.

2. Further smoothing is included by binning the results into 100 logarithmically
spaced intervals in frequency and averaging in those bins. That results
in the blue dots (or dark red dots for negative points).

3. The listed "total" flux is that arising from the part
of the flux with frequency above \unit{0.01\,Hz}. This 
frequency limit restricts the calculation to wavelengths 
smaller than about \unit{13\,km}. Another measurement of
the flux is calculated for wavelengths 
below \unit{2\,km}. That or a still smaller wavelength
limit is a reasonable
measure of the part of the flux contributed by turbulent air motions
in the boundary layer, so that second measurement 
is used as the primary measurement in this study.

4. The brown line labeled "exceedance" is
a cumulative distribution function for the cospectrum, called
"exceedance" because it is the contribution from all frequencies
*higher* than the indicated value. (This has been called the "ogive" by, e.g.,
\citet{Foken2006ACPclosure}.)
At high frequency on a logarithmic
scale, where some of the most interesting variation is located, the exceedance
distribution is more informative that the conventional cumulative distribution.
Its units are \unit{W\,m^{-2}}, not \unit{W\,m^{-2}}
per logarithmic interval as is the case for the weighted cospectrum.

The exceedance distributions before correction, shown as the dashed
brown lines, were calculated using a dynamic-heating correction that
was filtered to match the response of the sensor, but otherwise were
not corrected. Without correction for the response as represented
by the transfer function, about 33\% of the flux contributed by wavelengths
smaller than \unit{2\,km} would be missed. The underestimation is particularly
serious at higher frequencies: In both cases the measured contribution
from frequencies above \unit{1\,Hz} is more than twice as large after correction
as it is without correction. A significant contribution to the error is the phase shift that causes the measured temperature to be shifted in phase relative to the updraft, as shown in Fig.\ 1. 

@LawsonRodi1992 estimated that,
in comparison to their fast thermocouple sensor, the unheated Rosemount
sensor underestimated the flux by about 21\% in their measurements.
The magnitude of the correction here is larger than that estimated
error, but the flight speed of the aircraft was about 30\% higher
in this case so a larger error would be expected.

Because the corrected cospectrum appears realistic at frequencies 
of \unit{1\,Hz} and above,
it is possible to judge if the frequency
coverage is adequate. In this case, the exceedance curve is less than
2\% at \unit{10\,Hz} and falls rapidly above that frequency, even after correction,
so it appears likely that additional contributions from higher frequencies
can go unmeasured without introducing serious errors into the measurement
of flux. Additional guidance regarding the expected shape of the cospectrum and the required frequency response is provided by \citet{lenschow95micro}. The generalized cospectra provided there suggest that, for flight at \unit{130\,m\,s^{-1}}, frequencies up to about \unit{1.3\,Hz}--\unit{10\,Hz}, depending on altitude, must be measured. The higher frequency limit applies to low-level flight at about \unit{30\,m} above the surface. Those results suggest that, if the measurements are corrected as suggested here, reliable measurements of sensible-heat flux can be made with the unheated sensor.

## Evidence from Simulated Measurements

```{r reinitialization,echo=FALSE,include=FALSE}

Directory <- DataDirectory ()
Flight <- 1 				
Project = "SOCRATES"			
ProjectDir <- "SOCRATES"
fname = sprintf("%s%s/%srf%02d.nc", Directory, ProjectDir, Project, Flight)

```

As a test of the approach
described in the preceding section, a simulated case was analyzed in the same 
way. Time series were generated representing isotropic wind measurements
by starting with
a Gaussian-noise spectrum, weighting the Fourier components
to obtain a $-5/3$ slope, and then using an inverse Fourier transform
to reconstruct the simulated measurement series. 
<!-- \begin{equation} -->
<!-- P(\nu)=C\left(\frac{2\pi}{V}\right)^{-2/3}\epsilon^{2/3}\nu^{-5/3}{\label{eq:expectedSpectrum}} -->
<!-- \end{equation} -->
<!-- where $\nu$ is the frequency, $V$ the airspeed, $\epsilon$ the -->
<!-- eddy dissipation rate, and $C=0.5$ for the longitudinal component -->
<!-- <!-- of the wind and 2/3 for a lateral component. Thirty-minute sequences -->
<!-- were generated at \unit{50\,Hz} for the three components of the wind, for -->
<!-- an eddy dissipation rate of, -->
<!-- and then long-wavelength components with frequency below \unit{0.05\,Hz} -->
<!-- were attenuated by multiplying the Fourier components by $\exp(-5*0.05/|\nu|)$ -->
<!-- where $\nu$ is the frequency. This not only produced a more realistic -->
<!-- spectrum but also improved the accuracy of the high-frequency simulation, -->
<!-- which otherwise exhibited some variability for different random sequences.  -->

```{r varSpecISR, include=FALSE, echo=FALSE, fig.cap="Assumed spectral variance at periodogram points."}

epsilon <- 1.e-3  ## mks
e23 <- epsilon ^ (2 / 3)
V <- 200   ## assumed flight speed, m/s
duration <- 1800
Rate <- 50
Nyq <- Rate / 2
C <- (2 / 3) * (2 * pi / V) ^ (-2 / 3)
# freq <- seq(1/duration, Nyq, by=1/duration)  ## unaliased
freq <- seq(1 / duration, Nyq * 5, by = 1 / duration)  ## aliased version
p <-
  C * e23 * freq ^ (-5 / 3)  ## This is variance per frequency interval,
## normalized to be positive frequencies
r <- freq > 0 & freq <= Nyq
plotWAC(
  data.frame (freq[r], p[r]),
  log = 'xy',
  xlab = 'frequency [Hz]',
  ylab = bquote('P(frequency) [m' ^ 2 ~ 's' ^ -2 ~ 'Hz' ^ -1 ~ ']'),
  col = 'blue',
  lwd = 2
)

```

```{r generate, include=FALSE, echo=FALSE, fig.cap='The variance spectrum of the generated time series. Three wind components are shown: $u$ longitudinal; $v$ side lateral; $w$ upward. The simulated eddy dissipation rate was $10^{-3}$ m$^2s^{-3}$. The generated longitudinal spectral density (u) is 3/4 the lateral spectral densities (v and w), as expected in an inertial subrange. The dashed orange lines indicated the expected slope ($-2/3$ for this distribution because it is weighted by frequency), with the large-dot line representing $10^{-4}$ m$^2s^{-3}$ and other lines representing eddy dissipation rates  factors of 10 higher or lower. The spectral variance has been attenuated at low frequency to simulate the shapes that are often observed. The displayed wavelength scale was determined from the average flight speed.'}

if (file.exists('DF2.Rdata')) {
  ## This is to avoid having this change every run
  load(file = 'DF2.Rdata')
} else {
  Rate <- 25
  duration <- 2 ^ 16 / Rate
  epsilon <- 1.e-3  ## Specify the eddy dissipation rate, mks units
  V <- 200   ## assumed flight speed, m/s
  ## Spectral variance amplitude, lateral component
  C <- (2 / 3) * (2 * pi / V) ^ (-2 / 3) * epsilon ^ (2 / 3)
  Time <- seq(0, duration * Rate - 1) / Rate
  N <- length(Time)
  A <- sqrt(C * Rate / 2)
  u <-
    rnorm(N, 0, A) * sqrt(3 / 4)  ## sqrt(3/4) to get 3:4 ratio, spectra
  v <- rnorm(N, 0, A)
  w <- rnorm(N, 0, A)
  DF2 <- data.frame(
    Time = Time,
    TASX = V + u,
    u = u,
    v = v,
    w = w
  )
  attr(DF2, 'Rate') <- Rate
  f1 <- fft(DF2$u)
  f2 <- fft(DF2$v)
  f3 <- fft(DF2$w)
  df <- Rate / N
  frq <- c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
  f1[2:N] <- f1[2:N] * abs(frq[2:N]) ^ (-5 / 6)  ## Force -5/3 slope
  f2[2:N] <- f2[2:N] * abs(frq[2:N]) ^ (-5 / 6)
  f3[2:N] <- f3[2:N] * abs(frq[2:N]) ^ (-5 / 6)
  f_atten <- 0.05
  rf <- (abs(frq) < f_atten)
  rf[1] <- TRUE
  f1[rf] <-
    f1[rf] * exp(-5 * f_atten / abs(frq[rf]))  ## Truncate low-frequency
  ## (improves high-f accuracy)
  f2[rf] <- f2[rf] * exp(-5 * f_atten / abs(frq[rf]))
  f3[rf] <- f3[rf] * exp(-5 * f_atten / abs(frq[rf]))
  DF2$u <- Re(fft(f1, inverse = TRUE) / N)
  DF2$v <- Re(fft(f2, inverse = TRUE) / N)
  DF2$w <- Re(fft(f3, inverse = TRUE) / N)
  ## Modify time to get a POSIXct value as expected by Ranadu:
  load('chunks/Time_units.Rdata')  ## Saved from a conventional file
  attr(DF2$Time, 'units') <- Time_units$value
  tref <- sub ('seconds since ', '', attr (DF2$Time, 'units'))
  DF2$Time <- as.POSIXct(DF2$Time, tz = 'UTC', origin = tref)
  DF2 <-
    DF2 %>% selectTime(500, 3500)  # Select subset to avoid end effects
  save(DF2, file = 'DF2.Rdata')
}
DF2 %>% select(Time, TASX, u, v, w) %>%
  VSpec(
    xlim = c(0.01, 15),
    ylim = c(1.e-3, 10),
    method = 'MEM',
    poles = 100
  ) +
  theme_WAC(1)

```


```{r plotCS2, include=FALSE, echo=FALSE}

## plotCS is redefined here to get the form desired for a unified
## plot of the simulation results without distorting earlier plots.
plotCS <- function(CS,
                   Units,
                   spans = 149,
                   fL,
                   wavelengthLimit = 2000,
                   smoothBins = 100,
                   xlim = c(0.01, 15),
                   ylim = c(0.001, 80),
                   printTitle = TRUE,
                   CSprevious = NA,
                   plotFigure = TRUE,
                   plotRibbon = TRUE,
                   showNegative = TRUE,
                   ADD = FALSE) {
  if (ADD) {
    ## Add to an existing plot definition that is saved in a previous call
    if (exists('g.CS'))
      g <- g.CS  ## Saved from a previous call
  }
  ylab <- bquote(nu * " x flux cospectrum [" * .(Units) * "]")
  CSogive <- cumsum(CS$cospec) * CS$freq[1]
  CSogive <- CSogive[length(CSogive)] - CSogive
  CS$ogive <- CSogive
  CS$cospec <- SmoothInterp(CS$cospec, .Length = 0)  # treat NAs
  s25 <- spans %/% 25
  s10 <- spans %/% 10
  s3 <- spans %/% 3
  s25 <- s25 + (s25 + 1) %% 2
  s10 <- s10 + (s10 + 1) %% 2
  s3 <- s3 + (s3 + 1) %% 2
  CS$cospec <-
    zoo::rollapply(CS$cospec,
                   FUN = mean,
                   fill = 'extend',
                   width = s25)
  CS$cospec[CS$freq > 0.01] <-
    zoo::rollapply(CS$cospec,
                   FUN = mean,
                   fill = 'extend',
                   width = s10)[CS$freq > 0.01]
  CS$cospec[CS$freq > 0.1] <-
    zoo::rollapply(CS$cospec,
                   FUN = mean,
                   fill = 'extend',
                   width = s3)[CS$freq > 0.1]
  CS$cospec[CS$freq > 1] <-
    zoo::rollapply(CS$cospec,
                   FUN = mean,
                   fill = 'extend',
                   width = spans)[CS$freq > 1]
  FluxL <- CSogive[which(CS$freq > fL)[1]]
  Flux <- CSogive[which(CS$freq > 0.01)[1]]
  attr(CS, 'Flux') <- Flux
  attr(CS, 'FluxL') <- FluxL
  attr(CS, 'wavelengthLimit') <- wavelengthLimit
  ## Construct the plot:
  CS$ncospec <- -1 * CS$cospec
  ## Weight by frequency for log-abscissa plot:
  CS$cospec <- CS$cospec * CS$freq
  CS$ncospec <- CS$ncospec * CS$freq
  if (smoothBins > 5) {
    BS <-
      binStats(data.frame(CS$cospec, log(CS$freq)), bins = smoothBins)
    # lines(exp(BS$xc), BS$ybar, lwd=2, col='brown')
    BS$nybar <- -1 * BS$ybar
    BS$ybar[BS$ybar < 0] <- NA
    BS$nybar[BS$nybar < 0] <- NA
    BS$xc <- exp(BS$xc)
    # lines(exp(BS$xc), BS$nybar, lwd=2, col='magenta')
    attr(CS, 'smoothed data.frame') <- BS
    bse <-
      data.frame(
        x = BS$xc,
        ymin = BS$ybar - BS$sigma,
        ymax = BS$ybar + BS$sigma,
        yminN = BS$nybar - BS$sigma,
        ymaxN = BS$nybar + BS$sigma
      )
  }
  if (smoothBins > 5) {
    bse$ymin[bse$ymin < ylim[1]] <- ylim[1]
    bse$yminN[bse$yminN < ylim[1]] <- ylim[1]
  }
  if (ADD) {
    g <- g + geom_path(data = CS,
                       aes(
                         y = cospec,
                         colour = 'measured',
                         linetype = 'measured'
                       ))
    if (showNegative) {
      g <- g + geom_path(aes(
        y = ncospec,
        colour = '-cosp2',
        linetype = '-cosp2'
      ))
    }
    g <- g + geom_path(
      data = CS,
      aes(
        y = ogive,
        colour = 'exc-msrd',
        linetype = 'exc-msrd'
      ),
      lwd = 1.2
    )
  } else {
    g <- ggplot(data = CS, aes(x = freq))
    g <-
      g + geom_path(data = CS,
                    aes(
                      y = cospec,
                      colour = 'generated',
                      linetype = 'generated'
                    ))
    if (showNegative) {
      g <-
        g + geom_path(aes(
          y = ncospec,
          colour = '-cosp',
          linetype = '-cosp'
        ))
    }
    g <- g + geom_path(aes(
      y = ogive,
      colour = 'exceedance',
      linetype = 'exceedance'
    ),
    lwd = 1.2)
  }
  if (is.data.frame(CSprevious)) {
    g <- g + geom_path(
      data = CSprevious,
      aes(
        x = freq,
        y = ogive,
        colour = 'exc-corr',
        linetype = 'exc-corr'
      ),
      lwd = 1.2
    )
    if ('ogive2' %in% names(CSprevious)) {
      g <- g + geom_path(
        data = CSprevious,
        aes(
          x = freq,
          y = ogive2,
          colour = 'generated',
          linetype = 'generated'
        ),
        lwd = 1.3
      )
    }
  }
  if (smoothBins > 5) {
    pclr <- ifelse(ADD, 'measured', 'generated')
    pclr <- ifelse(ADD, 'forestgreen', 'blue')
    if (ADD) {
      g <-
        g + geom_point(data = BS,
                       aes(
                         x = xc,
                         y = ybar,
                         colour = 'measured'
                       ),
                       pch = 19)
    } else {
      g <-
        g + geom_point(data = BS,
                       aes(
                         x = xc,
                         y = ybar,
                         colour = 'generated'
                       ),
                       pch = 19)
    }
    if (showNegative) {
      g <-
        g + geom_point(
          data = BS,
          aes(x = xc, y = nybar),
          colour = 'darkred',
          pch = 19
        )
    }
    if (plotRibbon) {
      # GeomRibbon$handle_na <- function(data, params) {  data }
      g <- g + geom_ribbon(
        data = bse,
        aes(
          x = x,
          ymin = ymin,
          ymax = ymax
        ),
        fill = pclr,
        alpha = 0.2,
        show.legend = FALSE,
        inherit.aes = FALSE,
        na.rm = FALSE
      )
      if (showNegative) {
        g <- g + geom_ribbon(
          data = bse,
          aes(
            x = x,
            ymin = yminN,
            ymax = ymaxN
          ),
          fill = 'red',
          alpha = 0.2,
          show.legend = FALSE,
          inherit.aes = FALSE,
          na.rm = FALSE
        )
      }
    }
  }
  if (!ADD) {
    g <-
      g + geom_path(data = data.frame(x = rep(fL, 2), y = ylim),
                    aes(x = x, y = y),
                    linetype = 2)
    g <-
      g + scale_x_log10(
        breaks = trans_breaks("log10", function(x)
          10 ^ x, n = 2),
        labels = trans_format("log10", math_format(10 ^ .x))
      ) +
      scale_y_log10(
        breaks = trans_breaks("log10", function(x)
          10 ^ x, n = 4),
        labels = trans_format("log10", math_format(10 ^ .x))
      ) +
      annotation_logticks(sides = 'trbl') +
      coord_cartesian(xlim = xlim, ylim = ylim)
    g <- g + xlab('frequency [Hz]') + ylab(ylab)
    ttl <-
      bquote(
        'Total flux ' ~ .(format(Flux, digits = 3)) ~ .(Units) * '; partial <' *
          .(format((
            wavelengthLimit / 1000
          ), digits = 2)) ~ 'km:' ~ .(format(FluxL, digits = 3)) ~ .(Units)
      )
    if (printTitle) {
      g <- g + labs(title = ttl)
    }
    g <-
      g + theme_WAC(1) + theme(plot.title = element_text(size = 12)) +
      theme(legend.position = c(0.5, 0.91))
  } else {
    ## this is for ADD == TRUE
    if (showNegative) {
      g <- suppressWarnings(g + scale_colour_manual (
        name = '',
        values = c(
          'cosp' = 'blue',
          '-cosp' = 'red',
          'exceedance' = 'brown',
          'generated' = 'forestgreen',
          'measured' = 'forestgreen',
          '-cosp2' = 'darkorange',
          'exceedance2' = 'black'
        )
      ))
      g <- g + scale_linetype_manual (
        name = '',
        values = c(
          'cosp' = 1,
          '-cosp' = 1,
          'exceedance' = 1,
          'generated' = 4,
          'measured' = 1,
          '-cosp2' = 1,
          'exceedance2' = 2
        )
      )
    } else {
      g <- g + scale_linetype_manual (
        name = '',
        values = c(
          'generated' = 1,
          'exceedance' = 1,
          'exc-msrd' = 2,
          'measured' = 1,
          'exc-corr' = 2
        )
      )
      g <-
        g + scale_shape_manual(
          name = '',
          values = c(
            'generated' = 19,
            'exceedance' = NA,
            'exc-msrd' = NA,
            'measured' = 19,
            'exc-corr' = NA
          )
        )
      g <- g + scale_colour_manual (
        name = '',
        values = c(
          'generated' = 'blue',
          'exceedance' = 'brown',
          'exc-msrd' = 'brown',
          'measured' = 'forestgreen',
          'exc-corr' = 'black'
        ),
        guide = guide_legend(override.aes = list(
          shape = c('generated' = 19,
                    'measured' = 19)
        ))
      )
      g <- g + guides(
        colour = guide_legend(reverse = TRUE),
        linetype = guide_legend(reverse = TRUE),
        shape = guide_legend(reverse = TRUE)
      )
      g <-
        g + guides(shape = guide_legend(override.aes = list(shape = c(
          19, NA, NA, 19, NA
        ))))
    }
  }
  if (plotFigure)
    suppressWarnings(print(g))
  g.CS <<- g  ## Save for adding additional lines...
  return(CS)
}

```

A time series for temperature was generated similarly but
scaled by a factor of \unit{0.2^{\circ}C\,m^{-1}\,s}, and then a
correlation of 0.3 was introduced
between temperature and updraft fluctuations.
In this simulation, about 15\% of the flux from wavelengths below
\unit{2.5\,km} is contributed by frequencies
above \unit{1\,Hz}, where the sensor may respond incompletely to the fluctuations
and underestimate the flux. 

```{r genF, include=FALSE}

rc <- 0.3
DF2$T <- DF2$v / 5
DF2$T <- (1 - rc) * DF2$T + rc * DF2$w / 5 + 10
DF2$WIC <- DF2$w
DF2$Q <- 0.985 * DF2$TASX ^ 2 / 2010
## The true recovery temperature that is the measurand
DF2$RT <- DF2$T + DF2$Q
a <- Param1$a
tau1 <- Param1$tau1
tau2 <- Param1$tau2
DF2$TsQ <- DF2$RT
DF2$Qp <- DF2$Q
Rate <- attr (DF2, 'Rate')
fS <- function(y, i) {
  (DF2$Q[i] - y) / (Rate * tau2)
}
fM <- function (y, i) {
  (a * DF2$Q[i] + (1 - a) * DF2$TsQ[i] - y) / (Rate * tau1)
}
# DF2$TsQ <- rk4.integrate (fS, DF2$Q[1], 1:nrow(DF2))
# DF2$Qp <- rk4.integrate (fM, DF2$Q[1], 1:nrow(DF2))
DF2$QF <- as.vector(signal::filter(AR, DF2$Q))
DF2$QF <- ShiftInTime(DF2$QF, .shift = -Lshift * 40, .rate = 25)
## Find the measured recovery temperature Tm responding to RT
fS <- function(y, i) {
  (DF2$RT[i] - y) / (Rate * tau2)
}
fM <- function (y, i) {
  (a * DF2$RT[i] + (1 - a) * DF2$Ts[i] - y) / (Rate * tau1)
}
DF2$TF <- as.vector(signal::filter(AR, DF2$RT))
## TF is the filtered measurement of the recovery temperature,
## so this is what would be measured.
DF2$TF <- ShiftInTime(DF2$TF, .shift = -Lshift * 40, .rate = 25)
## The erroneous conventionally measured ambient temperature
DF2$ATm <- DF2$TF - DF2$Q
# It would be better to use the filtered dynamic-heating
DF2$ATM <- DF2$TF - DF2$QF
SF <- 100 * 850 / (287 * 283) * 1005
A <- flux(
  ## This is the "true" flux
  DF2,
  'T',
  Units = bquote("W" ~ m ^ -2),
  smoothBins = 100,
  scaleFactor = mean(SF, na.rm = TRUE),
  wavelengthLimit = 2500,
  .plot = FALSE
)

```
\begin{figure}
```{r simF, include=TRUE, fig.height = 3.5, out.width = "12cm"}

AF <- flux(
  DF2,
  'ATm',
  Units = bquote("W" ~ m ^ -2),
  smoothBins = 100,
  scaleFactor = mean(SF, na.rm=TRUE),
  Par = Param1,
  .plot = FALSE,
  wavelengthLimit = 2500
)

N <- 2^14   ## 16384 covers the 10-min (15000-pt) segments
# Get the transfer function:
a <- Param1$a
tau1 <- Param1$tau1
tau2 <- Param1$tau2
df <- Rate / N
frq <- c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
H <- LTphaseC(frq, Param1)
D <- DF2
# D$RTF1 <- ShiftInTime(D$RTF1, .rate=25, .shift=40)
# D$ATC <- ShiftInTime(D$ATC, .rate=25, .shift=0)
# D$WIC <- ShiftInTime(D$WIC, .rate=25, .shift=-40)
DX1 <- D %>% selectTime(500, 1500)
DX2 <- D %>% selectTime(1500, 2500)
DX3 <- D %>% selectTime(2500, 3500)
CoSp <- rep(0, N)
CoSpG <- rep(0, N)  ## cospectrum of generated T
CoSpUC <- rep(0, N)
.A <- 'ATm' # the simulated measurement of air temperature 
.B <- 'TF'  # the measured recovery temperature
.C <- 'ATM' # improved measurement using filtered Q
.D <- 'T'   # the generated air temperature
DCF <- data.frame()
for (.data in list(DX1, DX2, DX3)) {
  N1 <- (N - nrow(.data)) %/% 2
  N2 <- N - nrow(.data) - N1
  WP <- c(rep(0, N1), detrend(.data[, c('Time', 'WIC')]), rep(0, N2))
  TPuc <- c(rep(0, N1), detrend(.data[, c('Time', .A)]), rep(0, N2))
  TPB <- c(rep(0, N1), detrend(.data[, c('Time', .B)]), rep(0, N2))
  TP <- c(rep(0, N1), detrend(.data[, c('Time', .C)]), rep(0, N2))
  TPO <- c(rep(0, N1), detrend(.data[, c('Time', .D)]), rep(0, N2))
  Q  <- c(rep(0, N1), detrend(.data[, c('Time', 'Q')]), rep(0, N2))
  ff1 <- fft(TP)
  ff1uc <- fft(TPuc)
  ffb <- fft(TPB)
  ffo <- fft(TPO)
  ff2 <- fft(WP)
  ffq <- fft(Q)
  ## The original as generated
  cs.G <- 2 * Re(ffo * Conj(ff2)) / (Rate * nrow(.data))
  ## The predicted measurement before correction
  cs.orig <- 2 * Re(ff1uc * Conj(ff2)) / (Rate * nrow(.data))
  ## The predicted measurement with adjusted dynamic heating
  cs.orig <- 2 * Re(ff1 * Conj(ff2)) / (Rate * nrow(.data))
  # cs <- 2 * Re(ff1 * Conj(ff2)) / (Rate * N)
  ## The corrected cospectrum:
  cs <- 2 * Re((ffb / H - ffq) * Conj(ff2)) / (Rate * nrow(.data))
  CoSp <- CoSp + cs
  CoSpG <- CoSpG + cs.G
  CoSpUC <- CoSpUC + cs.orig
  DCF <- rbind(DCF, .data)
}
Tasm <- mean(DCF$TASX, na.rm=TRUE)
CoSp <- CoSp * scaleFactor / 3
CoSpG <- CoSpG * scaleFactor / 3
CoSpUC <- CoSpUC * scaleFactor / 3
Nby2 <- N %/% 2
CS <- data.frame(freq = frq[2:(Nby2+1)], cospec = CoSp[2:(Nby2+1)])
CS.G <- data.frame(freq = frq[2:(Nby2+1)], cospec = CoSpG[2:(Nby2+1)])
CS.orig <- data.frame(freq = frq[2:(Nby2+1)], cospec = CoSpUC[2:(Nby2+1)])
CSogiveUC <- cumsum(CoSpUC[2:(Nby2+1)]) * CS$freq[1]
CSogiveUC <- CSogiveUC[length(CSogiveUC)]-CSogiveUC
CS.orig$ogive <- CSogiveUC
wavelengthLimit <- 2500
fL <- Tasm / wavelengthLimit
ylim <- c(1.e-3, 100)
sBins <- 50
xlim <- c(0.08,15)
## This is just to get the corrected ogive
CS.corrected <- plotCS(CS, Units, spans=121, fL, wavelengthLimit, 
                   smoothBins=sBins, 
                   xlim=xlim, ylim=ylim, 
                   plotFigure = FALSE) 
CS.G <- plotCS(CS.G, Units, spans=121, fL, wavelengthLimit, 
                   smoothBins=sBins,
                   xlim, ylim, CSprevious = CS.corrected, 
                   plotFigure = FALSE,
                   showNegative = FALSE)
CS.X <- plotCS(CS.orig, Units, spans=151, fL, wavelengthLimit, 
                   smoothBins=sBins, 
                   xlim=xlim, ylim=ylim, 
                   showNegative = FALSE,
                   plotFigure = FALSE,
                   ADD = TRUE) 
CS <- CS.G
CS$cospecM <- CS.X$cospec
CS$ogiveM <- CS.X$ogive
CS$xcM <- CS.X$xc
CS$ybarM <- CS.X$ybar
CS$sigmaM <- CS.X$sigma
CS$nbM <- CS.X$nb
CS$cospecC <- CS.corrected$cospec
CS$ogiveC <- CS.corrected$ogive
CS$xcC <- CS.corrected$xc
CS$ybarC <- CS.corrected$ybar
CS$sigmaC <- CS.corrected$sigma
CS$nbC <- CS.corrected$nb
lLbl <- c('generated cospectrum', 'measured cospectrum',
                  'exceedance - generated', 'exceedance-measured',
                  'exceedance - corrected')
g <- ggplot(data = CS, aes(x=freq))
g <- g + geom_path(aes(y = cospec, colour = lLbl[1], 
            linetype = lLbl[1]), size = 1.2)
g <- g + geom_path(aes(y = cospecM, colour = lLbl[2],
            linetype = lLbl[2]), size = 1.2)
g <- g + geom_path(aes(y = ogive, colour = lLbl[3],
            linetype = lLbl[3]), size = 1.5)
g <- g + geom_path(aes(y = ogiveC, colour = lLbl[5],
            linetype = lLbl[5]), size = 1)
g <- g + geom_path(aes(y = ogiveM, colour = lLbl[4],
            linetype = lLbl[4]), size = 1.5)
g <- g + geom_point(aes(y = ogive, colour = lLbl[3],
            shape = lLbl[3]))
g <- g + geom_point(aes(y = ogiveC, colour = lLbl[5],
            shape = lLbl[5]))
g <- g + geom_point(aes(y = ogiveM, colour = lLbl[4],
            shape = lLbl[4]))
g <- g + geom_point(data = attr(CS.G, 'smoothed data.frame'),
           aes(x = xc, y = ybar, colour = lLbl[1],
               shape = lLbl[1]), cex = 2.5)
g <- g + geom_point(data = attr(CS.X, 'smoothed data.frame'),
           aes(x = xc, y = ybar, colour = lLbl[2],
               shape = lLbl[2]), cex = 2.5)
g <- g + geom_ribbon(data = attr(CS.X, 'smoothed data.frame'), 
           aes(x = xc, ymin = ybar - sigma, ymax = ybar + sigma),
           fill = 'darkgreen', alpha = 0.3, show.legend = FALSE,  
           inherit.aes = FALSE, na.rm = FALSE)
g <- g + geom_path(data=data.frame(x=rep(fL, 2), y=ylim), aes(x=x, y=y), linetype=2, lwd = 1.3)
g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x, n=2), #limits = xlim, 
                           labels = trans_format("log10", math_format(10^.x))) +
      scale_y_log10(breaks = trans_breaks("log10", function(x) 10^x, n=4), #limits = ylim,             
                    labels = trans_format("log10", math_format(10^.x))) +
      annotation_logticks(sides='trbl') +
      coord_cartesian(xlim=xlim, ylim=ylim)
    vllt <- c(1,1,1,4,4)
    vlsh <- c(19, 19, NA, NA, NA)
    vlcl <- c('blue', 'forestgreen', 'brown', 'brown', 'black')
    vlsz <- c(0.7, 0.7, 1.5, 2, 1.2)
    names(vllt) <- lLbl
    names(vlsh) <- lLbl
    names(vlcl) <- lLbl
    names(vlsz) <- lLbl
    g <- g + scale_linetype_manual (name = '  legend:', values = vllt)
    g <- g + scale_shape_manual(name = '  legend:', values = vlsh)
    g <- g + scale_colour_manual (name='  legend:', values = vlcl)
    g <- g + scale_size_manual(name = '  legend:', values = vlsz)
    g <- g + guides(colour = guide_legend(reverse = TRUE),  
                    linetype=guide_legend(reverse = TRUE),
                    shape = guide_legend(reverse = TRUE)) 
    g <- g + xlab('frequency [Hz]') + ylab(bquote(nu * " x flux cospectrum ["*.(Units)*"]"))
    g <- g + theme_WAC(1)
      g <- g + theme(legend.position=c(0.35, 0.3),
      plot.margin = unit(c(0.6, 0.6, 0.8, 0.6), "lines"),
      legend.background=element_rect(colour = 'black', size = 0.3,
                                     fill = "ivory"),
      legend.direction = "vertical",
      legend.key.width = unit(1.3, 'lines'),
      legend.key.height = unit(0.7, 'lines'),
      legend.text = element_text(size = 12))
      
if (generateFigures) {
  suppressWarnings(print(g + theme(legend.key.size = unit(0.5, "in"))))
} else {
  include_graphics('figure/fig11.pdf')
}

```
\caption{The cospectrum for the flux of sensible heat (blue line), weighted by frequency $\nu$, for the simulated data generated as described in the text. Three \unit{10\,min} segments of simulated \unit{25\,Hz} data were averaged. The measured cospectrum was obtained by filtering the simulated recovery temperature and subtracting the correction for dynamic heating. For the generated and measured cospectrum, filled circles indicate the average values calculated in 50 logarithmically space intervals, and for the measured cospectrum shading indicates the standard deviation in those intervals. The exceedance lines show the contribution to flux from frequencies higher than the plotted frequency. The corrected cospectrum is not shown but is consistent with the generated cospectrum, as demonstrated by the agreement between the generated exceedance and the corrected exceedance. The units for the exceedance distributions are \unit{W\,m^{-2}}, while the units for the weighted flux cospectra are \unit{W\,m^{-2}} per unit logarithmic increment.\label{fig:simF}}
\end{figure}

Figure\ \ref{fig:simF} shows (as the green line) how the simulated
cospectrum would be measured by a sensor with response parameters
\{$a,\,\tau_{1},\,\tau_{2}$\} equal to \{0.733, \unit{0.0308\,s}, \unit{0.447\,s}\},
as is characteristic of an unheated sensor. The simulated
measurement of air temperature was obtained by adding the dynamic-heating
correction to the simulated air temperature and then applying the
digital filter developed in Sect.\ \ref{sec:Correcting-for-Dynamic} to
estimate how the sensor would respond. Then the resulting value for
measured recovery temperature was corrected for dynamic heating to
obtain the value that would be measured for the air temperature, and
that value was used with the simulated updraft to calculate the cospectrum.
The resulting measured cospectrum is significantly smaller than the
generated cospectrum for frequencies above about \unit{1\,Hz} and is almost
a factor of ten too low at \unit{10\,Hz}. The measured exceedance distribution
(dashed brown line) emphasizes the extent of the missing flux at high
frequency.

The cospectrum obtained using the correction procedure of Sect.\ \ref{subsec:Outline-correction}
is consistent with the generated cospectrum, as illustrated by the
corrected exceedance distribution in Fig.\ \ref{fig:simF} (dashed
black line). For wavelengths smaller than \unit{2.5\,km}, the generated flux
of sensible heat is \unit{39.5\,W\,m^{-2}} and the measured values before
and after correction are 33.2 and \unit{38.5\,W\,m^{-2}}. The correction
thus reduces the 15\% measurement error to about 2.5\%. The representation
of the high-frequency contribution is improved significantly by the
correction procedure: For the contribution to the flux from frequencies
above \unit{3\,Hz}, the respective values for the generated, measured, and
corrected exceedance distributions are 15.3, 10.8, and \unit{15.1\,W\,m^{-2}},
so about 30\% of the contribution in this frequency range would be
missed without correction.

This test only confirms consistency between the prediction of the
transfer function and the correction procedure based on that function.
The former, when deployed in a digital filter, is dependent on the
assumptions and weaknesses in that filter, while the latter may be
influenced by end effects and window effects from calculating the
Fourier transforms. The agreement between the simulated and corrected
flux therefore provides some support for the filter developed in Sect.\ \ref{sec:Correcting-for-Dynamic}
and for the correction procedure developed in this paper.

\conclusions

The key findings are these:
\begin{enumerate}
\item The differential equations Eq.\ \eqref{eq:Ts} and Eq.\ \eqref{eq:Tm}
provide an analytical representation of the
transfer function for the recovery temperature measured by an unheated
sensor. With appropriate values of the parameters, that analytical transfer function was consistent 
with the phase and gain of the measured response
to dynamic-heating fluctuations. This is evidence that the equations
provide a valid representation of the time response for that sensor.
The predictions of the equations are less satisfactory when applied
to heated sensors, possibly indicating incomplete representation of
the transfer of heat to those slower sensors.
\item For the unheated Rosemount 102E4AL sensor, the three parameters in those equations
(characterizing the two time constants and the fraction of heat transfer
to the air vs.\ that to the structure supporting the sensing wire)
can be determined with small uncertainty by fitting the transfer function
to observations of dynamic heating. These parameters are thus constrained
well and can be relied upon to make corrections to the measurements
and otherwise to characterize the effects of time response of that
sensor.
\item The transfer function for the unheated sensor can then be used to estimate the true recovery temperature. 
Transfer functions for other sensors then can be determined by
comparison to that estimate of the measurand to which they are responding.
This approach has been used here for the slower heated sensors and
should provide a means of correcting other sensors slower than the
unheated sensor. Appendix\ A uses these results with standard methods
to correct the measurements from airborne temperature sensors for
their time response.
\item Because temperature sensors often do not respond fast enough to measure
high-frequency components of the dynamic-heating correction, erroneous
fluctuations are introduced by conventional data processing when the full dynamic-heating term is subtracted. Instead,
that term should be filtered to match the response of the temperature
sensor. A digital filter is
proposed that can be used to correct standard processing schemes to
eliminate the errors arising from the dynamic-heating term. The errors
discussed here are prevalent in almost all existing data from research
aircraft, so application of this proposed correction method would lead
to significant improvement in those measurements.
\item An algorithm was proposed for calculating sensible-heat flux that uses the transfer
function to correct the measured cospectrum.
Two illustrative cases were presented in which there was significant
correlation between temperature and updraft at a range of frequencies
including those above \unit{1\,Hz}. The measured values of sensible-heat
flux would be underestimated significantly (by about 33\%) without
correction.
\item The cospectrum with correction appears to be represented reasonably
at frequencies up to about \unit{10\,Hz}, so the decrease in the cospectrum
with frequency near that value suggests that it is not necessary to
measure contributions from still higher frequencies. This conclusion
is tentative and needs reconsideration when applied to new cases.
\item Results of a simulation support the consistency between the response
as represented by the digital filter and the application of the transfer
function to correct the measurement of the flux of sensible heat.
\end{enumerate}

\appendix 
# Correcting the Temperature \label{sec:Correcting-the-Temperature}

The true recovery temperature $T_{r}$ can be retrieved from the measured
temperature $T_{m}$ in two ways, either from the differential equations
or by Fourier transformation. Only a cursory discussion of these techniques
is included here because the procedures are standard and follow earlier
work, notably that of \citet{InverarityJTech2000} and \citet{Foster2012Improving}.

The differential equations Eq.\ \eqref{eq:Ts} and Eq.\ \eqref{eq:Tm} involve
two unknowns, the actual recovery temperature $T_{r}(t)$ and the
temperature of the supporting structure $T_{s}(t)$. The second equation
can be used to eliminate $T_{r}$ from the first:
\begin{equation}
\frac{dT_{s}(t)}{dt}=\frac{\frac{1}{a}\left\{ \tau_{1}\frac{dT_{m}(t)}{dt}+T_{m}(t)-(1-a)T_{s}(t)\right\} -T_{s}(t)}{\tau_{2}}{\label{eq:Ts3}}
\end{equation}
Because the measured temperature $T_{m}(t)$ is known, this can be
integrated from an assumed initial value $T_{s}(0)$ to find the temperature
of the support, $T_{s}(t)$. Then Eq.\ \eqref{eq:Tm} can be solved to
give the true recovery temperature $T_{r}(t)$ without further integration.
The only choices to be made are the numerical method used to find the
derivative $dT_{m}/dt$ (here centered fourth-order finite difference)
and the integration
method applied to Eq.\ \eqref{eq:Ts3} (here fourth-order Runge-Kutta integration
with Cash-Karp (\citet{cash1990variable}) adjustment of the step
size). If a centered second-order finite-difference expression is used
for $dT_{m}(t)/dt$ and an Euler integration is used to integrate
Eq.\ \eqref{eq:Ts3}, this correction is equivalent to
that developed by \citet{InverarityJTech2000}; cf.\ his Eqn.\ (12).
However, this correction should be applied to the *recovery *temperature,
not the *air *temperature. The sensor responds to the recovery
temperature that includes the increase caused by dynamic heating,
so applying the correction to the recovery temperature properly corrects
for the response to dynamic heating also. Then the usual dynamic-heating
correction can be subtracted to obtain an estimate of the air temperature. 

The correction procedure must be modified for the heated sensor because,
with the best-fit value $a=0$, Eq.\ \eqref{eq:Tm} can't be solved for
$T_{r}(t)$. However, for $a=0$ the differential equations can be
combined to give
\begin{equation}
T_{r}(t)=(\tau_{1}+\tau_{2})\frac{dT_{m}(t)}{dt}+T_{m}(t)+\tau_{2}\tau_{1}\frac{d^{2}T_{m}(t)}{dt^{2}}{\label{eq:HARCOsoln}}
\end{equation}
This gives $T_{r}(t)$ without integration because finite-difference
expressions can be used for the derivatives of the measurement ($T_{m}(t)$).
However, the finite-difference estimates introduce high-frequency noise so
the result was smoothed using a low-pass filter with \unit{2\,Hz} cutoff
frequency. 

```{r method1, include=FALSE}

a <- Param1$a
    tau1 <- Param1$tau1
    tau2 <- Param1$tau2
    ## RT is the working solution; Ts is the support temperature
    DT$Ts <- DT$RT
    Rate <- attr (DT, 'Rate')
    DT$DTMDT <- c(0, diff(DT$TTRR, 2), 0) * Rate / 2
    DT$DTMDT <-  (c(0, 8 * diff(DT$TTRR, 2), 0) -
                    c(0, 0, diff(DT$TTRR, 4), 0, 0)) * Rate / 12
    fS <- function(y, i) {
      # Eq. Ts3
      ((tau1 * DT$DTMDT[i] + DT$TTRR[i] - (1 - a) * y) / a - y) / (Rate * tau2)
    }
    
    DT$Ts <- rk4.integrate (fS, DT$Ts[1], 1:nrow(DT))
    DT$RT <- (1 / a) * (tau1 * DT$DTMDT + DT$TTRR - (1 - a) * DT$Ts)
    DT %>% select(Time, TTRR, RT, Ts) %>%
      selectTime(114500, 114505) %>%
      plotWAC()
    

```

```{r meth1Example, include=FALSE, fig.height=4, fig.cap=c('Examples of the changes produced by the correction procedures. The original measurement of recovery temperature is Tm and the revised value using is RT. The estimated temperature of the support (Ts) is also shown. The plotted time is seconds after 11:45:00 UTC for VOCALS flight 3.', 'Variance spectra for the original measurement of recovery temperature (TTRR) and for the corrected value (RT).')}

DT %>% select(Time, TTRR, RT, Ts) %>% 
  selectTime(114500, 114505) %>% 
  plotWAC(legend.position = 'topright')
g <- VSpec(DT, 'TTRR', ylim = c(1.e-5, 0.1))
VSpec(DT, 'RT', add = g) + theme_WAC(1)

```

```{r setUpFFT, include=FALSE}

N <- length(DT$TTRR)
if (N %% 2 == 1) {
  N <- N - 1
  DT  <- DT[-nrow(DT), ]
}
f <- fft (DT$TTRR)
N <- length(f)
df <- Rate / N
frq <-
  c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
N2 <- N %/% 2
fmax <- 2
nlim <- which(frq > fmax)[1]
## Modify the spectrum by the inverse of the response function:
AFFT <- LTphase(frq, Param1)
AFFT$frq <- frq
AFFT$Phase <- AFFT$Phase * pi / 180
H <- complex (modulus = AFFT$Amp, argument = AFFT$Phase)
xn <- Re(fft(f / H, inverse = TRUE)) / N
DT$FFT <- xn


```

An alternate approach is to find the recovery temperature using
Fourier transforms, from
$T_{r}(t)=\mathrm{Re}\left(\mathcal{F}^{-1}\left(\hat{T}_{m}(\omega)/H(\omega)\right)\right)$
where Re denotes the real part of the complex result. Examples of the corrections produced by these two procedures are shown
in Fig.\ \ref{fig:sampleFFT}. The agreement between the two correction
methods is very good, and both show evidence of faster and higher-amplitude
response to fluctuations. In comparison to the original measurement,
the corrected values for the heated sensor are improved significantly
by this correction procedure and are even a reasonable match to the
corrected measurement from the faster unheated sensor.
\begin{figure}
```{r sampleFFT, include=TRUE, fig.height = 3, out.width = "12cm", messages = FALSE}

DT$measured_uncorr <- DT$TTRR
DT$corrected_FFT <- DT$FFT
DT$corrected_DE <- DT$RT
DT$support <- DT$Ts
g1 <- DT %>% select(Time,
              corrected_FFT,
              corrected_DE,
              support,
              measured_uncorr) %>%
  selectTime(114500, 114502) %>%
  ggplotWAC(
    col = c('black', 'darkorange', 'forestgreen', 'blue'),
    ylab = bquote('recovery temperature [' ~ degree * 'C]'),
    lty = c(1, 2, 4, 1),
    lwd = c(1.5, 1, 1.5, 1)
  ) +
  xlab('time [s]') + theme_WAC(1) +
  annotate(
    'text',
    x = DT$Time[getIndex(DT, 114500)] + 1.5,
    y = 20.97,
    label = '(unheated)',
    size = 5
  ) +
  theme(
    plot.margin = unit(c(0.6, 0.6, 0.8, 0.6), "lines"),
    legend.direction = "vertical",
    legend.key.width = unit(1, 'lines'),
    legend.key.height = unit(0.5, 'lines'),
    legend.text = element_text(size = 8)
  ) +
  guides(colour = guide_legend(reverse = TRUE, '  legend:')) +
  guides(linetype = guide_legend(reverse = TRUE, '  legend:')) +
  guides(size = guide_legend(reverse = TRUE, '  legend:')) +
  theme(legend.direction = 'vertical',
        legend.position = c(0.65, 0.22))
grid.newpage()
vp2 <-
  viewport(
    x = unit(0.75, 'npc'),
    width = unit(0.5, 'npc'),
    layout.pos.col = 2
  )
vp1 <-
  viewport(
    x = unit(0.25, 'npc'),
    width = unit(0.5, 'npc'),
    layout.pos.col = 1
  )

if (generateFigures) {
  print(g1, vp = vp1)
}

a <- Param1$a
tau1 <- Param1$tau1
tau2 <- Param1$tau2
## RT is the working solution; Ts is the support temperature
DSX$Ts <- DSX$RTF1
Rate <- attr (DSX, 'Rate')
DSX$DTMDT <- c(0, diff(DSX$RTF1, 2), 0) * Rate / 2
DSX$DTMDT <-  (c(0, 8 * diff(DSX$RTF1, 2), 0) -
                 c(0, 0, diff(DSX$RTF1, 4), 0, 0)) * Rate / 12
fS <- function(y, i) {
  # Eq. Ts3
  ((1 / a) * (tau1 * DSX$DTMDT[i] + DSX$RTF1[i] - (1 - a) * y) - y) / 
    (Rate * tau2)
}

DSX$Ts <- rk4.integrate (fS, DSX$Ts[1], 1:nrow(DSX))
DSX$RT <- (1 / a) * (tau1 * DSX$DTMDT + DSX$RTF1 - (1 - a) * DSX$Ts)
MRHO <- MachNumber(DSX$PSXC, DSX$QCXC) * DSX$PSXC * 100 /
  (287.05 * (273.15 + DSX$ATX)) / rhozero
a <- bestSH[1]
tau1 <-
  bestSH[2] * (MRHO / 0.3) ^ 0.68  ## Note that these are variable
tau2 <- bestSH[3] ## * (MRHO / 0.3) ^ 0.68  ## inhibit this adjustment
Rate <- attr (DSX, 'Rate')
DSX$DTMDT <- c(0, diff(DSX$RTH1, 2), 0) * Rate / 2
DSX$DTMDT <-  (c(0, 8 * diff(DSX$RTH1, 2), 0) -
                 c(0, 0, diff(DSX$RTH1, 4), 0, 0)) * Rate / 12
DSX$DTM2DT2 <-
  (c(diff(DSX$RTH1), 0) - c(0, diff(DSX$RTH1))) * Rate ^ 2
DSX$DTM2DT2a <-  ## this doesn't work...
  (-c(diff(DSX$RTH1, 2), 0, 0) + c(0, 0, diff(DSX$RTH1, 2)) +
           16*(c(diff(DSX$RTH1, 1), 0)) - c(0, diff(DSX$RTH1, 1))) *
           (Rate^2) / 12
RTH1 <- DSX$RTH1
DSX$DTM2DT2 <- (-c(0,0, RTH1)[1:nrow(DSX)] + 16*c(0,RTH1)[1:nrow(DSX)] 
      - 30 * RTH1 + 16 * c(RTH1[2:nrow(DSX)], 0) 
      - c(RTH1[3:nrow(DSX)], 0, 0)) * (Rate^2) / 12
DSX$RTHC <-
  (tau1 + tau2) * DSX$DTMDT + DSX$RTH1 + tau1 * tau2 * DSX$DTM2DT2
DSX$RTHC <- zoo::na.approx (
  as.vector(DSX$RTHC),
  maxgap = 1000 * Rate,
  na.rm = FALSE,
  rule = 2
)
CutoffPeriod <- Rate / 2 ## 2 Hz for 25-Hz samples
DSX$RTHC <- signal::filtfilt (signal::butter (3,
                               2 / CutoffPeriod), DSX$RTHC)
# DSX$RTHC <- SmoothInterp(DSX$RTHC, .Length=25)
DSAP <- DSX
DSAP$RTH1 <-
  DSAP$RTH1 - mean(DSAP$RTH1[setRange(DSAP, 55700, 60000)], na.rm = TRUE)
DSAP$RTF1P <-
  DSAP$RTF1 - mean(DSAP$RTF1[setRange(DSAP, 55700, 60000)], na.rm = TRUE)
DSAP$RTHC <-
  DSAP$RTHC - mean(DSAP$RTHC[setRange(DSAP, 55700, 60000)], na.rm = TRUE)
DSAP$RT <-
  DSAP$RT - mean(DSAP$RT[setRange(DSAP, 55700, 60000)], na.rm = TRUE)
DSAX <- DSX %>% selectTime(55700, 60300)
DSAX <- DSAX[1:2 ^ 13,]
ft <- fft(DSAX$RTH1)
N <- length(ft)
Rate <- attr(DSX, 'Rate')
df <- Rate / N
frq <-
  c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df,-df, by = df))
fr <- log(abs(frq))
Gain  <- cfrHARCO[1] + fr * (cfrHARCO[2] + fr * fr * 
          (cfrHARCO[3] + fr * (cfrHARCO[4] + fr * cfrHARCO[5])))
Gain[abs(frq) < 0.024] <- 1
Phase <- cfHARCO[1] + cfHARCO[2] * fr + cfHARCO[3] * fr ^ 2 +
  cfHARCO[4] * atan(frq)
Phase[frq < 0] <- -Phase[frq < 0]
Phase[1] <- 0
Phase <- Phase * pi / 180
TF <- complex(modulus = Gain, argument = Phase)
tlmt <- 1.0
TF[abs(frq) > tlmt] <-
  TF[abs(frq) > tlmt] * exp(5 * abs(frq[abs(frq) > tlmt]) / tlmt)
ftx <- ft / TF
DSAX$RTFFT <- Re(fft(ftx, inverse = TRUE) / N)
N <- 2 ^ 13
Nby2 <- N / 2
RTH1 <- DSAX$RTH1
ff1 <- fft(RTH1)
RTH <- Re(fft(ff1, inverse = TRUE)) / N
df <- Rate / N
frq <-
  c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df,-df, by = df))
fr <- log(frq[1:(Nby2 + 1)])
## Get the transfer function from the fitted parameterized form:
Ph <- cfHARCO[1] + cfHARCO[2] * fr +
  cfHARCO[3] * fr ^ 2 + cfHARCO[4] * atan(frq[1:(Nby2 + 1)])
Ph[1] <- 0
G <- cfrHARCO[1] + fr * (cfrHARCO[2] + fr * fr * 
          (cfrHARCO[3] + fr * (cfrHARCO[4] + fr * cfrHARCO[5])))
G[frq[1:length(fr)] < 0.024] <- 1
G[frq[1:length(fr)] > 2] <- G[which.min(abs(frq - 2))]
H <- rep(complex(modulus = 0), N)
H[1:(Nby2 + 1)] <- complex(modulus = G, argument = Ph * pi / 180)
H[(Nby2 + 2):N] <- rev(Conj(H[2:Nby2]))
RTC <- Re(fft(ff1 / H, inverse = TRUE)) / N
DSAX$RTC <- RTC
dfTF <- data.frame('Time' = frq,
                   'Amp' = Gain,
                   'Phase' = Phase)
g <-
  ggplotWAC(dfTF,
            panels = 2,
            labelP = c('    Amplitude', 'Phase [degrees]'))
g <- g + 
  xlab('frequency [Hz]') + 
  ylab(bquote('transfer function H(' * nu ~ ')'))
g <- g + 
  scale_x_log10(
    breaks = trans_breaks("log10", function(x) 10^x, n = 4),
    labels = trans_format("log10", math_format(expr = 10 ^ .x))
  ) + 
  xlab('frequency [Hz]')
g <- g + annotation_logticks(sides = 'tb')
DSAP <- DSAX
DSAP$RTH1 <- DSAP$RTH1 - 
  mean(DSAP$RTH1[setRange(DSAP, 55700, 60000)], na.rm = TRUE)
DSAP$RTF1P <- DSAP$RTF1 - 
  mean(DSAP$RTF1[setRange(DSAP, 55700, 60000)], na.rm = TRUE)
DSAP$RTH <- DSAP$RTHC - 
  mean(DSAP$RTHC[setRange(DSAP, 55700, 60000)], na.rm = TRUE)
DSAP$RT <- DSAP$RT - 
  mean(DSAP$RT[setRange(DSAP, 55700, 60000)], na.rm = TRUE)
DSAP$FFT <- DSAP$RTFFT - 
  mean(DSAP$RTFFT[setRange(DSAP, 55700, 60000)], na.rm = TRUE)
DSAP$measured_uncorr <- DSAP$RTH1
DSAP$corrected_DE <- DSAP$RTH
DSAP$corrected_FFT <- DSAP$FFT
DSAP$reference_unheated <- DSAP$RT
g2 <- DSAP %>% selectTime(55915, 55935) %>%
  select(Time,
         reference_unheated,
         corrected_FFT,
         corrected_DE,
         measured_uncorr) %>%
  ggplotWAC(
    c('forestgreen', 'black', 'darkorange', 'blue'),
    ylab = bquote('recovery temperature [' ~ degree * 'C]'),
    lty = c(1, 1, 1, 1),
    lwd = c(0.5, 1.2, 0.8, 1.2)
  ) + 
  xlab('time [s]') +
  theme_WAC(1) +
  annotate(
    'text',
    x = DSAP$Time[getIndex(DSAP, 55923)] + 1.5,
    y = 0.15,
    label = '(heated)',
    size = 5
  ) +
  theme(
    plot.margin = unit(c(0.6, 0.6, 0.8, 0.6), "lines"),
    legend.direction = "vertical",
    legend.key.width = unit(1, 'lines'),
    legend.key.height = unit(0.5, 'lines'),
    legend.text = element_text(size = 8),
    axis.title.y = element_blank(),
    # legend.box.margin = margin(50, 6, 6, 6),
    legend.position = c(0.35, 0.79)
  ) +
  guides(colour = guide_legend(reverse = TRUE, '  legend:')) +
  guides(linetype = guide_legend(reverse = TRUE, '  legend:')) +
  guides(size = guide_legend(reverse = TRUE, '  legend:'))

if (generateFigures) {
  print(g2, vp = vp2)
} else {
  include_graphics('figure/figA1.pdf')
}

```
\caption{Examples of the corrected recovery temperatures compared to the original uncorrected measurements. In each case, the correction based on the differential equations is shown as "corrected\_DE" and that based on Fourier transforms is labeled "corrected\_FFT." The dashed green line in the left plot shows the calculated temperature of the support that contacts the sensing wire. The solid green line in the right plot shows the corrected measurement from the unheated sensor for comparison. (left): An unheated sensor. Measurements from VOCALS flight 3. (right): A heated sensor. In this case the "corrected\_DE" result is based on Eq.\ \eqref{eq:HARCOsoln} while "corrected\_FFT" uses the fit provided by Eq.\ \eqref{eq:lfitH}. Mean values have been subtracted to facilitate comparison.\label{fig:sampleFFT}}
\end{figure}

If the response of the sensor is indeed linear, as the differential equations
indicate, a correction procedure equivalent to that described above is
first to filter the dynamic-heating term as in Sect.\ 3, correct
the measured recovery temperature by subtracting this filtered term, and
then apply one of the correction procedures described above to obtain the corrected air temperature.
```{r HARCOcorrection, include=FALSE, fig.height=3.5, fig.cap=c('Corrected recovery temperature as measured by a heated sensor ("RTH" and "FFT"), the uncorrected measurement ("Tm"), and the best estimate of the true recovery temperature ("RT") based on an unheated after correction. The time is seconds after 2018-02-24 5:59:00 UTC, SOCRATES flight 15. "RTH" is based on the approximate formula (20), while "FFT" results from Fourier transformation after correction using the transfer function determined from (13). Mean values have been subtracted from all to facilitate comparisons.', 'Variance spectra for some measurements of recovery temperature: "RT" (the best estimate resulting from correction of the measurements from the unheated sensor); "Tm" (the uncorrected measurement from the heated sensor); "FFT" (the corrected heated-sensor measurement based on Fourier transforms); and "RTH" (the corrected heated-sensor measurement based on the correction formula (17)).')}

a <- Param1$a
tau1 <- Param1$tau1
tau2 <- Param1$tau2
## RT is the working solution; Ts is the support temperature
DSX$Ts <- DSX$RTF1
Rate <- attr (DSX, 'Rate')
DSX$DTMDT <- c(0, diff(DSX$RTF1, 2), 0) * Rate / 2
DSX$DTMDT <-  (c(0, 8 * diff(DSX$RTF1, 2), 0) -
                 c(0, 0, diff(DSX$RTF1, 4), 0, 0)) * Rate / 12
fS <- function(y, i) {
  ((1 / a) * (tau1 * DSX$DTMDT[i] + DSX$RTF1[i] - (1 - a) * y) - y) / 
    (Rate * tau2)
}

DSX$Ts <- rk4.integrate (fS, DSX$Ts[1], 1:nrow(DSX))
DSX$RT <- (1 / a) * (tau1 * DSX$DTMDT + DSX$RTF1 - (1 - a) * DSX$Ts)
MRHO <- MachNumber(DSX$PSXC, DSX$QCXC) * DSX$PSXC * 100 /
  (287.05 * (273.15 + DSX$ATX)) / rhozero
a <- bestSH[1]
tau1 <-
  bestSH[2] * (MRHO / 0.3) ^ 0.68  ## Note that these are variable
tau2 <- bestSH[3] * (MRHO / 0.3) ^ 0.68
Rate <- attr (DSX, 'Rate')
DSX$DTMDT <- c(0, diff(DSX$RTH1, 2), 0) * Rate / 2
DSX$DTM2DT2 <-
  (c(diff(DSX$RTH1), 0) - c(0, diff(DSX$RTH1))) * Rate ^ 2
DSX$RTHC <-
  (tau1 + tau2) * DSX$DTMDT + DSX$RTH1 + tau1 * tau2 * DSX$DTM2DT2
DSX$RTHC <- zoo::na.approx (
  as.vector(DSX$RTHC),
  maxgap = 1000 * Rate,
  na.rm = FALSE,
  rule = 2
)
CutoffPeriod <- 12.5
DSX$RTHC <- signal::filtfilt (signal::butter (3,
                                2 / CutoffPeriod), DSX$RTHC)
DSAP <- DSX
DSAP$RTH1 <- DSAP$RTH1 - 
  mean(DSAP$RTH1[setRange(DSAP, 55700, 60000)], na.rm = TRUE)
DSAP$RTF1P <- DSAP$RTF1 - 
  mean(DSAP$RTF1[setRange(DSAP, 55700, 60000)], na.rm = TRUE)
DSAP$RTHC <- DSAP$RTHC - 
  mean(DSAP$RTHC[setRange(DSAP, 55700, 60000)], na.rm = TRUE)
DSAP$RT <- DSAP$RT - 
  mean(DSAP$RT[setRange(DSAP, 55700, 60000)], na.rm = TRUE)
DSAX <- DSX %>% selectTime(55700, 60300)
DSAX <- DSAX[1:2^13, ]
ft <- fft(DSAX$RTH1)
N <- length(ft)
Rate <- attr(DSX, 'Rate')
df <- Rate / N
frq <-
  c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
fr <- log(abs(frq))
Gain  <- cfrHARCO[1] + fr * (cfrHARCO[2] + fr * fr * 
          (cfrHARCO[3] + fr * (cfrHARCO[4] + fr * cfrHARCO[5])))
Gain[abs(frq) < 0.024] <- 1
Phase <- cfHARCO[1] + cfHARCO[2] * fr + cfHARCO[3] * fr ^ 2 +
  cfHARCO[4] * atan(frq)
Phase[frq < 0] <- -Phase[frq < 0]
Phase[1] <- 0
Phase <- Phase * pi / 180
TF <- complex(modulus = Gain, argument = Phase)
tlmt <- 1.8
TF[abs(frq) > tlmt] <-
  TF[abs(frq) > tlmt] * exp(5 * abs(frq[abs(frq) > tlmt]) / tlmt)
ftx <- ft / TF
DSAX$RTFFT <- Re(fft(ftx, inverse = TRUE) / N)
N <- 2 ^ 13
Nby2 <- N / 2
RTH1 <- DSAX$RTH1
ff1 <- fft(RTH1)
RTH <- Re(fft(ff1, inverse = TRUE)) / N
df <- Rate / N
frq <-
  c(seq(0, Rate / 2, by = df), seq(-Rate / 2 + df, -df, by = df))
fr <- log(frq[1:(Nby2 + 1)])
## Get the transfer function from the fitted parameterized form:
Ph <- cfHARCO[1] + cfHARCO[2] * fr +
  cfHARCO[3] * fr ^ 2 + cfHARCO[4] * atan(frq[1:(Nby2 + 1)])
Ph[1] <- 0
G <- cfrHARCO[1] + fr * (cfrHARCO[2] + fr * fr * 
       (cfrHARCO[3] + fr * (cfrHARCO[4] + fr * cfrHARCO[5])))
G[frq[1:length(fr)] < 0.024] <- 1
G[frq[1:length(fr)] > 2] <- G[which.min(abs(frq - 2))]
H <- rep(complex(modulus = 0), N)
H[1:(Nby2 + 1)] <- complex(modulus = G, argument = Ph * pi / 180)
H[(Nby2 + 2):N] <- rev(Conj(H[2:Nby2]))
RTC <- Re(fft(ff1 / H, inverse = TRUE)) / N
DSAX$RTC <- RTC
dfTF <- data.frame('Time' = frq,
                   'Amp' = Gain,
                   'Phase' = Phase)
g <-
  ggplotWAC(dfTF,
            panels = 2,
            labelP = c('    Amplitude', 'Phase [degrees]'))
g <- g + 
  ylab(bquote('transfer function H(' * nu ~ ')')) +
  scale_x_log10(
    breaks = trans_breaks("log10", function(x) 10^x, n = 4),
    labels = trans_format("log10", math_format(expr = 10^.x))
  ) + 
  xlab('frequency [Hz]')
g <- g + annotation_logticks(sides = 'tb')
DSAP <- DSAX
DSAP$RTH1 <- DSAP$RTH1 - 
  mean(DSAP$RTH1[setRange(DSAP, 55700, 60000)], na.rm = TRUE)
DSAP$RTF1P <- DSAP$RTF1 - 
  mean(DSAP$RTF1[setRange(DSAP, 55700, 60000)], na.rm = TRUE)
DSAP$RTH <- DSAP$RTHC - 
  mean(DSAP$RTHC[setRange(DSAP, 55700, 60000)], na.rm = TRUE)
DSAP$RT <- DSAP$RT - 
  mean(DSAP$RT[setRange(DSAP, 55700, 60000)], na.rm = TRUE)
DSAP$FFT <- DSAP$RTFFT - 
  mean(DSAP$RTFFT[setRange(DSAP, 55700, 60000)], na.rm = TRUE)
DSAP$Tm <- DSAP$RTH1
DSAP %>% selectTime(55918, 55950) %>%
  select(Time, RT, Tm, FFT, RTH) %>%
  ggplotWAC(
    c('blue', 'forestgreen', 'black', 'darkorange'),
    ylab = bquote('recovery temperature [' ~ degree * 'C]'),
    lty = c(1, 2, 1, 1),
    lwd = c(0.8, 1.2, 1, 0.8)
  ) + 
  xlab('time [s]') +
  theme_WAC(1) +
  theme(legend.position = c(0.715, 0.93))
g <- DSAP %>% select(Time, TASX, Tm, RTH, RT) %>%
  VSpec(
    xlim = c(5.e-3, 15),
    ylim = c(2.e-6, 1.e-2),
    smoothBins = 100,
    method = 'MEM'
  )
VSpec(DSAP, 'FFT', add = g, type = 'MEM') + theme_WAC(1)

```

\clearpage{}

# References

